; C64 Assembler framework.
; General elements common to any C64 Program.
; By Ignacio Cea Forni√©s.
; Copyright Community Networks 2022 - 2023.

#../C64Programs/Code/Macros/MSCREEN.asm
#../C64Programs/Code/Macros/MVICII.asm
#../C64Programs/Code/Macros/MCIAS.asm

; ------------------------------
; TEMPLATES DEFINITION
; To save the main registers in the stack.
{ SAVEREGISTERS
							pha								; Starting from the accumulator...
							txa
							pha
							txy
							pha
}
							
; To recover the main registers from the stack.
{ RECOVERREGISTERS
							pla
							tay
							pla
							tax
							pla								; Ending with the accumulator...
}

; To switch off IRQ interrupts
{ SWITCHOFFIRQ
							sei								; Switch off IRQ
							lda #$7f
							sta CIA1IRQ						; Disable timer interrupts which can be generated by the two CIA chips.
							sta CIA2IRQ						; The kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better  stop it.
							lda CIA1IRQ						; By reading this two registers we "negate"" any pending CIA irqs.
							lda CIA2IRQ						; If we don't do this, a pending CIA irq might occur after we finish setting up our irq.
}
; ------------------------------

; ------------------------------
; DATA ZONE
; Very general zone to store variables.
; Defined in the page 0 just to speed up their use!
* = $02
; A zone of 48 bytes for general data is defined.
BYTES $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
BYTES $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
BYTES $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
; Temporary variables are defined in the first $10 (16) positions.
TEMP00_DATA					= $2
TEMP01_DATA					= $3
TEMP02_DATA					= $4
TEMP03_DATA					= $5
TEMP04_DATA					= $6
TEMP05_DATA					= $7
TEMP06_DATA					= $8
TEMP07_DATA					= $9
TEMP08_DATA					= $a
TEMP09_DATA					= $b
TEMP10_DATA					= $c
TEMP11_DATA					= $d
TEMP12_DATA					= $e
TEMP13_DATA					= $f
TEMP14_DATA					= $10
TEMP15_DATA					= $11
; The variables for the routines start from the position $12 (18) to $21 (33).
; So there is 16 positions for defining variables to feed routines.
VARIABLES_DATAZONE			= $12
; The variables to produce results start from the position $22 (34) to $31 (49).
; So there is 16 positions for defining outcome for rotuines.
OUTCOME_DATAZONE			= $22
; ------------------------------

; ------------------------------
; GENERAL ROUTINES
; The variable BASE has to be defined before this file is loaded.
; The pograms always should start from where this variable is defined onwards.
* = BASE

; ------------------------------
; DELAY
; To create a delay.
; The length of the delay is passed into the Registers X and Y.
DELAY:						txa
DELAY_LOOP:					nop
							dex
							bne DELAY_LOOP
							tax
							dey
							bne DELAY_LOOP
							rts
; ------------------------------

; ------------------------------
; MATRIXADDRESS
; To calculate the left side up corner address of a position in a matrix defined in the memory.
; The parameters used by this routine are:
; MATRIXADDR_XPOSVAR	:	The x position of the left up side corner to calculate.
; MATRIXADDR_YPOSVAR	:	The y position of the left up side corner to calculate.
; MATRIXADDR_MAXXVAR	:	The max number of columns of the matrix.
; MATRIXADDR_LOCLOWVAR	:	The initial low byte of the matrix address.
; MATRIXADDR_LOCHIGHVAR	:	The initial hight byte of the matrix address.
; The outcome of this routine is:
; MATRIXADDR_LOCLOWRST	:	The low byte of the address of most up left corner address after calculation.
; MATRIXADDR_LOCHIGHRST	:	The low byte of the address of most up left corner address after calculation.
MATRIXADDR_LOCLOWVAR		= VARIABLES_DATAZONE + 0
MATRIXADDR_LOCHIGHVAR		= VARIABLES_DATAZONE + 1
MATRIXADDR_XPOSVAR			= VARIABLES_DATAZONE + 2
MATRIXADDR_MAXXVAR			= VARIABLES_DATAZONE + 3
MATRIXADDR_YPOSVAR			= VARIABLES_DATAZONE + 4
MATRIXADDR_LOCLOWRST		= OUTCOME_DATAZONE + 0
MATRIXADDR_LOCHIGHRST		= OUTCOME_DATAZONE + 1
; Initially the result will be the same than the income...
MATRIXADDRESS:				lda MATRIXADDR_LOCLOWVAR
							sta MATRIXADDR_LOCLOWRST
							lda MATRIXADDR_LOCHIGHVAR
							sta MATRIXADDR_LOCHIGHRST
; Then moves the left up corner matrix address to the correct line.
							ldx MATRIXADDR_YPOSVAR
MATRIXADDR_CALCY:			beq MATRIXADDR_X
							clc
							lda MATRIXADDR_MAXXVAR
							adc MATRIXADDR_LOCLOWRST
							sta MATRIXADDR_LOCLOWRST
							bcc MATRIXADDR_MOVENEXTY
							inc MATRIXADDR_LOCHIGHRST
MATRIXADDR_MOVENEXTY:		dex
							jmp MATRIXADDR_CALCY
; Now move the left up corner matrix address to the correct column.
MATRIXADDR_X:				ldx MATRIXADDR_XPOSVAR
MATRIXADDR_CALCX:			beq MATRIXADDR_RTS
							clc
							lda #$01						; Step by step...
							adc MATRIXADDR_LOCLOWRST
							sta MATRIXADDR_LOCLOWRST
							bcc MATRIXADDR_MOVENEXTX
							inc MATRIXADDR_LOCHIGHRST
MATRIXADDR_MOVENEXTX:		dex
							jmp MATRIXADDR_CALCX
MATRIXADDR_RTS:				rts
; ------------------------------

; ------------------------------
; FILLMATRIX
; To fill a box within a matrix with a value.
; The parameters used by this routine are:
; FILLMX_XPOSVAR		:	The x position of the left up side corner of the box.
; FILLMX_XLENVAR		:	X len of the box. From 1 onwards.
; FILLMX_MAXXVAR		:	Max columns of the matrix
; FILLMX_YPOSVAR		:	The y position of the left up side corner of the box.
; FILLMX_YLENVAR		:	Y len of the box. From 1 onwards.
; FILLMX_BYTEVAR		:	The value to fill the box with.
; FILLMX_LOCSLOWVAR		:	The initial low byte of the most up left corner matrix address.
; FILLMX_LOCSHIGHVAR	:	The initial hight byte of the most up left corner matrix address.
FILLMX_LOCSLOWVAR			= MATRIXADDR_LOCLOWVAR
FILLMX_LOCSHIGHVAR			= MATRIXADDR_LOCHIGHVAR
FILLMX_XPOSVAR				= MATRIXADDR_XPOSVAR
FILLMX_YPOSVAR				= MATRIXADDR_YPOSVAR
FILLMX_MAXXVAR				= MATRIXADDR_MAXXVAR
FILLMX_XLENVAR				= VARIABLES_DATAZONE + 5
FILLMX_YLENVAR				= VARIABLES_DATAZONE + 6
FILLMX_BYTEVAR				= VARIABLES_DATAZONE + 7
; First calculate the address where to start to fill up...
FILLMATRIX:					jsr MATRIXADDRESS				; Outcome is in MATRIXADDR_LOCLOWRST and in MATRIXADDR_LOCHIGHRST.
; Now from that address fills up the matrix
; Take into account that the value 0 is not allowed.
							ldx FILLMX_YLENVAR
							beq FILLMX_RTS
FILLMX_LINE:				ldy FILLMX_XLENVAR
							beq FILLMX_RTS
							lda FILLMX_BYTEVAR
FILLMX_LINELOOP:			dey
							sta (MATRIXADDR_LOCLOWRST),y
							bne FILLMX_LINELOOP
							clc
							lda FILLMX_MAXXVAR
							adc MATRIXADDR_LOCLOWRST
							sta MATRIXADDR_LOCLOWRST
							bcc FILLMX_MOVENEXTY
							inc MATRIXADDR_LOCHIGHRST
FILLMX_MOVENEXTY:			dex
							bne FILLMX_LINE
FILLMX_RTS:					rts
; ------------------------------

; End.