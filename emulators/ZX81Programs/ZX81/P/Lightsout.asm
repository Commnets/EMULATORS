
;; 
;; Compile with "tasm -80 -b program.asm program.p" 
;; 


#define DB .byte
#define db .byte ; TASM cross-assembler definitions 
#define dw .word 
#define ds .block 
#define org .org 
#define end .end 
 
   org     $4009 
 
;= System variables ============================================ 
 
   db 0     ;VERSN 
   dw 0     ;E_PPC 
   dw dfile      ;D_FILE 
   dw dfile+1    ;DF_CC 
   dw var   ;VARS 
   dw 0     ;DEST 
   dw var+1      ;E_LINE 
   dw last-1     ;CH_ADD 
   dw 0     ;X_PTR 
   dw last  ;STKBOT 
   dw last  ;STKEND 
   db 0     ;BERG 
   dw membot     ;MEM 
   db 0     ;not used 
   db 2     ;DF_SZ 
   dw 1     ;S_TOP 
   db $FF,$FF,$FF     ;LAST_K 
   db 55    ;MARGIN 
   dw dfile      ;NXTLIN 
   dw 0     ;OLDPPC 
   db 0     ;FLAGX 
   dw 0     ;STRLEN 
   dw $0C8D      ;T_ADDR 
   dw 0     ;SEED 
   dw $FFFF      ;FRAMES 
   db 0,0   ;COORDS 
   db $BC   ;PR_CC 
   db 33,24      ;S_POSN 
   db 01000000B  ;CDFLAG 
   ds 33    ;Print buffer 
membot: 
   ds 30    ;Calculator´s memory area 
   ds 2     ;not used 
 
;= First BASIC line, asm code ================================== 
 
line0: 
   db 0,0 
   dw dfile-$-2 
   db $ea   ; REM 

;===============================================================
;MY CODE STARTS

;SOME ZX-81 CHARACTER CODE DEFINES

#DEFINE	ZX_SPC		$00		;SPACE
#DEFINE	ZX_TLQ		$01		;TOP LEFT QUAD
#DEFINE ZX_TRQ		$02		;TOP RIGHT QUAD
#DEFINE ZX_THB		$03		;TOP HALF BLACK
#DEFINE	ZX_BLQ		$04		;BOTTOM LEFT QUAD
#DEFINE ZX_LHB		$05		;LEFT HALF BLACK
#DEFINE ZX_BLTRQS	$06		;BOTTOM LEFT & TOP RIGHT QUADS
#DEFINE ZX_BLTLTRQS	$07		;BOTTOM LEFT & TOP LEFT & TOP RIGHT QUADS
#DEFINE ZX_GREY		$08		;FULL GREY
#DEFINE ZX_BG		$09		;BOTTOM GREY
#DEFINE ZX_TG		$0A		;TOP GREY
#DEFINE ZX_QUOTE	$0B		;QUOTE
#DEFINE ZX_POUND	$0C		;POUND SIGN
#DEFINE ZX_DOLLAR	$0D		;DOLLAR SIGN
#DEFINE ZX_COLON	$0E		;COLON
#DEFINE ZX_QUESTION	$0F		;QUESTION MARK
#DEFINE ZX_OPENBRACK	$10		;OPEN BRACKET
#DEFINE ZX_CLOSEBRACK	$11		;CLOSE BRACKET
#DEFINE ZX_GREATER	$12		;GREATER THAN SYMBOL
#DEFINE ZX_LESS		$13		;LESS THAN SYMBOL
#DEFINE ZX_EQUAL	$14		;EQUALS SYMBOL
#DEFINE ZX_PLUS		$15		;PLUS SIGN
#DEFINE ZX_MINUS	$16		;MINUS SIGN
#DEFINE ZX_MULT		$17		;MULTIPLY SIGN (STAR)
#DEFINE ZX_DIVIDE	$18		;DIVIDE SIGN (SLASH)
#DEFINE ZX_SEMI		$19		;SEMI COLON
#DEFINE ZX_COMMA	$1A		;COMMA
#DEFINE ZX_PERIOD	$1B		;PERIOD (FULL STOP)
#DEFINE ZX_0		$1C		;0
#DEFINE ZX_1		$1D		;1
#DEFINE ZX_2		$1E		;2
#DEFINE ZX_3		$1F		;3
#DEFINE ZX_4		$20		;4
#DEFINE	ZX_5		$21		;5
#DEFINE	ZX_6		$22		;6
#DEFINE ZX_7		$23		;7
#DEFINE	ZX_8		$24		;8
#DEFINE ZX_9		$25		;9
#DEFINE ZX_A		$26		;A
#DEFINE ZX_B		$27		;B
#DEFINE ZX_C		$28		;C
#DEFINE ZX_D		$29		;D
#DEFINE	ZX_E		$2A		;E
#DEFINE ZX_F		$2B		;F
#DEFINE	ZX_G		$2C		;G
#DEFINE ZX_H		$2D		;H
#DEFINE ZX_I		$2E		;I
#DEFINE ZX_J		$2F		;J
#DEFINE ZX_K		$30		;K
#DEFINE ZX_L		$31		;L
#DEFINE ZX_M		$32		;M
#DEFINE	ZX_N		$33		;N
#DEFINE ZX_O		$34		;O
#DEFINE ZX_P		$35		;P
#DEFINE ZX_Q		$36		;Q
#DEFINE	ZX_R		$37		;R
#DEFINE ZX_S		$38		;S
#DEFINE ZX_T		$39		;T
#DEFINE ZX_U		$3A		;U
#DEFINE ZX_V		$3B		;V
#DEFINE	ZX_W		$3C		;W
#DEFINE ZX_X		$3D		;X
#DEFINE ZX_Y		$3E		;Y
#DEFINE ZX_Z		$3F		;Z
#DEFINE ZX_NEWLINE	$76		;NEWLINE
#DEFINE ZX_FB		$80		;FULL BLACK
#DEFINE	ZX_TRBLBRQS	$81		;TOP RIGHT & BOTTOM LEFT & BOTTOM RIGHT QUADS
#DEFINE ZX_TLBLBRQS	$82		;TOP LEFT & BOTTOM LEFT & BTOOM RIGHT QUADS
#DEFINE ZX_BH		$83		;BOTTOM HALF BLACK
#DEFINE ZX_TLTRBRQS	$84		;TOP LEFT & TOP RIGHT & BOTTOM RIGHT QUADS
#DEFINE ZX_RH		$85		;RIGHT HALF BLACK
#DEFINE ZX_TLBRQS	$86		;TOP LEFT & BOTTOM RIGHT QUADS
#DEFINE ZX_BRQ		$87		;BOTTOM RIGHT QUAD
#DEFINE ZX_INVGREY	$88		;THE OTHER GREY
#DEFINE ZX_THBG		$89		;TOP HALF BLACK, BOTTOM GREY
#DEFINE ZX_BHTG		$8A		;BOTTOM HALF BLACK,TOP GREY

;============================================
;NOW SOME SYSTEM VARIABLES THAT MAY BE OF USE

#DEFINE D_FILE		$400C		;START OF DISPLAY FILE
#DEFINE LAST_K		$4025		;LAST KEYS PRESSED
#DEFINE FRAMES		$4034		;FRAMES COUNTER

;============================================
;NOW SOME ROM ADDRESSES
 

#DEFINE ROM_SETFAST 	$02E7		;ROM CALL SETS FAST MODE
#DEFINE	ROM_SLOWFAST	$0207		;ROM CALL RETURNS TO PREVIOUS SLOW FAST MODE
#DEFINE ROM_CLS		$0A2A		;ROM CALL CLS
#DEFINE ROM_SLOW	$0F2B		;ROM CALL SLOW MODE


CODE_START	.BYTE	$7E		;ZX WILL THINK NEXT 5 BYTES ARE NUMBER

		JP	REAL_START	;JUMP OVER TEXT

		.BYTE	0,0
		.BYTE	ZX_L , ZX_I , ZX_G , ZX_H , ZX_T , ZX_S , ZX_SPC
		.BYTE	ZX_O , ZX_U , ZX_T , ZX_PERIOD , ZX_SPC
		.BYTE	ZX_B , ZX_Y , ZX_SPC , ZX_A , ZX_N , ZX_D , ZX_Y
		.BYTE	ZX_SPC , ZX_R , ZX_E , ZX_A , ZX_SPC , ZX_NEWLINE

REAL_START	CALL	ROM_CLS		;CLEAR THE SCREEN TO ENSURE
					;A 'FULL' D-FILE
		CALL	ROM_SLOW	;MAKE SURE SLOW MODE
					;WILL HANG IN FAST AS I USE FRAMES
RE_START	CALL	FRAME_WAIT	;WAIT FOR THE NEXT FRAME
		CALL	INITIALIZE	;INITALIZE THE GAME
		XOR	A		;ZERO A
		LD	(TIMER_SECONDS),A
		LD	A,$15		;15 MINUTES
		LD	(TIMER_MINUTES),A

DEMO_LOOP	CALL	FRAME_WAIT	;WAIT FOR THE NEXT FRAME
		LD	HL,TICKS
		DEC	(HL)
		CALL	Z,SECONDS_UP
		LD	A,(TIMER_SECONDS)
		CP	$49
		CALL	Z,DEMO_NEXT	;CHANGE LEVEL EVERY 10 SECONDS
		
		CALL	SHOW_FRAME
		CALL	SCAN_KEYS	
		CALL	D_TEXT		;DO THE DEMO TEXT
		CALL	NEWLINE_PRESSED
		JR	C,START
		CALL	S_PRESSED
		JR	C,SAVE_GAME
		CALL	A_PRESSED
		JR	C,QUIT_GAME

		CALL	DEMO_RANDOM_TURN
		JP	DEMO_LOOP

SAVE_GAME	LD	BC,65535
		RET

QUIT_GAME	LD	BC,0
		RET



START		CALL	LEVEL_SELECT		;LEVEL SELECT ROUTINE
						;RETURNSWITH STARTING LEVEL IN
						;THE ACCUMULATOR
		
;START		LD	A,1

;		LD	(CURRENT_LEVEL),A

START_2
		CALL	INIT_COLUMN
		LD	A,3
		LD	(FRAME_X_POS),A
		LD	(FRAME_Y_POS),A

		XOR	A		;ZERO A
		LD	(TIMER_SECONDS),A
		LD	(MOVES),A
		LD	(MOVES+1),A
		LD	A,$15		;15 MINUTES
		LD	(TIMER_MINUTES),A
		
		CALL	SET_LEVEL
		CALL	LEVEL_TO_BCD		;DISPLAY LEVEL NUMBER
		

		
MAIN		CALL	FRAME_WAIT
		CALL	LEVEL_COMPLETED_YET
		
		JP	Z,NEXT_LEVEL

NEXT_TICK	LD	HL,TICKS
		DEC	(HL)
		CALL	Z,SECONDS_UP
		CALL	SCAN_KEYS
		CALL	SHOW_FRAME
		CALL	SHOW_TIME
		CALL	SHOW_MOVES
		
		CALL	SHIFT_Q_PRESSED	;CARRY SET IF Q AND SHIFT PRESSED
		JP	C,RE_START
		CALL	SHIFT_R_PRESSED	;CARRY SET IF R AND SHIFT PRESSED
		CALL	C,SET_LEVEL
		CALL	MOVE_OR_FLIP

		JR	MAIN

;**************************************************************************

;==========================================================================
;LEVEL SELECT ROUTINE
;ALLOWSTHE USERTOSELECT THE STARTING LEVEL
;UP TO THE BEST COMPLETED LEVEL

LEVEL_SELECT	CALL	ROM_CLS
		
INIT_SELECT	LD	HL,SELECT_TEXT
		LD	(DEMO_TEXT),HL
		LD	B,23		;THE COUNTER
INIT_SELECT_LP	PUSH	BC		;SAVE COUNTER
		CALL	FRAME_WAIT	;WAIT FOR FRAME
		CALL	TEXT_LINE	
		POP	BC
		DJNZ	INIT_SELECT_LP
WAIT_FOR_NL1	CALL	FRAME_WAIT
		CALL	SCAN_KEYS
		CALL	NEWLINE_PRESSED
		JR	C,WAIT_FOR_NL1	;WAIT UNTIL N/L IS NOT PRESSED
		LD	A,(BEST_LEVEL)
		LD	(CURRENT_LEVEL),A
	LD	A,(CURRENT_LEVEL)
		CALL	SET_LEVEL_B	;DISPLAY BEST LEVEL REACHED


WAIT_FOR_NL2	CALL	FRAME_WAIT
		CALL	SCAN_KEYS
		CALL	UP_DOWN
		JR	C,LEVEL_UP
		JR	NZ,LEVEL_DOWN

		CALL	NEWLINE_PRESSED
		JR	NC,WAIT_FOR_NL2

		RET

LEVEL_UP	LD	A,(CURRENT_LEVEL)
;		DEC	A
		LD	HL,BEST_LEVEL
		CP	(HL)
		JR	NC,TO_BEST
		INC	A
;TO_BEST		INC	A
TO_BEST		LD	(CURRENT_LEVEL),A
		LD	A,(CURRENT_LEVEL)
		CALL	SET_LEVEL_B
		CALL	INIT_COLUMN
		CALL	LEVEL_TO_BCD	

WAIT_UP		CALL	SCAN_KEYS
		CALL	UP_DOWN
		JR	C,WAIT_UP

		JP	WAIT_FOR_NL2

LEVEL_DOWN	LD	A,(CURRENT_LEVEL)
		DEC	A
		JR	NZ,NOT_MIN
		INC	A
NOT_MIN		LD	(CURRENT_LEVEL),A
		LD	A,(CURRENT_LEVEL)
		CALL	SET_LEVEL_B
		CALL	INIT_COLUMN
		CALL	LEVEL_TO_BCD	

WAIT_DOWN	CALL	SCAN_KEYS
		CALL	UP_DOWN
		JR	NZ,WAIT_DOWN

		JP	WAIT_FOR_NL2

	

;**************************************************************************

;==========================================================================
;RANDOM MOVE ROUTINE
;GETS A RANDOM NUMBER
ROM_POINTER	.WORD 0
;
DEMO_RANDOM_TURN		;CALLED EVERY TICK
			
		LD	HL,(ROM_POINTER)	;GET THE ROM POINTER
		INC	HL
		LD	A,H
		AND	%00011111		;STAY IN THE ROM
		LD	H,A
		LD	(ROM_POINTER),HL
		LD	A,(FRAMES+1)
		ADD	A,(HL)
		
		AND	%0000111	;0 TO 7
		JP	Z,MOVE_LEFT
		DEC	A
		JP	Z,MOVE_RIGHT
		DEC	A
		JP	Z,MOVE_UP
		DEC	A
		JP	Z,MOVE_DOWN
		LD	A,(ROM_POINTER)
		AND	%00011111
		
		RET	NZ
		XOR	A
		LD	(FLIPPED),A
		JP	FLIP_LIGHTS
		


			


;==========================================================================
;NEXT LEVEL
;STORE THE BEST TIME AND MOVES IF LESS THAN STORED


NEXT_LEVEL
		LD	B,4

CELERBRATE_OUTER_LOOP

		LD	DE,CELERBRATE1
		PUSH	BC		;SAVE OUTER LOOP COUNTER

		LD	B,8

CELERBRATE_INNER_LOOP

		PUSH	BC		;SAVE INNER LOOP COUNTER
		LD	B,D
		LD	C,E
		PUSH	BC
		CALL	FRAME_WAIT
		CALL	DRAW_CEL
		POP	DE		;GET ADDRESS BACK
		INC	DE
		INC	DE
		INC	DE
		INC	DE
		INC	DE
		POP	BC		;RETRIEVE INNER COUNTER
		DJNZ	CELERBRATE_INNER_LOOP
		POP	BC		;RETRIEVE OUTER COUNTER
		DJNZ	CELERBRATE_OUTER_LOOP



STORE_MOVES	LD	BC,(CURRENT_LEVEL_DATA+8)	;GET THE BEST MOVES
		LD	A,C
		OR	B				;IF ZERO NO BEST SET
		JR	Z,STORE_BEST_MOVES		;STORE MOVES
		
		LD	HL,(MOVES)			;GET NUMBER OF MOVES
							;TO COMPLETE LEVEL
		AND 	A				;CLEAR CARRY
		SBC	HL,BC				;SUBTRACT CURRENT BEST
							;FROM YOUR MOVES
							;CARRY SET IF 
							;YOUR MOVES LOWER
		JR	NC,STORE_TIME			;MOVES MORE
				
		
STORE_BEST_MOVES
		LD	BC,(MOVES)			;GET THE MOVES

		LD	A,(CURRENT_LEVEL)		;GET THE CURRENT LEVEL
		ADD	A,A				;DOUBLE IT
		LD	D,0				;PUT IN DE
		LD	E,A
		LD	HL,LEVEL_TABLE			;START OF LEVEL TABEL
		ADD	HL,DE				;PLUS OFFSET
		LD	E,(HL)				;GET LOW BYTE
		INC	HL
		LD	D,(HL)				;GET HIGH BYTE
		EX	DE,HL				;ADDRESS OF LEVEL DATA
							;NOW IN HL
		LD	DE,8				;FURTHER OFFSET TO MOVES
		ADD	HL,DE
		LD	(HL),C				;STORE LOW BYTE
		INC	HL
		LD	(HL),B				;STORE HIGH BYTE


STORE_TIME	LD	BC,(CURRENT_LEVEL_DATA+6)	;GET THE BEST TIME
		LD	A,C
		OR	B				;IF ZERO NO BEST SET
		JR	Z,STORE_BEST_TIME		;STORE TIME
		
		LD	HL,(TIMER_MINUTES)		;GET TIME LEFT
							;TO COMPLETE LEVEL
		AND 	A				;CLEAR CARRY
		SBC	HL,BC				;SUBTRACT BEST TIME
							;FROM YOUR TIME
							;CARRY SET IF
							;YOUR TIME LESS THAN
		JR	C,STORE_DONE			;BEST TIME

STORE_BEST_TIME	LD	BC,(TIMER_MINUTES)		;GET THE TIME
		
		LD	A,(CURRENT_LEVEL)		;GET THE CURRENT LEVEL
		ADD	A,A				;DOUBLE IT
		LD	D,0				;PUT IN DE
		LD	E,A
		LD	HL,LEVEL_TABLE			;START OF LEVEL TABEL
		ADD	HL,DE				;PLUS OFFSET
		LD	E,(HL)				;GET LOW BYTE
		INC	HL
		LD	D,(HL)				;GET HIGH BYTE
		EX	DE,HL				;ADDRESS OF LEVEL DATA
							;NOW IN HL
		LD	DE,6				;FURTHER OFFSET TO TIME
		ADD	HL,DE
		LD	(HL),C				;STORE LOW BYTE
		INC	HL
		LD	(HL),B				;STORE HIGH BYTE



STORE_DONE	LD	A,(CURRENT_LEVEL)
		INC	A
		LD	(CURRENT_LEVEL),A
		CP	101
		JR	Z,GAME_COMPLETED
		
			
		LD	HL,BEST_LEVEL			;COMPARE WITH PREVIOUS BEST
		CP	(HL)				;LEVEL, IF CURRENT LEVEL BETTER
		JR	C,NO_NEW_BEST			

		LD	(BEST_LEVEL),A			;REPLACE BEST LEVEL

NO_NEW_BEST	JP	START_2

GAME_COMPLETED	
		
		LD	A,100
		LD	(CURRENT_LEVEL),A
		LD	(BEST_LEVEL),A

		
		JP	START_2

;==========================================================================

;LEVEL COMPLETED YET?
;TESTS IF ALL THE LIGHTS ARE OUT 
;RETURN ZERO SET IF COMPLETE

LEVEL_COMPLETED_YET
		LD	B,5
		LD	HL,CURRENT_LEVEL_DATA
MASK_LOOP	LD	A,(HL)
		AND	%00111110
		LD	(HL),A
		INC	HL
		DJNZ	MASK_LOOP
		LD	A,(CURRENT_LEVEL_DATA)
		LD	HL,CURRENT_LEVEL_DATA+1
		LD	B,4
TEST_LOOP	OR	(HL)
		INC	HL
		DJNZ	TEST_LOOP
		RET
;***************************************************************

;===========================================================================
;MOVE FRAME OR FLIP CURRENT

MOVE_OR_FLIP	CALL	ZERO_PRESSED	;CARRY SET IF 0 PRESSED
		JR	NC,NO_FLIP
		CALL	FLIP_LIGHTS
		
		JR	NO_FLIP_SKIP
NO_FLIP		XOR	A
		LD	(FLIPPED),A
NO_FLIP_SKIP	CALL	UP_DOWN		;RETURNS EITHER CARRY SET OR NOT ZERO
					;BUT NOT BOTH, CARRY = UP, NOT ZERO = DOWN
		JR	NC,NO_MOVE_UP	;UP NOT PRESSED

		CALL	MOVE_UP		;MOVE UP, WILL SET FLAG
		JR	NO_MOVE_DOWN	;JUMP OVER THE CLEAR THE FLAG BIT

NO_MOVE_UP	LD	A,0		;CLEAR THE MOVED UP FLAG
		LD	(MOVED_UP),A

NO_MOVE_UP_SKIP	JR	Z,NO_MOVE_DOWN	;ZERO = NOT DOWN

		CALL	MOVE_DOWN	;MOVE DOWN, WILL SET FLAG
		JR	NO_MOVE_SKIP ;JUMP OVER THE CLEAR FLAG

NO_MOVE_DOWN	XOR	A
		LD	(MOVED_DOWN),A

NO_MOVE_SKIP	CALL	LEFT_RIGHT		;RETURNS EITHER CARRY SET OR NOT ZERO
					;BUT NOT BOTH, CARRY = UP, NOT ZERO = DOWN
		JR	NC,NO_MOVE_LEFT	;UP NOT PRESSED

		CALL	MOVE_LEFT		;MOVE UP, WILL SET FLAG
		JR	NO_MOVE_RIGHT	;JUMP OVER THE CLEAR THE FLAG BIT

NO_MOVE_LEFT	LD	A,0		;CLEAR THE MOVED UP FLAG
		LD	(MOVED_LEFT),A

NO_MOVE_LEFT_SKIP
		JR	Z,NO_MOVE_RIGHT	;ZERO = NOT DOWN

		CALL	MOVE_RIGHT	;MOVE DOWN, WILL SET FLAG
		JR	NO_MOVE_SKIP2	;JUMP OVER THE CLEAR FLAG

NO_MOVE_RIGHT	XOR	A
		LD	(MOVED_RIGHT),A

NO_MOVE_SKIP2	RET

;*****************************************************


		
;======================================================
;UP_DOWN ROUTINE
;TESTS THE UP AND DOWN KEYS
;AND SETS CARRY AND ZERO ACCORDINGLY
;IF BOTH KEYS ARE PRESSED THEN CARRY IS CLEAR AND ZERO IS ZERO
;IF JUST UP THEN CARRY IS SET
;IF JUST DOWN THEN ZERO IS NOT ZERO

UP_DOWN		LD	A,(SAME_KEYS+4)	;ROW	A12	(67890)
		BIT	3,A		;KEY 7 (UP)
		JR	NZ,UP_PRESSED_YES ;BIT IS 1 (KEY PRESSED)

		AND	A		;CLEAR CARRY
		JR	NO_UP

UP_PRESSED_YES	SCF
UP_DOWN_2	BIT	4,A
		JR NZ,BOTH
		RET
BOTH		XOR	A	;CLEARS CARRY AND SETS ZERO FLAG
		RET

NO_UP		BIT	4,A	;NO UP SO JUST RETURN THIS KEY
				;KEY 6 (DOWN)
				;ZERO     = NOT PRESSED
				;NOT ZERO = PRESSED
		RET
;*******************************************************

;======================================================
;LEFT_RIGHT ROUTINE
;TESTS THE LEFT AND RIGHT KEYS
;AND SETS CARRY AND ZERO ACCORDINGLY
;IF BOTH KEYS ARE PRESSED THEN CARRY IS CLEAR AND ZERO IS ZERO
;IF JUST LEFT THEN CARRY IS SET
;IF JUST RIGHT THEN ZERO IS NOT ZERO

LEFT_RIGHT	LD	A,(SAME_KEYS+3)	;ROW	A11	(12345)
		BIT	4,A		;KEY 5 (LEFT)
		JR	NZ,LEFT_PRESSED_YES ;BIT IS 1 (KEY PRESSED)

		AND	A		;CLEAR CARRY
		JR	NO_LEFT

LEFT_PRESSED_YES
		SCF
		LD	A,(SAME_KEYS+4)
LEFT_RIGHT_2	BIT	2,A
		JR NZ,BOTHLR
		RET
BOTHLR		XOR	A	;CLEARS CARRY AND SETS ZERO FLAG
		RET

NO_LEFT		LD	A,(SAME_KEYS+4)
		BIT	2,A	;NO LEFT SO JUST RETURN THIS KEY
				;KEY 8 (RIGHT)
				;ZERO     = NOT PRESSED
				;NOT ZERO = PRESSED
		RET
;******************************************************

;======================================================
;NEWLINE PRESSED
;RETURNS CARRY SET IF NEWLINE IS PRESSED
NEWLINE_PRESSED	LD	A,(SAME_KEYS+6)	;ROW	A14
		BIT	0,A
		JR	NZ,NL_PRESSED_YES
		AND	A		;CLEAR CARRY
		RET
NL_PRESSED_YES	SCF
		RET
;******************************************************

;======================================================
;S PRESSED
;RETURNS CARRY SET IF SIS PRESSED
S_PRESSED	LD	A,(SAME_KEYS+1)	;ROW	A9
		BIT	1,A
		JR	NZ,S_PRESSED_YES
		AND	A		;CLEAR CARRY
		RET
S_PRESSED_YES	SCF
		RET
;******************************************************

;======================================================
;A PRESSED
;RETURNS CARRY SET IF SIS PRESSED
A_PRESSED	LD	A,(SAME_KEYS+1)	;ROW	A9
		BIT	0,A
		JR	NZ,A_PRESSED_YES
		AND	A		;CLEAR CARRY
		RET
A_PRESSED_YES	SCF
		RET
;******************************************************

;======================================================
;ZERO PRESSED
;RETURND CARRY SET IF ZERO ID PRESSED
ZERO_PRESSED	LD	A,(SAME_KEYS+4)	;ROW	A12
		BIT	0,A
		JR	NZ,ZERO_PRESSED_YES
		AND	A		;CLEAR CARRY
		RET
ZERO_PRESSED_YES
		SCF
		RET
;******************************************************

;======================================================
;SHIFT_Q PRESSED
;RETURNS CARRY SET IF Q AND SHIFT PRESSED

SHIFT_Q_PRESSED	LD	A,(SAME_KEYS+2)	;ROW	A10
		BIT	0,A
		JR	NZ,Q_PRESSED_YES
NO_Q_OR_SHIFT	AND	A
		RET

Q_PRESSED_YES	LD	A,(SAME_KEYS)	;ROW	A8
		BIT	0,A
		JR	Z,NO_Q_OR_SHIFT
		SCF
		RET
;********************************************************

;======================================================
;SHIFT_R PRESSED
;RETURND CARRY SET IF R AND SHIFT PRESSED

SHIFT_R_PRESSED	LD	A,(SAME_KEYS+2)
		BIT	3,A
		JR	NZ,R_PRESSED_YES
NO_R_OR_SHIFT	AND	A		;CLEAR CARRY
		RET

R_PRESSED_YES	LD	A,(SAME_KEYS)	;ROW	A8
		BIT	0,A
		JR	Z,NO_R_OR_SHIFT
		SCF
		RET
;******************************************************

;======================================================
;FLIP THE LIGHTS IN A CROSS PATTERN

FLIP_PATTERNS
COL_1_PAT	.BYTE	%00100000
		.BYTE	%01110000
		.BYTE	%00100000
COL_2_PAT	.BYTE	%00010000
		.BYTE	%00111000
		.BYTE	%00010000
COL_3_PAT	.BYTE	%00001000
		.BYTE	%00011100
		.BYTE	%00001000
COL_4_PAT	.BYTE	%00000100
		.BYTE	%00001110
		.BYTE	%00000100
COL_5_PAT	.BYTE	%00000010
		.BYTE	%00000111
		.BYTE	%00000010

FLIPPED		.BYTE	$00

FLIP_LIGHTS	LD	A,(FLIPPED)
		INC	A
		RET	Z		;ALREADY FLIPPED
		LD	HL,FLIP_PATTERNS
		LD	A,(FRAME_X_POS)
		DEC	A
		LD	E,A
		LD	D,0
		ADD	HL,DE
		ADD	HL,DE
		ADD	HL,DE		;HL POINTS TO XOR PATTERN FOR
					;THE COLUMN
		LD	DE,CURRENT_LEVEL_DATA-2
		LD	A,(FRAME_Y_POS)
Y_FLIP_LOOP	INC	DE
		DEC	A
		JR	NZ,Y_FLIP_LOOP
		LD	B,3
XOR_LOOP	LD	A,(DE)
		XOR	(HL)
		LD	(DE),A
		INC	HL
		INC	DE
		DJNZ	XOR_LOOP

		LD	A,$FF
		LD	(FLIPPED),A
		LD	(CURRENT_LEVEL_DATA + 5),A
		CALL	DRAW_LEVEL
		

PLUS_1_MOVE	LD	A,(MOVES+1)
		INC	A
		DAA
		LD	(MOVES+1),A
		CP	0	;ROLLED ROUND FROM 99 TO ZERO ?
		RET	NZ
		LD	A,(MOVES)
		INC	A
		DAA
		LD	(MOVES),A
		CP	0	;ROLLED ROUND FROM 99 TO ZERO ?
		RET	NZ

		LD	A,$99
		LD	(MOVES),A
		LD	(MOVES+1),A	;OOPPS 9999 MOVES

		RET

SHOW_MOVES
		LD	HL,(D_FILE)
		LD	DE,586
		ADD	HL,DE
		LD	DE,MOVES
		LD	A,(DE)
		AND	$F0
		RRA
		RRA
		RRA
		RRA
		ADD	A,$1C
		LD	(HL),A
		INC	HL
		LD	A,(DE)
		AND	$0F
		ADD	A,$1C
		LD	(HL),A
		INC	HL
		INC	DE
		LD	A,(DE)
		AND 	$F0
		RRA
		RRA
		RRA
		RRA
		ADD	A,$1C
		LD	(HL),A
		INC	HL
		LD	A,(DE)
		AND	$0F
		ADD	A,$1C
		LD	(HL),A

		RET

		

		
;*****************************************************

;=======================================================
;MOVE THE FRAME UP

MOVED_UP	.BYTE	$00
MOVED_UP_REP	.BYTE	$00

MOVE_UP		LD	A,(MOVED_UP)
		INC	A
		JR	NZ,MOVE_UP_2		;NOT MOVED YET
		LD	A,(MOVED_UP_REP)	;GET THE REPEAT COUNTER
		INC	A
		LD	(MOVED_UP_REP),A
		CP	20			;20 TICKS YET?
		RET	C			;NOPE
MOVE_UP_2	XOR	A
		LD	(MOVED_UP_REP),A	;RESET THE REPEAT COUNTER

		LD	A,(FRAME_Y_POS)
		DEC	A
		JR	NZ,MOVE_UP_DONE
		INC	A			;BACK TO 1 THE MINIMUM
MOVE_UP_DONE	LD	(FRAME_Y_POS),A		;STORE THE NEW POS
		
		LD	A,$FF
		LD	(MOVED_UP),A
		RET

;********************************************************

;=======================================================
;MOVE THE FRAME DOWN

MOVED_DOWN	.BYTE	$00
MOVED_DOWN_REP	.BYTE	$00

MOVE_DOWN	LD	A,(MOVED_DOWN)
		INC	A
		JR	NZ,MOVE_DOWN_2		;NOT MOVED YET
		LD	A,(MOVED_DOWN_REP)	;GET THE REPEAT COUNTER
		INC	A
		LD	(MOVED_DOWN_REP),A
		CP	20			;20 TICKS YET?
		RET	C			;NOPE
MOVE_DOWN_2	XOR	A
		LD	(MOVED_DOWN_REP),A		;RESET THE REPEAT COUNTER

		LD	A,(FRAME_Y_POS)
		INC	A
		CP	6
		JR	C,MOVE_DOWN_DONE
		DEC	A			;BACK TO 5 THE MAXIMUM
MOVE_DOWN_DONE	LD	(FRAME_Y_POS),A		;STORE THE NEW POS
		
		LD	A,$FF
		LD	(MOVED_DOWN),A
		RET

;********************************************************

		
;=======================================================
;MOVE THE FRAME LEFT

MOVED_LEFT	.BYTE	$00
MOVED_LEFT_REP	.BYTE	$00

MOVE_LEFT		LD	A,(MOVED_LEFT)
		INC	A
		JR	NZ,MOVE_LEFT_2		;NOT MOVED YET
		LD	A,(MOVED_LEFT_REP)	;GET THE REPEAT COUNTER
		INC	A
		LD	(MOVED_LEFT_REP),A
		CP	20			;20 TICKS YET?
		RET	C			;NOPE
MOVE_LEFT_2	XOR	A
		LD	(MOVED_LEFT_REP),A	;RESET THE REPEAT COUNTER

		LD	A,(FRAME_X_POS)
		DEC	A
		JR	NZ,MOVE_LEFT_DONE
		INC	A			;BACK TO 1 THE MINIMUM
MOVE_LEFT_DONE	LD	(FRAME_X_POS),A		;STORE THE NEW POS
		
		LD	A,$FF
		LD	(MOVED_LEFT),A
		RET

;********************************************************

;=======================================================
;MOVE THE FRAME RIGHT

MOVED_RIGHT	.BYTE	$00
MOVED_RIGHT_REP	.BYTE	$00

MOVE_RIGHT	LD	A,(MOVED_RIGHT)
		INC	A
		JR	NZ,MOVE_RIGHT_2		;NOT MOVED YET
		LD	A,(MOVED_RIGHT_REP)	;GET THE REPEAT COUNTER
		INC	A
		LD	(MOVED_RIGHT_REP),A
		CP	20			;20 TICKS YET?
		RET	C			;NOPE
MOVE_RIGHT_2	XOR	A
		LD	(MOVED_RIGHT_REP),A		;RESET THE REPEAT COUNTER

		LD	A,(FRAME_X_POS)
		INC	A
		CP	6
		JR	C,MOVE_RIGHT_DONE
		DEC	A			;BACK TO 5 THE MAXIMUM
MOVE_RIGHT_DONE	LD	(FRAME_X_POS),A		;STORE THE NEW POS
		
		LD	A,$FF
		LD	(MOVED_RIGHT),A
		RET

;********************************************************

;======================================================
;DEMO TEXT TICKER
;EVERY XX TICKS DISPALY A NEW LINE OF THE 
;DEMO TEXT THAT SCROLL UP THE RIGHT HAND
;SIDE OF THE SCREEN
D_TEXT		LD	A,(DEMO_TEXT_TICKER)
		INC	A
		LD	(DEMO_TEXT_TICKER),A
		CP	13		;CARRY SET IF A<25
		RET	C		;NO CHANGE THIS TICK
		XOR	A		;ZERO A
		LD	(DEMO_TEXT_TICKER),A
					;RESET TICKER
TEXT_LINE	CALL	SCROLL_COLUMN	;SCROLL THE COLUMN UP
					;READY FOR NEXT LINE
					;OF TEXT
		LD	HL,(D_FILE)	;
		LD	DE,781
		ADD	HL,DE		;HL SHOULD BE LAST LINE 
		EX	DE,HL		;DE NOW SCREEN 
		LD	HL,(DEMO_TEXT)	;HL POINTS TO CURRENT LINE OF
					;DEMO TEXT
		LD	A,(HL)		;GET FIRST CHAR
					;WILL BE $FF IF END OF TEXT
		INC	A		;IF $FF THEN GOES TO ZERO
		JR	NZ,TRANS_TEXT	;NOT ZERO SO DO IT
		LD	HL,DEMOTEXT	;RESET HL BACK TO START
		LD	(DEMO_TEXT),HL	
TRANS_TEXT	LD	BC,11		;11 CHARS
		LDIR
		LD	(DEMO_TEXT),HL
		RET

;********************************************************

;=======================================================
;CLEAR COLUMN
;CALLS	SCROLL_COLUMN 24 TIMES
;ENSURING ITS CLEAR

INIT_COLUMN	LD	HL,GAME_TEXT
		LD	(DEMO_TEXT),HL
		LD	B,23		;THE COUNTER
INIT_COL_LOOP	PUSH	BC		;SAVE COUNTER
		CALL	FRAME_WAIT	;WAIT FOR FRAME
		CALL	TEXT_LINE	
		POP	BC
		DJNZ	INIT_COL_LOOP
;*******************************************************
		
;=======================================================
;COLUMN SCROLL
;THIS ROUTINE SCROLLS THE RIGHTHAND 11 COLUMNS
;VERTICALLY BY 1 LINE

SCROLL_COLUMN	LD	HL,(D_FILE)	;GET START OF SCREEN
		LD	DE,33
		ADD	HL,DE
		LD	A,23		;23 LINES TO SCROLL

SCROLL_LOOP	PUSH	AF
		LD	DE,22		;ADD TO GET TO TOP LEFT
		ADD	HL,DE		;OF COLUMN SECOND LINE
		LD	B,H
		LD	C,L		;SAVE IN BC
		LD	DE,33		
		AND	A		;CLEAR CARRY
		SBC	HL,DE		;FIRST LINE
		EX	DE,HL
		LD	H,B
		LD	L,C		;HL=SECOND LINE
					;DE=FIRST LINE
		LD	BC,11
		LDIR			;COPY SECOND LINE 
					;TO FIRST LINE
		POP	AF		;GET THE COUNTER
		DEC	A
		JR	NZ,SCROLL_LOOP

		
		LD	HL,22		
		ADD	HL,DE		;START OF LAST LINE
		LD	B,11
		XOR	A		;ZERO	A
BLANK_LOOP	LD	(HL),A
		INC	HL
		DJNZ	BLANK_LOOP
		
		RET
;********************************************************

			
		
		
;=======================================================
;SCAN THE KEY MATRIX, STORE EVERY 5 KEY ROW IN
;KEYS A8 FIRST THRU A15
;
SCAN_KEYS	LD	DE,LAST_KEYS
		LD	HL,KEYS
		LD	BC,8
		LDIR				;COPY THE LAST READ KEYS
						;BEFORE THIS SCAN

		LD	HL,KEYS			;HL POINTS TO KEYS LIST
		LD	BC,$FEFE		;START WITH A8 (BIT 0 B)
NEXT_KEYS	IN	A,(C)			;READ A ROW
		OR	%11100000		;MAKE TOP 3 BITS HIGH
		CPL				;NOW KEYS IN THAT ROW PRESSED
						;HAVE BITS SET TO 1
		LD	(HL),A
		INC	HL
		SCF				;SET CARRY FLAG
		RL	B			;MOVE THE ZERO BIT TO THE
						;NEXT COLUMN
		JR	C,NEXT_KEYS		;CARRY WILL BE SET 
						;UNTIL NO MORE KEYS

		LD	DE,SAME_KEYS
		LD	HL,KEYS
		LD	BC,LAST_KEYS
		LD	A,8
DE_BOUNCE	PUSH	AF		;SAVE COUNTER
		LD	A,(BC)
		AND	(HL)		;IF ANY KEY WAS PRESSEDON THELAST SCAN
					;ITS BIT WILL STILL BE 1 ELSE RESET TO 0
		LD	(DE),A		
		INC	HL
		INC	BC
		INC	DE
		POP	AF
		DEC	A
		JR	NZ,DE_BOUNCE	;NEXT ROW

		
		RET
;***************************************************
	
;===================================================
;COPIES LEVEL DATA TO CURRENT_LEVEL_DATA (WORKING AREA)
	
SET_LEVEL
		LD	A,(CURRENT_LEVEL)
SET_LEVEL_B	ADD	A,A
		LD	D,0
		LD	E,A
		LD	HL,LEVEL_TABLE
		ADD	HL,DE
		LD	E,(HL)
		INC	HL
		LD	D,(HL)
		EX	DE,HL
		LD	DE,CURRENT_LEVEL_DATA
		LD	BC,32
		LDIR
		CALL	DRAW_LEVEL	;DRAW THE CURRENT LEVEL
		RET
;******************************************************

;======================================================
;CHANGES THE LEVELS IN DEMO MODE
;AND CALLS SET_LEVEL ABOVE

DEMO_NEXT	LD	A,$59
		LD	(TIMER_SECONDS),A
		LD	A,(CURRENT_LEVEL)
		INC	A
		LD	(CURRENT_LEVEL),A
		CP	101
		JR	C,DEMO_NEXT1
		LD	A,1
		LD	(CURRENT_LEVEL),A
DEMO_NEXT1	CALL	SET_LEVEL
		CALL	DRAW_LEVEL	;DRAW THE CURRENT LEVEL
		RET
		
;*******************************************************


;=======================================================
;DRAW LEVEL ROUTINE
;SHOW THE STARTING GRID
;FOR THE CURRENT LEVEL
;
DRAW_LEVEL



SHOW_NAME	
		LD	HL,(D_FILE)
		LD	DE,34
		ADD	HL,DE
		LD	B,21
		XOR	A
CLEAR_NAME	LD	(HL),A
		INC	HL
		DJNZ	CLEAR_NAME

					;COPIES THE LEVEL NAME
					;TO THE SECOND LINE
		LD	HL,CURRENT_LEVEL_DATA+10
					;START OF LEVEL NAME (VARIABLE LENGTH)
		LD	B,0		;ZERO COUNTER
COUNT_CHARS	LD	A,(HL)
		INC	B		;COUNT THE CHARS
		INC	HL
		CP	$FF		;END OF TEXT?
		JR	NZ,COUNT_CHARS
		DEC	B		;UN-COUNT THE END MARKER
		LD	A,21		
		SUB	B
		AND	A
		RRA			;DIVIDE RESULT BY 2
		ADD	A,34		
		LD	D,0
		LD	E,A
		LD	HL,(D_FILE)
		ADD	HL,DE
		LD	DE,CURRENT_LEVEL_DATA+10
		EX	DE,HL
		LD	C,B
		LD	B,0
		LDIR
		
			
		LD	BC,CURRENT_LEVEL_DATA
DRAW_CEL	LD	HL,(D_FILE)
		LD	DE,101
		ADD	HL,DE

LIGHT_OUT_LOOP	PUSH	BC		;SAVE THE POINTER TO THE LEVEL DATA
		LD	A,(BC)		;GET THE NEXT BYTE
		INC	A		;INCREMENT IT,THE END MARKER IS $FF
					;SO IT WILL ROLL ROUND TO ZERO IF THE END
		JR	Z,LIGHTS_DONE	;ALL DONE ! (BC STILL ON STACK)

		DEC	A		;RETURN A TO ITS PREVIOUS VALUE
		LD	C,A		;TRANSFER A TO C
		PUSH	HL		;SAVE THE SCREEN ADDRESSS
		LD	B,3		;LOOP COUNTER

LIGHT_INNER_LOOP
		
		POP	HL		;GET THE SCREEN ADDRESS
		LD	DE,33		;OFFSET TO NEXT LINE
		ADD	HL,DE		;HL ONE MORE LINE DOWN 
		PUSH	HL		;SAVE THE ADDRESS AGAIN (1 ON STACK)

		BIT	5,C		;TEST BIT 5
		LD	A,128		;PRELOAD A WITH BLACK CHAR
		JR	Z,LIGHT_5OFF	;IS IT BLACK?
		LD	A,ZX_GREY	;NO GO GREY
LIGHT_5OFF	LD	(HL),A		
		INC	HL
		LD	(HL),A
		INC	HL
		LD	(HL),A
		INC	HL
		INC	HL		;3 CHARS + SPACE
		
		BIT	4,C		;TEST BIT 4
		LD	A,128
		JR	Z,LIGHT_4OFF
		LD	A,ZX_GREY
LIGHT_4OFF	LD	(HL),A
		INC	HL
		LD	(HL),A
		INC	HL
		LD	(HL),A
		INC	HL
		INC	HL		;3 CHARS + SPACE
		
		BIT	3,C		;TEST BIT 3
		LD	A,128
		JR	Z,LIGHT_3OFF
		LD	A,ZX_GREY
LIGHT_3OFF	LD	(HL),A
		INC	HL
		LD	(HL),A
		INC	HL
		LD	(HL),A
		INC	HL
		INC	HL		;3 CHARS + SPACE

		BIT	2,C		;TEST BIT 2
		LD	A,128
		JR	Z,LIGHT_2OFF
		LD	A,ZX_GREY
LIGHT_2OFF	LD	(HL),A
		INC	HL
		LD	(HL),A
		INC	HL
		LD	(HL),A
		INC	HL
		INC	HL		;3 CHARS + SPACE

		BIT	1,C		;TEST BIT 1
		LD	A,128
		JR	Z,LIGHT_1OFF
		LD	A,ZX_GREY
LIGHT_1OFF	LD	(HL),A
		INC	HL
		LD	(HL),A
		INC	HL
		LD	(HL),A
		INC	HL
		INC	HL		;3 CHARS + SPACE
	
		DJNZ	LIGHT_INNER_LOOP	
					;REPEAT FOR 3 LINES

		POP	HL		;GET THE OLD SCREEN ADDRESS
		LD	DE,33		;ADD AN EXTRA LINE
		ADD	HL,DE		;BLANK LINE BETWEEN ROWS
		POP	BC		;GET THE POINTER TO THE LEVEL
					;DATA
		INC	BC		;NEXT BYTE IN DATA

		JP	LIGHT_OUT_LOOP

LIGHTS_DONE	POP	BC		;DISGARD THIS VALUE LEFT ON STACK
		RET

;******************************************************

;========================================================
;SECONDS UP ROUTINE
;INCREMENTS THE TIMER_SECONDS ONCE EVERY SECOND
;IF SECOND >59 THEN RESET TO ZERO AND INCREMENT
;MINUTES
;THEN DISPLAY THE TIMER
;========================================================

SECONDS_UP	LD	A,(UK_US_RESET)
		LD	(TICKS),A

		AND	A		;CLEAR CARRY
		LD	A,(TIMER_SECONDS)
					;GET THE CURRENT SECONDS
		DEC	A		;INCREMENT IT
		DAA			;DECIAML ADJUST A (BCD)
		LD	(TIMER_SECONDS),A
					;STORE NEW SECONDS

		CP 	$99		;REACHED -1 SECONDS YET?
					;0 DECREMENTED AND DAA MAKE $99
					
		JR	NZ,SECONDS_UP_DONE
					;CARRY SET SO OK
		LD	A,$59		;ROLLS FROM 0 TO 59
		LD	(TIMER_SECONDS),A
					;ZERO THE SECONDS
		LD	A,(TIMER_MINUTES)
					;GET THE MINUTES COUNTER
		DEC	A		;INCREMENT IT
		DAA			;DECIMAL ADJUST A (BCD)
		CP	$99		;IS 16 MINUTES REACHED YET
		JR	NZ,MINUTES_DONE  ;NO
		LD	A,$00
		LD	(TIMER_SECONDS),A
					;SECONDS TO 59
		LD	A,$00		;YES RESET TO 15 (COUNTER MAXES OUT AT 15.59)
MINUTES_DONE	LD	(TIMER_MINUTES),A
SECONDS_UP_DONE	RET

;******************************************************

;=======================================================
;LEVEL TO BCD
;CONVERT THE CURRENT LEVEL NUMBER INTO A 3 DIGIT
;BCD NUMBER DUMB WAY OF DOING IT
;ALSO DISPLAYS THE BEST MOVES
;AND BEST TIMES

LEVEL_TO_BCD	LD	B,0			;100'S COUNTER
		LD	C,0			;10'COUNTER
		
		LD	A,(CURRENT_LEVEL)	;GET THE CURRENT LEVEL
						;BINARY

SUB_100		SUB	100			;FIRST TRY AND SUBTRACT 100

		JR	C,SUB_100_NO		;NO GOOD A<100

		INC	B			;COUNT THE 100'S
		JR	SUB_100

SUB_100_NO	ADD	A,100			;BACK TO PREVIOUS VALUE

						;BEFORE FAILED SUBTRACTION
SUB_10		SUB	10			;NOW LOOP ROUND ON 10'S
		JR	C,SUB_10_NO		;NO GOOD A<10
		INC	C			;COUNT THE 10'S
		JR	SUB_10

SUB_10_NO	ADD	A,10			;AT THIS POINT
						;I SHOULD HAVE
						;B = 100'S
						;C = 10'S
						;A = 1'S
		LD	HL,(D_FILE)
		LD	DE,94
		ADD	HL,DE
		ADD	A,$1C			;CONVERT A INTO ZX_CHAR
		LD	(HL),A			
		DEC	HL
		LD	A,C			;THE 10'S
		ADD	A,$1C
		LD	(HL),A
		DEC	HL
		LD	A,B
		ADD	A,$1C
		LD	(HL),A

BESTTIME	LD	HL,CURRENT_LEVEL_DATA+6	;SHOULDPOINT TO BEST TIME
						;2 BYTES BOTH ZERO IF
						;NO RECORD
		LD	A,(HL)			
		INC	HL			;SECONDBYTE
		OR	(HL)			;ANY BITS SET TO 1
		JR	NZ,SHOW_BESTTIME

						;NO TIME SET
						;DISPLAY A STRING INSTEAD
		LD	HL,(D_FILE)	
		LD	DE,419
		ADD	HL,DE	
		LD	DE,NO_RECORD
		EX	DE,HL
		LD	BC,9
		LDIR
		JR	BESTMOVES

SHOW_BESTTIME	LD	HL,(D_FILE)
		LD	DE,421
		ADD	HL,DE
		LD	DE,CURRENT_LEVEL_DATA+6
		LD	A,(DE)
		AND	$F0
		RRA
		RRA
		RRA
		RRA
		ADD	A,$1C
		LD	(HL),A
		INC	HL
		LD	A,(DE)
		AND	$0F
		ADD	A,$1C
		LD	(HL),A
		INC	HL
		LD	A,ZX_COLON
		LD	(HL),A
		INC	HL
		INC	DE
		LD	A,(DE)
		AND 	$F0
		RRA
		RRA
		RRA
		RRA
		ADD	A,$1C
		LD	(HL),A
		INC	HL
		LD	A,(DE)
		AND	$0F
		ADD	A,$1C
		LD	(HL),A

BESTMOVES	LD	HL,CURRENT_LEVEL_DATA+8
		LD	A,(HL)
		INC	HL
		OR	(HL)			;BOTH ZERO?
		JR	NZ,SHOW_BESTMOVES

		LD	HL,(D_FILE)
		LD	DE,749
		ADD	HL,DE
		LD	DE,NO_RECORD
		EX	DE,HL
		LD	BC,9
		LDIR
		RET

SHOW_BESTMOVES	LD	HL,(D_FILE)
		LD	DE,751
		ADD	HL,DE
		LD	DE,CURRENT_LEVEL_DATA+8
		LD	A,(DE)
		AND	$F0
		RRA
		RRA
		RRA
		RRA
		ADD	A,$1C
		LD	(HL),A
		INC	HL
		LD	A,(DE)
		AND	$0F
		ADD	A,$1C
		LD	(HL),A
		INC	HL
		INC	DE
		LD	A,(DE)
		AND 	$F0
		RRA
		RRA
		RRA
		RRA
		ADD	A,$1C
		LD	(HL),A
		INC	HL
		LD	A,(DE)
		AND	$0F
		ADD	A,$1C
		LD	(HL),A

		RET

NO_RECORD	.BYTE	ZX_N,ZX_O,ZX_SPC,ZX_R,ZX_E,ZX_C,ZX_O,ZX_R,ZX_D

;========================================================
;DISPLAY TIME
;QUICK AND DIRTY
;DISPLAY VARIOUS CHARACTERS FOR THE TIME
;ADD $1C TO THE VALUES

SHOW_TIME	LD	HL,(D_FILE)	;START OF D_FILE
		INC	H		;SOMEWHERE
		LD	A,(TIMER_MINUTES)
					;GET MINUTES
		AND	$F0		;TOP BCD NIBBLE
		RRA
		RRA
		RRA
		RRA
		ADD	A,$1C		;CONVERT TO CHARACTER CODE
		LD	(HL),A
		INC	HL
		LD	A,(TIMER_MINUTES)
					;GET MINUTES AGAIN
		AND 	$0F		;BOTTOM BCD NIBBLE
		ADD	A,$1C
		LD	(HL),A
		INC	HL
		LD	A,ZX_COLON	;COLON
		LD	(HL),A
		INC	HL
		LD	A,(TIMER_SECONDS)
					;GET SECONDS
		AND	$F0		;TOP BCD NIBBLE
		RRA 
		RRA
		RRA
		RRA
		ADD	A,$1C		
		LD	(HL),A
		INC	HL
		LD	A,(TIMER_SECONDS)
		AND	$0F
		ADD	A,$1C
		LD	(HL),A
		RET
;****************************************************

;=====================================================
;QUICK AND DIRTY SHOW FRAME
;DRAWS THE ANIMATED FRAME AROUND
;THE SELECT LIGHT

SHOW_FRAME	LD	A,(FRAME_X_POS)		;NEW X
		LD	B,A			;TO B
		LD	A,(FRAME_LAST_X)	;OLD X
		CP	B			;SAME ?
		JR	NZ,CLEAR_LAST		;NO
			;X THE SAME HERE
	
		LD	A,(FRAME_Y_POS)
		LD	B,A
		LD	A,(FRAME_LAST_Y)
		CP	B
		JR	Z,SHOW_CURRENT_FRAME

CLEAR_LAST	LD	HL,(FRAME_X_POS)	;GET THE CURRENT POS
		PUSH	HL			;SAVE IT
		LD	HL,(FRAME_LAST_X)	;GET POSITION TO CLEAR
		LD	(FRAME_X_POS),HL
		LD	BC,FRAME_EMPTY
		CALL	CLEAR_FRAME
		POP	HL
		LD	(FRAME_X_POS),HL

			




SHOW_CURRENT_FRAME
		LD	A,(CURRENT_FRAME)
		INC	A
		LD	(CURRENT_FRAME),A
		AND	$06		;KEEP ONLY A %00011000
		RLA			;ROTATE LEFT TIMES 2
		RLA
		RLA
		LD	E,A
		LD	D,0
		LD	HL,FRAME_0
		ADD	HL,DE		;HL POINTS TO FRAME TO USE
		LD	B,H
		LD	C,L
CLEAR_FRAME	LD	HL,(D_FILE)	;MUST BE ENTERED WITH BC
					;CONTAINING THE ADDRESS	
					;OF THE EMPTY FRAME.
		LD	DE,100
		ADD	HL,DE		;DE NOW LEFT HAND EDGE 4TH LINE
		LD	A,(FRAME_X_POS)
		DEC	A
		LD	D,0
		LD	E,A
		ADD	HL,DE
		ADD	HL,DE
		ADD	HL,DE
		ADD	HL,DE
		LD	A,(FRAME_Y_POS)
		
		LD	DE,132
		AND	A
		SBC	HL,DE
SFL		ADD	HL,DE
		DEC	A
		JR	NZ,SFL
		LD	D,0
		LD	E,
		LD	A,(BC)
		LD	(HL),A		;0
		INC	BC
		INC	HL
		LD	A,(BC)
		LD	(HL),A		;1
		INC	BC
		INC	HL
		LD	A,(BC)
		LD	(HL),A		;2
		INC	BC
		INC	HL
		LD	A,(BC)
		LD	(HL),A		;3
		INC	BC
		INC	HL
		LD	A,(BC)
		LD	(HL),A		;4
		LD	DE,33
		ADD	HL,DE
		INC	BC
		LD	A,(BC)
		LD	(HL),A		;5
		ADD	HL,DE
		INC	BC
		LD	A,(BC)
		LD	(HL),A		;6
		ADD	HL,DE
		INC	BC
		LD	A,(BC)
		LD	(HL),A		;7
		ADD	HL,DE
		INC	BC
		LD	A,(BC)
		LD	(HL),A		;8
		DEC	HL
		INC	BC
		LD	A,(BC)
		LD	(HL),A		;9
		DEC	HL
		INC	BC	
		LD	A,(BC)
		LD	(HL),A		;10
		DEC	HL
		INC	BC	
		LD	A,(BC)
		LD	(HL),A		;11
		DEC	HL
		INC	BC
		LD	A,(BC)
		LD	(HL),A		;12
		AND	A		;
		SBC	HL,DE
		INC	BC	
		LD	A,(BC)
		LD	(HL),A		;13
		AND	A
		SBC	HL,DE
		INC	BC
		LD	A,(BC)
		LD	(HL),A		;14
		AND	A
		SBC	HL,DE
		INC	BC
		LD	A,(BC)
		LD	(HL),A
		LD	A,(FRAME_X_POS)
		LD	(FRAME_LAST_X),A
		LD	A,(FRAME_Y_POS)
		LD	(FRAME_LAST_Y),A
		RET

;*******************************************************
		
;========================================================
;FRAME WAITING SUBROUTINE
;USES DE,HL,A
;WAITS FOR THE SYSTEM VARIABLE FRAMES
;TO CHANGE
;========================================================
		
FRAME_WAIT	LD	DE,(FRAMES)	;GET FRAMES

FRAME_WAIT_LOOP	LD	HL,(FRAMES)	;GET FRAMES
		AND	A		;CLEAR CARRY
		SBC	HL,DE		;HL=DE?
		JR	Z,FRAME_WAIT_LOOP
		RET			;END OF SUBROUTINE

;********************************************************

;=========================================================

INITIALIZE				;NOTHING HAPPENING YET
		IN 	A,($FE)		;READ UK/US
		BIT	6,A		;US OR US?
		LD	A,$3C		;UK RESET VALUE
		JR	Z,UK_US_DONE
		LD	A,$32		;US RESET VALUE
UK_US_DONE	LD	(UK_US_RESET),A
		LD	(TICKS),A	;RESET THE TICKER
					;COUNTS DOWN TO ZERO
					;EVERY FRAME
		LD	A,1
		LD	(CURRENT_LEVEL),A
		CALL	SET_LEVEL
		LD	HL,DEMOTEXT
		LD	(DEMO_TEXT),HL

		RET
;*******************************************************

START_LEVEL

		XOR	A		;ZERO ACCUMULATOR
		LD	(TIMER_SECONDS),A	
					;ZERO THE TIMER (SECONDS)
		LD	(TIMER_MINUTES),A
	
				;ZERO THE TIMER (MINUTES)
	
		RET

TIMER_MINUTES	.BYTE	$00		;BCD MINUTES 2 DIGITS
TIMER_SECONDS	.BYTE	$00		;BCD SECONDS 2 DIGITS
TICKS		.BYTE	$51		;TICKER COUNTER
UK_US_RESET	.BYTE	$51		;UK/US TICKER COUNTER RESET VALUE
MOVES		.WORD	$0000		;MOVES COUNTER

;========================================================
;IN GAME COLUMN TEXT
;
GAME_TEXT	
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_L,ZX_E,ZX_V,ZX_E,ZX_L,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB
		.BYTE	ZX_SPC,ZX_T,ZX_I,ZX_M,ZX_E,ZX_SPC,ZX_L,ZX_E,ZX_F,ZX_T,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB
		.BYTE	ZX_SPC,ZX_B,ZX_E,ZX_S,ZX_T,ZX_SPC,ZX_T,ZX_I,ZX_M,ZX_E,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_M,ZX_O,ZX_V,ZX_E,ZX_S,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB
		.BYTE	ZX_SPC,ZX_B,ZX_E,ZX_S,ZX_T,ZX_SPC,ZX_M,ZX_O,ZX_V,ZX_E,ZX_S
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0

;LEVEL SELECT TEXT

SELECT_TEXT	.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_U,ZX_S,ZX_E,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	ZX_U,ZX_P,ZX_SPC,ZX_A,ZX_N,ZX_D,ZX_SPC,ZX_D,ZX_O,ZX_W,ZX_N
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_T,ZX_O,ZX_SPC,ZX_S,ZX_E,ZX_L,ZX_E,ZX_C,ZX_T,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_T,ZX_H,ZX_E,ZX_SPC,ZX_S,ZX_T,ZX_A,ZX_R,ZX_T,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_L,ZX_E,ZX_V,ZX_E,ZX_L,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_SPC,ZX_Y,ZX_O,ZX_U,ZX_SPC,ZX_C,ZX_A,ZX_N,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_O,ZX_N,ZX_L,ZX_Y,ZX_SPC,ZX_S,ZX_E,ZX_L,ZX_E,ZX_C,ZX_T
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_A,ZX_SPC,ZX_L,ZX_E,ZX_V,ZX_E,ZX_L,ZX_SPC,ZX_Y,ZX_O,ZX_U
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_H,ZX_A,ZX_V,ZX_E,ZX_SPC,ZX_B,ZX_E,ZX_E,ZX_N,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_O,ZX_N,ZX_PERIOD,ZX_SPC,ZX_P,ZX_R,ZX_E,ZX_S,ZX_S,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_SPC,ZX_N,ZX_E,ZX_W,ZX_L,ZX_I,ZX_N,ZX_E,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_W,ZX_H,ZX_E,ZX_N,ZX_SPC,ZX_R,ZX_E,ZX_A,ZX_D,ZX_Y
		.BYTE	ZX_SPC,ZX_T,ZX_O,ZX_SPC,ZX_SPC,ZX_B,ZX_E,ZX_G,ZX_I,ZX_N,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		
;DEMOTEXT
DEMO_TEXT_TICKER
		.BYTE	$00

DEMO_TEXT	.WORD	DEMOTEXT		;USED TO STORE WHERE IN TEXT
						;THE NEXT LINE IS COMING FROM
DEMOTEXT	
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_L,ZX_I,ZX_G,ZX_H,ZX_T,ZX_S,ZX_SPC,ZX_SPC,ZX_O,ZX_U,ZX_T
		.BYTE	ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB,ZX_THB
		.BYTE	ZX_SPC,ZX_C,ZX_O,ZX_P,ZX_Y,ZX_R,ZX_I,ZX_G,ZX_H,ZX_T,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_T,ZX_I,ZX_G,ZX_E,ZX_R,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_G,ZX_A,ZX_M,ZX_E,ZX_S,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_Z,ZX_X,ZX_SPC,ZX_8,ZX_1,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_SPC,ZX_C,ZX_O,ZX_N,ZX_V,ZX_E,ZX_R,ZX_S,ZX_I,ZX_O,ZX_N
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_B,ZX_Y,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_A,ZX_N,ZX_D,ZX_R,ZX_E,ZX_W,ZX_SPC,ZX_SPC,ZX_R,ZX_E,ZX_A
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_A,ZX_P,ZX_R,ZX_I,ZX_L,ZX_SPC,ZX_SPC,ZX_2,ZX_0,ZX_0,ZX_7
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_T,ZX_R,ZX_Y,ZX_SPC,ZX_T,ZX_O,ZX_SPC,ZX_T,ZX_U,ZX_R,ZX_N
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_SPC,ZX_A,ZX_L,ZX_L,ZX_SPC,ZX_T,ZX_H,ZX_E,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_L,ZX_I,ZX_G,ZX_H,ZX_T,ZX_S,ZX_SPC,ZX_SPC,ZX_O,ZX_U,ZX_T
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_B,ZX_E,ZX_F,ZX_O,ZX_R,ZX_E,ZX_SPC,ZX_T,ZX_I,ZX_M,ZX_E
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_SPC,ZX_R,ZX_U,ZX_N,ZX_S,ZX_SPC,ZX_O,ZX_U,ZX_T,ZX_PERIOD,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_Y,ZX_O,ZX_U,ZX_SPC,ZX_H,ZX_A,ZX_V,ZX_E,ZX_SPC,ZX_1,ZX_5
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_SPC,ZX_SPC,ZX_M,ZX_I,ZX_N,ZX_U,ZX_T,ZX_E,ZX_S,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_T,ZX_O,ZX_SPC,ZX_C,ZX_O,ZX_M,ZX_P,ZX_L,ZX_E,ZX_T,ZX_E
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_E,ZX_A,ZX_C,ZX_H,ZX_SPC,ZX_SPC,ZX_L,ZX_E,ZX_V,ZX_E,ZX_L
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_A,ZX_N,ZX_SPC,ZX_O,ZX_N,ZX_SPC,ZX_L,ZX_I,ZX_G,ZX_H,ZX_T
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_I,ZX_S,ZX_SPC,ZX_S,ZX_H,ZX_O,ZX_W,ZX_N,ZX_SPC,ZX_A,ZX_S
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_GREY,ZX_GREY,ZX_GREY,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_GREY,ZX_GREY,ZX_GREY,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_GREY,ZX_GREY,ZX_GREY,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_A,ZX_N,ZX_D,ZX_SPC,ZX_O,ZX_F,ZX_F,ZX_SPC,ZX_A,ZX_S
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_FB,ZX_FB,ZX_FB,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_FB,ZX_FB,ZX_FB,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_FB,ZX_FB,ZX_FB,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_D,ZX_U,ZX_R,ZX_I,ZX_N,ZX_G,ZX_SPC,ZX_P,ZX_L,ZX_A,ZX_Y
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_P,ZX_R,ZX_E,ZX_S,ZX_S,ZX_SPC,ZX_T,ZX_H,ZX_E,ZX_S,ZX_E
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_K,ZX_E,ZX_Y,ZX_S,ZX_COLON,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_5,ZX_COLON,ZX_SPC,ZX_L,ZX_E,ZX_F,ZX_T,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0

		.BYTE	ZX_6,ZX_COLON,ZX_SPC,ZX_D,ZX_O,ZX_W,ZX_N,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0

		.BYTE	ZX_7,ZX_COLON,ZX_SPC,ZX_U,ZX_P,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0

		.BYTE	ZX_8,ZX_COLON,ZX_SPC,ZX_R,ZX_I,ZX_G,ZX_H,ZX_T,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0

		.BYTE	ZX_0,ZX_COLON,ZX_SPC,ZX_T,ZX_O,ZX_G,ZX_G,ZX_L,ZX_E,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0

		.BYTE	ZX_S,ZX_H,ZX_I,ZX_F,ZX_T,ZX_SPC,ZX_A,ZX_N,ZX_D,ZX_SPC,ZX_R
		.BYTE	0,0,0,0,0,0,0,0,0,0,0

		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_R,ZX_E,ZX_S,ZX_E,ZX_T,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC,ZX_L,ZX_E,ZX_V,ZX_E,ZX_L
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_S,ZX_H,ZX_I,ZX_F,ZX_T,ZX_SPC,ZX_A,ZX_N,ZX_D,ZX_SPC,ZX_Q
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	ZX_SPC,ZX_SPC,ZX_E,ZX_X,ZX_I,ZX_T,ZX_SPC,ZX_T,ZX_O,ZX_SPC,ZX_SPC
		.BYTE	ZX_D,ZX_E,ZX_M,ZX_O,ZX_SPC,ZX_S,ZX_C,ZX_R,ZX_E,ZX_E,ZX_N
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		

		.BYTE	ZX_A,ZX_T,ZX_SPC,ZX_T,ZX_H,ZX_E,ZX_SPC,ZX_D,ZX_E,ZX_M,ZX_O
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_S,ZX_C,ZX_R,ZX_E,ZX_E,ZX_N,ZX_SPC,ZX_U,ZX_S,ZX_E,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_T,ZX_H,ZX_E,ZX_S,ZX_E,ZX_SPC,ZX_K,ZX_E,ZX_Y,ZX_S,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0		
		.BYTE	ZX_S,ZX_COLON,ZX_SPC,ZX_S,ZX_A,ZX_V,ZX_E,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	ZX_SPC,ZX_SPC,ZX_SPC,ZX_P,ZX_R,ZX_O,ZX_G,ZX_R,ZX_E,ZX_S,ZX_S
		.BYTE	0,0,0,0,0,0,0,0,0,0,0

		.BYTE	ZX_A,ZX_COLON,ZX_SPC,ZX_Q,ZX_U,ZX_I,ZX_T,ZX_SPC,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	0,0,0,0,0,0,0,0,0,0,0

		.BYTE	ZX_N,ZX_E,ZX_W,ZX_L,ZX_I,ZX_N,ZX_E,ZX_COLON,ZX_SPC,ZX_SPC,ZX_SPC
		.BYTE	ZX_SPC,ZX_S,ZX_T,ZX_A,ZX_R,ZX_T,ZX_SPC,ZX_G,ZX_A,ZX_M,ZX_E
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	0,0,0,0,0,0,0,0,0,0,0
		.BYTE	$FF

;SOME OTHER VARIABLES

KEYS		.WORD	0,0,0,0
LAST_KEYS	.WORD	0,0,0,0
SAME_KEYS	.WORD	0,0,0,0

		.BYTE	0
CURRENT_LEVEL_DATA
		
		.WORD	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

;========================================================
;THE STRING DEFINITIONS FOR THE ANIMATED FRAME

FRAME_X_POS	.BYTE	$02
FRAME_Y_POS	.BYTE	$02
FRAME_LAST_X	.BYTE	$00
FRAME_LAST_Y	.BYTE	$00
CURRENT_FRAME 	.BYTE	$00

FRAME_0		.BYTE	ZX_BRQ , ZX_SPC , ZX_BRQ , ZX_SPC
		.BYTE	ZX_SPC , ZX_TLQ , ZX_SPC , ZX_TLQ
		.BYTE	ZX_SPC , ZX_TLQ , ZX_SPC , ZX_TLQ
		.BYTE	ZX_SPC , ZX_SPC , ZX_BRQ , ZX_SPC

FRAME_1		.BYTE	ZX_SPC , ZX_BLQ , ZX_SPC , ZX_BLQ
		.BYTE	ZX_SPC , ZX_BLQ , ZX_SPC , ZX_BLQ
		.BYTE	ZX_SPC , ZX_SPC , ZX_TRQ , ZX_SPC
		.BYTE	ZX_TRQ , ZX_SPC , ZX_TRQ , ZX_SPC

FRAME_2		.BYTE	ZX_SPC , ZX_BRQ , ZX_SPC , ZX_BRQ
		.BYTE	ZX_SPC , ZX_SPC , ZX_TLQ , ZX_SPC
		.BYTE	ZX_TLQ , ZX_SPC , ZX_TLQ , ZX_SPC
		.BYTE	ZX_SPC , ZX_BRQ , ZX_SPC , ZX_BRQ

FRAME_3		.BYTE	ZX_SPC , ZX_SPC , ZX_BLQ , ZX_SPC
		.BYTE	ZX_BLQ , ZX_SPC , ZX_BLQ , ZX_SPC
		.BYTE	ZX_SPC , ZX_TRQ , ZX_SPC , ZX_TRQ
		.BYTE	ZX_SPC , ZX_TRQ , ZX_SPC , ZX_TRQ

FRAME_EMPTY	.BYTE	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0


;===============================================================
;THE LEVELS
;STORED THUS 	5 BYTES DEFINE THE STARTING GRID
;		1 BYTE $FF
;		2 BYTES BEST TIME MINUTES,SECONDS (BCD)
;		2 BYTES BEST MOVES 4 DIGITS	(BCD)
;		VARIABLE LENGTH BYTES LEVEL NAME.
;		1 BYTE $FF	(END MARKER)

CURRENT_LEVEL	.BYTE	$01
BEST_LEVEL	.BYTE	$01


LEVEL_TABLE

LV0		.WORD	LEVEL_1
LV1		.WORD	LEVEL_1
LV2		.WORD	LEVEL_2
LV3		.WORD	LEVEL_3
LV4		.WORD	LEVEL_4
LV5		.WORD	LEVEL_5
LV6		.WORD	LEVEL_6
LV7		.WORD	LEVEL_7
LV8		.WORD	LEVEL_8
LV9		.WORD	LEVEL_9
LV10		.WORD	LEVEL_10
LV11		.WORD	LEVEL_11
LV12		.WORD	LEVEL_12
LV13		.WORD	LEVEL_13
LV14		.WORD	LEVEL_14
LV15		.WORD	LEVEL_15
LV16		.WORD	LEVEL_16
LV17		.WORD	LEVEL_17
LV18		.WORD	LEVEL_18
LV19		.WORD	LEVEL_19
LV20		.WORD	LEVEL_20
LV21		.WORD	LEVEL_21
LV22		.WORD	LEVEL_22
LV23		.WORD	LEVEL_23
LV24		.WORD	LEVEL_24
LV25		.WORD	LEVEL_25
LV26		.WORD	LEVEL_26
LV27		.WORD	LEVEL_27
LV28		.WORD	LEVEL_28
LV29		.WORD	LEVEL_29
LV30		.WORD	LEVEL_30
LV31		.WORD	LEVEL_31
LV32		.WORD	LEVEL_32
LV33		.WORD	LEVEL_33
LV34		.WORD	LEVEL_34
LV35		.WORD	LEVEL_35
LV36		.WORD	LEVEL_36
LV37		.WORD	LEVEL_37
LV38		.WORD	LEVEL_38
LV39		.WORD	LEVEL_39
LV40		.WORD	LEVEL_40
LV41		.WORD	LEVEL_3
LV42		.WORD	LEVEL_1
LV43		.WORD	LEVEL_2
LV44		.WORD	LEVEL_3
LV45		.WORD	LEVEL_1
LV46		.WORD	LEVEL_2
LV47		.WORD	LEVEL_3
LV48		.WORD	LEVEL_1
LV49		.WORD	LEVEL_2
LV50		.WORD	LEVEL_3
LV51		.WORD	LEVEL_1
LV52		.WORD	LEVEL_2
LV53		.WORD	LEVEL_3
LV54		.WORD	LEVEL_1
LV55		.WORD	LEVEL_2
LV56		.WORD	LEVEL_3
LV57		.WORD	LEVEL_1
LV58		.WORD	LEVEL_2
LV59		.WORD	LEVEL_3
LV60		.WORD	LEVEL_1
LV61		.WORD	LEVEL_2
LV62		.WORD	LEVEL_3
LV63		.WORD	LEVEL_1
LV64		.WORD	LEVEL_2
LV65		.WORD	LEVEL_3
LV66		.WORD	LEVEL_1
LV67		.WORD	LEVEL_2
LV68		.WORD	LEVEL_3
LV69		.WORD	LEVEL_1
LV70		.WORD	LEVEL_2
LV71		.WORD	LEVEL_3
LV72		.WORD	LEVEL_1
LV73		.WORD	LEVEL_2
LV74		.WORD	LEVEL_3
LV75		.WORD	LEVEL_1
LV76		.WORD	LEVEL_2
LV77		.WORD	LEVEL_3
LV78		.WORD	LEVEL_1
LV79		.WORD	LEVEL_2
LV80		.WORD	LEVEL_3
LV81		.WORD	LEVEL_1
LV82		.WORD	LEVEL_2
LV83		.WORD	LEVEL_3
LV84		.WORD	LEVEL_1
LV85		.WORD	LEVEL_2
LV86		.WORD	LEVEL_3
LV87		.WORD	LEVEL_1
LV88		.WORD	LEVEL_2
LV89		.WORD	LEVEL_3
LV90		.WORD	LEVEL_2
LV91		.WORD	LEVEL_1
LV92		.WORD	LEVEL_2
LV93		.WORD	LEVEL_3
LV94		.WORD	LEVEL_1
LV95		.WORD	LEVEL_2
LV96		.WORD	LEVEL_3
LV97		.WORD	LEVEL_1
LV98		.WORD	LEVEL_2
LV99		.WORD	LEVEL_3
LV100		.WORD 	LEVEL_2

LVLAST		.WORD	LEVEL_LAST


CELERBRATE1	.BYTE	%00001000
		.BYTE	%00001000
		.BYTE	%00001000
		.BYTE	%00001000
		.BYTE	%00001000

CELERBRATE2	.BYTE	%00000100
		.BYTE	%00000100
		.BYTE	%00001000
		.BYTE	%00010000
		.BYTE	%00010000

CELERBRATE3	.BYTE	%00000010
		.BYTE	%00000100
		.BYTE	%00001000
		.BYTE	%00010000
		.BYTE	%00100000

CELERBRATE4	.BYTE	%00000000
		.BYTE	%00000110
		.BYTE	%00001000
		.BYTE	%00110000
		.BYTE	%00000000

CELERBRATE5	.BYTE	%00000000
		.BYTE	%00000000
		.BYTE	%00111110
		.BYTE	%00000000
		.BYTE	%00000000

CELERBRATE6	.BYTE	%00000000
		.BYTE	%00110000
		.BYTE	%00001000
		.BYTE	%00000110
		.BYTE	%00000000

CELERBRAT7	.BYTE	%00100000
		.BYTE	%00010000
		.BYTE	%00001000
		.BYTE	%00000100
		.BYTE	%00000010

CELERBRATE8	.BYTE	%00010000
		.BYTE	%00010000
		.BYTE	%00001000
		.BYTE	%00000100
		.BYTE	%00000100


LEVEL_1		.BYTE	%00000000
		.BYTE	%00001000
		.BYTE	%00011100
		.BYTE	%00001000
		.BYTE	%00000000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_J , ZX_U , ZX_S , ZX_T , ZX_SPC
		.BYTE	ZX_F , ZX_O , ZX_R , ZX_SPC
		.BYTE	ZX_S , ZX_T , ZX_A , ZX_R , ZX_T
		.BYTE	ZX_E , ZX_R , ZX_S
		.BYTE	$FF

LEVEL_2		.BYTE	%00110110
		.BYTE	%00101010
		.BYTE	%00011100
		.BYTE	%00101010
		.BYTE	%00110110
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_L , ZX_E , ZX_A , ZX_R , ZX_N
		.BYTE	ZX_I , ZX_N , ZX_G
		.BYTE	$FF

LEVEL_3		.BYTE	%00111110
		.BYTE	%00110110
		.BYTE	%00011100
		.BYTE	%00110110
		.BYTE	%00111110
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_I , ZX_N , ZX_T , ZX_E , ZX_R
		.BYTE	ZX_E , ZX_S , ZX_T , ZX_I , ZX_N
		.BYTE	ZX_G
		.BYTE	$FF

LEVEL_4		.BYTE	%00001000
		.BYTE	%00011100
		.BYTE	%00001000
		.BYTE	%00001000
		.BYTE	%00001000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_C , ZX_R , ZX_O , ZX_S , ZX_S
		.BYTE	$FF

LEVEL_5		.BYTE	%00001000
		.BYTE	%00010100
		.BYTE	%00010100
		.BYTE	%00010100
		.BYTE	%00001000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_N,ZX_U,ZX_M,ZX_B,ZX_E,ZX_R,ZX_S,ZX_SPC
		.BYTE	ZX_U,ZX_P,ZX_SPC,ZX_0
		.BYTE	$FF

LEVEL_6		.BYTE	%00000000
		.BYTE	%00010100
		.BYTE	%00001000
		.BYTE	%00010100
		.BYTE	%00000000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_S,ZX_M,ZX_A,ZX_L,ZX_L,ZX_SPC
		.BYTE	ZX_X
		.BYTE	$FF

LEVEL_7		.BYTE	%00001000
		.BYTE	%00010100
		.BYTE	%00100010
		.BYTE	%00111110
		.BYTE	%00100010
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_A,ZX_L,ZX_P,ZX_H,ZX_A,ZX_B,ZX_E,ZX_T,ZX_SPC
		.BYTE	ZX_S,ZX_O,ZX_U,ZX_P,ZX_SPC,ZX_A
		.BYTE	$FF

LEVEL_8		.BYTE	%00101010
		.BYTE	%00101010
		.BYTE	%00101010
		.BYTE	%00101010
		.BYTE	%00101010
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_B,ZX_A,ZX_R,ZX_S
		.BYTE	$FF

LEVEL_9		.BYTE	%00001000
		.BYTE	%00010100
		.BYTE	%00100010
		.BYTE	%00010100
		.BYTE	%00001000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_D,ZX_I,ZX_A,ZX_M,ZX_O,ZX_N,ZX_D,ZX_SPC
		.BYTE	ZX_1
		.BYTE	$FF

LEVEL_10	.BYTE	%00111100
		.BYTE	%00100010
		.BYTE	%00111110
		.BYTE	%00100010
		.BYTE	%00111100
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_A,ZX_L,ZX_P,ZX_H,ZX_A,ZX_B,ZX_E,ZX_T,ZX_SPC
		.BYTE	ZX_S,ZX_O,ZX_U,ZX_P,ZX_SPC,ZX_B
		.BYTE	$FF

LEVEL_11	.BYTE	%00000000
		.BYTE	%00000000
		.BYTE	%00111110
		.BYTE	%00000000
		.BYTE	%00000000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_S,ZX_P,ZX_L,ZX_I,ZX_T
		.BYTE	$FF

LEVEL_12	.BYTE	%00001000
		.BYTE	%00011000
		.BYTE	%00001000
		.BYTE	%00001000
		.BYTE	%00011100
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_N,ZX_U,ZX_M,ZX_B,ZX_E,ZX_R,ZX_S,ZX_SPC
		.BYTE	ZX_U,ZX_P,ZX_SPC,ZX_1
		.BYTE	$FF

LEVEL_13	.BYTE	%00111110
		.BYTE	%00100010
		.BYTE	%00100010
		.BYTE	%00100010
		.BYTE	%00111110
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_B,ZX_O,ZX_X
		.BYTE	$FF

LEVEL_14	.BYTE	%00001110
		.BYTE	%00010000
		.BYTE	%00110000
		.BYTE	%00010000
		.BYTE	%00001110
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_A,ZX_L,ZX_P,ZX_H,ZX_A,ZX_B,ZX_E,ZX_T,ZX_SPC
		.BYTE	ZX_S,ZX_O,ZX_U,ZX_P,ZX_SPC,ZX_C
		.BYTE	$FF
		
LEVEL_15	.BYTE	%00101010
		.BYTE	%00111110
		.BYTE	%00011100
		.BYTE	%00011100
		.BYTE	%00011100
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_C,ZX_A,ZX_S,ZX_T,ZX_L,ZX_E
		.BYTE	$FF

LEVEL_16	.BYTE	%00111110
		.BYTE	%00111110
		.BYTE	%00110110
		.BYTE	%00111110
		.BYTE	%00111110
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_A,ZX_L,ZX_L,ZX_SPC,ZX_B,ZX_U,ZX_T,ZX_SPC,ZX_1
		.BYTE	$FF

LEVEL_17	.BYTE	%00011100
		.BYTE	%00000100
		.BYTE	%00001000
		.BYTE	%00010000
		.BYTE	%00011100
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_N,ZX_U,ZX_M,ZX_B,ZX_E,ZX_R,ZX_S,ZX_SPC
		.BYTE	ZX_U,ZX_P,ZX_SPC,ZX_2
		.BYTE	$FF

LEVEL_18	.BYTE	%00101010
		.BYTE	%00010100
		.BYTE	%00101010
		.BYTE	%00010100
		.BYTE	%00101010
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_C,ZX_H,ZX_E,ZX_Q,ZX_U,ZX_E,ZX_R,ZX_E,ZX_D
		.BYTE	$FF

LEVEL_19	.BYTE	%00111000
		.BYTE	%00100100
		.BYTE	%00100010
		.BYTE	%00100100
		.BYTE	%00111000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_A,ZX_L,ZX_P,ZX_H,ZX_A,ZX_B,ZX_E,ZX_T,ZX_SPC
		.BYTE	ZX_S,ZX_O,ZX_U,ZX_P,ZX_SPC,ZX_D
		.BYTE	$FF

LEVEL_20	.BYTE	%00111110
		.BYTE	%00100000
		.BYTE	%00111000
		.BYTE	%00100000
		.BYTE	%00111110
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_A,ZX_L,ZX_P,ZX_H,ZX_A,ZX_B,ZX_E,ZX_T,ZX_SPC
		.BYTE	ZX_S,ZX_O,ZX_U,ZX_P,ZX_SPC,ZX_E
		.BYTE	$FF

LEVEL_21	.BYTE	%00001000
		.BYTE	%00011100
		.BYTE	%00110110
		.BYTE	%00011100
		.BYTE	%00001000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_D,ZX_I,ZX_A,ZX_M,ZX_O,ZX_N,ZX_D,ZX_SPC,ZX_2
		.BYTE	$FF

LEVEL_22	.BYTE	%00011100
		.BYTE	%00000100
		.BYTE	%00011100
		.BYTE	%00000100
		.BYTE	%00011100
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_N,ZX_U,ZX_M,ZX_B,ZX_E,ZX_R,ZX_S,ZX_SPC
		.BYTE	ZX_U,ZX_P,ZX_SPC,ZX_3
		.BYTE	$FF

LEVEL_23	.BYTE	%00011110
		.BYTE	%00101100
		.BYTE	%00111000
		.BYTE	%00111100
		.BYTE	%00011110
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_P,ZX_A,ZX_C,ZX_MINUS,ZX_M,ZX_A,ZX_N
		.BYTE	$FF

LEVEL_24	.BYTE	%00101010
		.BYTE	%00010100
		.BYTE	%00001000
		.BYTE	%00000000
		.BYTE	%00001000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_W,ZX_H,ZX_A,ZX_T,ZX_SPC,ZX_I,ZX_S,ZX_SPC,ZX_I,ZX_T
		.BYTE	$FF

LEVEL_25	.BYTE	%00111110
		.BYTE	%00100000
		.BYTE	%00111100
		.BYTE	%00100000
		.BYTE	%00100000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_A,ZX_L,ZX_P,ZX_H,ZX_A,ZX_B,ZX_E,ZX_T,ZX_SPC
		.BYTE	ZX_S,ZX_O,ZX_U,ZX_P,ZX_SPC,ZX_F
		.BYTE	$FF
		
LEVEL_26	.BYTE	%00100000
		.BYTE	%00101000
		.BYTE	%00001000
		.BYTE	%00001010
		.BYTE	%00000010
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_H,ZX_M,ZX_M,ZX_M
		.BYTE	$FF

LEVEL_27	.BYTE	%00000000
		.BYTE	%00011100
		.BYTE	%00100010
		.BYTE	%00111110
		.BYTE	%00010100
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_M,ZX_U,ZX_S,ZX_H,ZX_R,ZX_O,ZX_O,ZX_M
		.BYTE	$FF

LEVEL_28	.BYTE	%00001000
		.BYTE	%00111110
		.BYTE	%00001000
		.BYTE	%00001000
		.BYTE	%00001000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_C,ZX_R,ZX_O,ZX_S,ZX_S,ZX_SPC,ZX_2
		.BYTE	$FF

LEVEL_29	.BYTE	%00011100
		.BYTE	%00100000
		.BYTE	%00101100
		.BYTE	%00100100
		.BYTE	%00011100
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_A,ZX_L,ZX_P,ZX_H,ZX_A,ZX_B,ZX_E,ZX_T,ZX_SPC
		.BYTE	ZX_S,ZX_O,ZX_U,ZX_P,ZX_SPC,ZX_G
		.BYTE	$FF

LEVEL_30	.BYTE	%00100010
		.BYTE	%00100010
		.BYTE	%00111110
		.BYTE	%00100010
		.BYTE	%00100010
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_A,ZX_L,ZX_P,ZX_H,ZX_A,ZX_B,ZX_E,ZX_T,ZX_SPC
		.BYTE	ZX_S,ZX_O,ZX_U,ZX_P,ZX_SPC,ZX_H
		.BYTE	$FF

LEVEL_31	.BYTE	%00001000
		.BYTE	%00011100
		.BYTE	%00011100
		.BYTE	%00011100
		.BYTE	%00011100
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_T,ZX_O,ZX_W,ZX_E,ZX_R
		.BYTE	$FF

LEVEL_32	.BYTE	%00011100
		.BYTE	%00010000
		.BYTE	%00011100
		.BYTE	%00000100
		.BYTE	%00011100
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_N,ZX_U,ZX_M,ZX_B,ZX_E,ZX_R,ZX_S,ZX_SPC
		.BYTE	ZX_U,ZX_P,ZX_SPC,ZX_5
		.BYTE	$FF

LEVEL_33	.BYTE	%00000000
		.BYTE	%00000000
		.BYTE	%00001000
		.BYTE	%00011100
		.BYTE	%00111110
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_T,ZX_R,ZX_I,ZX_A,ZX_N,ZX_G,ZX_L,ZX_E
		.BYTE	$FF

LEVEL_34	.BYTE	%00000000
		.BYTE	%00000000
		.BYTE	%00001000
		.BYTE	%00000000
		.BYTE	%00000000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_J,ZX_U,ZX_S,ZX_T,ZX_SPC,ZX_O,ZX_N,ZX_E
		.BYTE	$FF

LEVEL_35	.BYTE	%00111110
		.BYTE	%00001000
		.BYTE	%00001000
		.BYTE	%00001000
		.BYTE	%00111110
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_A,ZX_L,ZX_P,ZX_H,ZX_A,ZX_B,ZX_E,ZX_T,ZX_SPC
		.BYTE	ZX_S,ZX_O,ZX_U,ZX_P,ZX_SPC,ZX_I
		.BYTE	$FF

LEVEL_36	.BYTE	%00000000
		.BYTE	%00011100
		.BYTE	%00010100
		.BYTE	%00011100
		.BYTE	%00000000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_B,ZX_O,ZX_X,ZX_SPC,ZX_2
		.BYTE	$FF

LEVEL_37	.BYTE	%00011100
		.BYTE	%00010000
		.BYTE	%00011100
		.BYTE	%00010100
		.BYTE	%00011100
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_N,ZX_U,ZX_M,ZX_B,ZX_E,ZX_R,ZX_S,ZX_SPC
		.BYTE	ZX_U,ZX_P,ZX_SPC,ZX_6
		.BYTE	$FF

LEVEL_38	.BYTE	%00100010
		.BYTE	%00100010
		.BYTE	%00001000
		.BYTE	%00100010
		.BYTE	%00100010
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_H,ZX_M,ZX_M,ZX_M,ZX_SPC,ZX_2
		.BYTE	$FF

LEVEL_39	.BYTE	%00001110
		.BYTE	%00000100
		.BYTE	%00000100
		.BYTE	%00100100
		.BYTE	%00011000
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_A,ZX_L,ZX_P,ZX_H,ZX_A,ZX_B,ZX_E,ZX_T,ZX_SPC
		.BYTE	ZX_S,ZX_O,ZX_U,ZX_P,ZX_SPC,ZX_J
		.BYTE	$FF

LEVEL_40	.BYTE	%00111110
		.BYTE	%00111110
		.BYTE	%00111110
		.BYTE	%00111110
		.BYTE	%00111110
		.BYTE	$FF
		.WORD	0,0
		.BYTE	ZX_A,ZX_L,ZX_L,ZX_SPC,ZX_O,ZX_N
		.BYTE	$FF









LEVEL_LAST	.BYTE	$FE , $FE , $FE	

   db $76   ;N/L 
 
;- Display file -------------------------------------------- 
 
dfile: 
   db $76 
   db $76,$76,$76,$76,$76,$76,$76,$76 
   db $76,$76,$76,$76,$76,$76,$76,$76 
   db $76,$76,$76,$76,$76,$76,$76,$76 
 
;- BASIC-Variables ---------------------------------------- 
 
var: 
   db $80 
 
;- End of program area ---------------------------- 
 
last: 
 
   end 