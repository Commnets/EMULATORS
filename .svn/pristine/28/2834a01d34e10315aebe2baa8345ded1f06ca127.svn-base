#include <CORE/UInt.hpp>
#include <algorithm>
#include <sstream>

// ---
const MCHEmul::UInt MCHEmul::UInt::_0 = MCHEmul::UInt ({ MCHEmul::UByte::_0}, false, false);
const MCHEmul::UInt MCHEmul::UInt::_1 = MCHEmul::UInt ({ MCHEmul::UByte::_1}, false, false);

// ---
MCHEmul::UInt MCHEmul::UInt::add (const MCHEmul::UInt& u, bool iC) const
{
	if (_BCD != u._BCD)
		return (MCHEmul::UInt::_0); // Impossible to add!

	MCHEmul::UInt nU1 = *this;
	MCHEmul::UInt nU2 = u;
	size_t mL = std::max (nU1.size (), nU2.size ());
	// The operation has to be done with uints of the same length...
	nU1.setMinLength (mL); nU2.setMinLength (mL);

	// Numbers are always stored in Big-endian format...
	std::vector <MCHEmul::UByte> dt;
	bool c = iC;
	for (int i = (int) (nU1.size () - 1); i >= 0; i--) 
	{
		unsigned short s = 0;
		if (_BCD)
		{
			s = 
				(unsigned short) ((nU1._values [(size_t) i].value ()) & 0x0f) + 
				(unsigned short) ((nU2._values [(size_t) i].value ()) & 0x0f) + 
				(unsigned short) ((c) ? MCHEmul::UByte::_1 : MCHEmul::UByte::_0); // Nibble 1
			if (s > 0x09) s += 0x06;
			s +=
				(unsigned short) ((nU1._values [(size_t) i].value ()) & 0xf0) + 
				(unsigned short) ((nU2._values [(size_t) i].value ()) & 0xf0); // Nibble 2
			if ((s & 0x1f0) > 0x90) s += 0x60;
		}
		else
		{
			s = 
				(unsigned short) (nU1._values [(size_t) i].value ()) + 
				(unsigned short) (nU2._values [(size_t) i].value ()) + 
				(unsigned short) ((c) ? MCHEmul::UByte::_1 : MCHEmul::UByte::_0); 
		}

		c = (s > (unsigned short) MCHEmul::UByte::_FF);

		dt.insert (dt.begin (), MCHEmul::UByte ((unsigned char) s)); // Cut
	}

	MCHEmul::UInt result (dt, true, _BCD /** All will have the same. */);
	result._carry = c;
	result._overflow = (nU1.negative () && nU2.negative () && result.positive ()) ||
		(nU1.positive () && nU2.positive () && result.negative ());

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::complement () const
{
	std::vector <MCHEmul::UByte> dt;
	for (size_t i = 0; i < size (); i++) 
		dt.push_back (_values [(size_t) i].complement (_BCD ? MCHEmul::UByte::_99 : MCHEmul::UByte::_FF));

	MCHEmul::UInt result (dt, true, _BCD /** The same. */);

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::substract (const MCHEmul::UInt& u) const
{ 
	MCHEmul::UInt nU1 = *this;
	MCHEmul::UInt nU2 = u;
	size_t mL = std::max (nU1.size (), nU2.size ());
	// The operation has to be done with uints of the same length...
	nU1.setMinLength (mL); nU2.setMinLength (mL);

	return (nU1.add (nU2.complement_plus ()));
}

// ---
MCHEmul::UInt MCHEmul::UInt::multiply (const MCHEmul::UInt& u) const
{
	MCHEmul::UInt nU1 = *this;
	MCHEmul::UInt nU2 = u;
	size_t mL = std::max (nU1.size (), nU2.size ());
	// The operation has to be done with uints of the same length...
	nU1.setMinLength (mL); nU2.setMinLength (mL);

	// Is the final outcome going to be negative?
	bool neg = (nU1.negative () && nU2.positive ()) | (nU1.positive () && nU2.negative ());

	if (nU1.negative ()) nU1 = nU1.complement_plus ();
	MCHEmul::UInt result = MCHEmul::UInt::_0; result._BCD = nU1._BCD;
	unsigned int n = (unsigned int) std::abs (nU2.asInt ());
	for (unsigned int i = 0; i < n; i++)
		result += nU1;

	// if it is...the sign is assigned at the end!
	if (neg) result = result.complement_plus ();

	return (result);
}

// ---
bool MCHEmul::UInt::operator > (const MCHEmul::UInt& u) const
{
	MCHEmul::UInt nU1 = *this;
	MCHEmul::UInt nU2 = u;
	size_t mL = std::max (nU1.size (), nU2.size ());
	// The operation has to be done with uints of the same length...
	nU1.setMinLength (mL); nU2.setMinLength (mL);

	if (nU1.positive () && nU2.negative ())
		return (true);
	if (nU1.negative () && nU2.positive ())
		return (false);

	// Both with the same sign...
	// When there is two negative numbers represented in complement_2, the comparation is the same... 
	bool result = false;
	bool cont = true;
	for (size_t i = 0; i < nU1.size () && cont; i++)
		cont = !(result = (nU1._values [i].value () > nU2._values [i].value ())) && 
			(nU1._values [i].value () == nU2._values [i].value ());
	return (result);
}

// ---
bool MCHEmul::UInt::operator < (const MCHEmul::UInt& u) const
{
	MCHEmul::UInt nU1 = *this;
	MCHEmul::UInt nU2 = u;
	size_t mL = std::max (nU1.size (), nU2.size ());
	// The operation has to be done with uints of the same length...
	nU1.setMinLength (mL); nU2.setMinLength (mL);

	if (nU1.negative () && nU2.positive ())
		return (true);
	if (nU1.positive () && nU2.negative ())
		return (false);

	// Both with the same sign...
	// When there is two negative numbers represented in complement_2, the comparation is the same... 
	bool result = false;
	bool cont = true;
	for (size_t i = 0; i < nU1.size () && cont; i++)
		cont = !(result = (nU1._values [i].value () < nU2._values [i].value ())) && 
			(nU1._values [i].value () == nU2._values [i].value ());
	return (result);
}

// ---
unsigned int MCHEmul::UInt::asUnsignedInt () const
{
	unsigned int result = 0;

	if (_BCD)
	{
		int c = 1;
		for (int i = (int) (size () - 1); i >= 0; i -= 2, c *= 100)
			result += ((((_values [(size_t) i].value () & 0xf0) >> 4) * 10) + (_values [(size_t) i].value () & 0x0f)) * c;
	}
	else
	{
		int c = 0;
		for (int i = (int) (size () - 1); i >= 0; i--, c++)
			result += _values [(size_t) i].value () << (c * MCHEmul::UByte::sizeBits ());
	}

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::fromUnsignedInt (unsigned int n, bool bcd)
{
	std::vector <MCHEmul::UByte> dt;

	if (bcd)
	{
		std::string nS = std::to_string (n);
		for (int i = ((int) nS.length () - 1); i >= 0; i -= 2) // It can be negative..
		{
			if (i == 0) // odd number of digits...
				dt.insert (dt.begin (), nS [i] - '0');
			else 
				dt.insert (dt.begin (), ((nS [i - 1] - '0') << 4 /** MSNybble. */) | (nS [i] - '0' /** LSNybble. */));
		}
	}
	else
	{
		size_t nB = 1;
		while ((n / (MCHEmul::UByte::_1 << (nB * MCHEmul::UByte::sizeBits ()))) != 0) nB++; 
	
		unsigned int r = n;
		for (size_t i = nB - 1; i > 0; i--)
		{
			unsigned int dv = MCHEmul::UByte::_1 << (i * MCHEmul::UByte::sizeBits ());
			dt.push_back (r / dv);
			r = r % dv;
		}

		dt.push_back (r);
	}

	return (MCHEmul::UInt (MCHEmul::UBytes (dt), true, bcd));
}

// ---
MCHEmul::UInt MCHEmul::UInt::fromInt (int n, bool bcd)
{
	std::vector <MCHEmul::UByte> dt;

	// Negative?
	unsigned int r = (n > 0) ? n : -n;

	if (bcd)
	{
		std::string nS = std::to_string (r);
		for (int i = ((int) nS.length () - 1); i >= 0; i -= 2) // It might be negative..
		{
			if (i == 0) // odd number of digits...
				dt.insert (dt.begin (), nS [i] - '0');
			else 
				dt.insert (dt.begin (), ((nS [i - 1] - '0') << 4 /** MSNybble. */) | (nS [i] - '0' /** LSNybble. */));
		}

		// In case the number (abs) is bigger than the maximum allowed at the saize already calculated...
		if (r > (unsigned int) std::pow (100, dt.size ())) dt.insert (dt.begin (), 0); // One bit more for the sign...
	}
	else
	{
		size_t nB = 1;
		while ((r / (MCHEmul::UByte::_1 << (nB * MCHEmul::UByte::sizeBits ()))) != 0) nB++;
		if (r > (unsigned int) (0x01 << (nB * MCHEmul::UByte::sizeBits () - 1))) nB++; // One bit more for the the sign...

		for (size_t i = nB - 1; i > 0; i--)
		{
			unsigned int dv = MCHEmul::UByte::_1 << (i * MCHEmul::UByte::sizeBits ());
			dt.push_back (r / dv);
			r = r % dv;
		}

		dt.push_back (r);
	}

	return ((n < 0) ? MCHEmul::UInt (dt, true, bcd).complement_plus () : MCHEmul::UInt (dt, true, bcd));
}

// ---
MCHEmul::UInt MCHEmul::UInt::fromStr (const std::string& s, bool bcd)
{
	MCHEmul::UInt result ({ 0x00 });

	if (!MCHEmul::validBytes (s))
		return (result);

	switch (s [0])
	{
		case '$':
		{
			unsigned int i;
			std::istringstream ss (s.substr (1));
			ss >> std::hex >> i;
			result = MCHEmul::UInt::fromUnsignedInt (i); // Big - endian
		}
		
		break;

		case '0':
		{
			unsigned int i;
			std::istringstream ss (s.substr (1));
			ss >> std::oct >> i;
			result = MCHEmul::UInt::fromUnsignedInt (i); // Big - endian
		}
		
		break;

		default:
		{
			unsigned int i;
			std::istringstream ss (s);
			ss >> std::dec >> i;
			result = MCHEmul::UInt::fromUnsignedInt (i); // Big - endian
		}
			
		break;
	}

	return (result);
}
