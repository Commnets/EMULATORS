/** \ingroup COMMS */
/*@{*/

/**	
 *	@file	
 *	File: Comms.hpp \n
 *	Framework: CPU Emulators library \n
 *	Author: Ignacio Cea Forniés (EMULATORS library) \n
 *	Creation Date: 15/06/2021 \n
 *	Description: Defines the tube though out one process communicates to other. 
 *	Versions: 1.0 Initial
 */

#ifndef __MCHEMUL_COMMCHANNEL__
#define __MCHEMUL_COMMCHANNEL__

#include <CPU/incs.hpp>
#include <COMMS/IPAddress.hpp>
#include <RakPeerInterface.h>
#include <MessageIdentifiers.h>

namespace MCHEmul
{
	/** The class CommunicationChannel allows the communication between e.g. emulator and any external tool. \n
		It could be useful e.g. to run in debug mode the emulator or to know 
		which is the status of the computer. */
	class CommunicationChannel
	{
		public:
		/** The id of the package having the specific meesages to control emulator. */
		static const unsigned char _MESSAGEID = 
			DefaultMessageIDTypes::ID_USER_PACKET_ENUM + 1;

		/** To create the server version. */
		CommunicationChannel (unsigned int p, unsigned int nC = 5);

		/** To create the client version. */
		CommunicationChannel (const IPAddress& to);

		CommunicationChannel (const CommunicationChannel&) = delete;

		CommunicationChannel& operator = (const CommunicationChannel&) = delete;

		~CommunicationChannel ();

		/** What are you? */
		bool isServer () const
							{ return (_server); }

		/** In the cas of being a server. */
		unsigned short listenAtPort () const
							{ return (_data._serverData._listenAtPort); }
		unsigned short simulatenousConnections () const
							{ return (_data._serverData._simultaneousConnections); }

		/** In the case of being a client. */
		const IPAddress& connectedTo () const
							{ return (_data._connectedTo); }

		bool openChannel ();
		bool isChannelOpened ()
								{ return (_channelOpened); }
		bool closeChannel ();

		bool receiveString (std::string& str);

		/** Only makes sense if it is a client. */
		bool sendString (const std::string& str);

		unsigned int lastError () const
							{ return (_lastError); }

		bool operator ! () const
							{ return (_lastError != MCHEmul::_NOERROR); }

		protected:
		/** Data needed to represent a server version. */
		struct ServerData
		{
			ServerData ()
				: _listenAtPort (100), _simultaneousConnections (5)
							{ }

			ServerData (unsigned short lP, unsigned int sC)
				: _listenAtPort (lP), _simultaneousConnections (sC)
							{ }

			ServerData (const ServerData&) = default;

			ServerData& operator = (const ServerData&) = default;

			unsigned short _listenAtPort; 
			unsigned short _simultaneousConnections;
		};

		/** The data of a communication channel will be either
			data to rerpresent the server either data to represent the client. */
		union Data
		{
			Data (const ServerData& s)
				: _serverData (s) 
							{ }

			Data (const IPAddress& a)
				: _connectedTo (a)
							{ }

			Data (const Data&) = default;

			Data& operator = (const Data&) = default;

			ServerData _serverData;
			IPAddress _connectedTo;
		};

		/** The data managed by the communication channel. */
		const Data _data;
	
		// Implementation
		const bool _server;
		RakNet::RakPeerInterface* _peer;
		mutable bool _channelOpened;
		mutable unsigned int _lastError;
	};
}

#endif
  
// End of the file
/*@}*/
