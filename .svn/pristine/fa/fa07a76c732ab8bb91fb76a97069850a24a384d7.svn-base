/** \ingroup language */
/*@{*/

/**	
 *	@file	
 *	File: Parser.hpp \n
 *	Framework: CPU Emulators library \n
 *	Author: Ignacio Cea Forniés (EMULATORS library) \n
 *	Creation Date: 15/05/2021 \n
 *	Description: To read a file and convert it into set of data.
 *	Versions: 1.0 Initial
 */

#ifndef __MCHEMUL_PARSER__
#define __MCHEMUL_PARSER__

#include <core/CPU.hpp>
#include <language/Instruction.hpp>
#include <core/Address.hpp>

namespace MCHEmul
{
	namespace Assembler
	{
		/** The type of errors admitted by the parser and the compiler. */
		enum class Error
			{ _NOERROR, 
			  _BADDEFINEDLINE, _BADNUMBERPARAMETERS, _BADTYPEPARAMETERS, _MACROBADDEFINED, 
			  _CODENOTFOUND };

		/** A macro is always made up of a name and a value. \n
			The value can be either directly a value or a set of referencies (with operations) and links with other macros */
		class Macro;
		using Macros = std::vector <Macro>;
		class Macro
		{
			public:
			Macro ()
				: _name (""), _equivalent (""),
				  _value ({ }), 
				  _error (Error::_NOERROR) 
								{ }

			Macro (const std::string& n, const std::string& e)
				: _name (n), _equivalent (e),
				  _value ({ }),
				  _error (Error::_NOERROR)
							{ }

			Macro (const Macro&) = default;

			Macro& operator = (const Macro&) = default;

			const std::string& name () const
							{ return (_name); }
			const std::string& equivalent () const
							{ return (_equivalent); }
			Error error () const
							{ return (_error); }

			/** Gets the value of the macro taking into account potential relations with other macros. \n
				The first time it is invoked the very real value is calculated if possible. \n
				The variable _error will point whether there was and error in the calculus. */
			const std::vector <UByte>& value (const Macros& ms) const
							{ return (_value.empty () ? _value = calculateValue (_equivalent, ms) : _value ); }

			/** To simplify the analysis of the macro. */
			bool operator ! () const
							{ value ({ }) /** Calculated already? */; return (_error == Error::_NOERROR); }

			friend std::ostream& operator << (std::ostream& o, const Macro& m);

			private:
			/** To calculate the value first time. 
				It is able to take into account simple operations in the definition: *,+,- */
			std::vector <UByte> calculateValue (const std::string& e, const Macros& ms) const;

			private:
			const std::string _name = ""; // Adjusted at construction time
			const std::string _equivalent = ""; // Adjusted at construction time

			// Implementation
			mutable std::vector <UByte> _value;
			mutable Error _error;
		};

		/** A very especial type of macro is this that is usd to fix a memory location where put code. */
		class AddressMacro : public Macro
		{
			public:
			AddressMacro ()
				: Macro ("*", "")
							{ }

			AddressMacro (const std::string& v)
				: Macro ("*", v)
							{ }

			AddressMacro (const AddressMacro&) = default;

			AddressMacro& operator = (const AddressMacro&) = default;

			friend std::ostream& operator << (std::ostream& o, const AddressMacro& am);
		};

		/** The AddressMacro can be linked to the instructions, and it is always assigned associated to a Label. */
		using AddressMacros = std::map <unsigned int, AddressMacro>;

		/** The labels play a very important role also in the parsing process,
			They are usually related with speecifc points in the code, where the jumps usually refer to. */
		class Label;
		using Labels = std::map <std::string, Label>;
		class Label
		{
			public:
			Label (const std::string& n, unsigned int& a)
				: _name (n), _address (a),
				  _error (Error::_NOERROR) 
							{ }

			Label (const Label&) = default;

			Label& operator = (const Label&) = default;

			const std::string& name () const
							{ return (_name); }
			unsigned int address () const
							{ return (_address); }
			Error error () const
								{ return (_error); }

			/** Gets the value of the label taking into account The position where it is.
				The first time it is invoked the very real value is calculated if possible. \n
				The variable _error will point whether there was and error in the calculus. */
			const Address& value (const AddressMacros& m) const
								{ return (_value == Address ({ 0x00 }) ? _value = calculateValue (m) : _value ); }

			/** To simplify the analysis of the label. */
			bool operator ! () const
								{ return (_error == Error::_NOERROR); }

			friend std::ostream& operator << (std::ostream& o, const Label& l);

			private:
			/** To calculate the value first time. 
				It is able to take into account simple operations in the definition: *,+,- */
			Address calculateValue (const AddressMacros& m) const;

			private:
			const std::string _name = ""; // Adjusted at construction time
			const unsigned int _address = 0; // Adjusted at construction time

			// Implementation
			mutable Address _value;
			mutable Error _error;
		};

		/** A instruction is the very basic part of the executable code. \n
			The instruction has to be assigned at an address. \n
			The full compilation of the instruction is always made in two steps: \n
			-> First step: Gramatical undestanding. \n
			-> Second step: Undestading the parameters and converting them into values. \n
			The compilation of the instruction can generate any mistake at any of the two steps. 
			IMPORTANT: There is an special instruction to set the address. That instruction is named: "*" */
		class Instruction;
		using Instructions = std::vector <Instruction>;
		class Instruction
		{
			public:
			Instruction ()
				: _lineNumber (0), _address (0), _instruction (""), _parametersTxt ({ }), _codes ({ }),
				  _parameters ({ }), // Set up the second step of any compilation...
				  _error (Error::_NOERROR)
							{ }

			Instruction (unsigned int lN, unsigned int aM, const std::string& i, 
					const std::vector <std::string>& p, const std::vector <unsigned int>& c)
				: _lineNumber (lN), _address (0), _instruction (i), _parametersTxt (p), _codes (c),
				  _parameters ({ }), // Set up at the second step of any compilation...
				  _error (Error::_NOERROR)
							{ }

			Instruction (const Instruction&) = default;

			Instruction& operator = (const Instruction&) = default;

			unsigned int lineNumber () const
							{ return (_lineNumber); }
			unsigned int address () const
							{ return (_address); }
			const std::string& instruction () const
							{ return (_instruction); }
			const std::vector <UByte>& parameters (const Macros& m) const
							{ return (_parameters.empty () ? (_parameters = calculateParameters (m)) : _parameters); }
			Error error () const
							{ return (_error); }

			/** To simplify the analysis of potntial errors anaizing the instruction. */
			bool operator ! () const
							{ parameters ({ }) /** Calculated) */; return (_error == Error::_NOERROR); }

			friend std::ostream& operator << (std::ostream& o, const Instruction& i);

			private:
			std::vector <UByte> calculateParameters (const Macros& m) const;

			private:
			/** The line number (if any) where the instruction is defined. */
			const unsigned int _lineNumber = 0;
			/** The address. */
			const unsigned int _address = 0;
			/** The instruction as it appears in the original source once tabs and spaces are deleted. */
			const std::string _instruction = "";
			/** The parameters of that instruction once they have been extracted from it. \n
				The parameters are stored (first step) as they are written with no interpretation. */
			const std::vector <std::string> _parametersTxt = { };
			/** Before analyzing a instruction (second step) in detail several codes could be assigned.
				Only when the parameters are calculated with no error, then a unique code will be assigned. */
			const std::vector <unsigned int> _codes;

			// Implementation
			/** The parameters (second step) once they have been calculated. */
			mutable std::vector <UByte> _parameters;
			/** Whether there is or not error after calculating the parameters. */
			mutable Error _error;
		};

		/** After reading the code, a structure with all possible items should generated. \n
			These items ar always: Macros, Labels and Instructions. 
			Th different elements of the structur will keep the potential error when analyzing them. */
		struct CodeStructure
		{
			public:
			CodeStructure () = default;

			CodeStructure (const Macros& m, const AddressMacros& a, const Labels& l, const Instructions& i)
				: _macros (m), _addresses (a), _labels (l), _instructions (i)
							{ }

			CodeStructure (const CodeStructure&) = default;

			CodeStructure& operator = (const CodeStructure&) = default;

			/** These variables are modified directly by the parser. */
			Macros _macros;
			AddressMacros _addresses;
			Labels _labels;
			Instructions _instructions; // They include the address where they are defined...
		};

		/** The parser is accountable for generating the code structure reading a source. */
		class Parser;

		/** Any parser can growth following the user needs. \n
			So the every parser parses commands. */
		class CommandParser
		{
			public:
			friend Parser;

			CommandParser ()
				: _cpu (nullptr), _parser (nullptr)
							{ }

			virtual ~CommandParser ()
							{ }

			/** Determine whether a line can or not be parsed by this LineParser. */
			virtual bool canParse (const std::string& l) const = 0;
			/** Parse the line, obviously when it is able. \n
				Wheen parsing the line being parsed and the code structure are modified. */
			virtual void parse (std::string& l, CodeStructure& c) const = 0;

			protected:
			void setCPU (CPU* c)
							{ assert (c != nullptr); _cpu = c; }
			void setParser (Parser* p)
							{ assert (p!= nullptr); _parser = p; }

			protected:
			CPU* _cpu;
			Parser* _parser;
		};

		using CommandParsers = std::vector <CommandParser*>;

		/** To parser a comment.
			Th symbol defining the beginning of a comment can be redefined. */
		class CommentCommandParser final : public CommandParser
		{
			public:
			CommentCommandParser (unsigned char s = ';')
				: CommandParser (),
				  _symbol (s)
							{ }

			virtual bool canParse (const std::string& l) const override;
			virtual void parse (std::string& l, CodeStructure& c) const override;

			private:
			const unsigned char _symbol = ';';
		};

		/** To parser a macro. 
			The symbol defining the separation between definition and value can be redefined. */
		class MacroCommandParser final : public CommandParser
		{
			public:
			MacroCommandParser (unsigned char s = '=')
				: CommandParser (),
				  _symbol (s)
							{ }

			virtual bool canParse (const std::string& l) const override;
			virtual void parse (std::string& l, CodeStructure& c) const override;

			private:
			const unsigned char _symbol = '=';
		};

		/** To parser an address macro.
			The symbol defining the separation between definition and value can be redefined. */
		class AddressMacroCommandParser final : public CommandParser
		{
			public:
			AddressMacroCommandParser (unsigned char s = '=')
				: CommandParser (),
				  _symbol (s)
							{ }

			virtual bool canParse (const std::string& l) const override;
			virtual void parse (std::string& l, CodeStructure& c) const override;

			private:
			const unsigned char _symbol = '=';
		};

		/** To parser a label. */
		class LabelCommandParser final : public CommandParser
		{
			public:
			LabelCommandParser (unsigned char s = ':')
				: CommandParser (),
				  _symbol (s)
							{ }

			virtual bool canParse (const std::string& l) const override;
			virtual void parse (std::string& l, CodeStructure& c) const override;

			private:
			const unsigned char _symbol = ':';
		};

		/** To parser an instruction. */
		class InstructionCommandParser final : public CommandParser
		{
			public:
			InstructionCommandParser ()
				: CommandParser ()
							{ }

			virtual bool canParse (const std::string& l) const override;
			virtual void parse (std::string& l, CodeStructure& c) const override;
		};

		/** Now it is time to define the parser itself. \n
			To convert a file text (or text) into an internal structure. */
		class Parser
		{
			public:
			Parser (CPU* c, const CommandParsers& lP = 
					{ new CommentCommandParser, new MacroCommandParser, 
					  new AddressMacroCommandParser, new LabelCommandParser,
					  new InstructionCommandParser })
				: _cpu (c), _lineParsers (lP),
				  _error (Error::_NOERROR), _lastParsedLine (0)
							{ for (auto i : _lineParsers) { i -> setCPU (c), i -> setParser (this); } }

			Parser (Parser&) = delete;

			Parser& operator = (const Parser&) = delete;

			/** The parser doesn't own the instructions but the CPU, but the line parsers. */
			virtual ~Parser ();

			/**
			  * Type of code that is is accepted:
			  * The example has been written using the machine languaje of the Commodore 64
			  *	; Simple test that everything works \n
			  *	; By Ignacio Cea \n
			  * \n
			  *	; MACROS \n
			  *	FOREGROUND = $D020 \n
			  *	BACKGROUND = $D021 \n
			  * \n
			  *	* = $C000 \n
			  * \n
			  *	; Now the code \n
			  * \n
			  *	START:			LDA #$00 ;Load accumulator \n
			  *					STA BACKGROUND \n
			  *					STA FOREGROUND \n
			  *					BNE START \n
			  * \n
			  *	; Very simple
			  * Rules:
			  *	; Means comment. After that, nothing will be taken into account. \n
			  * MACROS & LABELS are represented using characteres (upper and lower case) and numbers, but never starting with number. \n
			  * NUMBERS AND DIRECTIONS can be represented using decimal, octal (starting with 0) and hexadecimal (with $) numbers. \n
			  * * = xxxx will identify the address from which the code after will be inserted!
			  */
			CodeStructure parse (const std::string& fN);

			Error error () const
							{ return (_error); }
			unsigned int lastParsedLine () const
							{ return (_lastParsedLine); }

			/** To simplify checking whether there was or not an error parsing. */
			bool operator ! () const
							{ return (_error == Error::_NOERROR); }

			private:
			CPU* _cpu;
			CommandParsers _lineParsers;

			// Implementation
			mutable Error _error;
			mutable unsigned int _lastParsedLine;
		};

		/** The structure of code generated by the parser is converted into code lines. 
			A code line is a set of bytes representing the instruction assigned to a spcific address. */
		class CodeLine
		{
			public:
			CodeLine () = delete;

			CodeLine (const Address& a, const std::vector <UByte> b)
				: _address (a), _bytes (b)
							{ }

			CodeLine (const CodeLine&) = default;

			CodeLine& operator = (const CodeLine&) = default;

			const Address& address () const
							{ return (_address); }
			const std::vector <UByte> bytes () const
							{ return (_bytes); }

			private:
			Address _address;
			std::vector <UByte> _bytes;
		};

		using CodeLines = std::vector <CodeLine>;

		/** ...and then the compiler. \n
			To convert the internal structure into a set of code lines. */
		class Compiler
		{
			public:
			Compiler (CPU* c);

			CodeLines compile (const CodeStructure& c) const;

			private:
			mutable Error _error;
		};
	}












	class Mempory;

	/** To read a file or a string and convrrting into data loaded in the memoty. */
	class Parser
	{
		public:
		/** The possible errors whn parsing. */
		enum class ParserError
		{
			_NOERROR,
			_BADDEFINEDLINE,
			_BADNUMBERPARAMETERS,
			_BADTYPEPARAMETERS,
			_CODENOTFOUND
		};

		using Lines = std::vector <std::string>;
		using Labels = std::map <std::string, Address>;
		using Macros = std::map <std::string, std::vector <MCHEmul::UByte>>;

		/** An structure to keep the info about a simple line of code. */
		struct CodeLine
		{
			public:
			CodeLine ()
				: _address (), _code ()
							{ }

			CodeLine (const CodeLine&) = default;

			CodeLine& operator = (const CodeLine&) = default;

			friend std::ostream& operator << (std::ostream& o, const CodeLine& cL);

			Address _address;
			std::vector <UByte> _code;
		};

		/** The code is made up of many code lines. */
		using Code = std::vector <CodeLine>;

		Parser () = delete;

		/**
		  * Type of code that is is accepted:
		  * The example has been written using the machine languaje of the Commodore 64
		  *	; Simple test that everything works \n
		  *	; By Ignacio Cea \n
		  * \n
		  *	; MACROS \n
		  *	FOREGROUND = $D020 \n
		  *	BACKGROUND = $D021 \n
		  * \n
		  *	* = $C000 \n
		  * \n
		  *	; Now the code \n
		  * \n
		  *	START:			LDA #$00 ;Load accumulator \n
		  *					STA BACKGROUND \n
		  *					STA FOREGROUND \n
		  *					BNE START \n
		  * \n
		  *	; Very simple
		  * Rules:
		  *	; Means comment. After that, nothing is taken into account. \n
		  * MACROS & LABELS are represented using characteres (upper and lower cas) and numbers, but never starting with number \n
		  * NUMBERS AND DIRECTIONS can be represented using decimal, octal (starting with 0) and hexadecimal (with $) numbers. \n
		  * * = xxxx will identify the starting address!
		  */
		Parser (CPU* c)
			: _instructions (c -> instructions ()),
			  _architecture (c -> architecture ()),
			  _parserError (ParserError::_NOERROR), _lastParserLine (0)
							{ }

		Parser (Parser&) = delete;

		Parser& operator = (const Parser&) = delete;

		/** The parser doesn't own the instructions but the CPU. */
		virtual ~Parser ()
							{ }

		/** To parser the file. The code is returned. */
		Code parse (const std::string& fN) const;
		/** To load a code into the memory (if possible). \n
			Returns true when ok and false in other case. */
		bool loadInMemory (const std::string& fN, Memory* m);
		/** To know whether an error has or not happened after parsing. */
		ParserError parserError () const
							{ return (_parserError); }
		unsigned int lastParserLine () const
							{ return (_lastParserLine); }

		/** To simplify checking whether there was or not an error parsing. */
		bool operator ! () const
							{ return (_parserError == ParserError::_NOERROR); }

		protected:
		/** To read a file and convert it into Lines to be treaten later. */
		Lines readLines (const std::string& fN) const;
		/** To convert a line into the part of the code. */
		Code parseLine (std::string& l, Labels& lbs, Macros& mcrs, Address& cA, ParserError& e) const;

		// Implementation
		Code parseCommentInst (std::string& cl, Labels& lbs, Macros& mcrs, Address& cA, ParserError& e) const;
		Code parseIncludeInst (std::string& cl, Labels& lbs, Macros& mcrs, Address& cA, ParserError& e) const;
		Code parseMacroInst (std::string& cl, Labels& lbs, Macros& mcrs, Address& cA, ParserError& e) const;
		Code parseLabelInst (std::string& cl, Labels& lbs, Macros& mcrs, Address& cA, ParserError& e) const;
		Code parseOpcodeInst (std::string& cl, Labels& lbs, Macros& mcrs, Address& cA, ParserError& e) const;

		protected:
		Instructions _instructions;
		CPUArchitecture _architecture;

		// Implementation
		mutable ParserError _parserError;
		mutable unsigned int _lastParserLine;
	};
}

#endif
  
// End of the file
/*@}*/