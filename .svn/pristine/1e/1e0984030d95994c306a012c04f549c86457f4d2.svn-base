#include <C64/VICII.hpp>
#include <C64/C64.hpp>
#include <F6500/incs.hpp>

const MCHEmul::Address C64::VICII::_COLORMEMORY ({ 0xd8, 0x00 });

// ---
C64::VICII::VICII (const MCHEmul::Attributes& attrs)
	: MCHEmul::GraphicalChip (_ID, attrs),
	  _VICRegisters (nullptr),
	  _nextRasterCycle (0),
	  _format (nullptr)
{ 
	_format = SDL_AllocFormat (SDL_PIXELFORMAT_ARGB8888);
}

// ---
C64::VICII::~VICII ()
{
	SDL_FreeFormat (_format);
}

// ---
bool C64::VICII::initialize ()
{
	assert (memoryRef () != nullptr);

	if (!MCHEmul::GraphicalChip::initialize ())
		return (false);

	// Gets the memory block dedicated to the VICII
	if (!(_VICRegisters = 
		dynamic_cast <C64::VICRegisters*> (memoryRef () -> block (C64::Commodore64::_VICREGS_MEMORY))))
	{
		_lastError = MCHEmul::_INIT_ERROR;

		return (false);
	}

	return (true);
}

// ---
bool C64::VICII::simulate (MCHEmul::CPU* cpu)
{
	if (_VICRegisters -> vicIItoGenerateIRQ ())
		cpu -> interrupt (F6500::IRQInterrupt::_ID) -> setActive (true);

	if (cpu -> clockCycles  () <= _nextRasterCycle)
		return (true);

	auto isBadRasterLine = [=]() -> bool
		{ return (_VICRegisters -> currentRasterPosition () >= 0x0030 &&
				  _VICRegisters -> currentRasterPosition () <= 0x007f &&
				  (_VICRegisters -> currentRasterPosition () & 0x0007) == 9); };

	if (_VICRegisters -> rasterIRQActive () && 
		_VICRegisters -> currentRasterPosition () == _VICRegisters -> IRQRasterPositionAt ())
	{
		_VICRegisters -> setRasterAtPosition (true);

		cpu -> interrupt (F6500::IRQInterrupt::_ID) -> setActive (true);
	}

	if (_VICRegisters -> currentRasterPosition () >= _RASTERFIRSTVISIBLELINE &&
		_VICRegisters -> currentRasterPosition () < _RASTERLASTVISIBLELINE)
	{
		screenMemory () -> setHorizontalLine (0, 
			(size_t) (_VICRegisters -> currentRasterPosition () - _RASTERFIRSTVISIBLELINE), 
				(size_t) _SCREENVISIBLECOLUMNS, _VICRegisters -> borderColor ());

		switch (_VICRegisters -> graphicModeActive ())
		{
			case C64::VICRegisters::GraphicMode::_CHARMODE:
			case C64::VICRegisters::GraphicMode::_MULTICOLORCHARMODE:
				drawRasterCharMode ();
				break;

			case C64::VICRegisters::GraphicMode::_BITMAPMODE:
			case C64::VICRegisters::GraphicMode::_MULTICOLORBITMAPMODE:
				drawRasterBitmapMode ();
				break;

			default:
				// The graphic system is not supported so far...
				break;
		}

		drawRasterSprites ();
	}

	_nextRasterCycle += isBadRasterLine () ? _BADLINERASTERCYCLES : _USUALRASTERCYCLES;

	_VICRegisters -> setCurrentRasterPosition (_VICRegisters -> currentRasterPosition () + 1);
	if (_VICRegisters -> currentRasterPosition () >= _RASTERLINES)
		_VICRegisters -> setCurrentRasterPosition (0);

	return (true);
}

// ---
MCHEmul::ScreenMemory* C64::VICII::createScreenMemory ()
{
	unsigned int* cP = new unsigned int [16];
	cP [0]  = SDL_MapRGB (_format, 0x00, 0x00, 0x00);
	cP [1]  = SDL_MapRGB (_format, 0xff, 0xff, 0xff);
	cP [2]  = SDL_MapRGB (_format, 0xab, 0x31, 0x26);
	cP [3]  = SDL_MapRGB (_format, 0x66, 0xda, 0xff);
	cP [4]  = SDL_MapRGB (_format, 0xbb, 0x3f, 0xb8);
	cP [5]  = SDL_MapRGB (_format, 0x55, 0xce, 0x58);
	cP [6]  = SDL_MapRGB (_format, 0x1d, 0x0e, 0x97);
	cP [7]  = SDL_MapRGB (_format, 0xea, 0xf5, 0x7c);
	cP [8]  = SDL_MapRGB (_format, 0xb9, 0x74, 0x18);
	cP [9]  = SDL_MapRGB (_format, 0x78, 0x53, 0x00);
	cP [10] = SDL_MapRGB (_format, 0xdd, 0x93, 0x87);
	cP [11] = SDL_MapRGB (_format, 0x5b, 0x5b, 0x5b);
	cP [12] = SDL_MapRGB (_format, 0x8b, 0x8b, 0x8b);
	cP [13] = SDL_MapRGB (_format, 0xb0, 0xf4, 0xac);
	cP [14] = SDL_MapRGB (_format, 0xaa, 0x9d, 0xef);
	cP [15] = SDL_MapRGB (_format, 0xb8, 0xb8, 0xb8);

	return (new MCHEmul::ScreenMemory (_SCREENCOLUMNS, _RASTERLINES, cP));
}

// ---
void C64::VICII::drawRasterCharMode ()
{
	// If the raster line is not in the screen zone dedicated to the graphics
	// or it is activated the flag for not to draw anything in that zone,
	// there is nothing else to do...
	if (_VICRegisters -> currentRasterPosition () < _RASTERFIRSTGRAPHLINE ||
		_VICRegisters -> currentRasterPosition () >= _RASTERLASTGRAPHLINE ||
		_VICRegisters -> screenSameColorBorderActive ())
		return;

	unsigned short y = _VICRegisters -> currentRasterPosition () - _RASTERFIRSTVISIBLELINE;

	// Draws the background by default...
	screenMemory () -> setHorizontalLine 
		(_SCREENFIRSTGRAPHCOLUMN, y, _GRAPHBITMAPCOLUMNS, _VICRegisters -> backgroundColor ());

	// Then draws the information of the characters in the current raster line...
	for (unsigned short c = 0; c < _GRAPHCHARCOLUMNS; c++)
	{
		if (!_VICRegisters -> textDisplay40ColumnsActive () &&
			(c == 0 || c == (_GRAPHCHARCOLUMNS - 1)))
				continue; // Nothing to do when the column is not visible...

		unsigned short x = _SCREENFIRSTGRAPHCOLUMN + (c << 3);

		// The info to draw...
		unsigned short screenRow	= // Which screen memory row has the character to be drawn?
			(_VICRegisters -> currentRasterPosition () - _RASTERFIRSTGRAPHLINE) >> 3; 
		unsigned short charDefRow	= // Which offset memory location has the definition of the character to be drawn?
			(_VICRegisters -> currentRasterPosition () - _RASTERFIRSTGRAPHLINE) % 8;
		MCHEmul::UByte chr		= getScreenCharCode (c, screenRow); // The character to draw
		MCHEmul::UByte clr		= getScreenCharColor (c, screenRow); // Its color
		MCHEmul::UByte chrDt	= getCharData (chr.value (), charDefRow); // The byte defining the character at the raster line

		// Finally draw it...
		if (_VICRegisters -> graphicModeActive () == C64::VICRegisters::GraphicMode::_MULTICOLORCHARMODE && clr.bit (3))
			drawMultiColorChar (x, y, chrDt, (clr.value () & 0x7));
		else
			drawChar (x, y, chrDt, clr.value ());
	}
}

// ---
void C64::VICII::drawRasterBitmapMode ()
{
}

// ---
void C64::VICII::drawRasterSprites ()
{
}

// ---
void C64::VICII::drawChar (unsigned short x, unsigned short y, MCHEmul::UByte dt, unsigned int c)
{
	for(unsigned int i = 0; i < 8; i++)
	{
		unsigned short xoffs = x + 8 - i + _VICRegisters -> horizontalScrollPosition ();
		if (xoffs < (_SCREENFIRSTGRAPHCOLUMN + _GRAPHBITMAPCOLUMNS) && dt.bit (i))
			screenMemory () -> setPixel ((size_t) xoffs, (size_t) y, c);
	}
}

// ---
void C64::VICII::drawMultiColorChar (unsigned short x, unsigned short y, MCHEmul::UByte dt, unsigned int c)
{
	for(unsigned int i = 0 ; i < 4; i++)
	{
		unsigned short fc;
		unsigned char cs = ((dt.value () >> (i << 1)) & 0x03);
		switch (cs)
		{
			case 0:
				fc = _VICRegisters -> backgroundColor (0); 
				break;
		
			case 1:
				fc = _VICRegisters -> backgroundColor (1); 
				break;

			case 2:
				fc = _VICRegisters -> backgroundColor (2); 
				break;

			case 3:
			default:
				fc = c;
				break;
		}

		unsigned short xoffs = x + 8 - (i << 1) + _VICRegisters -> horizontalScrollPosition ();
		if (xoffs < (_SCREENFIRSTGRAPHCOLUMN + _GRAPHBITMAPCOLUMNS))
			screenMemory () -> setPixel ((size_t) xoffs, (size_t) y, c);
		if ((xoffs + 1) < (_SCREENFIRSTGRAPHCOLUMN + _GRAPHBITMAPCOLUMNS))
			screenMemory () -> setPixel ((size_t) (xoffs + 1), (size_t) y, c);
	}
}

// ---
void C64::VICII::drawBitMap (unsigned short x, unsigned short y, MCHEmul::UByte dt, unsigned int c)
{
}

// ---
void C64::VICII::drawMultiColorBitMap (unsigned short x, unsigned short y, MCHEmul::UByte dt, unsigned int c)
{
}

// ---
void C64::VICII::drawSprite (unsigned short x, unsigned short y, size_t s, unsigned short row)
{
}

// ---
void C64::VICII::drawMultiColorSprite (unsigned short x, unsigned short y, size_t s, unsigned short row)
{
}

// ---
C64::VICII_NTSC::VICII_NTSC ()
	: C64::VICII (
		 { { "Name", "VIC-II (NTSC) Video Chip Interface II" },
		   { "Code", "6567/8562/8564" },
		   { "Manufacturer", "MOS Technology INC/Commodore Semiconductor Group (CBM)"},
		   { "Year", "1980" } })
{
	// Nothing else to do...
}

// ---
C64::VICII_PAL::VICII_PAL ()
	: C64::VICII (
		 { { "Name", "VIC-II (PAL) Video Chip Interface II" },
		   { "Code", "6569/8565/8566" },
		   { "Manufacturer", "MOS Technology INC/Commodore Semiconductor Group (CBM)"},
		   { "Year", "1980" } })
{
	// Nothing else to do...
}
