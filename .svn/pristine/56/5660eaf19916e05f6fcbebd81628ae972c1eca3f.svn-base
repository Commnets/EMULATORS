#include <CORE/UInt.hpp>
#include <algorithm>
#include <sstream>

MCHEmul::UInt::FormatManagers* MCHEmul::UInt::FormatManagers::_instance = nullptr;
const MCHEmul::UInt MCHEmul::UInt::_0 = MCHEmul::UInt ({ MCHEmul::UByte::_0 }, false, false);
const MCHEmul::UInt MCHEmul::UInt::_1 = MCHEmul::UInt ({ MCHEmul::UByte::_1 }, false, false);
MCHEmul::UInt::FormatManagers MCHEmul::UInt::_formaters 
	( { { MCHEmul::UInt::_BINARY, new MCHEmul::UInt::BinaryFormatManager },
		{ MCHEmul::UInt::_PACKAGEDBCD, new MCHEmul::UInt::PackagedBCDFormatManager } } );

// ---
unsigned int MCHEmul::UInt::BinaryFormatManager::asUnsignedInt (const MCHEmul::UInt& u) const
{
	unsigned int result = 0;

	int c = 0;
	for (int i = (int) (u.size () - 1); i >= 0; i--, c++)
		result += u._values [(size_t) i].value () << (c * MCHEmul::UByte::sizeBits ());

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::BinaryFormatManager::fromUnsignedInt (unsigned int n)
{
	std::vector <MCHEmul::UByte> dt;

	size_t nB = 1;
	while ((n / (MCHEmul::UByte::_1 << (nB * MCHEmul::UByte::sizeBits ()))) != 0) nB++; 
	
	unsigned int r = n;
	for (size_t i = nB - 1; i > 0; i--)
	{
		unsigned int dv = MCHEmul::UByte::_1 << (i * MCHEmul::UByte::sizeBits ());
		dt.push_back (r / dv);
		r = r % dv;
	}

	dt.push_back (r);

	return (MCHEmul::UInt (MCHEmul::UBytes (dt), true, MCHEmul::UInt::_BINARY));
}

// ---
MCHEmul::UInt MCHEmul::UInt::BinaryFormatManager::fromInt (int n)
{
	std::vector <MCHEmul::UByte> dt;

	// Negative?
	unsigned int r = (n > 0) ? n : -n;

	size_t nB = 1;
	while ((r / (MCHEmul::UByte::_1 << (nB * MCHEmul::UByte::sizeBits ()))) != 0) nB++;
	if (r > (unsigned int) (0x01 << (nB * MCHEmul::UByte::sizeBits () - 1))) nB++; // One bit more for the the sign...

	for (size_t i = nB - 1; i > 0; i--)
	{
		unsigned int dv = MCHEmul::UByte::_1 << (i * MCHEmul::UByte::sizeBits ());
		dt.push_back (r / dv);
		r = r % dv;
	}

	dt.push_back (r);

	return ((n < 0) 
		? MCHEmul::UInt (dt, true, MCHEmul::UInt::_BINARY).complement_2 () 
		: MCHEmul::UInt (dt, true, MCHEmul::UInt::_BINARY));
}

// ---
void MCHEmul::UInt::PackagedBCDFormatManager::adjustBytesAfterOperation 
	(const MCHEmul::UInt& u1, const MCHEmul::UInt& u2, MCHEmul::UInt& r)
{
	bool sameSgn = (u1.positive () && u2.positive ()) || (u1.negative () && u2.negative ());
	unsigned char aLSN = sameSgn ? MCHEmul::UByte::_06 : MCHEmul::UByte::_06N;
	unsigned char aMSN = sameSgn ? MCHEmul::UByte::_60 : MCHEmul::UByte::_60N;

	for (int i = (int) (r.bytes ().size () - 1); i >= 0; i--) 
	{
		if (r [i].LSNibble () > MCHEmul::UByte::_09) 
			r [i] = r [i].bitAdding (aLSN, false, r._carry, r._overflow);
		if (r [i].MSNibble () > MCHEmul::UByte::_90) 
			r [i] = r [i].bitAdding (aMSN, false /** taken into account before. */, r._carry, r._overflow);
	}
}

// ---
unsigned int MCHEmul::UInt::PackagedBCDFormatManager::asUnsignedInt (const UInt& u) const
{
	unsigned int result = 0;

	int c = 1;
	for (int i = (int) (u.size () - 1); i >= 0; i -= 2, c *= 100)
		result += ((((u._values [(size_t) i].value () & 0xf0) >> 4) * 10) + (u._values [(size_t) i].value () & 0x0f)) * c;

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::PackagedBCDFormatManager::fromUnsignedInt (unsigned int n)
{
	std::vector <MCHEmul::UByte> dt;

	std::string nS = std::to_string (n);
	for (int i = ((int) nS.length () - 1); i >= 0; i -= 2) // It can be negative..
	{
		if (i == 0) // odd number of digits...
			dt.insert (dt.begin (), nS [i] - '0');
		else 
			dt.insert (dt.begin (), ((nS [i - 1] - '0') << 4 /** MSNibble. */) | (nS [i] - '0' /** LSNibble. */));
	}

	return (MCHEmul::UInt (MCHEmul::UBytes (dt), true, MCHEmul::UInt::_PACKAGEDBCD));
}

// ---
MCHEmul::UInt MCHEmul::UInt::PackagedBCDFormatManager::fromInt (int n)
{
	std::vector <MCHEmul::UByte> dt;

	// Negative?
	unsigned int r = (n > 0) ? n : -n;

	std::string nS = std::to_string (r);
	for (int i = ((int) nS.length () - 1); i >= 0; i -= 2) // It might be negative..
	{
		if (i == 0) // odd number of digits...
			dt.insert (dt.begin (), nS [i] - '0');
		else 
			dt.insert (dt.begin (), ((nS [i - 1] - '0') << 4 /** MSNibble. */) | (nS [i] - '0' /** LSNibble. */));
	}

	// In case the number (abs) is bigger than the maximum allowed at the saize already calculated...
	if (r > (unsigned int) std::pow (100, dt.size ())) dt.insert (dt.begin (), 0); // One bit more for the sign...

	return ((n < 0) 
		? MCHEmul::UInt (dt, true, MCHEmul::UInt::_PACKAGEDBCD).complement_2 () 
		: MCHEmul::UInt (dt, true, MCHEmul::UInt::_PACKAGEDBCD));
}

// ---
MCHEmul::UInt MCHEmul::UInt::add (const MCHEmul::UInt& u, bool iC) const
{
	MCHEmul::UInt u1 = *this;
	MCHEmul::UInt u2 = u;
	size_t l = std::max (u1.size (), u2.size ());
	u1.setMinLength (l); u2.setMinLength (l);

	if (u1._format != u2._format)
		return (MCHEmul::UInt::_0); // Impossible to add different "structures"

	// Just adding bit to bit...
	bool c, o; 
	MCHEmul::UInt result (u1._values.bitAdding (u2._values, iC, c, o), true /** always in Big-endian */, _format);
	result._carry = c; result._overflow = o;
	MCHEmul::UInt::_formaters._formatManagers [_format] -> adjustBytesAfterOperation (u1, u2, result);

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::substract (const MCHEmul::UInt& u, bool iC) const
{ 
	MCHEmul::UInt u1 = *this;
	MCHEmul::UInt u2 = u;
	size_t l = std::max (u1.size (), u2.size ());
	u1.setMinLength (l); u2.setMinLength (l);

	return (u1.add (u2.complement (), iC)); 
}

// ---
MCHEmul::UInt MCHEmul::UInt::multiply (const MCHEmul::UInt& u) const
{
	MCHEmul::UInt result = *this;
	MCHEmul::UInt u2 = u;

	// Is the final outcome going to be negative?
	bool neg = (result.negative () && u.positive ()) | 
		(result.positive () && u.negative ());

	// All positive just for calculus...
	if (result.negative ()) result = result.complement_2 ();
	if (u2.negative ()) u2 = u2.complement_2 ();

	// Do the calculus...
	for (unsigned int i = (unsigned int) u2.asInt () /** always positive here. */; 
			i > 0; i--, result += u2);

	// The sign is assigned at the end!
	if (neg) result = result.complement_2 ();

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::fromStr (const std::string& s, unsigned char f)
{
	MCHEmul::UInt result ({ 0x00 });

	if (s == "")
		return (result);

	bool n = false;
	std::string str = s;
	if (str [0] == '-')
	{
		n = true;
		str = str.substr (1);
	}

	if (!MCHEmul::validBytes (str))
		return (result);

	switch (str [0])
	{
		case '$':
		{
			unsigned int i;
			std::istringstream ss (str.substr (1));
			ss >> std::hex >> i;
			result = MCHEmul::UInt::fromUnsignedInt (i, f); // Big - endian
		}
		
		break;

		case '0':
		{
			unsigned int i;
			std::istringstream ss (str.substr (1));
			ss >> std::oct >> i;
			result = MCHEmul::UInt::fromUnsignedInt (i, f); // Big - endian
		}
		
		break;

		default:
		{
			unsigned int i;
			std::istringstream ss (str);
			ss >> std::dec >> i;
			result = MCHEmul::UInt::fromUnsignedInt (i, f); // Big - endian
		}
			
		break;
	}

	if (n)
		result = -result;

	return (result);
}
