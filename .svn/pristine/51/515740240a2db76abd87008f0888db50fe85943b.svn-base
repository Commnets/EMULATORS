#include <CORE/UInt.hpp>
#include <algorithm>
#include <sstream>

// ---
MCHEmul::UInt::FormatManagers* MCHEmul::UInt::FormatManagers::_instance = nullptr;
const MCHEmul::UInt MCHEmul::UInt::_0 = MCHEmul::UInt ({ MCHEmul::UByte::_0 }, false, false);
const MCHEmul::UInt MCHEmul::UInt::_1 = MCHEmul::UInt ({ MCHEmul::UByte::_1 }, false, false);
MCHEmul::UInt::FormatManagers MCHEmul::UInt::_formaters 
	( { { MCHEmul::UInt::_BINARY, new MCHEmul::UInt::BinaryFormatManager },
		{ MCHEmul::UInt::_PACKAGEDBCD, new MCHEmul::UInt::PackagedBCDFormatManager } } );

// ---
MCHEmul::UInt MCHEmul::UInt::BinaryFormatManager::add 
	(const MCHEmul::UInt& u1, const MCHEmul::UInt& u2, bool cIn) const
{ 
	bool c,o; 
	MCHEmul::UInt result (u1._values.bitAdding (u2._values, cIn, c, o)); 
	result._carry = c; result._overflow = o; 
	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::BinaryFormatManager::substract 
	(const MCHEmul::UInt& u1, const MCHEmul::UInt& u2, bool cIn) const
{ 
	bool c,o; 
	MCHEmul::UInt result (u1._values.bitAdding (u2.complement ()._values, cIn, c, o)); 
	result._carry = c; result._overflow = o; 
	return (result);
}

// ---
unsigned int MCHEmul::UInt::BinaryFormatManager::asUnsignedInt (const MCHEmul::UInt& u) const
{
	unsigned int result = 0;

	int c = 0;
	for (int i = (int) (u.size () - 1); i >= 0; i--, c++)
		result += u._values [(size_t) i].value () << (c * MCHEmul::UByte::sizeBits ());

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::BinaryFormatManager::fromUnsignedInt (unsigned int n)
{
	std::vector <MCHEmul::UByte> dt;

	size_t nB = 1;
	while ((n / (MCHEmul::UByte::_1 << (nB * MCHEmul::UByte::sizeBits ()))) != 0) nB++; 
	
	unsigned int r = n;
	for (size_t i = nB - 1; i > 0; i--)
	{
		unsigned int dv = MCHEmul::UByte::_1 << (i * MCHEmul::UByte::sizeBits ());
		dt.push_back (r / dv);
		r = r % dv;
	}

	dt.push_back (r);

	return (MCHEmul::UInt (MCHEmul::UBytes (dt), true, MCHEmul::UInt::_BINARY));
}

// ---
MCHEmul::UInt MCHEmul::UInt::BinaryFormatManager::fromInt (int n)
{
	std::vector <MCHEmul::UByte> dt;

	// Negative?
	unsigned int r = (n > 0) ? n : -n;

	size_t nB = 1;
	while ((r / (MCHEmul::UByte::_1 << (nB * MCHEmul::UByte::sizeBits ()))) != 0) nB++;
	if (r > (unsigned int) (0x01 << (nB * MCHEmul::UByte::sizeBits () - 1))) nB++; // One bit more for the the sign...

	for (size_t i = nB - 1; i > 0; i--)
	{
		unsigned int dv = MCHEmul::UByte::_1 << (i * MCHEmul::UByte::sizeBits ());
		dt.push_back (r / dv);
		r = r % dv;
	}

	dt.push_back (r);

	return ((n < 0) 
		? MCHEmul::UInt (dt, true, MCHEmul::UInt::_BINARY).complement_2 () 
		: MCHEmul::UInt (dt, true, MCHEmul::UInt::_BINARY));
}

// ---
MCHEmul::UInt MCHEmul::UInt::PackagedBCDFormatManager::add 
	(const MCHEmul::UInt& u1, const MCHEmul::UInt& u2, bool cIn) const
{
	// At this point both elements has the same size...

	unsigned short r = 0;
	bool c = cIn;
	MCHEmul::UInt result = u1;
	for (int i = (int) (u2.bytes ().size () - 1); i >= 0; i--) 
	{
		r  = (unsigned short) (result [i].value () & 0x0f) + 
			 (unsigned short) (u2 [i].value () & 0x0f) + (c ? 0x0001 : 0x0000);
		if (r > (unsigned short) MCHEmul::UByte::_09) 
			r += (unsigned short) MCHEmul::UByte::_06;
		r += (unsigned short) (result [i].value () & 0xf0) +
			 (unsigned short) (u2 [i].value () & 0xf0);
		if ((r & 0x01f0) > (unsigned short) MCHEmul::UByte::_90)
			r += (unsigned short) MCHEmul::UByte::_60;

		c = r > 0x00ff;
		
		result [i] = (unsigned char) r;
	}

	result._carry = c;
	result._overflow = !((u1 [0].value () ^ u2 [0].value ()) & 0x80) && 
		((u1 [0].value () ^ result [0].value ()) & 0x80);

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::PackagedBCDFormatManager::substract
	(const MCHEmul::UInt& u1, const MCHEmul::UInt& u2, bool cIn) const
{
	// At this point both elements has the same size...

	unsigned short r = 0;
	bool c = cIn;
	MCHEmul::UInt result = u1;
	for (int i = (int) (u2.bytes ().size () - 1); i >= 0; i--) 
	{
		r  = (unsigned short) (result [i].value () & 0x0f) -
			 (unsigned short) (u2 [i].value () & 0x0f) - (c ? 0x0000 : 0x0001);
		r = ((r & 0x0010) != 0x0000) 
				? ((r - (unsigned short) MCHEmul::UByte::_06) & 0x000f) | 
				  ((unsigned short) (result [i].value () & 0xf0) - (unsigned short) (u2 [i].value () & 0xf0) - (unsigned short) 0x10)
				: (r & 0x000f) | 
				  ((unsigned short) (result [i].value () & 0xf0) - (unsigned short) (u2 [i].value () & 0xf0));
		if ((r & 0x0100) != 0x0000)
			r -= (unsigned short) MCHEmul::UByte::_60;

		c = r < 0x0100;
		
		result [i] = (unsigned char) r;
	}

	result._carry = c;
	result._overflow = ((u1 [0].value () ^ u2 [0].value ()) & 0x80) && 
		((u1 [0].value () ^ result [0].value ()) & 0x80);

	return (result);
}

// ---
unsigned int MCHEmul::UInt::PackagedBCDFormatManager::asUnsignedInt (const UInt& u) const
{
	unsigned int result = 0;

	int c = 1;
	for (int i = (int) (u.size () - 1); i >= 0; i -= 2, c *= 100)
		result += ((((u._values [(size_t) i].value () & 0xf0) >> 4) * 10) + (u._values [(size_t) i].value () & 0x0f)) * c;

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::PackagedBCDFormatManager::fromUnsignedInt (unsigned int n)
{
	std::vector <MCHEmul::UByte> dt;

	std::string nS = std::to_string (n);
	for (int i = ((int) nS.length () - 1); i >= 0; i -= 2) // It can be negative..
	{
		if (i == 0) // odd number of digits...
			dt.insert (dt.begin (), nS [i] - '0');
		else 
			dt.insert (dt.begin (), ((nS [i - 1] - '0') << 4 /** MSNibble. */) | (nS [i] - '0' /** LSNibble. */));
	}

	return (MCHEmul::UInt (MCHEmul::UBytes (dt), true, MCHEmul::UInt::_PACKAGEDBCD));
}

// ---
MCHEmul::UInt MCHEmul::UInt::PackagedBCDFormatManager::fromInt (int n)
{
	std::vector <MCHEmul::UByte> dt;

	// Negative?
	unsigned int r = (n > 0) ? n : -n;

	std::string nS = std::to_string (r);
	for (int i = ((int) nS.length () - 1); i >= 0; i -= 2) // It might be negative..
	{
		if (i == 0) // odd number of digits...
			dt.insert (dt.begin (), nS [i] - '0');
		else 
			dt.insert (dt.begin (), ((nS [i - 1] - '0') << 4 /** MSNibble. */) | (nS [i] - '0' /** LSNibble. */));
	}

	// In case the number (abs) is bigger than the maximum allowed at the saize already calculated...
	if (r > (unsigned int) std::pow (100, dt.size ())) dt.insert (dt.begin (), 0); // One bit more for the sign...

	return ((n < 0) 
		? MCHEmul::UInt (dt, true, MCHEmul::UInt::_PACKAGEDBCD).complement_2 () 
		: MCHEmul::UInt (dt, true, MCHEmul::UInt::_PACKAGEDBCD));
}

// ---
MCHEmul::UInt MCHEmul::UInt::add (const MCHEmul::UInt& u, bool iC) const
{
	if (_format != u._format)
		return (MCHEmul::UInt::_0); // Impossible to add different "structures"

	MCHEmul::UInt result;
	if (size () != u.size ())
	{
		size_t l = std::max (size (), u.size ());
		MCHEmul::UInt u1 = *this; MCHEmul::UInt u2 = u;
		u1.setMinLength (l); u2.setMinLength (l);

		result = MCHEmul::UInt::_formaters._formatManagers [_format] -> add (u1, u2, iC);
	}
	else
		result = MCHEmul::UInt::_formaters._formatManagers [_format] -> add (*this, u, iC);

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::substract (const MCHEmul::UInt& u, bool iC) const
{
	if (_format != u._format)
		return (MCHEmul::UInt::_0); // Impossible to add different "structures"

	MCHEmul::UInt result;
	if (size () != u.size ())
	{
		size_t l = std::max (size (), u.size ());
		MCHEmul::UInt u1 = *this; MCHEmul::UInt u2 = u;
		u1.setMinLength (l); u2.setMinLength (l);

		result = MCHEmul::UInt::_formaters._formatManagers [_format] -> substract (u1, u2, iC);
	}
	else
		result = MCHEmul::UInt::_formaters._formatManagers [_format] -> substract (*this, u, iC);

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::multiply (const MCHEmul::UInt& u) const
{
	MCHEmul::UInt result = *this;
	MCHEmul::UInt u2 = u;

	// Is the final outcome going to be negative?
	bool neg = (result.negative () && u.positive ()) | 
		(result.positive () && u.negative ());

	// All positive just for calculus...
	if (result.negative ()) result = result.complement_2 ();
	if (u2.negative ()) u2 = u2.complement_2 ();

	// Do the calculus...
	for (unsigned int i = (unsigned int) u2.asInt () /** always positive here. */; 
			i > 0; i--, result += u2);

	// The sign is assigned at the end!
	if (neg) result = result.complement_2 ();

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::fromStr (const std::string& s, unsigned char f)
{
	MCHEmul::UInt result ({ 0x00 });

	if (s == "")
		return (result);

	bool n = false;
	std::string str = s;
	if (str [0] == '-')
	{
		n = true;
		str = str.substr (1);
	}

	if (!MCHEmul::validBytes (str))
		return (result);

	switch (str [0])
	{
		case '$':
		{
			unsigned int i;
			std::istringstream ss (str.substr (1));
			ss >> std::hex >> i;
			result = MCHEmul::UInt::fromUnsignedInt (i, f); // Big - endian
		}
		
		break;

		case '0':
		{
			unsigned int i = 0;
			if (str.length () != 0)
			{
				std::istringstream ss (str.substr (1));
				ss >> std::oct >> i;
			}
			
			result = MCHEmul::UInt::fromUnsignedInt (i, f); // Big - endian
		}
		
		break;

		default:
		{
			unsigned int i;
			std::istringstream ss (str);
			ss >> std::dec >> i;
			result = MCHEmul::UInt::fromUnsignedInt (i, f); // Big - endian
		}
			
		break;
	}

	if (n)
		result = -result;

	return (result);
}
