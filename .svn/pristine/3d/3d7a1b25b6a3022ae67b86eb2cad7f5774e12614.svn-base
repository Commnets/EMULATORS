#include <CORE/UInt.hpp>
#include <algorithm>
#include <sstream>

// ---
const MCHEmul::UInt MCHEmul::UInt::_0 = MCHEmul::UInt ({ MCHEmul::UByte::_0 }, false, false);
const MCHEmul::UInt MCHEmul::UInt::_1 = MCHEmul::UInt ({ MCHEmul::UByte::_1 }, false, false);

// ---
MCHEmul::UInt MCHEmul::UInt::add (const MCHEmul::UInt& u, bool iC) const
{
	if (_BCD != u._BCD)
		return (MCHEmul::UInt::_0); // Impossible to add different "structures"

	// Just adding bit to bit...
	bool c, o; 
	MCHEmul::UBytes r = values ().bitAdding (u.values (), iC, c, o);

	// Then adjust, if it is BCD...
	std::vector <MCHEmul::UByte> dt;
	if (_BCD)
	{
		bool cP = false, oP = false; // Partial carries and overflows...
		for (int i = (int) (r.bytes ().size () - 1); i >= 0; i--) 
		{
			MCHEmul::UByte d = r.bytes ()[i];
			if (d.LSNibble () > MCHEmul::UByte::_09) 
				d = d.bitAdding (MCHEmul::UByte::_06, cP, cP, oP);
			if (d.MSNiblle () > MCHEmul::UByte::_90) 
				d = d.bitAdding (MCHEmul::UByte::_60, false /** taken into account before. */, cP, oP);
			
			dt.insert (dt.begin (), d);
		}

		r = dt;
	}

	// The result...
	MCHEmul::UInt result (r, true /** always in Big-endian */, _BCD);
	result._carry = c;
	result._overflow = o;

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::substract (const MCHEmul::UInt& u, bool iC) const
{
	if (_BCD != u._BCD)
		return (MCHEmul::UInt::_0); // Impossible to add!

	bool c, o;
	MCHEmul::UBytes u2 = u.values ().complement ();
	if (iC) u2 = u2.bitAdding (MCHEmul::UBytes ({ MCHEmul::UByte::_1 }), false /** already taken into account. */, c, o);
	// This previous line is equivalent to make the complement_2!
	// The potential c generated previously is not taken into account!

	// Then just adding bit to bit...
	MCHEmul::UBytes r = values ().bitAdding (u2, false, c, o);

	std::vector <MCHEmul::UByte> dt = r.bytes ();
	if (_BCD)
	{
		bool cP = false, oP = false; // Partial carries and overflows...
		for (int i = (int) (r.bytes ().size () - 1); i >= 0; i--) 
		{
			MCHEmul::UByte d = r.bytes ()[i];
			if (d.LSNibble () > MCHEmul::UByte::_09) 
				d = d.bitAdding (MCHEmul::UByte::_06N, cP, cP, oP);
			if (d.MSNiblle () > MCHEmul::UByte::_90) 
				d = d.bitAdding (MCHEmul::UByte::_60N, false /** taken into account before. */, cP, oP);
			
			dt.insert (dt.begin (), d);
		}

		r = dt;
	}

	MCHEmul::UInt result (r, true /** always in big-endian. */, _BCD);
	result._carry = c;
	result._overflow = o;

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::multiply (const MCHEmul::UInt& u) const
{
	MCHEmul::UInt result = *this;
	MCHEmul::UInt u2 = u;

	// Is the final outcome going to be negative?
	bool neg = (result.negative () && u.positive ()) | 
		(result.positive () && u.negative ());

	// All positive just for calculus...
	if (result.negative ()) result = result.complement_2 ();
	if (u2.negative ()) u2 = u2.complement_2 ();

	// Do the calculus...
	for (unsigned int i = (unsigned int) u2.asInt () /** always positive here. */; 
			i > 0; i--, result += u2);

	// The sign is assigned at the end!
	if (neg) result = result.complement_2 ();

	return (result);
}

// ---
unsigned int MCHEmul::UInt::asUnsignedInt () const
{
	unsigned int result = 0;

	if (_BCD)
	{
		int c = 1;
		for (int i = (int) (size () - 1); i >= 0; i -= 2, c *= 100)
			result += ((((_values [(size_t) i].value () & 0xf0) >> 4) * 10) + (_values [(size_t) i].value () & 0x0f)) * c;
	}
	else
	{
		int c = 0;
		for (int i = (int) (size () - 1); i >= 0; i--, c++)
			result += _values [(size_t) i].value () << (c * MCHEmul::UByte::sizeBits ());
	}

	return (result);
}

// ---
MCHEmul::UInt MCHEmul::UInt::fromUnsignedInt (unsigned int n, bool bcd)
{
	std::vector <MCHEmul::UByte> dt;

	if (bcd)
	{
		std::string nS = std::to_string (n);
		for (int i = ((int) nS.length () - 1); i >= 0; i -= 2) // It can be negative..
		{
			if (i == 0) // odd number of digits...
				dt.insert (dt.begin (), nS [i] - '0');
			else 
				dt.insert (dt.begin (), ((nS [i - 1] - '0') << 4 /** MSNibble. */) | (nS [i] - '0' /** LSNibble. */));
		}
	}
	else
	{
		size_t nB = 1;
		while ((n / (MCHEmul::UByte::_1 << (nB * MCHEmul::UByte::sizeBits ()))) != 0) nB++; 
	
		unsigned int r = n;
		for (size_t i = nB - 1; i > 0; i--)
		{
			unsigned int dv = MCHEmul::UByte::_1 << (i * MCHEmul::UByte::sizeBits ());
			dt.push_back (r / dv);
			r = r % dv;
		}

		dt.push_back (r);
	}

	return (MCHEmul::UInt (MCHEmul::UBytes (dt), true, bcd));
}

// ---
MCHEmul::UInt MCHEmul::UInt::fromInt (int n, bool bcd)
{
	std::vector <MCHEmul::UByte> dt;

	// Negative?
	unsigned int r = (n > 0) ? n : -n;

	if (bcd)
	{
		std::string nS = std::to_string (r);
		for (int i = ((int) nS.length () - 1); i >= 0; i -= 2) // It might be negative..
		{
			if (i == 0) // odd number of digits...
				dt.insert (dt.begin (), nS [i] - '0');
			else 
				dt.insert (dt.begin (), ((nS [i - 1] - '0') << 4 /** MSNibble. */) | (nS [i] - '0' /** LSNibble. */));
		}

		// In case the number (abs) is bigger than the maximum allowed at the saize already calculated...
		if (r > (unsigned int) std::pow (100, dt.size ())) dt.insert (dt.begin (), 0); // One bit more for the sign...
	}
	else
	{
		size_t nB = 1;
		while ((r / (MCHEmul::UByte::_1 << (nB * MCHEmul::UByte::sizeBits ()))) != 0) nB++;
		if (r > (unsigned int) (0x01 << (nB * MCHEmul::UByte::sizeBits () - 1))) nB++; // One bit more for the the sign...

		for (size_t i = nB - 1; i > 0; i--)
		{
			unsigned int dv = MCHEmul::UByte::_1 << (i * MCHEmul::UByte::sizeBits ());
			dt.push_back (r / dv);
			r = r % dv;
		}

		dt.push_back (r);
	}

	return ((n < 0) ? MCHEmul::UInt (dt, true, bcd).complement_2 () : MCHEmul::UInt (dt, true, bcd));
}

// ---
MCHEmul::UInt MCHEmul::UInt::fromStr (const std::string& s, bool bcd)
{
	MCHEmul::UInt result ({ 0x00 });

	if (!MCHEmul::validBytes (s))
		return (result);

	switch (s [0])
	{
		case '$':
		{
			unsigned int i;
			std::istringstream ss (s.substr (1));
			ss >> std::hex >> i;
			result = MCHEmul::UInt::fromUnsignedInt (i); // Big - endian
		}
		
		break;

		case '0':
		{
			unsigned int i;
			std::istringstream ss (s.substr (1));
			ss >> std::oct >> i;
			result = MCHEmul::UInt::fromUnsignedInt (i); // Big - endian
		}
		
		break;

		default:
		{
			unsigned int i;
			std::istringstream ss (s);
			ss >> std::dec >> i;
			result = MCHEmul::UInt::fromUnsignedInt (i); // Big - endian
		}
			
		break;
	}

	return (result);
}
