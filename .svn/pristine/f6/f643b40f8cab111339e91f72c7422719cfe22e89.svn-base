#include <language/Parser.hpp>
#include <core/Memory.hpp>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <cctype>

// ---
std::ostream& MCHEmul::Assembler::operator << (std::ostream& o, const MCHEmul::Assembler::Macro& m)
{
	// To output the macro, it has to be calculated previouly, and not having errors!
	// Otherwise, output will be either eerror or nothing...
	if (!m)
		o << m._name << ": ERROR";
	else
	{
		o << m._name << ":";
	
		bool f = true;
		for (auto i : m._value)
		{
			o << (f ? "" : i.asString (MCHEmul::UByte::OutputFormat::_HEXA)) << " ";
			f = false;
		}
	}

	return (o);
}

// ---
std::vector <MCHEmul::UByte> MCHEmul::Assembler::Macro::calculateValue 
	(const std::string& e, const MCHEmul::Assembler::Macros& ms) const
{
	std::vector <MCHEmul::UByte> result = { }; 

	// Check whether it exists operations between other macros to define this one...
	size_t r = e.find_first_of ('*'); // To multiply values...
	if (r == std::string::npos) r = e.find_first_of ('+'); // To add values...
	if (r == std::string::npos) r = e.find_first_of ('-'); // To subtract values...

	// If no operation symbold has been found, 
	// it is supossed it will be either a label or a set of valid data 
	if (r == std::string::npos)
	{
		// If the final element found is a valid label (meaning macro name), 
		// it should to have the same value of that other macro!
		if (MCHEmul::validLabel (e))
		{
			MCHEmul::Assembler::Macros::const_iterator i;
			if ((i = std::find_if (ms.begin (), ms.end (), 
					[=](const MCHEmul::Assembler::Macro& m) { return (m.equivalent () == e); })) != ms.end ())
			{
				result = (*i).value (ms);
				if (!(*i)) 
					_error = (*i)._error;  // If the referered macro had an error, 
										   // it would mean that there is an error also in this one!
			}
			else
				_error = MCHEmul::Assembler::Error::_MACROBADDEFINED; // If there were no macro with that label, 
																	  // an error would exist...
		}
		else
		if (MCHEmul::validBytes (e))
		{
			result = MCHEmul::UInt::fromStr (_equivalent).bytes ().values ();
		}
		else
			_error = MCHEmul::Assembler::Error::_MACROBADDEFINED;
	}
	// If there is an operrator it has to be solved first...
	else
	{
		switch (e [r])
		{
			case '*':
				result = (MCHEmul::UInt (calculateValue (e.substr (0, r), ms)) * 
						  MCHEmul::UInt (calculateValue (e.substr (0, r + 1), ms))).bytes ().values ();
				break;

			case '+':
				result = (MCHEmul::UInt (calculateValue (e.substr (0, r), ms)) + 
						  MCHEmul::UInt (calculateValue (e.substr (0, r + 1), ms))).bytes ().values ();
				break;

			case '-':
				result = (MCHEmul::UInt (calculateValue (e.substr (0, r), ms)) - 
						  MCHEmul::UInt (calculateValue (e.substr (0, r + 1), ms))).bytes ().values ();
				break;

			default:
				assert (false); // It shouldn't be here...just in case!
		}
	}

	return (result);
}

// ---
std::ostream& MCHEmul::Assembler::operator << (std::ostream& o, const MCHEmul::Assembler::AddressMacro& am)
{
	return (o << (const MCHEmul::Assembler::Macro&) am);
}

// ---
std::ostream& MCHEmul::Assembler::operator << (std::ostream& o, const MCHEmul::Assembler::Label& l)
{
	if (!l)
	{
	}
	else
	{

	}
}

// ---
MCHEmul::Address MCHEmul::Assembler::Label::calculateValue (const MCHEmul::Assembler::AddressMacros& m) const
{
}

// ---
std::ostream& MCHEmul::Assembler::operator << (std::ostream& o, const MCHEmul::Assembler::Instruction& i)
{
}

// ---
std::vector <MCHEmul::UByte> MCHEmul::Assembler::Instruction::calculateParameters (const MCHEmul::Assembler::Macros& m) const
{
}

// ---
bool MCHEmul::Assembler::CommentCommandParser::canParse (const std::string& l) const
{
}

// ---
void MCHEmul::Assembler::CommentCommandParser::parse (std::string& l, MCHEmul::Assembler::CodeStructure& c) const
{
}

// ---
bool MCHEmul::Assembler::MacroCommandParser::canParse (const std::string& l) const
{
}

// ---
void MCHEmul::Assembler::MacroCommandParser::parse (std::string& l, MCHEmul::Assembler::CodeStructure& c) const
{
}

// ---
bool MCHEmul::Assembler::AddressMacroCommandParser::canParse (const std::string& l) const
{
}

// ---
void MCHEmul::Assembler::AddressMacroCommandParser::parse (std::string& l, MCHEmul::Assembler::CodeStructure& c) const
{
}

// ---
bool MCHEmul::Assembler::LabelCommandParser::canParse (const std::string& l) const
{
}

// ---
void MCHEmul::Assembler::LabelCommandParser::parse (std::string& l, MCHEmul::Assembler::CodeStructure& c) const
{
}

// ---
bool MCHEmul::Assembler::InstructionCommandParser::canParse (const std::string& l) const
{
}

// ---
void MCHEmul::Assembler::InstructionCommandParser::parse (std::string& l, MCHEmul::Assembler::CodeStructure& c) const
{
}

// ---
MCHEmul::Assembler::Parser::~Parser ()
{
}

// ---
MCHEmul::Assembler::CodeStructure MCHEmul::Assembler::Parser::parse (const std::string& fN)
{
}

// ---
MCHEmul::Assembler::CodeLines MCHEmul::Assembler::Compiler::compile (const MCHEmul::Assembler::CodeStructure& c) const
{
}





































// ---
std::ostream& MCHEmul::operator << (std::ostream& o, const MCHEmul::Parser::CodeLine& cL)
{
	o << cL._address << ":";

	bool f = true;
	for (auto i : cL._code)
	{
		o << ((!f) ? "," : "") << i;
		f = false;
	}

	return (o);
}

// ---
MCHEmul::Parser::Code MCHEmul::Parser::parse (const std::string& fN) const
{
	MCHEmul::Parser::Code result;
	
	std::vector <std::string> lines = readLines (fN); // If there have been any error no lines would be returned!

	_parserError = MCHEmul::Parser::ParserError::_NOERROR;
	_lastParserLine = 0;

	MCHEmul::Parser::Labels lbs;
	MCHEmul::Parser::Macros mcrs;
	MCHEmul::Address cA;
	for (std::vector <std::string>::const_iterator i = lines.begin (); 
		i != lines.end () && _parserError == MCHEmul::Parser::ParserError::_NOERROR; i++, _lastParserLine++)
	{
		std::string cl = (*i);

		while (cl != "")
		{
			MCHEmul::Parser::Code cd = parseLine (cl, lbs, mcrs, cA, _parserError);
			if (_parserError == MCHEmul::Parser::ParserError::_NOERROR)
				result.insert (result.end (), cd.begin (), cd.end ());
		}
	}

	return (result);
}

// ---
bool MCHEmul::Parser::loadInMemory (const std::string& fN, MCHEmul::Memory* m)
{
	assert (m != nullptr);

	MCHEmul::Parser::Code code = parse (fN);
	if (!*this)
	{
		// Copies the data...
		for (auto i : code)
			m -> set (i._address, i._code); // The memory is not forced!

		return (true);
	}

	return (false);
}

// ---
MCHEmul::Parser::Lines MCHEmul::Parser::readLines (const std::string& fN) const
{
	std::ifstream f;
	f.open (fN.c_str (), std::ios::in);
	if (!f)
		return (MCHEmul::Parser::Lines ());

	MCHEmul::Parser::Lines ls;
	char l [512];
	while (!f.eof ())
		{ f.getline (l, 512); ls.push_back (MCHEmul::trim (std::string (l))); }

	f.close ();

	return (ls);
}

// ---
MCHEmul::Parser::Code MCHEmul::Parser::parseLine 
	(std::string& cl, MCHEmul::Parser::Labels& lbs, MCHEmul::Parser::Macros& mcrs, 
	 MCHEmul::Address& cA, MCHEmul::Parser::ParserError& e) const
{
	enum class InstructionType
		{ _NOTHING, _COMMENT, _INCLUDE, _MACRO, _LABEL, _OPCODE } lIT = InstructionType::_NOTHING;

	MCHEmul::Parser::Code result;

	auto addCode = [&](const MCHEmul::Parser::Code& c) -> void
		{ if (e == MCHEmul::Parser::ParserError::_NOERROR)
			for (auto i : c) result.push_back (i); };

	while (cl != "" && e == MCHEmul::Parser::ParserError::_NOERROR)
	{
		// Comment?
		if (cl [0] == ';') // Meaning a comment...
		{
			lIT = InstructionType::_COMMENT;

			addCode (parseCommentInst (cl, lbs, mcrs, cA, e));

			break;
		}

		// To include another file? (it must be alone in the line)
		if (cl [0] == '#' && lIT == InstructionType::_NOTHING) // Meaning to include...
															   // It must be alone in the instruction line
		{
			lIT = InstructionType::_INCLUDE;

			addCode (parseIncludeInst (cl, lbs, mcrs, cA, e));

			break;
		}

		// Is it a macro definition?
		size_t mD = std::string::npos;
		if ((mD = cl.find ('=')) != std::string::npos && 
			 lIT == InstructionType::_NOTHING) // Meaning a mcro definition 
											   // It must be alone in the instruction line
		{
			lIT = InstructionType::_MACRO;

			addCode (parseMacroInst (cl, lbs, mcrs, cA, e));

			break;
		}

		// Is it a label definition (for branches)?
		size_t eL = std::string::npos;
		if ((eL = cl.find (':')) != std::string::npos && 
			 lIT == InstructionType::_NOTHING) // Meaning a label before
											   // It must be first in the instruction line...
		{
			lIT = InstructionType::_LABEL;

			addCode (parseLabelInst (cl, lbs, mcrs, cA, e));

			break;
		}

		// Any other case, it should be opcode...who know!!
		addCode (parseOpcodeInst (cl, lbs, mcrs, cA, e));
	}

	return (result);
}

// ---
MCHEmul::Parser::Code MCHEmul::Parser::parseCommentInst 
	(std::string& cl, MCHEmul::Parser::Labels& lbs, MCHEmul::Parser::Macros& mcrs, 
	 MCHEmul::Address& cA, MCHEmul::Parser::ParserError& e) const
{
	assert (cl [0] = ';');

	cl =""; // There can not be more things in the line...

	return (MCHEmul::Parser::Code ()); // It doesn't generate code...
}

// ---
MCHEmul::Parser::Code MCHEmul::Parser::parseIncludeInst 
	(std::string& cl, MCHEmul::Parser::Labels& lbs, MCHEmul::Parser::Macros& mcrs, 
	 MCHEmul::Address& cA, MCHEmul::Parser::ParserError& e) const
{
	assert (cl [0] = '#');

	MCHEmul::Parser::Code result;

	MCHEmul::Parser::Code r = parse (MCHEmul::trim (cl.substr (1, cl.find (';')))); // Maybe a comment behind...

	if (_parserError != MCHEmul::Parser::ParserError::_NOERROR)
	{
		result = r;

		cl = ""; // There can not be more things in the line...
	}
	
	return (result);
}

MCHEmul::Parser::Code MCHEmul::Parser::parseMacroInst 
	(std::string& cl, MCHEmul::Parser::Labels& lbs, MCHEmul::Parser::Macros& mcrs, 
	 MCHEmul::Address& cA, MCHEmul::Parser::ParserError& e) const
{
	size_t mD = cl.find ('=');

	assert (mD != std::string::npos);

	std::string mL = MCHEmul::trim (cl.substr (0, mD));
	std::string mR = 
		MCHEmul::trim (cl.substr (mD + 1, cl.find (';'))); // Maybe a comment can be later...

	bool t = false;
	if (mL != "" && mR != "")
	{
		// That macro is "special" to redefine the address of the code...
		if (mL [0] == '*')
		{
			if (MCHEmul::validBytes (mR))
			{
				cA = MCHEmul::Address::fromStr (mR); // Change the address...

				t = true;
			}
		}
		else
		{
			if (MCHEmul::validLabel (mL) && 
				MCHEmul::validBytes (mR)) // The usual type of macro is made of a label and a value...
			{
				mcrs.insert (MCHEmul::Parser::Macros::value_type (mL, MCHEmul::UInt::fromStr (mR).bytes ().values ()));

				t = true;
			}
		}
	}

	if (!t)
		e = MCHEmul::Parser::ParserError::_BADDEFINEDLINE;

	cl = ""; // There can not be more things in the line...

	return (MCHEmul::Parser::Code ()); // It doesn't generate code...
}

MCHEmul::Parser::Code MCHEmul::Parser::parseLabelInst 
	(std::string& cl, MCHEmul::Parser::Labels& lbs, MCHEmul::Parser::Macros& mcrs, 
	 MCHEmul::Address& cA, MCHEmul::Parser::ParserError& e) const
{
	size_t eL = cl.find (':');
	
	assert (eL != std::string::npos);

	std::string lb = (eL > 0) 
		? MCHEmul::trim (MCHEmul::upper (cl.substr (0, eL))) : "";
	if (lb != "" && MCHEmul::validLabel (lb)) // Inserts it only if it is a valid label....
	{
		lbs.insert (MCHEmul::Parser::Labels::value_type (lb, cA)); // The label is defined where the current address is...

		cl = MCHEmul::trim (cl.substr (eL + 1)); // Does it continue parsing the line? (depends on what is behind...)
	}
	else
		e = MCHEmul::Parser::ParserError::_BADDEFINEDLINE;

	// There could be more things after the definition of the label...

	return (MCHEmul::Parser::Code ()); // It doesn't generate code...
}

MCHEmul::Parser::Code MCHEmul::Parser::parseOpcodeInst 
	(std::string& cl, MCHEmul::Parser::Labels& lbs, MCHEmul::Parser::Macros& mcrs, 
	 MCHEmul::Address& cA, MCHEmul::Parser::ParserError& e) const
{
	cl = cl.substr (0, cl.find (';')); // Until a potential comment before...
	// This is goinf to happen anyway...

	// To compare in the right way the instruction
	// an homogeneization is needed...
	std::string clS = MCHEmul::upper (MCHEmul::noSpaces (cl));

	// Find the right instruction...
	MCHEmul::Instruction* inst = nullptr;
	std::vector <MCHEmul::UByte> prmsB;
	for (MCHEmul::Instructions::const_iterator i = _instructions.begin (); 
		i != _instructions.end () && inst == nullptr; i++) // Check it against the list of opcodes...
	{
		std::vector <std::string> prms; 
		if ((*i).second -> matchesWith (clS, prms))
		{
			// Initially it could be the instruction to take into account...
			// Becaus it initially matches a pattern...
			inst = (*i).second;

			// But it could happend that this instruction had no byte parameter but a either a macro or a label
			// In that case, a wrong decision could have been taken during the matching,
			// being then necessary to analyze also the size of the parameter compare with the
			// number required by the initially selected instruction...
			prmsB = { };
			e = MCHEmul::Parser::ParserError::_NOERROR;
			bool vPrms = true; // To indicate whether the parameteres matches or not the right size...
			for (size_t i = 0; i < prms.size () && vPrms; i++)
			{
				MCHEmul::Parser::Macros::const_iterator mI = mcrs.find (prms [i]);
				MCHEmul::Parser::Labels::const_iterator lI = lbs.find (prms  [i]);

				std::vector <MCHEmul::UByte> dt;
				// Is the prm a macro?
				if (mI != mcrs.end ()) 
					dt = (*mI).second;
				// Is it a label?
				else 
				if (lI != lbs.end ()) 
					dt = MCHEmul::UInt::fromInt 
						(cA.next (inst -> memoryPositions () /** including this */).distanceWith ((*lI).second)).bytes ().values ();
				// Is it a "number"?
				else
				if (MCHEmul::validBytes (prms [i])) 
					dt = MCHEmul::UInt::fromStr (prms [i]).bytes ().values ();
				//... no more possibilities it has to be a mistake...
				else
					e = MCHEmul::Parser::ParserError::_BADTYPEPARAMETERS;

				// Does the data size match with the size of the parameter?
				if (dt.size () == inst -> internalStructure ()._parameters [i]._numberBytes)
				{
					// If the architecture is Little - endian the bytes in an address parameter should be in the other way around...
					if (dt.size () > 1 && !_architecture.bigEndian ())
						dt = MCHEmul::UBytes (dt, false /** To force the rerverse. */).values ();
					// ...finally insrt them into the list of parameters...
					prmsB.insert (prmsB.end (), dt.begin (), dt.end ());
				}
				else
				{
					vPrms = false;
					e = MCHEmul::Parser::ParserError::_BADTYPEPARAMETERS;
				}
			}

			if (!vPrms)
				inst = nullptr; // After all, it not valid!!...What a pity
		}
	}

	// No right match has been found at all...
	if (inst == nullptr)
	{
		e = MCHEmul::Parser::ParserError::_CODENOTFOUND;

		return (MCHEmul::Parser::Code ());
	}

	cl ="";

	MCHEmul::Parser::CodeLine cdL;
	cdL._address = cA;
	cdL._code = prmsB;
	std::vector <MCHEmul::UByte> instC = 
		MCHEmul::UInt::fromUnsignedInt (inst -> code ()).bytes ().values ();
	cdL._code.insert (cdL._code.begin (), instC.begin (), instC.end ()); // Add the op code...
	cA = cA.next (cdL._code.size ()); // The address has to be incremented in the size of the code...

	return (MCHEmul::Parser::Code ({ cdL }));
}
