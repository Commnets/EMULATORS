{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment EMULATORS }EMULATORS}
{\comment Generated by doxygen1.9.3.}
{\creatim \yr2022\mo9\dy24\hr19\min47\sec12}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt EMULATORS}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Sat Sep 24 2022 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Module Index\par \pard\plain 
{\tc \v Module Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Modules\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all modules:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Classes representing any CPU\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Classes representing a Parseer/Compiler emulator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Classes representing the communications between server and client.\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Classes needed to excute an emultor from a console.\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Classes defining the 6500 chip family\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
All classes defining the C64 Computer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
All classes defining a template for any emulator.\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all namespaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b C64} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Console} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAART \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Emuls} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::Address\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::ByteCode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::ByteCodeLine\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Chip\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::CIA1\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::CIA2\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::SpecialFunctionsChip\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::GraphicalChip\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::VICII\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALT \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::VICII_NTSC\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::VICII_PAL\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
MCHEmul::NoChip\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
C64::CIAClock\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::CIATimer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Computer::Clock\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Command\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::CommandBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIT \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::StandardCommandBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::Assembler::CommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPJ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::Assembler::BytesCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::CommentCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::IncludeCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::InstructionCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::LabelCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::MacroCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::StartingPointCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACUO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::CommunicationMessage\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::GetMemoryDataMessage\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::GetRegisterStatusMessage\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::CommunicationSystem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::Compiler\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Computer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKD \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::Commodore64\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Console::Console\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Memory::Content\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::CPU\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABML \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
F6500::C6500\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAS \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
F6500::C6510\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
MCHEmul::CPUArchitecture\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::CPUInterrupt\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOS \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
F6500::IRQInterrupt\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::NMIInterrupt\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Emuls::Emulator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASU \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Emuls::C64Emulator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::Assembler::Error\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::UInt::FormatManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMV \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::UInt::BinaryFormatManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::UInt::PackagedBCDFormatManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::UInt::FormatManagers\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::GrammaticalElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACRB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::Assembler::BytesInMemoryElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::InstructionElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::LabelElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::StartingPointElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACUQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::Instruction\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQJ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
F6500::Instruction\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCP \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
F6500::ADC_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::AND_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::ASL_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::BXX_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::CMP_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::CPX_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::CPY_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::DEC_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::EOR_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::INC_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::LDA_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::LDX_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::LDY_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::LSR_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::ORA_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::ROL_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::ROR_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::SBC_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::STA_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::STX_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::STY_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
MCHEmul::IODevice\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::UserIOPort\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::InputOSSystem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPV \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::InputOSSystem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::Screen\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::Screen\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKT \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::ScreenNTSC\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::ScreenPAL\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
}\par
MCHEmul::IOPeripheral\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTP \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::UserIOPeripheral\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::UserIONoPeripheral\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
MCHEmul::IOPeripheralBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUF \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::IOPeripheralBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::IPAddress\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::Macro\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Memory\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVE \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::Memory\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::MemoryView\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::MessageBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYP \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::StandardMessageBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::Instruction::Structure::Parameter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::Parser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::PeerCommunicationChannel\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::PhisicalStorage\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::PhisicalStorageSubset\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAY \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::CIA1Registers\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::CIA2Registers\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::ColorRAMMemory\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::VICIIRegisters\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Stack\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
C64::VICII::Raster\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::VICII::RasterData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Register\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::ProgramCounter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::StatusRegister\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::ScreenMemory\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::Semantic\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Instruction::Structure\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::UByte\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::UBytes\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::UInt\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b F6500::ADC_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Address} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::AND_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::ASL_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UInt::BinaryFormatManager} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::BXX_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::ByteCode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::ByteCodeLine} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::BytesCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::BytesInMemoryElement} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Emuls::C64Emulator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::C6500} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::C6510} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Chip} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::CIA1} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::CIA1Registers} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::CIA2} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::CIA2Registers} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::CIAClock} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::CIATimer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Computer::Clock} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::CMP_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::ColorRAMMemory} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Command} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::CommandBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::CommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::CommentCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::Commodore64} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::CommunicationMessage} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::CommunicationSystem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::Compiler} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Computer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Console::Console} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Memory::Content} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::CPU} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABML \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::CPUArchitecture} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::CPUInterrupt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::CPX_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::CPY_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::DEC_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Emuls::Emulator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::EOR_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::Error} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UInt::FormatManager} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UInt::FormatManagers} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::GetMemoryDataMessage} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::GetRegisterStatusMessage} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::GrammaticalElement} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACRB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::GraphicalChip} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::INC_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::IncludeCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::InputOSSystem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::InputOSSystem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::Instruction} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Instruction} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::InstructionCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::InstructionElement} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::IODevice} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::IOPeripheral} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::IOPeripheralBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::IOPeripheralBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::IPAddress} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::IRQInterrupt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::LabelCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::LabelElement} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::LDA_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::LDX_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::LDY_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::LSR_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::Macro} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::MacroCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::Memory} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Memory} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::MemoryView} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::MessageBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::NMIInterrupt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::NoChip} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::ORA_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UInt::PackagedBCDFormatManager} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Instruction::Structure::Parameter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::Parser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::PeerCommunicationChannel} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::PhisicalStorage} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::PhisicalStorageSubset} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::ProgramCounter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::VICII::Raster} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::VICII::RasterData} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Register} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::ROL_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::ROR_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::SBC_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::Screen} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Screen} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::ScreenMemory} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::ScreenNTSC} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::ScreenPAL} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::Semantic} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::SpecialFunctionsChip} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::STA_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Stack} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::StandardCommandBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::StandardMessageBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::StartingPointCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACUO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::StartingPointElement} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACUQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::StatusRegister} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Instruction::Structure} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::STX_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::STY_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UByte} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UBytes} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UInt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::UserIONoPeripheral} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::UserIOPeripheral} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::UserIOPort} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::VICII} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::VICII_NTSC} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::VICII_PAL} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::VICIIRegisters} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b C:/WorkspacesII/EMULATORS/include/{\b doxy.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Compiler.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Error.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b C64.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b CIA1.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b CIA1Registers.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b CIA2.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b CIA2Registers.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b CIAClock.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b CIATimer.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b ColorMemory.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b global.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b IOPBuilder.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b Memory.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b OSIO.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b Screen.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b SFChip.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b UserPeripherals.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b UserPort.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b VICII.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b VICIIRegisters.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/COMMS/{\b Channel.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/COMMS/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/COMMS/{\b IPAddress.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/COMMS/{\b Message.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/COMMS/{\b StdMessages.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/COMMS/{\b System.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CONSOLE/{\b Console.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CONSOLE/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Address.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Chip.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Command.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b CommandBuilder.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Computer.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b CPU.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b CPUArchitecture.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b CPUInterrupt.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b global.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b GraphicalChip.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Instruction.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b IO.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b IOPBuilder.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b IOPeripheral.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAES \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Memory.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b OSIO.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b ProgramCounter.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAET \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Register.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Screen.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b ScreenMemory.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Stack.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b StatusRegister.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b UByte.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b UBytes.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b UInt.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/EMULATORS/{\b C64Emulator.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/EMULATORS/{\b Emulator.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/EMULATORS/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/F6500/{\b C6500.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/F6500/{\b C6510.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/F6500/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/F6500/{\b IRQInterrupt.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/F6500/{\b NMIInterrupt.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Module Documentation{\tc \v Module Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Classes representing any CPU\par \pard\plain 
{\tc\tcl2 \v Classes representing any CPU}
{\xe \v Classes representing any CPU}
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the core of any CPU emulator. \par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Classes representing a Parseer/Compiler emulator\par \pard\plain 
{\tc\tcl2 \v Classes representing a Parseer/Compiler emulator}
{\xe \v Classes representing a Parseer/Compiler emulator}
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the Parser and Compiling processes for any type assambler. \par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Classes representing the communications between server and client.\par \pard\plain 
{\tc\tcl2 \v Classes representing the communications between server and client.}
{\xe \v Classes representing the communications between server and client.}
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the way an emulator can communication with other external tools. \par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Classes needed to excute an emultor from a console.\par \pard\plain 
{\tc\tcl2 \v Classes needed to excute an emultor from a console.}
{\xe \v Classes needed to excute an emultor from a console.}
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the way an emulator can be similated from a console. \par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Classes defining the 6500 chip family\par \pard\plain 
{\tc\tcl2 \v Classes defining the 6500 chip family}
{\xe \v Classes defining the 6500 chip family}
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the characteristics of the Motorola 6500 chip family. \par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
All classes defining the C64 Computer\par \pard\plain 
{\tc\tcl2 \v All classes defining the C64 Computer}
{\xe \v All classes defining the C64 Computer}
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the characteristics of any Commodore64 Computer. \par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
All classes defining a template for any emulator.\par \pard\plain 
{\tc\tcl2 \v All classes defining a template for any emulator.}
{\xe \v All classes defining a template for any emulator.}
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the common characteristics to any Emulator. \par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64 Namespace Reference\par \pard\plain 
{\tc\tcl2 \v C64}
{\xe \v C64}
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CIA1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CIA1Registers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CIA2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CIA2Registers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CIAClock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CIATimer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ColorRAMMemory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Commodore64}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InputOSSystem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IOPeripheralBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Memory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Screen}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ScreenNTSC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ScreenPAL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SpecialFunctionsChip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UserIONoPeripheral}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UserIOPeripheral}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UserIOPort}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VICII}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VICII_NTSC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VICII_PAL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VICIIRegisters}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Duration} = std::chrono::duration< unsigned long, std::deci >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Time} = std::chrono::time_point< std::chrono::steady_clock, {\b Duration} >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b actualizeGlobalTime} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Duration\:C64}
{\xe \v C64\:Duration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b C64::Duration} = typedef std::chrono::duration <unsigned long, std::deci>}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b C64} counts using tenth of seconds only. \par
}{
Definition at line {\b 22} of file {\b global.hpp}.}\par
}
{\xe \v Time\:C64}
{\xe \v C64\:Time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b C64::Time} = typedef std::chrono::time_point <std::chrono::steady_clock, {\b Duration}>}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b global.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v actualizeGlobalTime\:C64}
{\xe \v C64\:actualizeGlobalTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::actualizeGlobalTime ()}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To actualize the time. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_c64_af90d49657dd593c30399c041da0e7259_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Console Namespace Reference\par \pard\plain 
{\tc\tcl2 \v Console}
{\xe \v Console}
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Console}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Emuls Namespace Reference\par \pard\plain 
{\tc\tcl2 \v Emuls}
{\xe \v Emuls}
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64Emulator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Emulator}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500 Namespace Reference\par \pard\plain 
{\tc\tcl2 \v F6500}
{\xe \v F6500}
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ADC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AND_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ASL_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BXX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C6500}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C6510}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CMP_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPY_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DEC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EOR_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b INC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Instruction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IRQInterrupt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LDA_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LDX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LDY_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LSR_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NMIInterrupt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ORA_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ROL_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ROR_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SBC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b STA_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b STX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b STY_General}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x69, 2, 2, "ADC#[#1]", ADC_Inmediate, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x6d, 3, 4, "ADC[$2]", ADC_Absolute, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x65, 2, 3, "ADC[$1]", ADC_ZeroPage, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x61, 2, 6, "ADC([$1],X)", ADC_ZeroPageIndirectX, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x71, 2, 5, "ADC([$1]),Y", ADC_ZeroPageIndirectY, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x75, 2, 4, "ADC[$1],X", ADC_ZeroPageX, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x7d, 3, 4, "ADC[$2],X", ADC_AbsoluteX, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x79, 3, 4, "ADC[$2],Y", ADC_AbsoluteY, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x29, 2, 2, "AND#[#1]", AND_Inmediate, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x2d, 3, 4, "AND[$2]", AND_Absolute, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x25, 2, 3, "AND[$1]", AND_ZeroPage, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x21, 2, 6, "AND([$1],X)", AND_ZeroPageIndirectX, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x31, 2, 5, "AND([$1]),Y", AND_ZeroPageIndirectY, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x35, 2, 4, "AND[$1],X", AND_ZeroPageX, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x3d, 3, 4, "AND[$2],X", AND_AbsoluteX, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x39, 3, 4, "AND[$2],Y", AND_AbsoluteY, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x0e, 3, 6, "ASL[$2]", ASL_Absolute, {\b ASL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x06, 2, 5, "ASL[$1]", ASL_ZeroPage, {\b ASL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x0a, 1, 2, "ASL", ASL_Accumulator, {\b ASL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x16, 2, 6, "ASL[$1],X", ASL_ZeroPageX, {\b ASL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x1e, 3, 7, "ASL[$2],X", ASL_AbsoluteX, {\b ASL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x90, 2, 2, "BCC[&1]", BCC, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb0, 2, 2, "BCS[&1]", BCS, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xf0, 2, 2, "BEQ[&1]", BEQ, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x2c, 3, 4, "BIT[$2]", BIT_Absolute, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x24, 2, 3, "BIT[$1]", BIT_ZeroPage, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x30, 2, 2, "BMI[&1]", BMI, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xd0, 2, 2, "BNE[&1]", BNE, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x10, 2, 2, "BPL[&1]", BPL, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x00, 1, 7, "BRK", BRK, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x50, 2, 2, "BVC[&1]", BVC, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x70, 2, 2, "BVS[&1]", BVS, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x18, 1, 2, "CLC", CLC, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xd8, 1, 2, "CLD", CLD, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x58, 1, 2, "CLI", CLI, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb8, 1, 2, "CLV", CLV, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc9, 2, 2, "CMP#[#1]", CMP_Inmediate, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xcd, 3, 4, "CMP[$2]", CMP_Absolute, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc5, 2, 3, "CMP[$1]", CMP_ZeroPage, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc1, 2, 6, "CMP([$1],X)", CMP_ZeroPageIndirectX, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xd1, 2, 5, "CMP([$1]),Y", CMP_ZeroPageIndirectY, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xd5, 2, 4, "CMP[$1],X", CMP_ZeroPageX, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xdd, 3, 4, "CMP[$2],X", CMP_AbsoluteX, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xd9, 3, 4, "CMP[$2],Y", CMP_AbsoluteY, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe0, 2, 2, "CPX#[#1]", CPX_Inmediate, {\b CPX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xec, 3, 4, "CPX[$2]", CPX_Absolute, {\b CPX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe4, 2, 3, "CPX[$1]", CPX_ZeroPage, {\b CPX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc0, 2, 2, "CPY#[#1]", CPY_Inmediate, {\b CPY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xcc, 3, 4, "CPY[$2]", CPY_Absolute, {\b CPY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc4, 2, 3, "CPY[$1]", CPY_ZeroPage, {\b CPY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xce, 3, 6, "DEC[$2]", DEC_Absolute, {\b DEC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc6, 2, 5, "DEC[$1]", DEC_ZeroPage, {\b DEC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xd6, 2, 6, "DEC[$1],X", DEC_ZeroPageX, {\b DEC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xde, 3, 7, "DEC[$2],X", DEC_AbsoluteX, {\b DEC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xca, 1, 2, "DEX", DEX, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x88, 1, 2, "DEY", DEY, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x49, 2, 2, "EOR#[#1]", EOR_Inmediate, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x4d, 3, 4, "EOR[$2]", EOR_Absolute, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x45, 2, 3, "EOR[$1]", EOR_ZeroPage, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x41, 2, 6, "EOR([$1],X)", EOR_ZeroPageIndirectX, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x51, 2, 5, "EOR([$1]),Y", EOR_ZeroPageIndirectY, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x55, 2, 4, "EOR[$1],X", EOR_ZeroPageX, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x5d, 3, 4, "EOR[$2],X", EOR_AbsoluteX, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x59, 3, 4, "EOR[$2],Y", EOR_AbsoluteY, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xee, 3, 6, "INC[$2]", INC_Absolute, {\b INC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe6, 2, 5, "INC[$1]", INC_ZeroPage, {\b INC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xf6, 2, 6, "INC[$1],X", INC_ZeroPageX, {\b INC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xfe, 3, 7, "INC[$2],X", INC_AbsoluteX, {\b INC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe8, 1, 2, "INX", INX, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc8, 1, 2, "INY", INY, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x4c, 3, 3, "JMP[%2]", JMP_Absolute, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x6c, 3, 5, "JMP([%2])", JMP_Indirect, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x20, 3, 6, "JSR[%2]", JSR_Absolute, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa9, 2, 2, "LDA#[#1]", LDA_Inmediate, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xad, 3, 4, "LDA[$2]", LDA_Absolute, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa5, 2, 3, "LDA[$1]", LDA_ZeroPage, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa1, 2, 6, "LDA([$1],X)", LDA_ZeroPageIndirectX, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb1, 2, 5, "LDA([$1]),Y", LDA_ZeroPageIndirectY, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb5, 2, 4, "LDA[$1],X", LDA_ZeroPageX, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xbd, 3, 4, "LDA[$2],X", LDA_AbsoluteX, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb9, 3, 4, "LDA[$2],Y", LDA_AbsoluteY, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa2, 2, 2, "LDX#[#1]", LDX_Inmediate, {\b LDX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xae, 3, 4, "LDX[$2]", LDX_Absolute, {\b LDX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa6, 2, 3, "LDX[$1]", LDX_ZeroPage, {\b LDX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xbe, 3, 4, "LDX[$2],Y", LDX_AbsoluteY, {\b LDX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb6, 2, 4, "LDX[$1],Y", LDX_ZeroPageY, {\b LDX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa0, 2, 2, "LDY#[#1]", LDY_Inmediate, {\b LDY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xac, 3, 4, "LDY[$2]", LDY_Absolute, {\b LDY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa4, 2, 3, "LDY[$1]", LDY_ZeroPage, {\b LDY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb4, 2, 4, "LDY[$1],X", LDY_ZeroPageX, {\b LDY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xbc, 3, 4, "LDY[$2],X", LDY_AbsoluteX, {\b LDY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x4e, 3, 6, "LSR[$2]", LSR_Absolute, {\b LSR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x46, 2, 5, "LSR[$1]", LSR_ZeroPage, {\b LSR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x4a, 1, 2, "LSR", LSR_Accumulator, {\b LSR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x56, 2, 6, "LSR[$1],X", LSR_ZeroPageX, {\b LSR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x5e, 3, 7, "LSR[$2],X", LSR_AbsoluteX, {\b LSR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xea, 1, 2, "NOP", NOP, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x09, 2, 2, "ORA#[#1]", ORA_Inmediate, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x0d, 3, 4, "ORA[$2]", ORA_Absolute, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x05, 2, 3, "ORA[$1]", ORA_ZeroPage, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x01, 2, 6, "ORA([$1],X)", ORA_ZeroPageIndirectX, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x11, 2, 5, "ORA([$1]),Y", ORA_ZeroPageIndirectY, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x15, 2, 4, "ORA[$1],X", ORA_ZeroPageX, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x1d, 3, 4, "ORA[$2],X", ORA_AbsoluteX, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x19, 3, 4, "ORA[$2],Y", ORA_AbsoluteY, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x48, 1, 3, "PHA", PHA, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x08, 1, 3, "PHP", PHP, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x68, 1, 4, "PLA", PLA, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x28, 1, 4, "PLP", PLP, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x2e, 3, 6, "ROL[$2]", ROL_Absolute, {\b ROL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x26, 2, 5, "ROL[$1]", ROL_ZeroPage, {\b ROL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x2a, 1, 2, "ROL", ROL_Accumulator, {\b ROL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x36, 2, 6, "ROL[$1],X", ROL_ZeroPageX, {\b ROL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x3e, 3, 7, "ROL[$2],X", ROL_AbsoluteX, {\b ROL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x6e, 3, 6, "ROR[$2]", ROR_Absolute, {\b ROR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x66, 2, 5, "ROR[$1]", ROR_ZeroPage, {\b ROR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x6a, 1, 2, "ROR", ROR_Accumulator, {\b ROR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x76, 2, 6, "ROR[$1],X", ROR_ZeroPageX, {\b ROR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x7e, 3, 7, "ROR[$2],X", ROR_AbsoluteX, {\b ROR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x40, 1, 6, "RTI", RTI, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x60, 1, 6, "RTS", RTS, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe9, 2, 2, "SBC#[#1]", SBC_Inmediate, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xed, 3, 4, "SBC[$2]", SBC_Absolute, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe5, 2, 3, "SBC[$1]", SBC_ZeroPage, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe1, 2, 6, "SBC([$1],X)", SBC_ZeroPageIndirectX, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xf1, 2, 5, "SBC([$1]),Y", SBC_ZeroPageIndirectY, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xf5, 2, 4, "SBC[$1],X", SBC_ZeroPageX, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xfd, 3, 4, "SBC[$2],X", SBC_AbsoluteX, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xf9, 3, 4, "SBC[$2],Y", SBC_AbsoluteY, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x38, 1, 2, "SEC", SEC, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xf8, 1, 2, "SED", SED, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x78, 1, 2, "SEI", SEI, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x8d, 3, 4, "STA[$2]", STA_Absolute, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x85, 2, 3, "STA[$1]", STA_ZeroPage, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x81, 2, 6, "STA([$1],X)", STA_ZeroPageIndirectX, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x91, 2, 6, "STA([$1]),Y", STA_ZeroPageIndirectY, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x95, 2, 4, "STA[$1],X", STA_ZeroPageX, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x9d, 3, 5, "STA[$2],X", STA_AbsoluteX, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x99, 3, 5, "STA[$2],Y", STA_AbsoluteY, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x8e, 3, 4, "STX[$2]", STX_Absolute, {\b STX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x86, 2, 3, "STX[$1]", STX_ZeroPage, {\b STX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x96, 2, 4, "STX[$1],Y", STX_ZeroPageY, {\b STX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x8c, 3, 4, "STY[$2]", STY_Absolute, {\b STY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x84, 2, 3, "STY[$1]", STY_ZeroPage, {\b STY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x94, 2, 4, "STY[$1],X", STY_ZeroPageX, {\b STY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xaa, 1, 2, "TAX", TAX, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa8, 1, 2, "TAY", TAY, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xba, 1, 2, "TSX", TSX, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x8a, 1, 2, "TXA", TXA, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x9a, 1, 2, "TXS", TXS, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x98, 1, 2, "TYA", TYA, {\b Instruction})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x00 , 1 , 7 , "BRK" , BRK , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x01 , 2 , 6 , "ORA([$1],X)" , ORA_ZeroPageIndirectX , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x05 , 2 , 3 , "ORA" [ $1], ORA_ZeroPage , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x06 , 2 , 5 , "ASL" [ $1], ASL_ZeroPage , {\b ASL_General} )}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x08 , 1 , 3 , "PHP" , PHP , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x09 , 2 , 2 , "ORA#" [#1], ORA_Inmediate , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x0a , 1 , 2 , "ASL" , ASL_Accumulator , {\b ASL_General} )}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x0d , 3 , 4 , "ORA" [ $2], ORA_Absolute , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x0e , 3 , 6 , "ASL" [ $2], ASL_Absolute , {\b ASL_General} )}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x10 , 2 , 2 , "BPL" [&1], BPL , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x11 , 2 , 5 , "  {\i ORA}[$1], Y" , ORA_ZeroPageIndirectY , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x15 , 2 , 4 , "  {\i ORA}[ $1], X" , ORA_ZeroPageX , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x16 , 2 , 6 , "  {\i ASL}[ $1], X" , ASL_ZeroPageX , {\b ASL_General} )}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x18 , 1 , 2 , "CLC" , CLC , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x19 , 3 , 4 , "  {\i ORA}[ $2], Y" , ORA_AbsoluteY , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x1d , 3 , 4 , "  {\i ORA}[ $2], X" , ORA_AbsoluteX , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x1e , 3 , 7 , "  {\i ASL}[ $2], X" , ASL_AbsoluteX , {\b ASL_General} )}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x20 , 3 , 6 , "JSR" [%2], JSR_Absolute , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x21 , 2 , 6 , "AND([$1],X)" , AND_ZeroPageIndirectX , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x24 , 2 , 3 , "BIT" [ $1], BIT_ZeroPage , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x25 , 2 , 3 , "AND" [ $1], AND_ZeroPage , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x26 , 2 , 5 , "ROL" [ $1], ROL_ZeroPage , {\b ROL_General} )}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x28 , 1 , 4 , "PLP" , PLP , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x29 , 2 , 2 , "AND#" [#1], AND_Inmediate , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x2a , 1 , 2 , "ROL" , ROL_Accumulator , {\b ROL_General} )}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x2c , 3 , 4 , "BIT" [ $2], BIT_Absolute , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x2d , 3 , 4 , "AND" [ $2], AND_Absolute , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x2e , 3 , 6 , "ROL" [ $2], ROL_Absolute , {\b ROL_General} )}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x30 , 2 , 2 , "BMI" [&1], BMI , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x31 , 2 , 5 , "  {\i AND}[$1], Y" , AND_ZeroPageIndirectY , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x35 , 2 , 4 , "  {\i AND}[ $1], X" , AND_ZeroPageX , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x36 , 2 , 6 , "  {\i ROL}[ $1], X" , ROL_ZeroPageX , {\b ROL_General} )}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x38 , 1 , 2 , "SEC" , SEC , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x39 , 3 , 4 , "  {\i AND}[ $2], Y" , AND_AbsoluteY , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x3d , 3 , 4 , "  {\i AND}[ $2], X" , AND_AbsoluteX , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x3e , 3 , 7 , "  {\i ROL}[ $2], X" , ROL_AbsoluteX , {\b ROL_General} )}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x40 , 1 , 6 , "RTI" , RTI , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x41 , 2 , 6 , "EOR([$1],X)" , EOR_ZeroPageIndirectX , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x45 , 2 , 3 , "EOR" [ $1], EOR_ZeroPage , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x46 , 2 , 5 , "LSR" [ $1], LSR_ZeroPage , {\b LSR_General} )}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x48 , 1 , 3 , "PHA" , PHA , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x49 , 2 , 2 , "EOR#" [#1], EOR_Inmediate , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x4a , 1 , 2 , "LSR" , LSR_Accumulator , {\b LSR_General} )}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x4c , 3 , 3 , "JMP" [%2], JMP_Absolute , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x4d , 3 , 4 , "EOR" [ $2], EOR_Absolute , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x4e , 3 , 6 , "LSR" [ $2], LSR_Absolute , {\b LSR_General} )}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x50 , 2 , 2 , "BVC" [&1], BVC , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x51 , 2 , 5 , "  {\i EOR}[$1], Y" , EOR_ZeroPageIndirectY , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x55 , 2 , 4 , "  {\i EOR}[ $1], X" , EOR_ZeroPageX , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x56 , 2 , 6 , "  {\i LSR}[ $1], X" , LSR_ZeroPageX , {\b LSR_General} )}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x58 , 1 , 2 , "CLI" , CLI , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x59 , 3 , 4 , "  {\i EOR}[ $2], Y" , EOR_AbsoluteY , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x5d , 3 , 4 , "  {\i EOR}[ $2], X" , EOR_AbsoluteX , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x5e , 3 , 7 , "  {\i LSR}[ $2], X" , LSR_AbsoluteX , {\b LSR_General} )}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x60 , 1 , 6 , "RTS" , RTS , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x61 , 2 , 6 , "ADC([$1],X)" , ADC_ZeroPageIndirectX , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x65 , 2 , 3 , "ADC" [ $1], ADC_ZeroPage , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x66 , 2 , 5 , "ROR" [ $1], ROR_ZeroPage , {\b ROR_General} )}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x68 , 1 , 4 , "PLA" , PLA , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x69 , 2 , 2 , "ADC#" [#1], ADC_Inmediate , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x6a , 1 , 2 , "ROR" , ROR_Accumulator , {\b ROR_General} )}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x6c , 3 , 5 , "JMP([%2])" , JMP_Indirect , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x6d , 3 , 4 , "ADC" [ $2], ADC_Absolute , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x6e , 3 , 6 , "ROR" [ $2], ROR_Absolute , {\b ROR_General} )}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x70 , 2 , 2 , "BVS" [&1], BVS , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x71 , 2 , 5 , "  {\i ADC}[$1], Y" , ADC_ZeroPageIndirectY , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x75 , 2 , 4 , "  {\i ADC}[ $1], X" , ADC_ZeroPageX , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x76 , 2 , 6 , "  {\i ROR}[ $1], X" , ROR_ZeroPageX , {\b ROR_General} )}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x78 , 1 , 2 , "SEI" , SEI , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x79 , 3 , 4 , "  {\i ADC}[ $2], Y" , ADC_AbsoluteY , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x7d , 3 , 4 , "  {\i ADC}[ $2], X" , ADC_AbsoluteX , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x7e , 3 , 7 , "  {\i ROR}[ $2], X" , ROR_AbsoluteX , {\b ROR_General} )}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x81 , 2 , 6 , "STA([$1],X)" , STA_ZeroPageIndirectX , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x84 , 2 , 3 , "STY" [ $1], STY_ZeroPage , {\b STY_General} )}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x85 , 2 , 3 , "STA" [ $1], STA_ZeroPage , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x86 , 2 , 3 , "STX" [ $1], STX_ZeroPage , {\b STX_General} )}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x88 , 1 , 2 , "DEY" , DEY , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x8a , 1 , 2 , "TXA" , TXA , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x8c , 3 , 4 , "STY" [ $2], STY_Absolute , {\b STY_General} )}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x8d , 3 , 4 , "STA" [ $2], STA_Absolute , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x8e , 3 , 4 , "STX" [ $2], STX_Absolute , {\b STX_General} )}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x90 , 2 , 2 , "BCC" [&1], BCC , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x91 , 2 , 6 , "  {\i STA}[$1], Y" , STA_ZeroPageIndirectY , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x94 , 2 , 4 , "  {\i STY}[ $1], X" , STY_ZeroPageX , {\b STY_General} )}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x95 , 2 , 4 , "  {\i STA}[ $1], X" , STA_ZeroPageX , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x96 , 2 , 4 , "  {\i STX}[ $1], Y" , STX_ZeroPageY , {\b STX_General} )}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x98 , 1 , 2 , "TYA" , TYA , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x99 , 3 , 5 , "  {\i STA}[ $2], Y" , STA_AbsoluteY , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x9a , 1 , 2 , "TXS" , TXS , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x9d , 3 , 5 , "  {\i STA}[ $2], X" , STA_AbsoluteX , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa0 , 2 , 2 , "LDY#" [#1], LDY_Inmediate , {\b LDY_General} )}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa1 , 2 , 6 , "LDA([$1],X)" , LDA_ZeroPageIndirectX , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa2 , 2 , 2 , "LDX#" [#1], LDX_Inmediate , {\b LDX_General} )}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa4 , 2 , 3 , "LDY" [ $1], LDY_ZeroPage , {\b LDY_General} )}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa5 , 2 , 3 , "LDA" [ $1], LDA_ZeroPage , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa6 , 2 , 3 , "LDX" [ $1], LDX_ZeroPage , {\b LDX_General} )}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa8 , 1 , 2 , "TAY" , TAY , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa9 , 2 , 2 , "LDA#" [#1], LDA_Inmediate , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xaa , 1 , 2 , "TAX" , TAX , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xac , 3 , 4 , "LDY" [ $2], LDY_Absolute , {\b LDY_General} )}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xad , 3 , 4 , "LDA" [ $2], LDA_Absolute , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xae , 3 , 4 , "LDX" [ $2], LDX_Absolute , {\b LDX_General} )}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb0 , 2 , 2 , "BCS" [&1], BCS , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb1 , 2 , 5 , "  {\i LDA}[$1], Y" , LDA_ZeroPageIndirectY , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb4 , 2 , 4 , "  {\i LDY}[ $1], X" , LDY_ZeroPageX , {\b LDY_General} )}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb5 , 2 , 4 , "  {\i LDA}[ $1], X" , LDA_ZeroPageX , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb6 , 2 , 4 , "  {\i LDX}[ $1], Y" , LDX_ZeroPageY , {\b LDX_General} )}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb8 , 1 , 2 , "CLV" , CLV , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb9 , 3 , 4 , "  {\i LDA}[ $2], Y" , LDA_AbsoluteY , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xba , 1 , 2 , "TSX" , TSX , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xbc , 3 , 4 , "  {\i LDY}[ $2], X" , LDY_AbsoluteX , {\b LDY_General} )}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xbd , 3 , 4 , "  {\i LDA}[ $2], X" , LDA_AbsoluteX , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xbe , 3 , 4 , "  {\i LDX}[ $2], Y" , LDX_AbsoluteY , {\b LDX_General} )}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc0 , 2 , 2 , "CPY#" [#1], CPY_Inmediate , {\b CPY_General} )}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc1 , 2 , 6 , "CMP([$1],X)" , CMP_ZeroPageIndirectX , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc4 , 2 , 3 , "CPY" [ $1], CPY_ZeroPage , {\b CPY_General} )}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc5 , 2 , 3 , "CMP" [ $1], CMP_ZeroPage , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc6 , 2 , 5 , "DEC" [ $1], DEC_ZeroPage , {\b DEC_General} )}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc8 , 1 , 2 , "INY" , INY , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc9 , 2 , 2 , "CMP#" [#1], CMP_Inmediate , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xca , 1 , 2 , "DEX" , DEX , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xcc , 3 , 4 , "CPY" [ $2], CPY_Absolute , {\b CPY_General} )}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xcd , 3 , 4 , "CMP" [ $2], CMP_Absolute , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xce , 3 , 6 , "DEC" [ $2], DEC_Absolute , {\b DEC_General} )}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xd0 , 2 , 2 , "BNE" [&1], BNE , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xd1 , 2 , 5 , "  {\i CMP}[$1], Y" , CMP_ZeroPageIndirectY , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xd5 , 2 , 4 , "  {\i CMP}[ $1], X" , CMP_ZeroPageX , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xd6 , 2 , 6 , "  {\i DEC}[ $1], X" , DEC_ZeroPageX , {\b DEC_General} )}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xd8 , 1 , 2 , "CLD" , CLD , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xd9 , 3 , 4 , "  {\i CMP}[ $2], Y" , CMP_AbsoluteY , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xdd , 3 , 4 , "  {\i CMP}[ $2], X" , CMP_AbsoluteX , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xde , 3 , 7 , "  {\i DEC}[ $2], X" , DEC_AbsoluteX , {\b DEC_General} )}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe0 , 2 , 2 , "CPX#" [#1], CPX_Inmediate , {\b CPX_General} )}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe1 , 2 , 6 , "SBC([$1],X)" , SBC_ZeroPageIndirectX , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe4 , 2 , 3 , "CPX" [ $1], CPX_ZeroPage , {\b CPX_General} )}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe5 , 2 , 3 , "SBC" [ $1], SBC_ZeroPage , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe6 , 2 , 5 , "INC" [ $1], INC_ZeroPage , {\b INC_General} )}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe8 , 1 , 2 , "INX" , INX , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe9 , 2 , 2 , "SBC#" [#1], SBC_Inmediate , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xea , 1 , 2 , "NOP" , NOP , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xec , 3 , 4 , "CPX" [ $2], CPX_Absolute , {\b CPX_General} )}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xed , 3 , 4 , "SBC" [ $2], SBC_Absolute , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xee , 3 , 6 , "INC" [ $2], INC_Absolute , {\b INC_General} )}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xf0 , 2 , 2 , "BEQ" [&1], BEQ , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xf1 , 2 , 5 , "  {\i SBC}[$1], Y" , SBC_ZeroPageIndirectY , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xf5 , 2 , 4 , "  {\i SBC}[ $1], X" , SBC_ZeroPageX , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xf6 , 2 , 6 , "  {\i INC}[ $1], X" , INC_ZeroPageX , {\b INC_General} )}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xf8 , 1 , 2 , "SED" , SED , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xf9 , 3 , 4 , "  {\i SBC}[ $2], Y" , SBC_AbsoluteY , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xfd , 3 , 4 , "  {\i SBC}[ $2], X" , SBC_AbsoluteX , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xfe , 3 , 7 , "  {\i INC}[ $2], X" , INC_AbsoluteX , {\b INC_General} )}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul Namespace Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul}
{\xe \v MCHEmul}
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Assembler}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Address}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Chip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Command}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CommandBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CommunicationMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CommunicationSystem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Computer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPU}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPUArchitecture}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPUInterrupt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GetMemoryDataMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GetRegisterStatusMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GraphicalChip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InputOSSystem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Instruction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IODevice}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IOPeripheral}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IOPeripheralBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IPAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Memory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MemoryView}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MessageBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NoChip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PeerCommunicationChannel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PhisicalStorage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PhisicalStorageSubset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ProgramCounter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Register}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Screen}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ScreenMemory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Stack}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StandardCommandBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StandardMessageBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StatusRegister}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UByte}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UBytes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UInt}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Chips} = std::map< int, {\b Chip} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b CPUInterrups} = std::map< int, {\b CPUInterrupt} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Attributes} = std::map< std::string, std::string >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Instructions} = std::map< unsigned int, {\b Instruction} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b IODevices} = std::map< int, {\b IODevice} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b IOPeripherals} = std::map< int, {\b IOPeripheral} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b PhisicalStorages} = std::map< int, {\b PhisicalStorage} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b PhisicalStorageSubsets} = std::map< int, {\b PhisicalStorageSubset} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b PhisicalStorageSubsetsList} = std::vector< {\b PhisicalStorageSubset} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MemoryViews} = std::map< int, {\b MemoryView} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Registers} = std::vector< {\b Register} >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Attributes} &attrs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b ltrim} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b rtrim} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b trim} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b upper} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b lower} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b noSpaces} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b onlyAlphanumeric} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b noneOf} (const std::string &s, const std::string &chrs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b removeAllFrom} (const std::string &s, std::vector< std::string > &strs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b getElementsFrom} (const std::string &txt, unsigned char ch, size_t nE=std::numeric_limits< size_t >::max())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b validLabel} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b validBytesOctal} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b validBytesHexadecimal} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b validBytesDecimal} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b validBytes} (const std::string &s)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Attributes\:MCHEmul}
{\xe \v MCHEmul\:Attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Attributes} = typedef std::map <std::string, std::string>}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attributes ar used in many places. \par
}{
Definition at line {\b 27} of file {\b global.hpp}.}\par
}
{\xe \v Chips\:MCHEmul}
{\xe \v MCHEmul\:Chips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Chips} = typedef std::map <int, {\b Chip}*>}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Chip.hpp}.}\par
}
{\xe \v CPUInterrups\:MCHEmul}
{\xe \v MCHEmul\:CPUInterrups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::CPUInterrups} = typedef std::map <int, {\b CPUInterrupt}*>}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A map of interrupts. \par
}{
Definition at line {\b 72} of file {\b CPUInterrupt.hpp}.}\par
}
{\xe \v Instructions\:MCHEmul}
{\xe \v MCHEmul\:Instructions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Instructions} = typedef std::map <unsigned int, {\b Instruction}*>}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 177} of file {\b Instruction.hpp}.}\par
}
{\xe \v IODevices\:MCHEmul}
{\xe \v MCHEmul\:IODevices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::IODevices} = typedef std::map <int, {\b IODevice}*>}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the management of a map of devices. \par
}{
Definition at line {\b 106} of file {\b IO.hpp}.}\par
}
{\xe \v IOPeripherals\:MCHEmul}
{\xe \v MCHEmul\:IOPeripherals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::IOPeripherals} = typedef std::map <int, {\b IOPeripheral}*>}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the management of a set of peripherals. \par
}{
Definition at line {\b 77} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v MemoryViews\:MCHEmul}
{\xe \v MCHEmul\:MemoryViews}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::MemoryViews} = typedef std::map <int, {\b MemoryView}*>}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the way a map of elements is managed. \par
}{
Definition at line {\b 284} of file {\b Memory.hpp}.}\par
}
{\xe \v PhisicalStorages\:MCHEmul}
{\xe \v MCHEmul\:PhisicalStorages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::PhisicalStorages} = typedef std::map <int, {\b PhisicalStorage}*>}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the way a map of elements is managed. \par
}{
Definition at line {\b 96} of file {\b Memory.hpp}.}\par
}
{\xe \v PhisicalStorageSubsets\:MCHEmul}
{\xe \v MCHEmul\:PhisicalStorageSubsets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::PhisicalStorageSubsets} = typedef std::map <int, {\b PhisicalStorageSubset}*>}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the way a map of elements is managed. \par
}{
Definition at line {\b 217} of file {\b Memory.hpp}.}\par
}
{\xe \v PhisicalStorageSubsetsList\:MCHEmul}
{\xe \v MCHEmul\:PhisicalStorageSubsetsList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::PhisicalStorageSubsetsList} = typedef std::vector <{\b PhisicalStorageSubset}*>}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 218} of file {\b Memory.hpp}.}\par
}
{\xe \v Registers\:MCHEmul}
{\xe \v MCHEmul\:Registers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Registers} = typedef std::vector <{\b Register}>}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b Register.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v getElementsFrom\:MCHEmul}
{\xe \v MCHEmul\:getElementsFrom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > MCHEmul::getElementsFrom (const std::string &  {\i txt}, unsigned char  {\i ch}, size_t  {\i nE} = {\f2 std::numeric_limits<\~ size_t\~ >::max()})}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lower\:MCHEmul}
{\xe \v MCHEmul\:lower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::lower (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ltrim\:MCHEmul}
{\xe \v MCHEmul\:ltrim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::ltrim (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
General functions to manage strings \par
}}
{\xe \v noneOf\:MCHEmul}
{\xe \v MCHEmul\:noneOf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::noneOf (const std::string &  {\i s}, const std::string &  {\i chrs})}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v noSpaces\:MCHEmul}
{\xe \v MCHEmul\:noSpaces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::noSpaces (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v onlyAlphanumeric\:MCHEmul}
{\xe \v MCHEmul\:onlyAlphanumeric}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::onlyAlphanumeric (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:MCHEmul}
{\xe \v MCHEmul\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & MCHEmul::operator<< (std::ostream &  {\i o}, const {\b Attributes} &  {\i attrs})}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The list of attributes can be printed out. \par
}}
{\xe \v removeAllFrom\:MCHEmul}
{\xe \v MCHEmul\:removeAllFrom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::removeAllFrom (const std::string &  {\i s}, std::vector< std::string > &  {\i strs})}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rtrim\:MCHEmul}
{\xe \v MCHEmul\:rtrim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::rtrim (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v trim\:MCHEmul}
{\xe \v MCHEmul\:trim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::trim (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_a034cc9e64b4baebddc5a25929dca4998_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v upper\:MCHEmul}
{\xe \v MCHEmul\:upper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::upper (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_a2b043f08c484f8d1f84de570ce94b142_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v validBytes\:MCHEmul}
{\xe \v MCHEmul\:validBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::validBytes (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v validBytesDecimal\:MCHEmul}
{\xe \v MCHEmul\:validBytesDecimal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::validBytesDecimal (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v validBytesHexadecimal\:MCHEmul}
{\xe \v MCHEmul\:validBytesHexadecimal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::validBytesHexadecimal (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v validBytesOctal\:MCHEmul}
{\xe \v MCHEmul\:validBytesOctal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::validBytesOctal (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v validLabel\:MCHEmul}
{\xe \v MCHEmul\:validLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::validLabel (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
General functions to determine whether a string is or not valid from a spcific perspective. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_a2a2a1493f37f186d6ce1cc43eaff9c35_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler Namespace Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler}
{\bkmkstart AAAAAAACNH}
{\bkmkend AAAAAAACNH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ByteCode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ByteCodeLine}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BytesCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BytesInMemoryElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CommentCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Compiler}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Error}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GrammaticalElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IncludeCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InstructionCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InstructionElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LabelCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LabelElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Macro}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MacroCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Parser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Semantic}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StartingPointCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StartingPointElement}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Errors} = std::vector< {\b Error} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Macros} = std::map< std::string, {\b Macro} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b StartingPointElements} = std::vector< {\b StartingPointElement} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b CommandParsers} = std::vector< {\b CommandParser} * >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b ErrorType} \{ {\b _NOERROR} = 0
, {\b _MACROBADDEFINED}
, {\b _MACRONOTDEFINED}
, {\b _LABELNOTVALID}
, {\b _LABELNOTDEFINED}
, {\b _BYTESNOTVALID}
, {\b _INSTRUCTIONNOTVALID}
, {\b _INSTRUCTIONNOTDEFINED}
, {\b _STARTINGPOINTNOTVALID}
, {\b _GRAMARELEMENTNOTVALID}
, {\b _STARTINGPOINTNOTDEFINED}
, {\b _DUPLICATEMACRO}
, {\b _SEMANTICERROR}
, {\b _FILEEMPTY}
, {\b _PARSERNOTFOUND}
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v CommandParsers\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:CommandParsers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Assembler::CommandParsers} = typedef std::vector <{\b CommandParser}*>}}
\par
{\bkmkstart AAAAAAACNI}
{\bkmkend AAAAAAACNI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To facilitate the use of a list of commands. \par
}{
Definition at line {\b 68} of file {\b Parser.hpp}.}\par
}
{\xe \v Errors\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:Errors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Assembler::Errors} = typedef std::vector <{\b Error}>}}
\par
{\bkmkstart AAAAAAACNJ}
{\bkmkend AAAAAAACNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b Error.hpp}.}\par
}
{\xe \v Macros\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:Macros}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Assembler::Macros} = typedef std::map <std::string, {\b Macro}>}}
\par
{\bkmkstart AAAAAAACNK}
{\bkmkend AAAAAAACNK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Grammar.hpp}.}\par
}
{\xe \v StartingPointElements\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:StartingPointElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Assembler::StartingPointElements} = typedef std::vector <{\b StartingPointElement}*>}}
\par
{\bkmkstart AAAAAAACNL}
{\bkmkend AAAAAAACNL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Notice that it is a set of pointers. \par
}{
Definition at line {\b 253} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v ErrorType\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:ErrorType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b MCHEmul::Assembler::ErrorType}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAACNM}
{\bkmkend AAAAAAACNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The type of errors admitted by the system. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _NOERROR\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_NOERROR}
{\qr _NOERROR{\bkmkstart AAAAAAACNN}
{\bkmkend AAAAAAACNN}
\cell }{\cell }{\row }
{\xe \v _MACROBADDEFINED\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_MACROBADDEFINED}
{\qr _MACROBADDEFINED{\bkmkstart AAAAAAACNO}
{\bkmkend AAAAAAACNO}
\cell }{\cell }{\row }
{\xe \v _MACRONOTDEFINED\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_MACRONOTDEFINED}
{\qr _MACRONOTDEFINED{\bkmkstart AAAAAAACNP}
{\bkmkend AAAAAAACNP}
\cell }{\cell }{\row }
{\xe \v _LABELNOTVALID\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_LABELNOTVALID}
{\qr _LABELNOTVALID{\bkmkstart AAAAAAACNQ}
{\bkmkend AAAAAAACNQ}
\cell }{\cell }{\row }
{\xe \v _LABELNOTDEFINED\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_LABELNOTDEFINED}
{\qr _LABELNOTDEFINED{\bkmkstart AAAAAAACNR}
{\bkmkend AAAAAAACNR}
\cell }{\cell }{\row }
{\xe \v _BYTESNOTVALID\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_BYTESNOTVALID}
{\qr _BYTESNOTVALID{\bkmkstart AAAAAAACNS}
{\bkmkend AAAAAAACNS}
\cell }{\cell }{\row }
{\xe \v _INSTRUCTIONNOTVALID\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_INSTRUCTIONNOTVALID}
{\qr _INSTRUCTIONNOTVALID{\bkmkstart AAAAAAACNT}
{\bkmkend AAAAAAACNT}
\cell }{\cell }{\row }
{\xe \v _INSTRUCTIONNOTDEFINED\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_INSTRUCTIONNOTDEFINED}
{\qr _INSTRUCTIONNOTDEFINED{\bkmkstart AAAAAAACNU}
{\bkmkend AAAAAAACNU}
\cell }{\cell }{\row }
{\xe \v _STARTINGPOINTNOTVALID\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_STARTINGPOINTNOTVALID}
{\qr _STARTINGPOINTNOTVALID{\bkmkstart AAAAAAACNV}
{\bkmkend AAAAAAACNV}
\cell }{\cell }{\row }
{\xe \v _GRAMARELEMENTNOTVALID\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_GRAMARELEMENTNOTVALID}
{\qr _GRAMARELEMENTNOTVALID{\bkmkstart AAAAAAACNW}
{\bkmkend AAAAAAACNW}
\cell }{\cell }{\row }
{\xe \v _STARTINGPOINTNOTDEFINED\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_STARTINGPOINTNOTDEFINED}
{\qr _STARTINGPOINTNOTDEFINED{\bkmkstart AAAAAAACNX}
{\bkmkend AAAAAAACNX}
\cell }{\cell }{\row }
{\xe \v _DUPLICATEMACRO\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_DUPLICATEMACRO}
{\qr _DUPLICATEMACRO{\bkmkstart AAAAAAACNY}
{\bkmkend AAAAAAACNY}
\cell }{\cell }{\row }
{\xe \v _SEMANTICERROR\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_SEMANTICERROR}
{\qr _SEMANTICERROR{\bkmkstart AAAAAAACNZ}
{\bkmkend AAAAAAACNZ}
\cell }{\cell }{\row }
{\xe \v _FILEEMPTY\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_FILEEMPTY}
{\qr _FILEEMPTY{\bkmkstart AAAAAAACOA}
{\bkmkend AAAAAAACOA}
\cell }{\cell }{\row }
{\xe \v _PARSERNOTFOUND\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_PARSERNOTFOUND}
{\qr _PARSERNOTFOUND{\bkmkstart AAAAAAACOB}
{\bkmkend AAAAAAACOB}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 24} of file {\b Error.hpp}.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::ADC_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::ADC_General}
{\xe \v F6500::ADC_General}
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::ADC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_d_c___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::ADC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_d_c___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ADC_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ADC_General}: To aggregate common steps in every ADC instruction. \par
}{
Definition at line {\b 84} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ADC_General\:F6500::ADC_General}
{\xe \v F6500::ADC_General\:ADC_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::ADC_General::ADC_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::ADC_General}
{\xe \v F6500::ADC_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::ADC_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Address Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Address}
{\xe \v MCHEmul::Address}
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
\par
{
{\f2 #include <Address.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} (const {\b UInt} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} (const {\b MCHEmul::UBytes} &a, bool bE=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} (const std::vector< {\b UByte} > &a, bool bE=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} (const {\b Address} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} & {\b operator=} (const {\b Address} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UInt} & {\b value} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UBytes} & {\b values} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< {\b UByte} > & {\b bytes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b distanceWith} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b next} (size_t n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b previous} (size_t n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b operator+} (size_t n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} & {\b operator+=} (size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b operator-} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b operator-} (size_t n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} & {\b operator-=} (size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} & {\b operator--} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator[]} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} ({\b UByte::OutputFormat} oF) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Address} {\b fromStr} (const std::string &str)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b operator+} (size_t n, const {\b Address} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b operator-} (size_t n, const {\b Address} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Address} &a)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing and address that can vary from 0 to a limit. An initial value and the limit is given at construction time. If no limit is given the maximum possible in the framework is taken. \par
}{
Definition at line {\b 27} of file {\b Address.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Address\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Address::Address (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b Address.hpp}.}\par
}
{\xe \v Address\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Address::Address (const {\b UInt} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set at the length of the limit. \par
}{
Definition at line {\b 35} of file {\b Address.hpp}.}\par
}
{\xe \v Address\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Address::Address (const {\b MCHEmul::UBytes} &  {\i a}, bool  {\i bE} = {\f2 true}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b Address.hpp}.}\par
}
{\xe \v Address\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Address::Address (const std::vector< {\b UByte} > &  {\i a}, bool  {\i bE} = {\f2 true}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b Address.hpp}.}\par
}
{\xe \v Address\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Address::Address (const {\b Address} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asString\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Address::asString ({\b UByte::OutputFormat}  {\i oF}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_ad430a2b6338964f32de2067547d4d39e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bytes\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< {\b UByte} > & MCHEmul::Address::bytes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_ad67872c7f0572e693a090ac876528f7a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_ad67872c7f0572e693a090ac876528f7a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v distanceWith\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:distanceWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::Address::distanceWith (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Could be negative. \par
}{
Definition at line {\b 61} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a62b90165f365b170279f28e1193cbb2f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a62b90165f365b170279f28e1193cbb2f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fromStr\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:fromStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b Address} MCHEmul::Address::fromStr (const std::string &  {\i str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create an {\b Address} from an string.\par
The string should start with $ if written in hexadecimal, with 0 if it is in octal and with no 0 number in decimal: \par
e.g $D400 (hexa), 07600 (octal), 53248 (decimal). \par
If the str is not valid, then an empty address will be given. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_ab3ed6eaaa836fc4e0c66c404d5ad9f89_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v next\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::Address::next (size_t  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When reach the limit start back in th other side. \par
}{
Definition at line {\b 65} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a0323eecc3f036752cdd155b78d38d61f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a0323eecc3f036752cdd155b78d38d61f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!=\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Address::operator!= (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b Address.hpp}.}\par
}
{\xe \v operator+\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::Address::operator+ (size_t  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a8ed281710b6e7bacc5a74892193b162a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} & MCHEmul::Address::operator+= (size_t  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b Address.hpp}.}\par
}
{\xe \v operator-\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::Address::operator- (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_ab2f5b4d71707e4c053240243b34cad7b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::Address::operator- (size_t  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a0e37cda7d3a3ed82a141e7b67f22c980_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator--\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} & MCHEmul::Address::operator-- (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b Address.hpp}.}\par
}
{\xe \v operator-=\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} & MCHEmul::Address::operator-= (size_t  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b Address.hpp}.}\par
}
{\xe \v operator<\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Address::operator< (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b Address.hpp}.}\par
}
{\xe \v operator<=\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Address::operator<= (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Address.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} & MCHEmul::Address::operator= (const {\b Address} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Address::operator== (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b Address.hpp}.}\par
}
{\xe \v operator>\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Address::operator> (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Address.hpp}.}\par
}
{\xe \v operator>=\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Address::operator>= (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b Address.hpp}.}\par
}
{\xe \v operator[]\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::Address::operator[] (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b Address.hpp}.}\par
}
{\xe \v previous\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:previous}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::Address::previous (size_t  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a83511885ae269ba97fd3c9bc04cdf6b7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a83511885ae269ba97fd3c9bc04cdf6b7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::Address::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a1202d7aa588b99ab03c788bd931b947c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt} & MCHEmul::Address::value () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b Address.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_aa55936e1140c35634e3c3a5a83fca288_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v values\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UBytes} & MCHEmul::Address::values () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a0853a0eeb8ccc3d4ea72f89ab682dce6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator+\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} operator+ (size_t  {\i n}, const {\b Address} &  {\i a}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b Address.hpp}.}\par
}
{\xe \v operator-\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} operator- (size_t  {\i n}, const {\b Address} &  {\i a}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b Address.hpp}.}\par
}
{\xe \v operator<<\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Address} &  {\i a}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Address.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::AND_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::AND_General}
{\xe \v F6500::AND_General}
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::AND_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_n_d___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::AND_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_n_d___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AND_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AND_General}: To aggregate common steps in every AND instruction. \par
}{
Definition at line {\b 106} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AND_General\:F6500::AND_General}
{\xe \v F6500::AND_General\:AND_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::AND_General::AND_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::AND_General}
{\xe \v F6500::AND_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::AND_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::ASL_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::ASL_General}
{\xe \v F6500::ASL_General}
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::ASL_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_s_l___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::ASL_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_s_l___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ASL_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ASL_General}: To aggregate common steps in every ASL instruction. \par
}{
Definition at line {\b 128} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ASL_General\:F6500::ASL_General}
{\xe \v F6500::ASL_General\:ASL_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::ASL_General::ASL_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::ASL_General}
{\xe \v F6500::ASL_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::ASL_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UInt::BinaryFormatManager Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UInt::BinaryFormatManager}
{\xe \v MCHEmul::UInt::BinaryFormatManager}
{\bkmkstart AAAAAAACMK}
{\bkmkend AAAAAAACMK}
\par
{
{\f2 #include <UInt.hpp>}}\par
Inheritance diagram for MCHEmul::UInt::BinaryFormatManager:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_binary_format_manager__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::UInt::BinaryFormatManager:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_binary_format_manager__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b add} (const {\b UInt} &u1, const {\b UInt} &u2, bool cIn) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b substract} (const {\b UInt} &u1, const {\b UInt} &u2, bool cIn) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b asUnsignedInt} (const {\b UInt} &u) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b fromUnsignedInt} (unsigned int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b fromInt} (int n)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For _BINARY format. \par
}{
Definition at line {\b 55} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add\:MCHEmul::UInt::BinaryFormatManager}
{\xe \v MCHEmul::UInt::BinaryFormatManager\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::BinaryFormatManager::add (const {\b UInt} &  {\i u1}, const {\b UInt} &  {\i u2}, bool  {\i cIn}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACML}
{\bkmkend AAAAAAACML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For _BINARY numbers no adjustment is needed at all after adding operation. \par
}{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v asUnsignedInt\:MCHEmul::UInt::BinaryFormatManager}
{\xe \v MCHEmul::UInt::BinaryFormatManager\:asUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual unsigned int MCHEmul::UInt::BinaryFormatManager::asUnsignedInt (const {\b UInt} &  {\i u}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMN}
{\bkmkend AAAAAAACMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v fromInt\:MCHEmul::UInt::BinaryFormatManager}
{\xe \v MCHEmul::UInt::BinaryFormatManager\:fromInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::BinaryFormatManager::fromInt (int  {\i n}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMP}
{\bkmkend AAAAAAACMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v fromUnsignedInt\:MCHEmul::UInt::BinaryFormatManager}
{\xe \v MCHEmul::UInt::BinaryFormatManager\:fromUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::BinaryFormatManager::fromUnsignedInt (unsigned int  {\i n}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMR}
{\bkmkend AAAAAAACMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v substract\:MCHEmul::UInt::BinaryFormatManager}
{\xe \v MCHEmul::UInt::BinaryFormatManager\:substract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::BinaryFormatManager::substract (const {\b UInt} & , const {\b UInt} & , bool ) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMT}
{\bkmkend AAAAAAACMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The same for substracting. \par
}{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UInt.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::BXX_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::BXX_General}
{\xe \v F6500::BXX_General}
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::BXX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_b_x_x___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::BXX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_b_x_x___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BXX_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b executeBranch} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b BXX_General}: To aggregate common steps in every Branch instruction. \par
}{
Definition at line {\b 146} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BXX_General\:F6500::BXX_General}
{\xe \v F6500::BXX_General\:BXX_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::BXX_General::BXX_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeBranch\:F6500::BXX_General}
{\xe \v F6500::BXX_General\:executeBranch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void F6500::BXX_General::executeBranch (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::ByteCode Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode}
{\bkmkstart AAAAAAACOC}
{\bkmkend AAAAAAACOC}
\par
{
{\f2 #include <Compiler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCode} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCode} (const {\b ByteCode} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCode} & {\b operator=} (const {\b ByteCode} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b asSetOfBytes} ({\b Address} &iA) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< {\b Address}, unsigned int > {\b listOfActions} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b loadIntoMemory} ({\b Memory} *m)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b ByteCode} {\b createFromMemory} (const {\b Address} &a, unsigned int b, {\b Memory} *m, {\b CPU} *cpu)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b ByteCodeLine} > {\b _lines}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To manage the set of bytecode lines. \par
}{
Definition at line {\b 51} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ByteCode\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:ByteCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::ByteCode::ByteCode (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACOD}
{\bkmkend AAAAAAACOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ByteCode\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:ByteCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::ByteCode::ByteCode (const {\b ByteCode} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACOE}
{\bkmkend AAAAAAACOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asSetOfBytes\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:asSetOfBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b UByte} > MCHEmul::Assembler::ByteCode::asSetOfBytes ({\b Address} &  {\i iA}) const}}
\par
{\bkmkstart AAAAAAACOF}
{\bkmkend AAAAAAACOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the initial address in the iA variable. The addresses with no info are filled with 0x00. \par
}}
{\xe \v createFromMemory\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:createFromMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b ByteCode} MCHEmul::Assembler::ByteCode::createFromMemory (const {\b Address} &  {\i a}, unsigned int  {\i b}, {\b Memory} *  {\i m}, {\b CPU} *  {\i cpu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACOG}
{\bkmkend AAAAAAACOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listOfActions\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:listOfActions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map< {\b Address}, unsigned int > MCHEmul::Assembler::ByteCode::listOfActions () const}}
\par
{\bkmkstart AAAAAAACOH}
{\bkmkend AAAAAAACOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the list of actions per address. Action == 0 are not actions! \par
}}
{\xe \v loadIntoMemory\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:loadIntoMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::ByteCode::loadIntoMemory ({\b Memory} *  {\i m})}}
\par
{\bkmkstart AAAAAAACOI}
{\bkmkend AAAAAAACOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To load the info into the memory. \par
}}
{\xe \v operator=\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ByteCode} & MCHEmul::Assembler::ByteCode::operator= (const {\b ByteCode} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACOJ}
{\bkmkend AAAAAAACOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _lines\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:_lines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b ByteCodeLine}> MCHEmul::Assembler::ByteCode::_lines}}
\par
{\bkmkstart AAAAAAACOK}
{\bkmkend AAAAAAACOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Compiler.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::ByteCodeLine Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine}
{\bkmkstart AAAAAAACOL}
{\bkmkend AAAAAAACOL}
\par
{
{\f2 #include <Compiler.hpp>}}\par
Collaboration diagram for MCHEmul::Assembler::ByteCodeLine:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_byte_code_line__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCodeLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCodeLine} (const {\b Address} &a, const std::vector< {\b UByte} > &b, const std::string &n, const {\b Instruction} *i, unsigned int act)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCodeLine} (const {\b ByteCodeLine} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCodeLine} & {\b operator=} (const {\b ByteCodeLine} &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b _address}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b _bytes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _label}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Instruction} * {\b _instruction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _actionOn}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b ByteCodeLine} &c)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The compiler reads the semantic and transform it into lines of bytes. \par
}{
Definition at line {\b 26} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ByteCodeLine\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:ByteCodeLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::ByteCodeLine::ByteCodeLine (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOM}
{\bkmkend AAAAAAACOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b Compiler.hpp}.}\par
}
{\xe \v ByteCodeLine\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:ByteCodeLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::ByteCodeLine::ByteCodeLine (const {\b Address} &  {\i a}, const std::vector< {\b UByte} > &  {\i b}, const std::string &  {\i n}, const {\b Instruction} *  {\i i}, unsigned int  {\i act}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACON}
{\bkmkend AAAAAAACON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Compiler.hpp}.}\par
}
{\xe \v ByteCodeLine\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:ByteCodeLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::ByteCodeLine::ByteCodeLine (const {\b ByteCodeLine} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACOO}
{\bkmkend AAAAAAACOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ByteCodeLine} & MCHEmul::Assembler::ByteCodeLine::operator= (const {\b ByteCodeLine} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACOP}
{\bkmkend AAAAAAACOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b ByteCodeLine} &  {\i c}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACOQ}
{\bkmkend AAAAAAACOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _actionOn\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:_actionOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Assembler::ByteCodeLine::_actionOn}}
\par
{\bkmkstart AAAAAAACOR}
{\bkmkend AAAAAAACOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b Compiler.hpp}.}\par
}
{\xe \v _address\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:_address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::Assembler::ByteCodeLine::_address}}
\par
{\bkmkstart AAAAAAACOS}
{\bkmkend AAAAAAACOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b Compiler.hpp}.}\par
}
{\xe \v _bytes\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:_bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b UByte}> MCHEmul::Assembler::ByteCodeLine::_bytes}}
\par
{\bkmkstart AAAAAAACOT}
{\bkmkend AAAAAAACOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b Compiler.hpp}.}\par
}
{\xe \v _instruction\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:_instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Instruction}* MCHEmul::Assembler::ByteCodeLine::_instruction}}
\par
{\bkmkstart AAAAAAACOU}
{\bkmkend AAAAAAACOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Compiler.hpp}.}\par
}
{\xe \v _label\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:_label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Assembler::ByteCodeLine::_label}}
\par
{\bkmkstart AAAAAAACOV}
{\bkmkend AAAAAAACOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Compiler.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::BytesCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::BytesCommandParser}
{\xe \v MCHEmul::Assembler::BytesCommandParser}
{\bkmkstart AAAAAAACOW}
{\bkmkend AAAAAAACOW}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::BytesCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_bytes_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::BytesCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_bytes_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BytesCommandParser} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *s) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser a set of bytes. \par
}{
Definition at line {\b 182} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BytesCommandParser\:MCHEmul::Assembler::BytesCommandParser}
{\xe \v MCHEmul::Assembler::BytesCommandParser\:BytesCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::BytesCommandParser::BytesCommandParser (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOX}
{\bkmkend AAAAAAACOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 185} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::BytesCommandParser}
{\xe \v MCHEmul::Assembler::BytesCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::BytesCommandParser::canParse (const std::string &  {\i l}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACOY}
{\bkmkend AAAAAAACOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 193} of file {\b Parser.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_bytes_command_parser_af5bb0e91f810b38eba0697631e3f16c2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::Assembler::BytesCommandParser}
{\xe \v MCHEmul::Assembler::BytesCommandParser\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::BytesCommandParser::initialize (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPA}
{\bkmkend AAAAAAACPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maybe one of them could need it. \par
}{
Reimplemented from {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 190} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::BytesCommandParser}
{\xe \v MCHEmul::Assembler::BytesCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::BytesCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPC}
{\bkmkend AAAAAAACPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::BytesInMemoryElement Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::BytesInMemoryElement}
{\xe \v MCHEmul::Assembler::BytesInMemoryElement}
{\bkmkstart AAAAAAACPE}
{\bkmkend AAAAAAACPE}
\par
{
{\f2 #include <Grammar.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::BytesInMemoryElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_bytes_in_memory_element__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::BytesInMemoryElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_bytes_in_memory_element__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BytesInMemoryElement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BytesInMemoryElement} (const {\b BytesInMemoryElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BytesInMemoryElement} & {\b operator=} (const {\b BytesInMemoryElement} &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b _elements}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
explanation at the beggining of the file. \par
}}}{
Definition at line {\b 179} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BytesInMemoryElement\:MCHEmul::Assembler::BytesInMemoryElement}
{\xe \v MCHEmul::Assembler::BytesInMemoryElement\:BytesInMemoryElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::BytesInMemoryElement::BytesInMemoryElement (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPF}
{\bkmkend AAAAAAACPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 181} of file {\b Grammar.hpp}.}\par
}
{\xe \v BytesInMemoryElement\:MCHEmul::Assembler::BytesInMemoryElement}
{\xe \v MCHEmul::Assembler::BytesInMemoryElement\:BytesInMemoryElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::BytesInMemoryElement::BytesInMemoryElement (const {\b BytesInMemoryElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACPG}
{\bkmkend AAAAAAACPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:MCHEmul::Assembler::BytesInMemoryElement}
{\xe \v MCHEmul::Assembler::BytesInMemoryElement\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BytesInMemoryElement} & MCHEmul::Assembler::BytesInMemoryElement::operator= (const {\b BytesInMemoryElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACPH}
{\bkmkend AAAAAAACPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _elements\:MCHEmul::Assembler::BytesInMemoryElement}
{\xe \v MCHEmul::Assembler::BytesInMemoryElement\:_elements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<std::string> MCHEmul::Assembler::BytesInMemoryElement::_elements}}
\par
{\bkmkstart AAAAAAACPI}
{\bkmkend AAAAAAACPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 189} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Emuls::C64Emulator Class Reference\par \pard\plain 
{\tc\tcl2 \v Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator}
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
\par
{
{\f2 #include <C64Emulator.hpp>}}\par
Inheritance diagram for Emuls::C64Emulator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_c64_emulator__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for Emuls::C64Emulator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_c64_emulator__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C64Emulator} (const std::vector< std::string > &argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b NTSCSystem} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _PARAMNTSC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const std::string {\b _NTSC}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Computer} * {\b createComputer} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::IOPeripheralBuilder} * {\b createPeripheralBuilder} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b additionalRunCycle} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 24} of file {\b C64Emulator.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v C64Emulator\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:C64Emulator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Emuls::C64Emulator::C64Emulator (const std::vector< std::string > &  {\i argv})}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor: {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argc} \cell }{: N\'FAmero de par\'E1metros. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argv} \cell }{: The parameters.\par
The basic parameters for any {\b C64} emulator are (apart of the ones defined by the parent: \par
/n : To indicate if the visualization system is NTSC. PAL by default. \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v additionalRunCycle\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:additionalRunCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Emuls::C64Emulator::additionalRunCycle (){\f2 [inline]}, {\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Just to actualize the global time of the {\b C64}. \par
}{
Reimplemented from {\b Emuls::Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 56} of file {\b C64Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_c64_emulator_a3ecd6ddfe8870352c3be0c9f4d6a95a3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v createComputer\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:createComputer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Computer} * Emuls::C64Emulator::createComputer () const{\f2 [inline]}, {\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create the right version of the computer, attending the parameters received by the constructor. \par
}{
Implements {\b Emuls::Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 48} of file {\b C64Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_c64_emulator_a117cc6906d6cff90836c233680b37030_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v createPeripheralBuilder\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:createPeripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::IOPeripheralBuilder} * Emuls::C64Emulator::createPeripheralBuilder () const{\f2 [inline]}, {\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create the right version of the Peripheral Builder. \par
}{
Implements {\b Emuls::Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 52} of file {\b C64Emulator.hpp}.}\par
}
{\xe \v initialize\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Emuls::C64Emulator::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To add the peripherals linked to the computer, according to the parameters. \par
}{
Reimplemented from {\b Emuls::Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v NTSCSystem\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:NTSCSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::C64Emulator::NTSCSystem () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know whether the visualizacion system is or not NTSC. \par
}{
Definition at line {\b 41} of file {\b C64Emulator.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_c64_emulator_ae84cf6a01e8c2d43a984fd9503d5c49a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _NTSC\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:_NTSC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string Emuls::C64Emulator::_NTSC{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b C64Emulator.hpp}.}\par
}
{\xe \v _PARAMNTSC\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:_PARAMNTSC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char Emuls::C64Emulator::_PARAMNTSC{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The possible additional parameters of the {\b C64} {\b Emulator}. \par
}{
Definition at line {\b 28} of file {\b C64Emulator.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/EMULATORS/{\b C64Emulator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::C6500 Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::C6500}
{\xe \v F6500::C6500}
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
\par
{
{\f2 #include <C6500.hpp>}}\par
Inheritance diagram for F6500::C6500:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6500__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::C6500:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6500__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b AddressMode} \{ {\b _IMPLICIT}
, {\b _INMEDIATE}
, {\b _ABSOLUTE}
, {\b _ZEROPAGE}
, {\b _ABSOLUTE_X}
, {\b _ABSOLUTE_Y}
, {\b _RELATIVE}
, {\b _INDIRECT}
, {\b _ZEROPAGE_X}
, {\b _ZEROPAGE_Y}
, {\b _INDIRECT_X}
, {\b _INDIRECT_Y}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C6500} (const {\b MCHEmul::CPUArchitecture} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Address} {\b IRQVectorAddress} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Address} {\b NMIVectorAddress} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Address} {\b ResetVectorAddress} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Register} & {\b accumulator} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Register} & {\b xRegister} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Register} & {\b yRegister} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b _ACCUMULATOR} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b _XREGISTER} = 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b _YREGISTER} = 2\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Chip CPU type 6500 \par
}{
Definition at line {\b 22} of file {\b C6500.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v AddressMode\:F6500::C6500}
{\xe \v F6500::C6500\:AddressMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b F6500::C6500::AddressMode}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The different possibilities a 6500 instruction set has to understand its parameters. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _IMPLICIT\:F6500::C6500}
{\xe \v F6500::C6500\:_IMPLICIT}
{\qr _IMPLICIT{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
\cell }{\cell }{\row }
{\xe \v _INMEDIATE\:F6500::C6500}
{\xe \v F6500::C6500\:_INMEDIATE}
{\qr _INMEDIATE{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
\cell }{\cell }{\row }
{\xe \v _ABSOLUTE\:F6500::C6500}
{\xe \v F6500::C6500\:_ABSOLUTE}
{\qr _ABSOLUTE{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
\cell }{\cell }{\row }
{\xe \v _ZEROPAGE\:F6500::C6500}
{\xe \v F6500::C6500\:_ZEROPAGE}
{\qr _ZEROPAGE{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
\cell }{\cell }{\row }
{\xe \v _ABSOLUTE_X\:F6500::C6500}
{\xe \v F6500::C6500\:_ABSOLUTE_X}
{\qr _ABSOLUTE_X{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
\cell }{\cell }{\row }
{\xe \v _ABSOLUTE_Y\:F6500::C6500}
{\xe \v F6500::C6500\:_ABSOLUTE_Y}
{\qr _ABSOLUTE_Y{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
\cell }{\cell }{\row }
{\xe \v _RELATIVE\:F6500::C6500}
{\xe \v F6500::C6500\:_RELATIVE}
{\qr _RELATIVE{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
\cell }{\cell }{\row }
{\xe \v _INDIRECT\:F6500::C6500}
{\xe \v F6500::C6500\:_INDIRECT}
{\qr _INDIRECT{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
\cell }{\cell }{\row }
{\xe \v _ZEROPAGE_X\:F6500::C6500}
{\xe \v F6500::C6500\:_ZEROPAGE_X}
{\qr _ZEROPAGE_X{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
\cell }{\cell }{\row }
{\xe \v _ZEROPAGE_Y\:F6500::C6500}
{\xe \v F6500::C6500\:_ZEROPAGE_Y}
{\qr _ZEROPAGE_Y{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
\cell }{\cell }{\row }
{\xe \v _INDIRECT_X\:F6500::C6500}
{\xe \v F6500::C6500\:_INDIRECT_X}
{\qr _INDIRECT_X{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
\cell }{\cell }{\row }
{\xe \v _INDIRECT_Y\:F6500::C6500}
{\xe \v F6500::C6500\:_INDIRECT_Y}
{\qr _INDIRECT_Y{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 26} of file {\b C6500.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v C6500\:F6500::C6500}
{\xe \v F6500::C6500\:C6500}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::C6500::C6500 (const {\b MCHEmul::CPUArchitecture} &  {\i a})}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v accumulator\:F6500::C6500}
{\xe \v F6500::C6500\:accumulator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Register} & F6500::C6500::accumulator (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b C6500.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6500_a6346170632f1750f1cffdef79ccb09bc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:F6500::C6500}
{\xe \v F6500::C6500\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool F6500::C6500::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the CPU. It could be overloaded later. \par
By default it just initialize registers and program counter to 0. \par
Returns true if everything was ok and false in any other case. \par
}{
Reimplemented from {\b MCHEmul::CPU} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v IRQVectorAddress\:F6500::C6500}
{\xe \v F6500::C6500\:IRQVectorAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Address} F6500::C6500::IRQVectorAddress () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b F6500::C6510} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v NMIVectorAddress\:F6500::C6500}
{\xe \v F6500::C6500\:NMIVectorAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Address} F6500::C6500::NMIVectorAddress () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b F6500::C6510} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ResetVectorAddress\:F6500::C6500}
{\xe \v F6500::C6500\:ResetVectorAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Address} F6500::C6500::ResetVectorAddress () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b F6500::C6510} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v xRegister\:F6500::C6500}
{\xe \v F6500::C6500\:xRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Register} & F6500::C6500::xRegister (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b C6500.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6500_ac9facf1bb7a0026087553330b21e3d05_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v yRegister\:F6500::C6500}
{\xe \v F6500::C6500\:yRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Register} & F6500::C6500::yRegister (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b C6500.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6500_ab6a03805d14af306c92b1d8c066d111a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ACCUMULATOR\:F6500::C6500}
{\xe \v F6500::C6500\:_ACCUMULATOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t F6500::C6500::_ACCUMULATOR = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To identify the number of the registers. \par
}{
Definition at line {\b 58} of file {\b C6500.hpp}.}\par
}
{\xe \v _XREGISTER\:F6500::C6500}
{\xe \v F6500::C6500\:_XREGISTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t F6500::C6500::_XREGISTER = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b C6500.hpp}.}\par
}
{\xe \v _YREGISTER\:F6500::C6500}
{\xe \v F6500::C6500\:_YREGISTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t F6500::C6500::_YREGISTER = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b C6500.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b C6500.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::C6510 Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::C6510}
{\xe \v F6500::C6510}
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
\par
{
{\f2 #include <C6510.hpp>}}\par
Inheritance diagram for F6500::C6510:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6510__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::C6510:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6510__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C6510} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Address} {\b IRQVectorAddress} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Address} {\b NMIVectorAddress} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Address} {\b ResetVectorAddress} () const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Chip CPU 6510 \par
}{
Definition at line {\b 22} of file {\b C6510.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v C6510\:F6500::C6510}
{\xe \v F6500::C6510\:C6510}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::C6510::C6510 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b C6510.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v IRQVectorAddress\:F6500::C6510}
{\xe \v F6500::C6510\:IRQVectorAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Address} F6500::C6510::IRQVectorAddress () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Little - endian\par
}{
Implements {\b F6500::C6500} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 29} of file {\b C6510.hpp}.}\par
}
{\xe \v NMIVectorAddress\:F6500::C6510}
{\xe \v F6500::C6510\:NMIVectorAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Address} F6500::C6510::NMIVectorAddress () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Little - endian\par
}{
Implements {\b F6500::C6500} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 31} of file {\b C6510.hpp}.}\par
}
{\xe \v ResetVectorAddress\:F6500::C6510}
{\xe \v F6500::C6510\:ResetVectorAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Address} F6500::C6510::ResetVectorAddress () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Little - endian\par
}{
Implements {\b F6500::C6500} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 33} of file {\b C6510.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b C6510.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Chip Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Chip}
{\xe \v MCHEmul::Chip}
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
\par
{
{\f2 #include <Chip.hpp>}}\par
Inheritance diagram for MCHEmul::Chip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_chip__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Chip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_chip__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chip} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chip} (int {\b id}, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chip} (const {\b Chip} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chip} & {\b operator=} (const {\b Chip} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Chip} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMemoryRef} ({\b Memory} *m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Memory} * {\b memoryRef} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b memoryRef} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} & {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b attribute} (const std::string &aN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ({\b CPU} *)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetErrors} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b _id} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b _memory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} {\b _attributes} = \{ \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Chip} &c)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A chip is a specialized element within the computer (different that the {\b CPU}). \par
All chips are set with the full memory accesibl when the computer is initialized, unless something specific is said initializing the chip itself!. \par
}{
Definition at line {\b 27} of file {\b Chip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Chip\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:Chip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Chip::Chip (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Chip\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:Chip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Chip::Chip (int  {\i id}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Chip.hpp}.}\par
}
{\xe \v Chip\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:Chip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Chip::Chip (const {\b Chip} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Chip\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:~Chip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::Chip::~Chip (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The chip is not owner of the memory. \par
}{
Definition at line {\b 42} of file {\b Chip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attribute\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::Chip::attribute (const std::string &  {\i aN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b Chip.hpp}.}\par
}
{\xe \v attributes\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} & MCHEmul::Chip::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b Chip.hpp}.}\par
}
{\xe \v id\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::Chip::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b Chip.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Chip::initialize (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Implemented in {\b C64::CIA1} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFW \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::CIA2} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::SpecialFunctionsChip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::VICII} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::NoChip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABHT \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::GraphicalChip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v lastError\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Chip::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the last error happend (after initialize or simulate methods). \par
}{
Definition at line {\b 74} of file {\b Chip.hpp}.}\par
}
{\xe \v memoryRef\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:memoryRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory} * MCHEmul::Chip::memoryRef (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b Chip.hpp}.}\par
}
{\xe \v memoryRef\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:memoryRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Memory} * MCHEmul::Chip::memoryRef () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b Chip.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Chip} & MCHEmul::Chip::operator= (const {\b Chip} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resetErrors\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:resetErrors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Chip::resetErrors (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Chip.hpp}.}\par
}
{\xe \v setMemoryRef\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:setMemoryRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Chip::setMemoryRef ({\b Memory} *  {\i m}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The memory the chip can access to. \par
}{
Definition at line {\b 49} of file {\b Chip.hpp}.}\par
}
{\xe \v simulate\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Chip::simulate ({\b CPU} * ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate th behaviour of the chip. It has to be defined per chip. \par
Returns true if everything was ok, and false in any other circunstance. \par
 The last error could be recovered from the variable _lastError in that case. \par
The clock cyclees is added. \par
}{
Implemented in {\b MCHEmul::NoChip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABIA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::CIA1} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFY \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::CIA2} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::SpecialFunctionsChip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALD \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b C64::VICII} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Chip} &  {\i c}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _attributes\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} MCHEmul::Chip::_attributes = \{ \}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b Chip.hpp}.}\par
}
{\xe \v _id\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int MCHEmul::Chip::_id = -1{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b Chip.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Chip::_lastError{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b Chip.hpp}.}\par
}
{\xe \v _memory\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:_memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory}* MCHEmul::Chip::_memory{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b Chip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Chip.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::CIA1 Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::CIA1}
{\xe \v C64::CIA1}
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
\par
{
{\f2 #include <CIA1.hpp>}}\par
Inheritance diagram for C64::CIA1:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a1__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::CIA1:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a1__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIA1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ({\b MCHEmul::CPU} *cpu) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b InputOSSystem}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _ID} = 2\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CIA1} is mainly to communicate {\b C64} with external devices. Additionaly it is also used to read the keyboard and the joysticks. \par
}{
Definition at line {\b 28} of file {\b CIA1.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CIA1\:C64::CIA1}
{\xe \v C64::CIA1\:CIA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::CIA1::CIA1 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b CIA1.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::CIA1}
{\xe \v C64::CIA1\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool C64::CIA1::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v simulate\:C64::CIA1}
{\xe \v C64::CIA1\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool C64::CIA1::simulate ({\b MCHEmul::CPU} * ){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate th behaviour of the chip. It has to be defined per chip. \par
Returns true if everything was ok, and false in any other circunstance. \par
 The last error could be recovered from the variable _lastError in that case. \par
The clock cyclees is added. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::CIA1}
{\xe \v C64::CIA1\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int C64::CIA1::_ID = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b CIA1.hpp}.}\par
}
{\xe \v InputOSSystem\:C64::CIA1}
{\xe \v C64::CIA1\:InputOSSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend C64::CIA1::InputOSSystem}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b CIA1.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b CIA1.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::CIA1Registers Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::CIA1Registers}
{\xe \v C64::CIA1Registers}
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
\par
{
{\f2 #include <CIA1Registers.hpp>}}\par
Inheritance diagram for C64::CIA1Registers:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a1_registers__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::CIA1Registers:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a1_registers__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIA1Registers} (int {\b id}, {\b MCHEmul::PhisicalStorage} *pS)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b CIA1}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In the {\b CIA1} {\b Memory}, there are a couple of records that behave different when they are read that when they are written. \par
}{
Definition at line {\b 27} of file {\b CIA1Registers.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CIA1Registers\:C64::CIA1Registers}
{\xe \v C64::CIA1Registers\:CIA1Registers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::CIA1Registers::CIA1Registers (int  {\i id}, {\b MCHEmul::PhisicalStorage} *  {\i pS})}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::CIA1Registers}
{\xe \v C64::CIA1Registers\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void C64::CIA1Registers::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To init the memory. It might be overloaded. By default the "defaultData" value is assigned. It doesn't matter whether the subset is or not active. \par
}{
Reimplemented from {\b MCHEmul::PhisicalStorageSubset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v CIA1\:C64::CIA1Registers}
{\xe \v C64::CIA1Registers\:CIA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend C64::CIA1Registers::CIA1}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b CIA1Registers.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b CIA1Registers.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::CIA2 Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::CIA2}
{\xe \v C64::CIA2}
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
\par
{
{\f2 #include <CIA2.hpp>}}\par
Inheritance diagram for C64::CIA2:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a2__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::CIA2:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a2__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIA2} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ({\b MCHEmul::CPU} *cpu) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b Commodore64}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _ID} = 3\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The chip is to communicate the {\b C64} with the environment. \par
}{
Definition at line {\b 28} of file {\b CIA2.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CIA2\:C64::CIA2}
{\xe \v C64::CIA2\:CIA2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::CIA2::CIA2 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b CIA2.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::CIA2}
{\xe \v C64::CIA2\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool C64::CIA2::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v simulate\:C64::CIA2}
{\xe \v C64::CIA2\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool C64::CIA2::simulate ({\b MCHEmul::CPU} * ){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate th behaviour of the chip. It has to be defined per chip. \par
Returns true if everything was ok, and false in any other circunstance. \par
 The last error could be recovered from the variable _lastError in that case. \par
The clock cyclees is added. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::CIA2}
{\xe \v C64::CIA2\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int C64::CIA2::_ID = 3{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b CIA2.hpp}.}\par
}
{\xe \v Commodore64\:C64::CIA2}
{\xe \v C64::CIA2\:Commodore64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend C64::CIA2::Commodore64}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b CIA2.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b CIA2.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::CIA2Registers Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::CIA2Registers}
{\xe \v C64::CIA2Registers}
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
\par
{
{\f2 #include <CIA2Registers.hpp>}}\par
Inheritance diagram for C64::CIA2Registers:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a2_registers__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::CIA2Registers:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a2_registers__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIA2Registers} (int {\b id}, {\b MCHEmul::PhisicalStorage} *pS)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b VICIIBank} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b CIA2}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In the {\b CIA2} {\b Memory}, there are a couple of records that behave different when they are read that when they are written. \par
}{
Definition at line {\b 27} of file {\b CIA2Registers.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CIA2Registers\:C64::CIA2Registers}
{\xe \v C64::CIA2Registers\:CIA2Registers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::CIA2Registers::CIA2Registers (int  {\i id}, {\b MCHEmul::PhisicalStorage} *  {\i pS})}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::CIA2Registers}
{\xe \v C64::CIA2Registers\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void C64::CIA2Registers::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To init the memory. It might be overloaded. By default the "defaultData" value is assigned. It doesn't matter whether the subset is or not active. \par
}{
Reimplemented from {\b MCHEmul::PhisicalStorageSubset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v VICIIBank\:C64::CIA2Registers}
{\xe \v C64::CIA2Registers\:VICIIBank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::CIA2Registers::VICIIBank () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b CIA2Registers.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v CIA2\:C64::CIA2Registers}
{\xe \v C64::CIA2Registers\:CIA2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend C64::CIA2Registers::CIA2}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b CIA2Registers.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b CIA2Registers.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::CIAClock Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::CIAClock}
{\xe \v C64::CIAClock}
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
\par
{
{\f2 #include <CIAClock.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIAClock} (int {\b id})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b reachesAlarm} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IRQEnabled} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setIRQEnabled} (bool e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IRQRequested} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAlarmHours} (unsigned char h)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAlarmMinutes} (unsigned char m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAlarmSeconds} (unsigned char s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAlarmTenthSeconds} (unsigned char ts)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHours} (unsigned char h)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinutes} (unsigned char m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSeconds} (unsigned char s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTenthSeconds} (unsigned char ts)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b hours} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b minutes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b seconds} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b tenthsSecond} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b simulate} ({\b MCHEmul::CPU} *cpu)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 22} of file {\b CIAClock.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CIAClock\:C64::CIAClock}
{\xe \v C64::CIAClock\:CIAClock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::CIAClock::CIAClock (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i id} \cell }{unique in the CIA chip. \cell }
{\row }
}
}{
Definition at line {\b 25} of file {\b CIAClock.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a_clock_a90a830650939b544d5478279a8c60079_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v hours\:C64::CIAClock}
{\xe \v C64::CIAClock\:hours}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::CIAClock::hours () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know the alarm, by pieces. This is the way the chips works. Anytime hours are read, no new value can be read until tenths of second are also read. \par
}{
Definition at line {\b 70} of file {\b CIAClock.hpp}.}\par
}
{\xe \v id\:C64::CIAClock}
{\xe \v C64::CIAClock\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int C64::CIAClock::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b CIAClock.hpp}.}\par
}
{\xe \v initialize\:C64::CIAClock}
{\xe \v C64::CIAClock\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void C64::CIAClock::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the timer. By default it is not enabled. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a_clock_a2227535fd8818c98eaef2b94c82bf53f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IRQEnabled\:C64::CIAClock}
{\xe \v C64::CIAClock\:IRQEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIAClock::IRQEnabled () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b CIAClock.hpp}.}\par
}
{\xe \v IRQRequested\:C64::CIAClock}
{\xe \v C64::CIAClock\:IRQRequested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIAClock::IRQRequested () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b CIAClock.hpp}.}\par
}
{\xe \v minutes\:C64::CIAClock}
{\xe \v C64::CIAClock\:minutes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::CIAClock::minutes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b CIAClock.hpp}.}\par
}
{\xe \v reachesAlarm\:C64::CIAClock}
{\xe \v C64::CIAClock\:reachesAlarm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIAClock::reachesAlarm () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To point whether the timer reached the alarm set. This variable will be true until the clock moves to the next tenth of second. \par
}{
Definition at line {\b 37} of file {\b CIAClock.hpp}.}\par
}
{\xe \v seconds\:C64::CIAClock}
{\xe \v C64::CIAClock\:seconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::CIAClock::seconds () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setAlarmHours\:C64::CIAClock}
{\xe \v C64::CIAClock\:setAlarmHours}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setAlarmHours (unsigned char  {\i h}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To set the alarm by pieces, because this is the way the CIA chip works. \par
}{
Definition at line {\b 49} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setAlarmMinutes\:C64::CIAClock}
{\xe \v C64::CIAClock\:setAlarmMinutes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setAlarmMinutes (unsigned char  {\i m}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setAlarmSeconds\:C64::CIAClock}
{\xe \v C64::CIAClock\:setAlarmSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setAlarmSeconds (unsigned char  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setAlarmTenthSeconds\:C64::CIAClock}
{\xe \v C64::CIAClock\:setAlarmTenthSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setAlarmTenthSeconds (unsigned char  {\i ts}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setHours\:C64::CIAClock}
{\xe \v C64::CIAClock\:setHours}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setHours (unsigned char  {\i h}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setIRQEnabled\:C64::CIAClock}
{\xe \v C64::CIAClock\:setIRQEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setIRQEnabled (bool  {\i e}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setMinutes\:C64::CIAClock}
{\xe \v C64::CIAClock\:setMinutes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setMinutes (unsigned char  {\i m}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setSeconds\:C64::CIAClock}
{\xe \v C64::CIAClock\:setSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setSeconds (unsigned char  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setTenthSeconds\:C64::CIAClock}
{\xe \v C64::CIAClock\:setTenthSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setTenthSeconds (unsigned char  {\i ts}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b CIAClock.hpp}.}\par
}
{\xe \v simulate\:C64::CIAClock}
{\xe \v C64::CIAClock\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::simulate ({\b MCHEmul::CPU} *  {\i cpu})}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate the behaviour of the timer. \par
It invokes also some private methods. When an interruption is launches the variable _IRQRequested is set. It becomes back to false when it is read. \par
}}
{\xe \v tenthsSecond\:C64::CIAClock}
{\xe \v C64::CIAClock\:tenthsSecond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::CIAClock::tenthsSecond () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b CIAClock.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b CIAClock.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::CIATimer Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::CIATimer}
{\xe \v C64::CIATimer}
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
\par
{
{\f2 #include <CIATimer.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b RunMode} \{ {\b _RESTART} = 0
, {\b _ONETIME}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b CountMode} \{ {\b _PROCESSORCYCLES} = 0
, {\b _SIGNALSONCNTLINE} = 1
, {\b _TIMERCOUNTSDOWNTO0} = 2
, {\b _0ONCNTPULSES} = 3
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIATimer} (int {\b id})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RunMode} {\b runMode} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRunMode} ({\b RunMode} rm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CountMode} {\b countMode} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCountMode} ({\b CountMode} cm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b reaches0} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b enabled} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEnabled} (bool e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IRQEnabled} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setIRQEnabled} (bool e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IRQRequested} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b initialValue} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInitialValue} (unsigned char iV)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentValue} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b simulate} ({\b MCHEmul::CPU} *cpu, {\b CIATimer} *t=nullptr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 22} of file {\b CIATimer.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v CountMode\:C64::CIATimer}
{\xe \v C64::CIATimer\:CountMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b C64::CIATimer::CountMode}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To determine the signal that moves a timer to count down... \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _PROCESSORCYCLES\:C64::CIATimer}
{\xe \v C64::CIATimer\:_PROCESSORCYCLES}
{\qr _PROCESSORCYCLES{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
\cell }{\cell }{\row }
{\xe \v _SIGNALSONCNTLINE\:C64::CIATimer}
{\xe \v C64::CIATimer\:_SIGNALSONCNTLINE}
{\qr _SIGNALSONCNTLINE{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
\cell }{\cell }{\row }
{\xe \v _TIMERCOUNTSDOWNTO0\:C64::CIATimer}
{\xe \v C64::CIATimer\:_TIMERCOUNTSDOWNTO0}
{\qr _TIMERCOUNTSDOWNTO0{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
\cell }{\cell }{\row }
{\xe \v _0ONCNTPULSES\:C64::CIATimer}
{\xe \v C64::CIATimer\:_0ONCNTPULSES}
{\qr _0ONCNTPULSES{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 33} of file {\b CIATimer.hpp}.}\par
}
{\xe \v RunMode\:C64::CIATimer}
{\xe \v C64::CIATimer\:RunMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b C64::CIATimer::RunMode}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To determine the behaviour of the Timer onces it reaches the 0. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _RESTART\:C64::CIATimer}
{\xe \v C64::CIATimer\:_RESTART}
{\qr _RESTART{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
\cell }{\cell }{\row }
{\xe \v _ONETIME\:C64::CIATimer}
{\xe \v C64::CIATimer\:_ONETIME}
{\qr _ONETIME{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 26} of file {\b CIATimer.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CIATimer\:C64::CIATimer}
{\xe \v C64::CIATimer\:CIATimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::CIATimer::CIATimer (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the timer is created, the value of the internal variables will be as follows: RUNMODE = RESTART COUNTMODE = PROCESSORCYCLES ENABLED = FALSE IRQENABLED = FALSE INITIALVALUE = 0 TIME = 0 (in thenth of second) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i id} \cell }{unique in the CIA chip. \cell }
{\row }
}
}{
Definition at line {\b 52} of file {\b CIATimer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a_timer_a2b44b7df089f442cf0a483217343e186_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v countMode\:C64::CIATimer}
{\xe \v C64::CIATimer\:countMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CountMode} C64::CIATimer::countMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b CIATimer.hpp}.}\par
}
{\xe \v currentValue\:C64::CIATimer}
{\xe \v C64::CIATimer\:currentValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::CIATimer::currentValue () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current value of the timer. \par
}{
Definition at line {\b 97} of file {\b CIATimer.hpp}.}\par
}
{\xe \v enabled\:C64::CIATimer}
{\xe \v C64::CIATimer\:enabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIATimer::enabled () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b CIATimer.hpp}.}\par
}
{\xe \v id\:C64::CIATimer}
{\xe \v C64::CIATimer\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int C64::CIATimer::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b CIATimer.hpp}.}\par
}
{\xe \v initialize\:C64::CIATimer}
{\xe \v C64::CIATimer\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void C64::CIATimer::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the timer. By default it is not enabled. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a_timer_a71f72ec9a213921905b1f2481ec57b69_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialValue\:C64::CIATimer}
{\xe \v C64::CIATimer\:initialValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::CIATimer::initialValue () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The value used as the starting point for the count down. \par
}{
Definition at line {\b 92} of file {\b CIATimer.hpp}.}\par
}
{\xe \v IRQEnabled\:C64::CIATimer}
{\xe \v C64::CIATimer\:IRQEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIATimer::IRQEnabled () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b CIATimer.hpp}.}\par
}
{\xe \v IRQRequested\:C64::CIATimer}
{\xe \v C64::CIATimer\:IRQRequested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIATimer::IRQRequested () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b CIATimer.hpp}.}\par
}
{\xe \v reaches0\:C64::CIATimer}
{\xe \v C64::CIATimer\:reaches0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIATimer::reaches0 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To point whether the timer reached 0. This variable will be true until the timer starts back. \par
}{
Definition at line {\b 74} of file {\b CIATimer.hpp}.}\par
}
{\xe \v reset\:C64::CIATimer}
{\xe \v C64::CIATimer\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::reset (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The timer is forced to start back. \par
}{
Definition at line {\b 100} of file {\b CIATimer.hpp}.}\par
}
{\xe \v runMode\:C64::CIATimer}
{\xe \v C64::CIATimer\:runMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RunMode} C64::CIATimer::runMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b CIATimer.hpp}.}\par
}
{\xe \v setCountMode\:C64::CIATimer}
{\xe \v C64::CIATimer\:setCountMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::setCountMode ({\b CountMode}  {\i cm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b CIATimer.hpp}.}\par
}
{\xe \v setEnabled\:C64::CIATimer}
{\xe \v C64::CIATimer\:setEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::setEnabled (bool  {\i e}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b CIATimer.hpp}.}\par
}
{\xe \v setInitialValue\:C64::CIATimer}
{\xe \v C64::CIATimer\:setInitialValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::setInitialValue (unsigned char  {\i iV}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b CIATimer.hpp}.}\par
}
{\xe \v setIRQEnabled\:C64::CIATimer}
{\xe \v C64::CIATimer\:setIRQEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::setIRQEnabled (bool  {\i e}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b CIATimer.hpp}.}\par
}
{\xe \v setRunMode\:C64::CIATimer}
{\xe \v C64::CIATimer\:setRunMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::setRunMode ({\b RunMode}  {\i rm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b CIATimer.hpp}.}\par
}
{\xe \v simulate\:C64::CIATimer}
{\xe \v C64::CIATimer\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::simulate ({\b MCHEmul::CPU} *  {\i cpu}, {\b CIATimer} *  {\i t} = {\f2 nullptr})}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate the behaviour of the timer. \par
It invokes also some private methods. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b CIATimer.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Computer::Clock Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock}
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
\par
{
{\f2 #include <Computer.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clock} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clock} (unsigned int cS)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clock} (const {\b Clock} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clock} & {\b operator=} (const {\b Clock} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b cyclesPerSecond} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b start} (unsigned int cC)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b waitFor} (unsigned int cC)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to align the speed to the microprocessor to the speed of the code in this machine. \par
}{
Definition at line {\b 155} of file {\b Computer.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Clock\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:Clock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Computer::Clock::Clock (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Clock\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:Clock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Computer::Clock::Clock (unsigned int  {\i cS}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b Computer.hpp}.}\par
}
{\xe \v Clock\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:Clock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Computer::Clock::Clock (const {\b Clock} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v cyclesPerSecond\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:cyclesPerSecond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Computer::Clock::cyclesPerSecond () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b Computer.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_1_1_clock_ab3a8cc1f93be0fac0ce1de58528c7b37_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Clock} & MCHEmul::Computer::Clock::operator= (const {\b Clock} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v start\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::Clock::start (unsigned int  {\i cC})}}
\par
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_1_1_clock_a0883f759ef8325dd545778b77f1cc501_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v waitFor\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:waitFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::Clock::waitFor (unsigned int  {\i cC})}}
\par
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_1_1_clock_ad18d47837d809a73080c435815be486c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Computer.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::CMP_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::CMP_General}
{\xe \v F6500::CMP_General}
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::CMP_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_m_p___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::CMP_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_m_p___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMP_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CMP_General}: To aggregate common steps in every CMP instruction. \par
}{
Definition at line {\b 202} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CMP_General\:F6500::CMP_General}
{\xe \v F6500::CMP_General\:CMP_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::CMP_General::CMP_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 205} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::CMP_General}
{\xe \v F6500::CMP_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::CMP_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::ColorRAMMemory Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::ColorRAMMemory}
{\xe \v C64::ColorRAMMemory}
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
\par
{
{\f2 #include <ColorMemory.hpp>}}\par
Inheritance diagram for C64::ColorRAMMemory:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_color_r_a_m_memory__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::ColorRAMMemory:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_color_r_a_m_memory__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ColorRAMMemory} (int {\b id}, {\b MCHEmul::PhisicalStorage} *ps)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The color RAM type {\b Memory} manage only LSB nibbles. \par
}{
Definition at line {\b 22} of file {\b ColorMemory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ColorRAMMemory\:C64::ColorRAMMemory}
{\xe \v C64::ColorRAMMemory\:ColorRAMMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::ColorRAMMemory::ColorRAMMemory (int  {\i id}, {\b MCHEmul::PhisicalStorage} *  {\i ps}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b ColorMemory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b ColorMemory.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Command Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Command}
{\xe \v MCHEmul::Command}
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
\par
{
{\f2 #include <Command.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Command} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Command} (int {\b id}, const {\b Attributes} &prms=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Command} (const {\b Command} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Command} & {\b operator=} (const {\b Command} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Command} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} & {\b parameters} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setParameters} (const {\b Attributes} &prms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canBeExecuted} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b execute} ({\b Computer} *c, const {\b Attributes} &rst)=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Attributes} {\b _parameters}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 21} of file {\b Command.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Command\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:Command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Command::Command (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Command\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:Command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Command::Command (int  {\i id}, const {\b Attributes} &  {\i prms} = {\f2 \{\~ \}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b Command.hpp}.}\par
}
{\xe \v Command\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:Command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Command::Command (const {\b Command} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Command\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:~Command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::Command::~Command (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b Command.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canBeExecuted\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:canBeExecuted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Command::canBeExecuted () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v execute\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:execute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Command::execute ({\b Computer} *  {\i c}, const {\b Attributes} &  {\i rst}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v id\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::Command::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b Command.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Command} & MCHEmul::Command::operator= (const {\b Command} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parameters\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} & MCHEmul::Command::parameters () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b Command.hpp}.}\par
}
{\xe \v setParameters\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:setParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Command::setParameters (const {\b Attributes} &  {\i prms}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b Command.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _id\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::Command::_id{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b Command.hpp}.}\par
}
{\xe \v _parameters\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:_parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Attributes} MCHEmul::Command::_parameters{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Command.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Command.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::CommandBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::CommandBuilder}
{\xe \v MCHEmul::CommandBuilder}
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
\par
{
{\f2 #include <CommandBuilder.hpp>}}\par
Inheritance diagram for MCHEmul::CommandBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_command_builder__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CommandBuilder} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Command} * {\b createCommand} (const std::string &cmd) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Command} * {\b createEmptyCommand} (const std::string &cmdName) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readCommandName} (const std::string &cmd) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Attributes} {\b readCommandParameters} (const std::string &cmd) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create commands from an string that represents it. \par
}{
Definition at line {\b 22} of file {\b CommandBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ~CommandBuilder\:MCHEmul::CommandBuilder}
{\xe \v MCHEmul::CommandBuilder\:~CommandBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::CommandBuilder::~CommandBuilder (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b CommandBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createCommand\:MCHEmul::CommandBuilder}
{\xe \v MCHEmul::CommandBuilder\:createCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Command} * MCHEmul::CommandBuilder::createCommand (const std::string &  {\i cmd}) const}}
\par
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v createEmptyCommand\:MCHEmul::CommandBuilder}
{\xe \v MCHEmul::CommandBuilder\:createEmptyCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b Command} * MCHEmul::CommandBuilder::createEmptyCommand (const std::string &  {\i cmdName}) const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b MCHEmul::StandardCommandBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABIX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v readCommandName\:MCHEmul::CommandBuilder}
{\xe \v MCHEmul::CommandBuilder\:readCommandName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::CommandBuilder::readCommandName (const std::string &  {\i cmd}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v readCommandParameters\:MCHEmul::CommandBuilder}
{\xe \v MCHEmul::CommandBuilder\:readCommandParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Attributes} MCHEmul::CommandBuilder::readCommandParameters (const std::string &  {\i cmd}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b CommandBuilder.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::CommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser}
{\bkmkstart AAAAAAACPJ}
{\bkmkend AAAAAAACPJ}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::CommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::CommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommandParser} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CommandParser} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPU} * {\b cpu} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Parser} * {\b parser} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *s) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCPU} (const {\b CPU} *c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setParser} (const {\b Parser} *p)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b Parser}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPU} * {\b _cpu}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Parser} * {\b _parser}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 29} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CommandParser\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:CommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::CommandParser::CommandParser (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPK}
{\bkmkend AAAAAAACPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b Parser.hpp}.}\par
}
{\xe \v ~CommandParser\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:~CommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::Assembler::CommandParser::~CommandParser (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPL}
{\bkmkend AAAAAAACPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::CommandParser::canParse (const std::string &  {\i l}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACOZ}
{\bkmkend AAAAAAACOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implemented in {\b MCHEmul::Assembler::CommentCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::IncludeCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPN \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::MacroCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::StartingPointCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::LabelCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::BytesCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACOY \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::Assembler::InstructionCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v cpu\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPU} * MCHEmul::Assembler::CommandParser::cpu () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPS}
{\bkmkend AAAAAAACPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b Parser.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::CommandParser::initialize (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPB}
{\bkmkend AAAAAAACPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maybe one of them could need it. \par
}{
Reimplemented in {\b MCHEmul::Assembler::StartingPointCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPT \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::LabelCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::BytesCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPA \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::Assembler::InstructionCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 47} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::CommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACPD}
{\bkmkend AAAAAAACPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{
Implemented in {\b MCHEmul::Assembler::IncludeCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPW \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::MacroCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::StartingPointCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPY \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::LabelCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::BytesCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::InstructionCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACQA \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::Assembler::CommentCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACQB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v parser\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Parser} * MCHEmul::Assembler::CommandParser::parser () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQC}
{\bkmkend AAAAAAACQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b Parser.hpp}.}\par
}
{\xe \v setCPU\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:setCPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::CommandParser::setCPU (const {\b CPU} *  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQD}
{\bkmkend AAAAAAACQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invoked from the {\b Parser}'s constructor. \par
}{
Definition at line {\b 57} of file {\b Parser.hpp}.}\par
}
{\xe \v setParser\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:setParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::CommandParser::setParser (const {\b Parser} *  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQE}
{\bkmkend AAAAAAACQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _cpu\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:_cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPU}* MCHEmul::Assembler::CommandParser::_cpu{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQF}
{\bkmkend AAAAAAACQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b Parser.hpp}.}\par
}
{\xe \v _parser\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:_parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Parser}* MCHEmul::Assembler::CommandParser::_parser{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQG}
{\bkmkend AAAAAAACQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b Parser.hpp}.}\par
}
{\xe \v Parser\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:Parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend MCHEmul::Assembler::CommandParser::Parser}}
\par
{\bkmkstart AAAAAAACQH}
{\bkmkend AAAAAAACQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::CommentCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::CommentCommandParser}
{\xe \v MCHEmul::Assembler::CommentCommandParser}
{\bkmkstart AAAAAAACQI}
{\bkmkend AAAAAAACQI}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::CommentCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_comment_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::CommentCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_comment_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommentCommandParser} (unsigned char s=';')\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b symbol} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int, {\b Semantic} *) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser a comment. Th symbol defining the beginning of a comment can be redefined. \par
}{
Definition at line {\b 72} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CommentCommandParser\:MCHEmul::Assembler::CommentCommandParser}
{\xe \v MCHEmul::Assembler::CommentCommandParser\:CommentCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::CommentCommandParser::CommentCommandParser (unsigned char  {\i s} = {\f2 ';'}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQJ}
{\bkmkend AAAAAAACQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::CommentCommandParser}
{\xe \v MCHEmul::Assembler::CommentCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::CommentCommandParser::canParse (const std::string &  {\i l}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPM}
{\bkmkend AAAAAAACPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 83} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::CommentCommandParser}
{\xe \v MCHEmul::Assembler::CommentCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::CommentCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACQB}
{\bkmkend AAAAAAACQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nothing after the comment is important.\par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 85} of file {\b Parser.hpp}.}\par
}
{\xe \v symbol\:MCHEmul::Assembler::CommentCommandParser}
{\xe \v MCHEmul::Assembler::CommentCommandParser\:symbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::Assembler::CommentCommandParser::symbol () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQK}
{\bkmkend AAAAAAACQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::Commodore64 Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::Commodore64}
{\xe \v C64::Commodore64}
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
\par
{
{\f2 #include <C64.hpp>}}\par
Inheritance diagram for C64::Commodore64:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_commodore64__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::Commodore64:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_commodore64__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b VisualSystem} \{ {\b _NTSC}
, {\b _PAL}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Commodore64} ({\b VisualSystem} vS={\b VisualSystem::_PAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b connect} ({\b MCHEmul::IOPeripheral} *p, {\b MCHEmul::IODevice} *d) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VisualSystem} {\b _visualSystem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Attributes} {\b _parameters}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
There were two main lines of versions for the {\b C64}, atenfing to the standard of video system: NTSC and PAL. However the constructor receives attributes comming from the emulator class (createComputer method) and within those there might be attributes to define specific devices connected. \par
}{
Definition at line {\b 28} of file {\b C64.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v VisualSystem\:C64::Commodore64}
{\xe \v C64::Commodore64\:VisualSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b C64::Commodore64::VisualSystem}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _NTSC\:C64::Commodore64}
{\xe \v C64::Commodore64\:_NTSC}
{\qr _NTSC{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
\cell }{\cell }{\row }
{\xe \v _PAL\:C64::Commodore64}
{\xe \v C64::Commodore64\:_PAL}
{\qr _PAL{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 31} of file {\b C64.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Commodore64\:C64::Commodore64}
{\xe \v C64::Commodore64\:Commodore64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::Commodore64::Commodore64 ({\b VisualSystem}  {\i vS} = {\f2 {\b VisualSystem::_PAL}})}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vS} \cell }{Europe initially \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v connect\:C64::Commodore64}
{\xe \v C64::Commodore64\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool C64::Commodore64::connect ({\b MCHEmul::IOPeripheral} *  {\i p}, {\b MCHEmul::IODevice} *  {\i d}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To connect a peripheral to a device on the computer. \par
It returns true when it is ok, and false in other circunstance. The way the peripheral is connected will depend on the computer, on the device and on the peripheral itself. \par
}{
Implements {\b MCHEmul::Computer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v initialize\:C64::Commodore64}
{\xe \v C64::Commodore64\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool C64::Commodore64::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the Computer, when the "power is set up". \par
 It could be defined per computer. By default it initializes the chips. \par
Returns true, when verything was ok, and false in any other circusntance. \par
The last error happend could then be checked in _lastEerror. \par
}{
Reimplemented from {\b MCHEmul::Computer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _parameters\:C64::Commodore64}
{\xe \v C64::Commodore64\:_parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Attributes} C64::Commodore64::_parameters{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Other parameters used when initialized. \par
}{
Definition at line {\b 48} of file {\b C64.hpp}.}\par
}
{\xe \v _visualSystem\:C64::Commodore64}
{\xe \v C64::Commodore64\:_visualSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b VisualSystem} C64::Commodore64::_visualSystem{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The video system used by the commodore 64. \par
}{
Definition at line {\b 46} of file {\b C64.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b C64.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::CommunicationMessage Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage}
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
\par
{
{\f2 #include <Message.hpp>}}\par
Inheritance diagram for MCHEmul::CommunicationMessage:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_message__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommunicationMessage} (unsigned char t, const {\b Attributes} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommunicationMessage} (const {\b CommunicationMessage} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommunicationMessage} & {\b operator=} (const {\b CommunicationMessage} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CommunicationMessage} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b type} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b executeOn} ({\b Computer} *, {\b CommunicationMessage} *&)=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _MESSAGEID}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Attributes} {\b _attributes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _error}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b CommunicationMessage} class referes to the different instructions a client can sent to a server or a server can answer to a client on ergard to processing an emulator. \par
}{
Definition at line {\b 27} of file {\b Message.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CommunicationMessage\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:CommunicationMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CommunicationMessage::CommunicationMessage (unsigned char  {\i t}, const {\b Attributes} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b Message.hpp}.}\par
}
{\xe \v CommunicationMessage\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:CommunicationMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CommunicationMessage::CommunicationMessage (const {\b CommunicationMessage} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To avoid uncontrolable behaviours of any one inheriting from this. \par
}}
{\xe \v ~CommunicationMessage\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:~CommunicationMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::CommunicationMessage::~CommunicationMessage (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b Message.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attributes\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} MCHEmul::CommunicationMessage::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Message.hpp}.}\par
}
{\xe \v executeOn\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual unsigned int MCHEmul::CommunicationMessage::executeOn ({\b Computer} * , {\b CommunicationMessage} *& ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very important method. \par
This method execute what was required from the computer. \par
It must be overloaded per any specific behaviour. \par
The communication message can have an answer, and it is given in the second parameter. The method returns a number than can be additional info for the invoker. NOTE that Default result should be 0 meaning "No additional info for invoker". \par
}{
Implemented in {\b MCHEmul::GetRegisterStatusMessage} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABJG \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::GetMemoryDataMessage} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABJH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CommunicationMessage} & MCHEmul::CommunicationMessage::operator= (const {\b CommunicationMessage} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v toString\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:toString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::CommunicationMessage::toString () const}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_message_a354593ef90a679c5fad409bc93a79a4f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v type\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::CommunicationMessage::type () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b Message.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _attributes\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Attributes} MCHEmul::CommunicationMessage::_attributes{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The attributes of the message. \par
}{
Definition at line {\b 67} of file {\b Message.hpp}.}\par
}
{\xe \v _error\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CommunicationMessage::_error{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b Message.hpp}.}\par
}
{\xe \v _MESSAGEID\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:_MESSAGEID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::CommunicationMessage::_MESSAGEID{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \par
            DefaultMessageIDTypes::ID_USER_PACKET_ENUM + 1\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The id of the package having the specific meesages to control emulator. \par
}{
Definition at line {\b 31} of file {\b Message.hpp}.}\par
}
{\xe \v _type\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CommunicationMessage::_type{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The type of the message. \par
}{
Definition at line {\b 65} of file {\b Message.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b Message.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::CommunicationSystem Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem}
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
\par
{
{\f2 #include <System.hpp>}}\par
Collaboration diagram for MCHEmul::CommunicationSystem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_system__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommunicationSystem} ({\b PeerCommunicationChannel} *cC, {\b MessageBuilder} *mB)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommunicationSystem} (const {\b CommunicationSystem} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommunicationSystem} & {\b operator=} (const {\b CommunicationSystem} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CommunicationSystem} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b processMessagesOn} ({\b Computer} *c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b finalize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b error} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageBuilder} * {\b _messageBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PeerCommunicationChannel} * {\b _communicationChannel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _error}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 25} of file {\b System.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CommunicationSystem\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:CommunicationSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CommunicationSystem::CommunicationSystem ({\b PeerCommunicationChannel} *  {\i cC}, {\b MessageBuilder} *  {\i mB}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b System.hpp}.}\par
}
{\xe \v CommunicationSystem\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:CommunicationSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CommunicationSystem::CommunicationSystem (const {\b CommunicationSystem} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~CommunicationSystem\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:~CommunicationSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::CommunicationSystem::~CommunicationSystem (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b System.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v error\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CommunicationSystem::error () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b System.hpp}.}\par
}
{\xe \v finalize\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:finalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::CommunicationSystem::finalize (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b System.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_system_a3943c54136ea1d393feb5b137ff71c5e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_system_a3943c54136ea1d393feb5b137ff71c5e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::CommunicationSystem::initialize (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b System.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_system_a640a7d08dc85d4dfbf8ce95964257ef6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_system_a640a7d08dc85d4dfbf8ce95964257ef6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CommunicationSystem::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b System.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CommunicationSystem} & MCHEmul::CommunicationSystem::operator= (const {\b CommunicationSystem} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v processMessagesOn\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:processMessagesOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual unsigned int MCHEmul::CommunicationSystem::processMessagesOn ({\b Computer} *  {\i c}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The method returns a potential additional info to the caller. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _communicationChannel\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:_communicationChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PeerCommunicationChannel}* MCHEmul::CommunicationSystem::_communicationChannel{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b System.hpp}.}\par
}
{\xe \v _error\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CommunicationSystem::_error{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b System.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CommunicationSystem::_lastError{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b System.hpp}.}\par
}
{\xe \v _messageBuilder\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:_messageBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MessageBuilder}* MCHEmul::CommunicationSystem::_messageBuilder{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b System.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b System.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::Compiler Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::Compiler}
{\xe \v MCHEmul::Assembler::Compiler}
{\bkmkstart AAAAAAACQL}
{\bkmkend AAAAAAACQL}
\par
{
{\f2 #include <Compiler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Compiler} (const {\b Parser} &p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCode} {\b compile} (const std::string &fN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPU} * {\b cpu} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Errors} {\b errors} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Compiler} just to do the work. \par
The {\b Compiler} is defined for a {\b CPU} too (the same than the {\b Parser}). \par
The {\b Compiler} doesn't own the {\b Parser}. \par
}{
Definition at line {\b 78} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Compiler\:MCHEmul::Assembler::Compiler}
{\xe \v MCHEmul::Assembler::Compiler\:Compiler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Compiler::Compiler (const {\b Parser} &  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQM}
{\bkmkend AAAAAAACQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v compile\:MCHEmul::Assembler::Compiler}
{\xe \v MCHEmul::Assembler::Compiler\:compile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ByteCode} MCHEmul::Assembler::Compiler::compile (const std::string &  {\i fN}) const}}
\par
{\bkmkstart AAAAAAACQN}
{\bkmkend AAAAAAACQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The key method. Generic the Byte Codes to by load and executed. It receives the file with the instructions as parameter. A file with the extension ".act" from the previous one will be looked for. This file could have commands on the code like stop it (break points). \par
}}
{\xe \v cpu\:MCHEmul::Assembler::Compiler}
{\xe \v MCHEmul::Assembler::Compiler\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPU} * MCHEmul::Assembler::Compiler::cpu () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQO}
{\bkmkend AAAAAAACQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b Compiler.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_compiler_a57eb6c63cacf8cea3b4a6bcd3318ae97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v errors\:MCHEmul::Assembler::Compiler}
{\xe \v MCHEmul::Assembler::Compiler\:errors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Errors} MCHEmul::Assembler::Compiler::errors () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQP}
{\bkmkend AAAAAAACQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b Compiler.hpp}.}\par
}
{\xe \v operator!\:MCHEmul::Assembler::Compiler}
{\xe \v MCHEmul::Assembler::Compiler\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::Compiler::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQQ}
{\bkmkend AAAAAAACQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify checking whether there was or not an error compiling. \par
}{
Definition at line {\b 98} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Compiler.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Computer Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Computer}
{\xe \v MCHEmul::Computer}
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
\par
{
{\f2 #include <Computer.hpp>}}\par
Inheritance diagram for MCHEmul::Computer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Computer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Clock}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Computer} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Computer} ({\b CPU} *{\b cpu}, const {\b Chips} &c, {\b Memory} *m, const {\b IODevices} &d, unsigned int cs, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Computer} (const {\b Computer} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Computer} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Computer} & {\b operator=} (const {\b Computer} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPU} * {\b cpu} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} * {\b cpu} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Chips} & {\b chips} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsChip} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Chip} * {\b chip} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chip} * {\b chip} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b GraphicalChip} * {\b graphicalChip} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GraphicalChip} * {\b graphicalChip} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Memory} * {\b memory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b memory} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b IODevices} & {\b devices} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsDevice} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b IODevice} * {\b device} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} * {\b device} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b connect} ({\b IOPeripheral} *p, {\b IODevice} *d)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Screen} * {\b screen} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Screen} * {\b screen} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b InputOSSystem} * {\b inputOSSystem} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InputOSSystem} * {\b inputOSSytem} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b cyclesPerSecond} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} & {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b attribute} (const std::string &aN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadInto} (const std::string &fN, const {\b Address} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b run} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b startsCycle} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b runComputerCycle} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b runIOCycle} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b finishCycle} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b exit} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setExit} (bool e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b debugLevel} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDebugLevel} (unsigned int dL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetErrors} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} * {\b _cpu}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chips} {\b _chips}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b _memory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevices} {\b _devices}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} {\b _attributes} = \{ \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _exit}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _debugLevel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Screen} * {\b _screen}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InputOSSystem} * {\b _inputOSSystem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GraphicalChip} * {\b _graphicalChip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clock} {\b _clock}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Computer} &c)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The computer links many different elements. \par
 The computer owns all the elements linked. \par
}{
Definition at line {\b 33} of file {\b Computer.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Computer\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:Computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Computer::Computer (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Computer\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:Computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Computer::Computer ({\b CPU} *  {\i cpu}, const {\b Chips} &  {\i c}, {\b Memory} *  {\i m}, const {\b IODevices} &  {\i d}, unsigned int  {\i cs}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}})}}
\par
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The computer owns the different elements. The devices mandatory are the screen and the InputOSDevice. This is verified at construction level. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spd} \cell }{the number of cycles per second of the clock. \cell }
{\row }
}
}}
{\xe \v Computer\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:Computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Computer::Computer (const {\b Computer} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Computer\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:~Computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::Computer::~Computer (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attribute\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::Computer::attribute (const std::string &  {\i aN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b Computer.hpp}.}\par
}
{\xe \v attributes\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} & MCHEmul::Computer::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b Computer.hpp}.}\par
}
{\xe \v chip\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:chip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Chip} * MCHEmul::Computer::chip (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_ab6841c2842b160846080ddcfb798ad9e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v chip\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:chip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Chip} * MCHEmul::Computer::chip (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_ae99e32e2ebb5bda1c1139da9102d0e1a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v chips\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:chips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Chips} & MCHEmul::Computer::chips () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Computer.hpp}.}\par
}
{\xe \v connect\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Computer::connect ({\b IOPeripheral} *  {\i p}, {\b IODevice} *  {\i d}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To connect a peripheral to a device on the computer. \par
It returns true when it is ok, and false in other circunstance. The way the peripheral is connected will depend on the computer, on the device and on the peripheral itself. \par
}{
Implemented in {\b C64::Commodore64} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v cpu\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU} * MCHEmul::Computer::cpu (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b Computer.hpp}.}\par
}
{\xe \v cpu\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPU} * MCHEmul::Computer::cpu () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Computer.hpp}.}\par
}
{\xe \v cyclesPerSecond\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:cyclesPerSecond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Computer::cyclesPerSecond () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a78b0432c9686150be15c099ba719316c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v debugLevel\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:debugLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Computer::debugLevel () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b Computer.hpp}.}\par
}
{\xe \v device\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IODevice} * MCHEmul::Computer::device (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a2af801eb58860184d2a67e608ac3a45c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v device\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b IODevice} * MCHEmul::Computer::device (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a12264630fee0a6d9a83c9f405a96a45f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v devices\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:devices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b IODevices} & MCHEmul::Computer::devices () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b Computer.hpp}.}\par
}
{\xe \v existsChip\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:existsChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::existsChip (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b Computer.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a66adc31b27b3e8eba56a4d63371baaae_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsDevice\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:existsDevice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::existsDevice (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Computer.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a523ee54dfb5187e4e2aba5a3baad909c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v exit\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::exit () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b Computer.hpp}.}\par
}
{\xe \v finishCycle\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:finishCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::finishCycle (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To indicate that the cycle finishes. \par
}{
Definition at line {\b 131} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a744410e1d92d05c59d3dfa69534d82c0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v graphicalChip\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:graphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GraphicalChip} * MCHEmul::Computer::graphicalChip (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b Computer.hpp}.}\par
}
{\xe \v graphicalChip\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:graphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b GraphicalChip} * MCHEmul::Computer::graphicalChip () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is specifically choosen at construction time. \par
}{
Definition at line {\b 64} of file {\b Computer.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Computer::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the {\b Computer}, when the "power is set up". \par
 It could be defined per computer. By default it initializes the chips. \par
Returns true, when verything was ok, and false in any other circusntance. \par
The last error happend could then be checked in _lastEerror. \par
}{
Reimplemented in {\b C64::Commodore64} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v inputOSSystem\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:inputOSSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b InputOSSystem} * MCHEmul::Computer::inputOSSystem () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b Computer.hpp}.}\par
}
{\xe \v inputOSSytem\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:inputOSSytem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InputOSSystem} * MCHEmul::Computer::inputOSSytem (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b Computer.hpp}.}\par
}
{\xe \v lastError\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Computer::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the last error happend (after initialize or simulate methods). \par
}{
Definition at line {\b 145} of file {\b Computer.hpp}.}\par
}
{\xe \v loadInto\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:loadInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::loadInto (const std::string &  {\i fN}, const {\b Address} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_aa351aeb25e904383dd971086d440878f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_aa351aeb25e904383dd971086d440878f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v memory\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory} * MCHEmul::Computer::memory (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b Computer.hpp}.}\par
}
{\xe \v memory\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Memory} * MCHEmul::Computer::memory () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b Computer.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a8326cd7ead7fb291cfb13938c39ccd7b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Computer} & MCHEmul::Computer::operator= (const {\b Computer} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resetErrors\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:resetErrors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::resetErrors (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b Computer.hpp}.}\par
}
{\xe \v run\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::run ()}}
\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate how the computer works. Returns true when finalizing the run ok, and false with error. \par
The parameter is the log level. \par
This method used the other tow defined behind and it can be simulated from outside. \par
}}
{\xe \v runComputerCycle\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:runComputerCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::runComputerCycle ()}}
\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Execute one computer cycle (cpu + chips). \par
}}
{\xe \v runIOCycle\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:runIOCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::runIOCycle ()}}
\par
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Execute the IO Cycle. Returns true when ok, and false when no ok. \par
}}
{\xe \v screen\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Screen} * MCHEmul::Computer::screen (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Computer.hpp}.}\par
}
{\xe \v screen\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Screen} * MCHEmul::Computer::screen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b Computer.hpp}.}\par
}
{\xe \v setDebugLevel\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:setDebugLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::setDebugLevel (unsigned int  {\i dL}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b Computer.hpp}.}\par
}
{\xe \v setExit\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:setExit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::setExit (bool  {\i e}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b Computer.hpp}.}\par
}
{\xe \v startsCycle\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:startsCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::startsCycle (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To indicate that th loop starts. \par
}{
Definition at line {\b 123} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a53d2b5b93dafc09f7322fa2bda468507_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Computer} &  {\i c}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _attributes\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} MCHEmul::Computer::_attributes = \{ \}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 187} of file {\b Computer.hpp}.}\par
}
{\xe \v _chips\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_chips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Chips} MCHEmul::Computer::_chips{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 184} of file {\b Computer.hpp}.}\par
}
{\xe \v _clock\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_clock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Clock} MCHEmul::Computer::_clock{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 201} of file {\b Computer.hpp}.}\par
}
{\xe \v _cpu\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU}* MCHEmul::Computer::_cpu{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 183} of file {\b Computer.hpp}.}\par
}
{\xe \v _debugLevel\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_debugLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Computer::_debugLevel{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The level of the debug info. \par
}{
Definition at line {\b 194} of file {\b Computer.hpp}.}\par
}
{\xe \v _devices\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_devices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IODevices} MCHEmul::Computer::_devices{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b Computer.hpp}.}\par
}
{\xe \v _exit\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::_exit{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to to indicate the execution must finishes. There could have been an error or not. \par
}{
Definition at line {\b 191} of file {\b Computer.hpp}.}\par
}
{\xe \v _graphicalChip\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_graphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GraphicalChip}* MCHEmul::Computer::_graphicalChip{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b Computer.hpp}.}\par
}
{\xe \v _inputOSSystem\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_inputOSSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InputOSSystem}* MCHEmul::Computer::_inputOSSystem{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b Computer.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Computer::_lastError{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 197} of file {\b Computer.hpp}.}\par
}
{\xe \v _memory\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory}* MCHEmul::Computer::_memory{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 185} of file {\b Computer.hpp}.}\par
}
{\xe \v _screen\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Screen}* MCHEmul::Computer::_screen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 198} of file {\b Computer.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Computer.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Console::Console Class Reference\par \pard\plain 
{\tc\tcl2 \v Console::Console}
{\xe \v Console::Console}
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
\par
{
{\f2 #include <Console.hpp>}}\par
Collaboration diagram for Console::Console:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_console_1_1_console__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Console} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Console} ({\b Emuls::Emulator} *e, {\b MCHEmul::CommandBuilder} *cB)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Console} (const {\b Console} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Console} & {\b operator=} (const {\b Console} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Console} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b run} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b readCommand} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b readChar} (char &chr) const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Emuls::Emulator} * {\b _emulator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::CommandBuilder} * {\b _commandBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _command}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 21} of file {\b Console.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Console\:Console::Console}
{\xe \v Console::Console\:Console}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Console::Console::Console (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Console\:Console::Console}
{\xe \v Console::Console\:Console}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Console::Console::Console ({\b Emuls::Emulator} *  {\i e}, {\b MCHEmul::CommandBuilder} *  {\i cB})}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Console\:Console::Console}
{\xe \v Console::Console\:Console}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Console::Console::Console (const {\b Console} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Console\:Console::Console}
{\xe \v Console::Console\:~Console}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Console::Console::~Console (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Console.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:Console::Console}
{\xe \v Console::Console\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Console} & Console::Console::operator= (const {\b Console} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v readChar\:Console::Console}
{\xe \v Console::Console\:readChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Console::Console::readChar (char &  {\i chr}) const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The way a character is read from the console is different depending on the OS. \par
The method returns true when a char is read and false in other case. \par
The internal variable chr holds the char code read if any!. \par
}}
{\xe \v readCommand\:Console::Console}
{\xe \v Console::Console\:readCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Console::Console::readCommand (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true when a instruction is ready and false in other case. \par
}}
{\xe \v run\:Console::Console}
{\xe \v Console::Console\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Console::Console::run ()}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _command\:Console::Console}
{\xe \v Console::Console\:_command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Console::Console::_command{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b Console.hpp}.}\par
}
{\xe \v _commandBuilder\:Console::Console}
{\xe \v Console::Console\:_commandBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::CommandBuilder}* Console::Console::_commandBuilder{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b Console.hpp}.}\par
}
{\xe \v _emulator\:Console::Console}
{\xe \v Console::Console\:_emulator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Emuls::Emulator}* Console::Console::_emulator{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b Console.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CONSOLE/{\b Console.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Memory::Content Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content}
{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
\par
{
{\f2 #include <Memory.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Content} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Content} (const {\b Content} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Content} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Content} & {\b operator=} (const {\b Content} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b verifyCoherence} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorages} & {\b phisicalStorages} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsPhisicalStorage} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorage} * {\b phisicalStorage} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} * {\b phisicalStorage} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorageSubsets} & {\b Subsets} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsSubset} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorageSubset} * {\b subset} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} * {\b subset} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MemoryViews} & {\b views} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsView} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MemoryView} * {\b view} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} * {\b view} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} * {\b firstView} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b error} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorages} {\b _phisicalStorages}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubsets} {\b _subsets}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryViews} {\b _views}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To content all together the elements a memory is made up of. \par
}{
Definition at line {\b 297} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Content\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:Content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::Content::Content (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 300} of file {\b Memory.hpp}.}\par
}
{\xe \v Content\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:Content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::Content::Content (const {\b Content} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Content\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:~Content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::Content::~Content (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v error\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::Content::error () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 348} of file {\b Memory.hpp}.}\par
}
{\xe \v existsPhisicalStorage\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:existsPhisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::Content::existsPhisicalStorage (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 316} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_ab0ded3bf026c17a4f9fa9f1383f5a0a5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsSubset\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:existsSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::Content::existsSubset (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 326} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a54fd8d0e84f038f5e33173f0f35626ef_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsView\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:existsView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::Content::existsView (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 336} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a51f9541905b8bfa5d96dd335410824de_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v firstView\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:firstView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView} * MCHEmul::Memory::Content::firstView () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 343} of file {\b Memory.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::Content::initialize ()}}
\par
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a1b9e9aecf19d4ac15947ef2b705d350d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Content} & MCHEmul::Memory::Content::operator= (const {\b Content} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v phisicalStorage\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorage} * MCHEmul::Memory::Content::phisicalStorage (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 320} of file {\b Memory.hpp}.}\par
}
{\xe \v phisicalStorage\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorage} * MCHEmul::Memory::Content::phisicalStorage (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 318} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a7864c52b616a6138c973299e4553abc6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a7864c52b616a6138c973299e4553abc6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v phisicalStorages\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:phisicalStorages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorages} & MCHEmul::Memory::Content::phisicalStorages () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 314} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a9723b3d5edd36d58c80e4b2d2135f8c6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subset\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:subset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorageSubset} * MCHEmul::Memory::Content::subset (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 330} of file {\b Memory.hpp}.}\par
}
{\xe \v subset\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:subset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorageSubset} * MCHEmul::Memory::Content::subset (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 328} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_ad146d8b25735bb142bba8dd7eaf7567c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_ad146d8b25735bb142bba8dd7eaf7567c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Subsets\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:Subsets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorageSubsets} & MCHEmul::Memory::Content::Subsets () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 324} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a076b2e004e6f1375b7fdc386183822c1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v verifyCoherence\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:verifyCoherence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::Content::verifyCoherence () const}}
\par
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unless this method is executed, the class is always in error (_error = true). \par
}}
{\xe \v view\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:view}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView} * MCHEmul::Memory::Content::view (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 340} of file {\b Memory.hpp}.}\par
}
{\xe \v view\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:view}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MemoryView} * MCHEmul::Memory::Content::view (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 338} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_ad14149e8e2342e6dbf02006374380969_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_ad14149e8e2342e6dbf02006374380969_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v views\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:views}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MemoryViews} & MCHEmul::Memory::Content::views () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 334} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a752ac27288c65a515f42d00302fafc5d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _phisicalStorages\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:_phisicalStorages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorages} MCHEmul::Memory::Content::_phisicalStorages}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Can be accesses directly to set them up. \par
}{
Definition at line {\b 352} of file {\b Memory.hpp}.}\par
}
{\xe \v _subsets\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:_subsets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorageSubsets} MCHEmul::Memory::Content::_subsets}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 353} of file {\b Memory.hpp}.}\par
}
{\xe \v _views\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:_views}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryViews} MCHEmul::Memory::Content::_views}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 354} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Memory.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::CPU Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::CPU}
{\xe \v MCHEmul::CPU}
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
\par
{
{\f2 #include <CPU.hpp>}}\par
Inheritance diagram for MCHEmul::CPU:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::CPU:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} (const {\b CPUArchitecture} &a, const {\b Registers} &r, const {\b StatusRegister} &sR, const {\b Instructions} &ins)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} (const {\b CPU} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} & {\b operator=} (const {\b CPU} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CPU} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPUArchitecture} & {\b architecture} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Registers} & {\b internalRegisters} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsInternalRegister} (size_t nR) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Register} & {\b internalRegister} (size_t nR) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} & {\b internalRegister} (size_t nR)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInternalRegister} (size_t nR, {\b UBytes} v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b ProgramCounter} & {\b programCounter} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} & {\b programCounter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b StatusRegister} & {\b statusRegister} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StatusRegister} & {\b statusRegister} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsInstruction} (unsigned int i) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Instructions} & {\b instructions} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Instruction} * {\b instruction} (unsigned int i) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} * {\b instruction} (unsigned int i)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Instruction} * {\b lastInstruction} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMemoryRef} ({\b Memory} *m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Memory} * {\b memoryRef} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b memoryRef} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b clockCycles} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addClockCycles} (unsigned int cC)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsInterrupt} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPUInterrupt} * {\b interrupt} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUInterrupt} * {\b interrupt} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addInterrupt} ({\b CPUInterrupt} *in)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeInterrrupt} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeNextInstruction} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetErrors} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPUArchitecture} {\b _architecture}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Registers} {\b _registers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Instructions} {\b _instructions} = \{ \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} {\b _programCounter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StatusRegister} {\b _statusRegister}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b _memory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUInterrups} {\b _interrupts}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} * {\b _lastInstruction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _clockCycles}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b CPU} &c)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The center of any Machine. \par
}{
Definition at line {\b 30} of file {\b CPU.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CPU\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:CPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPU::CPU (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CPU\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:CPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPU::CPU (const {\b CPUArchitecture} &  {\i a}, const {\b Registers} &  {\i r}, const {\b StatusRegister} &  {\i sR}, const {\b Instructions} &  {\i ins}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b CPU.hpp}.}\par
}
{\xe \v CPU\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:CPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPU::CPU (const {\b CPU} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~CPU\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:~CPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::CPU::~CPU (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addClockCycles\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:addClockCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPU::addClockCycles (unsigned int  {\i cC}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b CPU.hpp}.}\par
}
{\xe \v addInterrupt\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:addInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPU::addInterrupt ({\b CPUInterrupt} *  {\i in})}}
\par
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v architecture\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:architecture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPUArchitecture} & MCHEmul::CPU::architecture () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b CPU.hpp}.}\par
}
{\xe \v clockCycles\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:clockCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CPU::clockCycles () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b CPU.hpp}.}\par
}
{\xe \v executeNextInstruction\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:executeNextInstruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPU::executeNextInstruction ()}}
\par
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To execute the next instruction. \par
}}
{\xe \v existsInstruction\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:existsInstruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPU::existsInstruction (unsigned int  {\i i}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b CPU.hpp}.}\par
}
{\xe \v existsInternalRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:existsInternalRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPU::existsInternalRegister (size_t  {\i nR}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b CPU.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_a0f3db0544dca669c146de751ca492447_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsInterrupt\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:existsInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPU::existsInterrupt (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To add and remove interrupts. \par
}{
Definition at line {\b 104} of file {\b CPU.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::CPU::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the {\b CPU}. It could be overloaded later. \par
By default it just initialize registers and program counter to 0. \par
Returns true if everything was ok and false in any other case. \par
}{
Reimplemented in {\b F6500::C6500} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v instruction\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Instruction} * MCHEmul::CPU::instruction (unsigned int  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b CPU.hpp}.}\par
}
{\xe \v instruction\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Instruction} * MCHEmul::CPU::instruction (unsigned int  {\i i}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b CPU.hpp}.}\par
}
{\xe \v instructions\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:instructions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Instructions} & MCHEmul::CPU::instructions () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b CPU.hpp}.}\par
}
{\xe \v internalRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:internalRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Register} & MCHEmul::CPU::internalRegister (size_t  {\i nR}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b CPU.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_a47aa6ee1b5bde914c5c48df7a07da948_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v internalRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:internalRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Register} & MCHEmul::CPU::internalRegister (size_t  {\i nR}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b CPU.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_ad232a6b8d848b23bc4542f8dcbe6cd08_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_ad232a6b8d848b23bc4542f8dcbe6cd08_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v internalRegisters\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:internalRegisters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Registers} & MCHEmul::CPU::internalRegisters () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b CPU.hpp}.}\par
}
{\xe \v interrupt\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPUInterrupt} * MCHEmul::CPU::interrupt (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b CPU.hpp}.}\par
}
{\xe \v interrupt\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPUInterrupt} * MCHEmul::CPU::interrupt (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b CPU.hpp}.}\par
}
{\xe \v lastError\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CPU::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the last error happend (after initialize or simulate methods). \par
}{
Definition at line {\b 117} of file {\b CPU.hpp}.}\par
}
{\xe \v lastInstruction\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:lastInstruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Instruction} * MCHEmul::CPU::lastInstruction () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b CPU.hpp}.}\par
}
{\xe \v memoryRef\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:memoryRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory} * MCHEmul::CPU::memoryRef (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b CPU.hpp}.}\par
}
{\xe \v memoryRef\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:memoryRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Memory} * MCHEmul::CPU::memoryRef () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b CPU.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU} & MCHEmul::CPU::operator= (const {\b CPU} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v programCounter\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:programCounter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} & MCHEmul::CPU::programCounter (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b CPU.hpp}.}\par
}
{\xe \v programCounter\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:programCounter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b ProgramCounter} & MCHEmul::CPU::programCounter () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b CPU.hpp}.}\par
}
{\xe \v removeInterrrupt\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:removeInterrrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPU::removeInterrrupt (int  {\i id})}}
\par
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resetErrors\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:resetErrors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPU::resetErrors (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b CPU.hpp}.}\par
}
{\xe \v setInternalRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:setInternalRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPU::setInternalRegister (size_t  {\i nR}, {\b UBytes}  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b CPU.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_ab61dbdbe572f9f75b50ce9a11648d769_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setMemoryRef\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:setMemoryRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPU::setMemoryRef ({\b Memory} *  {\i m}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b CPU} is not the owner of the memory, but the computer (just to keep all in the same place) A reference is here given to simplify the execution of transactions. \par
}{
Definition at line {\b 86} of file {\b CPU.hpp}.}\par
}
{\xe \v statusRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:statusRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StatusRegister} & MCHEmul::CPU::statusRegister (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b CPU.hpp}.}\par
}
{\xe \v statusRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:statusRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b StatusRegister} & MCHEmul::CPU::statusRegister () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b CPU.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b CPU} &  {\i c}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _architecture\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_architecture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPUArchitecture} MCHEmul::CPU::_architecture{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \par
            CPUArchitecture (2 , 1 )\par
}
{
Definition at line {\b 125} of file {\b CPU.hpp}.}\par
}
{\xe \v _clockCycles\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_clockCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CPU::_clockCycles{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b CPU.hpp}.}\par
}
{\xe \v _instructions\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_instructions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Instructions} MCHEmul::CPU::_instructions = \{ \}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b CPU.hpp}.}\par
}
{\xe \v _interrupts\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_interrupts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPUInterrups} MCHEmul::CPU::_interrupts{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b CPU.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CPU::_lastError{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b CPU.hpp}.}\par
}
{\xe \v _lastInstruction\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_lastInstruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Instruction}* MCHEmul::CPU::_lastInstruction{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b CPU.hpp}.}\par
}
{\xe \v _memory\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory}* MCHEmul::CPU::_memory{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b CPU.hpp}.}\par
}
{\xe \v _programCounter\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_programCounter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} MCHEmul::CPU::_programCounter{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b CPU.hpp}.}\par
}
{\xe \v _registers\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_registers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Registers} MCHEmul::CPU::_registers{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b CPU.hpp}.}\par
}
{\xe \v _statusRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_statusRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StatusRegister} MCHEmul::CPU::_statusRegister{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b CPU.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b CPU.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::CPUArchitecture Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture}
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
\par
{
{\f2 #include <CPUArchitecture.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUArchitecture} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUArchitecture} (size_t nb, size_t iL, bool bE=true, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUArchitecture} (const {\b CPUArchitecture} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUArchitecture} & {\b operator=} (const {\b CPUArchitecture} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b numberBytes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b numberBits} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b instructionLength} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b bigEndian} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} {\b registerLength} (int id, const std::string &n, size_t nb) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Register} & {\b longestRegisterPossible} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} & {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b attribute} (const std::string &aN) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b CPUArchitecture} &a)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The architecture of {\b CPU} is related usually with the maximum size of its registers in number of bytes. \par
}{
Definition at line {\b 23} of file {\b CPUArchitecture.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CPUArchitecture\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:CPUArchitecture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPUArchitecture::CPUArchitecture (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CPUArchitecture\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:CPUArchitecture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPUArchitecture::CPUArchitecture (size_t  {\i nb}, size_t  {\i iL}, bool  {\i bE} = {\f2 true}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}})}}
\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nb} \cell }{Bytes \cell }
{\row }
}
}}
{\xe \v CPUArchitecture\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:CPUArchitecture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPUArchitecture::CPUArchitecture (const {\b CPUArchitecture} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attribute\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::CPUArchitecture::attribute (const std::string &  {\i aN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v attributes\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} & MCHEmul::CPUArchitecture::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v bigEndian\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:bigEndian}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPUArchitecture::bigEndian () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v instructionLength\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:instructionLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::CPUArchitecture::instructionLength () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v longestRegisterPossible\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:longestRegisterPossible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Register} & MCHEmul::CPUArchitecture::longestRegisterPossible () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get a exampla of the longest possible register. It is constant so it would have to be copied once it is got. \par
}{
Definition at line {\b 48} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v numberBits\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:numberBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::CPUArchitecture::numberBits () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v numberBytes\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:numberBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::CPUArchitecture::numberBytes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPUArchitecture} & MCHEmul::CPUArchitecture::operator= (const {\b CPUArchitecture} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v registerLength\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:registerLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Register} MCHEmul::CPUArchitecture::registerLength (int  {\i id}, const std::string &  {\i n}, size_t  {\i nb}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get a register of a specific length only if is possible. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nb} \cell }{Bytes. \cell }
{\row }
}
}{
Definition at line {\b 44} of file {\b CPUArchitecture.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b CPUArchitecture} &  {\i a}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b CPUArchitecture.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::CPUInterrupt Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt}
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
\par
{
{\f2 #include <CPUInterrupt.hpp>}}\par
Inheritance diagram for MCHEmul::CPUInterrupt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_interrupt__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUInterrupt} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUInterrupt} (int {\b id})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUInterrupt} (const {\b CPUInterrupt} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CPUInterrupt} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUInterrupt} & {\b operator=} (const {\b CPUInterrupt} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b active} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setActive} (bool a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOver} ({\b CPU} *c, unsigned int &nC)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isTime} ({\b CPU} *c) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b executeOverImpl} ({\b CPU} *c, unsigned int &nC)=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _active}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastClockCyclesExecuted}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A {\b CPU} Interrupt is something that is able to stop the normal progress of the {\b CPU} execution. \par
}{
Definition at line {\b 24} of file {\b CPUInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CPUInterrupt\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:CPUInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPUInterrupt::CPUInterrupt (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CPUInterrupt\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:CPUInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPUInterrupt::CPUInterrupt (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b CPUInterrupt.hpp}.}\par
}
{\xe \v CPUInterrupt\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:CPUInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPUInterrupt::CPUInterrupt (const {\b CPUInterrupt} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~CPUInterrupt\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:~CPUInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::CPUInterrupt::~CPUInterrupt (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b CPUInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v active\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:active}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPUInterrupt::active () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b CPUInterrupt.hpp}.}\par
}
{\xe \v executeOver\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:executeOver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPUInterrupt::executeOver ({\b CPU} *  {\i c}, unsigned int &  {\i nC})}}
\par
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Receive the {\b CPU} the interrupts works for. \par
It receives also a reference to a variable where to load the number of cycles it took the execution (when the return was ok). \par
It returns true if ok and false if not. \par
}}
{\xe \v executeOverImpl\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:executeOverImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::CPUInterrupt::executeOverImpl ({\b CPU} *  {\i c}, unsigned int &  {\i nC}){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To really execute the interrupt. \par
 This must be overloaded by the real interrupt. \par
}{
Implemented in {\b F6500::IRQInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABDM \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b F6500::NMIInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABEF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v id\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::CPUInterrupt::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b CPUInterrupt.hpp}.}\par
}
{\xe \v isTime\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:isTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::CPUInterrupt::isTime ({\b CPU} *  {\i c}) const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To determine whether it is the time to execute the interruption. \par
}{
Implemented in {\b F6500::IRQInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABDO \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b F6500::NMIInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABEG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPUInterrupt} & MCHEmul::CPUInterrupt::operator= (const {\b CPUInterrupt} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setActive\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:setActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPUInterrupt::setActive (bool  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b CPUInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _active\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:_active}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPUInterrupt::_active{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b CPUInterrupt.hpp}.}\par
}
{\xe \v _id\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::CPUInterrupt::_id{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b CPUInterrupt.hpp}.}\par
}
{\xe \v _lastClockCyclesExecuted\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:_lastClockCyclesExecuted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CPUInterrupt::_lastClockCyclesExecuted{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b CPUInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b CPUInterrupt.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::CPX_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::CPX_General}
{\xe \v F6500::CPX_General}
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::CPX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_p_x___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::CPX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_p_x___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPX_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CPX_General}: To aggregate common steps in every CPX instruction. \par
}{
Definition at line {\b 224} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CPX_General\:F6500::CPX_General}
{\xe \v F6500::CPX_General\:CPX_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::CPX_General::CPX_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 227} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::CPX_General}
{\xe \v F6500::CPX_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::CPX_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::CPY_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::CPY_General}
{\xe \v F6500::CPY_General}
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::CPY_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_p_y___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::CPY_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_p_y___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPY_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CPY_General}: To aggregate common steps in every CPY instruction. \par
}{
Definition at line {\b 241} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CPY_General\:F6500::CPY_General}
{\xe \v F6500::CPY_General\:CPY_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::CPY_General::CPY_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 244} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::CPY_General}
{\xe \v F6500::CPY_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::CPY_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::DEC_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::DEC_General}
{\xe \v F6500::DEC_General}
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::DEC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_d_e_c___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::DEC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_d_e_c___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DEC_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b DEC_General}: To aggregate common steps in every DEC instruction. \par
}{
Definition at line {\b 258} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DEC_General\:F6500::DEC_General}
{\xe \v F6500::DEC_General\:DEC_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::DEC_General::DEC_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 261} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::DEC_General}
{\xe \v F6500::DEC_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::DEC_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Emuls::Emulator Class Reference\par \pard\plain 
{\tc\tcl2 \v Emuls::Emulator}
{\xe \v Emuls::Emulator}
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
\par
{
{\f2 #include <Emulator.hpp>}}\par
Inheritance diagram for Emuls::Emulator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for Emuls::Emulator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MapOfActions} = std::map< {\b MCHEmul::Address}, unsigned int >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Emulator} (const std::vector< std::string > &argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Emulator} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MCHEmul::Attributes} & {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MCHEmul::Computer} * {\b computer} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Computer} * {\b computer} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCommunicationSystem} ({\b MCHEmul::CommunicationSystem} *cS)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b byteFileName} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asmFileName} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b logLevel} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b startingAddress} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b debugLevel} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDebugLevel} (unsigned int dL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setActions} (const {\b MapOfActions} &at)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addAction} (const {\b MCHEmul::Address} &at, unsigned int a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeAction} (const {\b MCHEmul::Address} &at)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b connectPeripheral} (int id, const {\b MCHEmul::Attributes} &prms, {\b MCHEmul::IODevice} *d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b run} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b runCycle} (unsigned int a=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _PARAMBYTEFILE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const std::string {\b _BYTEFILE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _PARAMASMFILE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const std::string {\b _ASMFILE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _PARAMLOGLEVEL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const std::string {\b _LOGLEVEL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _PARAMADDRESS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const std::string {\b _ADDRESS}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MCHEmul::IOPeripheralBuilder} * {\b peripherialBuilder} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::IOPeripheralBuilder} * {\b peripherialBuilder} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b executeAction} (unsigned int &lA, unsigned int at, unsigned int a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b additionalRunCycle} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Computer} * {\b createComputer} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::IOPeripheralBuilder} * {\b createPeripheralBuilder} () const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Attributes} {\b _attributes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::CommunicationSystem} * {\b _communicationSystem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _debugLevel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< {\b MCHEmul::Address}, unsigned int > {\b _actionsAt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Computer} * {\b _computer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::IOPeripheralBuilder} * {\b _peripheralBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _running}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastAction}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 24} of file {\b Emulator.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v MapOfActions\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:MapOfActions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Emuls::Emulator::MapOfActions} =  std::map <{\b MCHEmul::Address}, unsigned int>}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b Emulator.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Emulator\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:Emulator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Emuls::Emulator::Emulator (const std::vector< std::string > &  {\i argv})}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor: {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argc} \cell }{: N\'FAmero de par\'E1metros. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argv} \cell }{: The parameters. The basic parameters for any emulator are: \par
/fFILENAME : bytes file (with path) to be loaded into the memory. /cFILENAME : ASM file (with path) to be parsed, compiled and loadd into the memory. /lLEVEL : To print out logs. /aADDRESS : The address where to start the execution of the emulator. \cell }
{\row }
}
}}
{\xe \v ~Emulator\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:~Emulator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Emuls::Emulator::~Emulator (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addAction\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:addAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Emuls::Emulator::addAction (const {\b MCHEmul::Address} &  {\i at}, unsigned int  {\i a})}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To manage them individually. \par
}}
{\xe \v additionalRunCycle\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:additionalRunCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Emuls::Emulator::additionalRunCycle (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An exit method that can hold specific code needed per cycle and per type of emulator. By default it does nothing. \par
}{
Reimplemented in {\b Emuls::C64Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 143} of file {\b Emulator.hpp}.}\par
}
{\xe \v asmFileName\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:asmFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Emuls::Emulator::asmFileName () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know whether there is an ASM file where data to be loaded. "" when there is no ASM file data. \par
}{
Definition at line {\b 72} of file {\b Emulator.hpp}.}\par
}
{\xe \v attributes\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::Attributes} & Emuls::Emulator::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b Emulator.hpp}.}\par
}
{\xe \v byteFileName\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:byteFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Emuls::Emulator::byteFileName () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know whether there is a byte file where data to be loaded. \par
"" when there is no byte file data. \par
}{
Definition at line {\b 66} of file {\b Emulator.hpp}.}\par
}
{\xe \v computer\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Computer} * Emuls::Emulator::computer (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a469c363da0b7f3bae69211a90c12371a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v computer\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::Computer} * Emuls::Emulator::computer () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_af7eae1eb535a9539d1e6b11c3f28bcd4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_af7eae1eb535a9539d1e6b11c3f28bcd4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connectPeripheral\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:connectPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::Emulator::connectPeripheral (int  {\i id}, const {\b MCHEmul::Attributes} &  {\i prms}, {\b MCHEmul::IODevice} *  {\i d}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a716f074ddd49d290162f1220dcdd19b1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v createComputer\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:createComputer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Computer} * Emuls::Emulator::createComputer () const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create the right version of the computer, attending the parameters received by the constructor. \par
}{
Implemented in {\b Emuls::C64Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_ac32f27fbb6f8a20b54a1bfa0098c6247_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v createPeripheralBuilder\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:createPeripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::IOPeripheralBuilder} * Emuls::Emulator::createPeripheralBuilder () const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create the right version of the Peripheral Builder. \par
}{
Implemented in {\b Emuls::C64Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_acd5f251736a6eafede84ab397ed46629_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v debugLevel\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:debugLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Emuls::Emulator::debugLevel () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Emulator.hpp}.}\par
}
{\xe \v executeAction\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:executeAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Emuls::Emulator::executeAction (unsigned int &  {\i lA}, unsigned int  {\i at}, unsigned int  {\i a}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In the method runCycle, before executing the cycle related to the computer (cpu + chips), this method is invoked. \par
The parameters passed through are: "lA" is the last action executed (if any), "at" is the action associated to the point where the program counter is now at, and "a" is the action parameter received by the method itself. \par
A potential "like a" parameter received through the communication system (if active and if any) is also taken into account. However the parameter "a" received by the method has priority. With these three/four variables this method should do whatever is requires and decide whether execute the cycle of the computer (true) or not (return false). \par
It can be overloaded for specific pruposes. \par
During the execution of the method the firt parameter (lastAction) can be modified. \par
}}
{\xe \v initialize\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Emuls::Emulator::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the emulator. \par
}{
Reimplemented in {\b Emuls::C64Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v lastError\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Emuls::Emulator::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b Emulator.hpp}.}\par
}
{\xe \v logLevel\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:logLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Emuls::Emulator::logLevel () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know the level of the log. 0 means no log. \par
}{
Definition at line {\b 78} of file {\b Emulator.hpp}.}\par
}
{\xe \v operator!\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::Emulator::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b Emulator.hpp}.}\par
}
{\xe \v peripherialBuilder\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:peripherialBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::IOPeripheralBuilder} * Emuls::Emulator::peripherialBuilder (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a4d9b31c092cab6a4c88613889a7bb451_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v peripherialBuilder\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:peripherialBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::IOPeripheralBuilder} * Emuls::Emulator::peripherialBuilder () const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a9afb486d4f3cabd7d9155066bf529eac_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a9afb486d4f3cabd7d9155066bf529eac_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v removeAction\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:removeAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Emuls::Emulator::removeAction (const {\b MCHEmul::Address} &  {\i at})}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v run\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::Emulator::run ()}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
True when finishes ok, false when no ok. \par
}}
{\xe \v runCycle\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:runCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::Emulator::runCycle (unsigned int  {\i a} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Execute just one cycle. The method can receive an action that can affect the execution of the compuer cycle. \par
}}
{\xe \v setActions\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:setActions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Emuls::Emulator::setActions (const {\b MapOfActions} &  {\i at}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set a couple of them. \par
}{
Definition at line {\b 97} of file {\b Emulator.hpp}.}\par
}
{\xe \v setCommunicationSystem\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:setCommunicationSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Emuls::Emulator::setCommunicationSystem ({\b MCHEmul::CommunicationSystem} *  {\i cS})}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not possible to change when running. \par
}}
{\xe \v setDebugLevel\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:setDebugLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Emuls::Emulator::setDebugLevel (unsigned int  {\i dL}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a4c73b0ae4c901030277a83413c08e855_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a4c73b0ae4c901030277a83413c08e855_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v startingAddress\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:startingAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} Emuls::Emulator::startingAddress () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know the address where to start the execution from. \par
0x00 when no address has been defined. \par
}{
Definition at line {\b 85} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a59bf87811004c1b9cb5090c64b9e8e86_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _actionsAt\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_actionsAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<{\b MCHEmul::Address}, unsigned int> Emuls::Emulator::_actionsAt{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b Emulator.hpp}.}\par
}
{\xe \v _ADDRESS\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string Emuls::Emulator::_ADDRESS{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b Emulator.hpp}.}\par
}
{\xe \v _ASMFILE\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_ASMFILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string Emuls::Emulator::_ASMFILE{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b Emulator.hpp}.}\par
}
{\xe \v _attributes\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Attributes} Emuls::Emulator::_attributes{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defined in the constructor. \par
}{
Definition at line {\b 156} of file {\b Emulator.hpp}.}\par
}
{\xe \v _BYTEFILE\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_BYTEFILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string Emuls::Emulator::_BYTEFILE{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b Emulator.hpp}.}\par
}
{\xe \v _communicationSystem\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_communicationSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::CommunicationSystem}* Emuls::Emulator::_communicationSystem{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b Emulator.hpp}.}\par
}
{\xe \v _computer\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Computer}* Emuls::Emulator::_computer{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b Emulator.hpp}.}\par
}
{\xe \v _debugLevel\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_debugLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Emuls::Emulator::_debugLevel{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b Emulator.hpp}.}\par
}
{\xe \v _lastAction\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_lastAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Emuls::Emulator::_lastAction{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b Emulator.hpp}.}\par
}
{\xe \v _lastError\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Emuls::Emulator::_lastError{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b Emulator.hpp}.}\par
}
{\xe \v _LOGLEVEL\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_LOGLEVEL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string Emuls::Emulator::_LOGLEVEL{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b Emulator.hpp}.}\par
}
{\xe \v _PARAMADDRESS\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_PARAMADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char Emuls::Emulator::_PARAMADDRESS{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b Emulator.hpp}.}\par
}
{\xe \v _PARAMASMFILE\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_PARAMASMFILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char Emuls::Emulator::_PARAMASMFILE{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b Emulator.hpp}.}\par
}
{\xe \v _PARAMBYTEFILE\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_PARAMBYTEFILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char Emuls::Emulator::_PARAMBYTEFILE{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The possible parameters of the {\b Emulator}. \par
}{
Definition at line {\b 28} of file {\b Emulator.hpp}.}\par
}
{\xe \v _PARAMLOGLEVEL\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_PARAMLOGLEVEL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char Emuls::Emulator::_PARAMLOGLEVEL{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Emulator.hpp}.}\par
}
{\xe \v _peripheralBuilder\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_peripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::IOPeripheralBuilder}* Emuls::Emulator::_peripheralBuilder{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 163} of file {\b Emulator.hpp}.}\par
}
{\xe \v _running\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_running}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::Emulator::_running{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b Emulator.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/EMULATORS/{\b Emulator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::EOR_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::EOR_General}
{\xe \v F6500::EOR_General}
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::EOR_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_e_o_r___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::EOR_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_e_o_r___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EOR_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b EOR_General}: To aggregate common steps in every EOR instruction. \par
}{
Definition at line {\b 282} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EOR_General\:F6500::EOR_General}
{\xe \v F6500::EOR_General\:EOR_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::EOR_General::EOR_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 285} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::EOR_General}
{\xe \v F6500::EOR_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::EOR_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::Error Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error}
{\bkmkstart AAAAAAACQR}
{\bkmkend AAAAAAACQR}
\par
{
{\f2 #include <Error.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Error} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Error} ({\b ErrorType} eT, const std::string &f, unsigned int l, unsigned int c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Error} (const {\b Error} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Error} & {\b operator=} (const {\b Error} &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ErrorType} {\b _type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _file}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _line}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _column}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Error} &e)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The error class. \par
}{
Definition at line {\b 48} of file {\b Error.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Error\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:Error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Error::Error (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQS}
{\bkmkend AAAAAAACQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Error.hpp}.}\par
}
{\xe \v Error\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:Error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Error::Error ({\b ErrorType}  {\i eT}, const std::string &  {\i f}, unsigned int  {\i l}, unsigned int  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQT}
{\bkmkend AAAAAAACQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b Error.hpp}.}\par
}
{\xe \v Error\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:Error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Error::Error (const {\b Error} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACQU}
{\bkmkend AAAAAAACQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Error} & MCHEmul::Assembler::Error::operator= (const {\b Error} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACQV}
{\bkmkend AAAAAAACQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Error} &  {\i e}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACQW}
{\bkmkend AAAAAAACQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _column\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:_column}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Assembler::Error::_column}}
\par
{\bkmkstart AAAAAAACQX}
{\bkmkend AAAAAAACQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b Error.hpp}.}\par
}
{\xe \v _file\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Assembler::Error::_file}}
\par
{\bkmkstart AAAAAAACQY}
{\bkmkend AAAAAAACQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b Error.hpp}.}\par
}
{\xe \v _line\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:_line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Assembler::Error::_line}}
\par
{\bkmkstart AAAAAAACQZ}
{\bkmkend AAAAAAACQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b Error.hpp}.}\par
}
{\xe \v _type\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ErrorType} MCHEmul::Assembler::Error::_type}}
\par
{\bkmkstart AAAAAAACRA}
{\bkmkend AAAAAAACRA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b Error.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Error.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UInt::FormatManager Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager}
{\bkmkstart AAAAAAACMV}
{\bkmkend AAAAAAACMV}
\par
{
{\f2 #include <UInt.hpp>}}\par
Inheritance diagram for MCHEmul::UInt::FormatManager:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_format_manager__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FormatManager} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b add} (const {\b UInt} &, const {\b UInt} &, bool) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b substract} (const {\b UInt} &, const {\b UInt} &, bool) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b asUnsignedInt} (const {\b UInt} &) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b fromUnsignedInt} (unsigned int n)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b fromInt} (int n)=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is accountable for managing aspects specifically related with the format of a number. \par
}{
Definition at line {\b 38} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v FormatManager\:MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager\:FormatManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::FormatManager::FormatManager (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACMW}
{\bkmkend AAAAAAACMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add\:MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::FormatManager::add (const {\b UInt} & , const {\b UInt} & , bool ) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACMM}
{\bkmkend AAAAAAACMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The way the add is executed depends on the format. \par
}{
Implemented in {\b MCHEmul::UInt::BinaryFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACML \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::UInt::PackagedBCDFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v asUnsignedInt\:MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager\:asUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual unsigned int MCHEmul::UInt::FormatManager::asUnsignedInt (const {\b UInt} & ) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACMO}
{\bkmkend AAAAAAACMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b MCHEmul::UInt::BinaryFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMN \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::UInt::PackagedBCDFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v fromInt\:MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager\:fromInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::FormatManager::fromInt (int  {\i n}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACMQ}
{\bkmkend AAAAAAACMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b MCHEmul::UInt::BinaryFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMP \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::UInt::PackagedBCDFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v fromUnsignedInt\:MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager\:fromUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::FormatManager::fromUnsignedInt (unsigned int  {\i n}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACMS}
{\bkmkend AAAAAAACMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b MCHEmul::UInt::BinaryFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMR \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::UInt::PackagedBCDFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACNA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v substract\:MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager\:substract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::FormatManager::substract (const {\b UInt} & , const {\b UInt} & , bool ) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACMU}
{\bkmkend AAAAAAACMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The same for substracting. \par
}{
Implemented in {\b MCHEmul::UInt::BinaryFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMT \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::UInt::PackagedBCDFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACNB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UInt.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UInt::FormatManagers Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UInt::FormatManagers}
{\xe \v MCHEmul::UInt::FormatManagers}
{\bkmkstart AAAAAAACNC}
{\bkmkend AAAAAAACNC}
\par
{
{\f2 #include <UInt.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FormatManagers} (const std::map< unsigned char, {\b FormatManager} * > &fM)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~FormatManagers} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< unsigned char, {\b FormatManager} * > {\b _formatManagers}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create and destroy the format managers. There can only be onky one instance of this class!. \par
}{
Definition at line {\b 89} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v FormatManagers\:MCHEmul::UInt::FormatManagers}
{\xe \v MCHEmul::UInt::FormatManagers\:FormatManagers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::FormatManagers::FormatManagers (const std::map< unsigned char, {\b FormatManager} * > &  {\i fM}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACND}
{\bkmkend AAAAAAACND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the formates used, Only one instance can exists. \par
}{
Definition at line {\b 93} of file {\b UInt.hpp}.}\par
}
{\xe \v ~FormatManagers\:MCHEmul::UInt::FormatManagers}
{\xe \v MCHEmul::UInt::FormatManagers\:~FormatManagers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::FormatManagers::~FormatManagers (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNE}
{\bkmkend AAAAAAACNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _formatManagers\:MCHEmul::UInt::FormatManagers}
{\xe \v MCHEmul::UInt::FormatManagers\:_formatManagers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<unsigned char, {\b FormatManager}*> MCHEmul::UInt::FormatManagers::_formatManagers}}
\par
{\bkmkstart AAAAAAACNF}
{\bkmkend AAAAAAACNF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It can be accessed from anyplace. \par
So other formaters can be added later if needed. \par
}{
Definition at line {\b 103} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UInt.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::GetMemoryDataMessage Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::GetMemoryDataMessage}
{\xe \v MCHEmul::GetMemoryDataMessage}
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
\par
{
{\f2 #include <StdMessages.hpp>}}\par
Inheritance diagram for MCHEmul::GetMemoryDataMessage:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_get_memory_data_message__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::GetMemoryDataMessage:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_get_memory_data_message__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GetMemoryDataMessage} (const {\b Attributes} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b executeOn} ({\b Computer} *c, {\b CommunicationMessage} *&ans) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _ID} = 'B'\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A message to get the data of the memory. \par
}{
Definition at line {\b 47} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GetMemoryDataMessage\:MCHEmul::GetMemoryDataMessage}
{\xe \v MCHEmul::GetMemoryDataMessage\:GetMemoryDataMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::GetMemoryDataMessage::GetMemoryDataMessage (const {\b Attributes} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:MCHEmul::GetMemoryDataMessage}
{\xe \v MCHEmul::GetMemoryDataMessage\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual unsigned int MCHEmul::GetMemoryDataMessage::executeOn ({\b Computer} * , {\b CommunicationMessage} *& ){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very important method. \par
This method execute what was required from the computer. \par
It must be overloaded per any specific behaviour. \par
The communication message can have an answer, and it is given in the second parameter. The method returns a number than can be additional info for the invoker. NOTE that Default result should be 0 meaning "No additional info for invoker". \par
}{
Implements {\b MCHEmul::CommunicationMessage} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABJF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:MCHEmul::GetMemoryDataMessage}
{\xe \v MCHEmul::GetMemoryDataMessage\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::GetMemoryDataMessage::_ID = 'B'{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b StdMessages.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::GetRegisterStatusMessage Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::GetRegisterStatusMessage}
{\xe \v MCHEmul::GetRegisterStatusMessage}
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
\par
{
{\f2 #include <StdMessages.hpp>}}\par
Inheritance diagram for MCHEmul::GetRegisterStatusMessage:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_get_register_status_message__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::GetRegisterStatusMessage:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_get_register_status_message__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GetRegisterStatusMessage} (const {\b Attributes} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b executeOn} ({\b Computer} *c, {\b CommunicationMessage} *&ans) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _ID} = 'A'\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A message to get the status of the internal registers. \par
}{
Definition at line {\b 34} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GetRegisterStatusMessage\:MCHEmul::GetRegisterStatusMessage}
{\xe \v MCHEmul::GetRegisterStatusMessage\:GetRegisterStatusMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::GetRegisterStatusMessage::GetRegisterStatusMessage (const {\b Attributes} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:MCHEmul::GetRegisterStatusMessage}
{\xe \v MCHEmul::GetRegisterStatusMessage\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual unsigned int MCHEmul::GetRegisterStatusMessage::executeOn ({\b Computer} * , {\b CommunicationMessage} *& ){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very important method. \par
This method execute what was required from the computer. \par
It must be overloaded per any specific behaviour. \par
The communication message can have an answer, and it is given in the second parameter. The method returns a number than can be additional info for the invoker. NOTE that Default result should be 0 meaning "No additional info for invoker". \par
}{
Implements {\b MCHEmul::CommunicationMessage} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABJF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:MCHEmul::GetRegisterStatusMessage}
{\xe \v MCHEmul::GetRegisterStatusMessage\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::GetRegisterStatusMessage::_ID = 'A'{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b StdMessages.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::GrammaticalElement Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement}
{\bkmkstart AAAAAAACRB}
{\bkmkend AAAAAAACRB}
\par
{
{\f2 #include <Grammar.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::GrammaticalElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_grammatical_element__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::GrammaticalElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_grammatical_element__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Type} \{ {\b _LABEL} = 0
, {\b _BYTESINMEMORY}
, {\b _INSTRUCTION}
, {\b _STARTINGPOINT}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GrammaticalElement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GrammaticalElement} (const {\b GrammaticalElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GrammaticalElement} & {\b operator=} (const {\b GrammaticalElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GrammaticalElement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b size} (const {\b Semantic} *s) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b codeBytes} (const {\b Semantic} *s, bool bE=true) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Address} {\b address} (const {\b MCHEmul::Assembler::Semantic} *s) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ErrorType} {\b error} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Type} {\b _type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _line}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _actionOn}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GrammaticalElement} * {\b _nextElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GrammaticalElement} * {\b _previousElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ErrorType} {\b _error}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::vector< {\b UByte} > {\b calculateCodeBytes} (const {\b Semantic} *s, bool bE=true) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b bytesFromExpression} (const std::string &e, const {\b Macros} &ms, bool &er) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b _codeBytes}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 101} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Type\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MCHEmul::Assembler::GrammaticalElement::Type}}}
\par
{\bkmkstart AAAAAAACRC}
{\bkmkend AAAAAAACRC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _LABEL\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_LABEL}
{\qr _LABEL{\bkmkstart AAAAAAACRD}
{\bkmkend AAAAAAACRD}
\cell }{\cell }{\row }
{\xe \v _BYTESINMEMORY\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_BYTESINMEMORY}
{\qr _BYTESINMEMORY{\bkmkstart AAAAAAACRE}
{\bkmkend AAAAAAACRE}
\cell }{\cell }{\row }
{\xe \v _INSTRUCTION\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_INSTRUCTION}
{\qr _INSTRUCTION{\bkmkstart AAAAAAACRF}
{\bkmkend AAAAAAACRF}
\cell }{\cell }{\row }
{\xe \v _STARTINGPOINT\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_STARTINGPOINT}
{\qr _STARTINGPOINT{\bkmkstart AAAAAAACRG}
{\bkmkend AAAAAAACRG}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 103} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GrammaticalElement\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:GrammaticalElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::GrammaticalElement::GrammaticalElement (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRH}
{\bkmkend AAAAAAACRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b Grammar.hpp}.}\par
}
{\xe \v GrammaticalElement\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:GrammaticalElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::GrammaticalElement::GrammaticalElement (const {\b GrammaticalElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACRI}
{\bkmkend AAAAAAACRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~GrammaticalElement\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:~GrammaticalElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::Assembler::GrammaticalElement::~GrammaticalElement (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACRJ}
{\bkmkend AAAAAAACRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Chained.\par
}{
Definition at line {\b 115} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v address\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b Address} MCHEmul::Assembler::GrammaticalElement::address (const {\b MCHEmul::Assembler::Semantic} *  {\i s}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACRK}
{\bkmkend AAAAAAACRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know the address of the grammatical element. \par
}{
Reimplemented in {\b MCHEmul::Assembler::StartingPointElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACRL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v bytesFromExpression\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:bytesFromExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b UByte} > MCHEmul::Assembler::GrammaticalElement::bytesFromExpression (const std::string &  {\i e}, const {\b Macros} &  {\i ms}, bool &  {\i er}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRM}
{\bkmkend AAAAAAACRM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v calculateCodeBytes\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:calculateCodeBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::vector< {\b UByte} > MCHEmul::Assembler::GrammaticalElement::calculateCodeBytes (const {\b Semantic} *  {\i s}, bool  {\i bE} = {\f2 true}) const{\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACRN}
{\bkmkend AAAAAAACRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To calculat the codeBytes first time. \par
}{
Definition at line {\b 156} of file {\b Grammar.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_grammatical_element_a3b8814ee95bdada6b97bc76f3086aa44_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v codeBytes\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:codeBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b UByte} > MCHEmul::Assembler::GrammaticalElement::codeBytes (const {\b Semantic} *  {\i s}, bool  {\i bE} = {\f2 true}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRO}
{\bkmkend AAAAAAACRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the value of the grammatical element (if makes sense) as a set of executable bytes. The value is get taking into account a semantic. \par
When using this method errors could be generated. \par
}{
Definition at line {\b 126} of file {\b Grammar.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_grammatical_element_a0b0f68836d3b7e183e9a64295d484f24_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_grammatical_element_a0b0f68836d3b7e183e9a64295d484f24_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v error\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ErrorType} MCHEmul::Assembler::GrammaticalElement::error () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRP}
{\bkmkend AAAAAAACRP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b Grammar.hpp}.}\par
}
{\xe \v operator!\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::GrammaticalElement::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRQ}
{\bkmkend AAAAAAACRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To visually simplify the way the error system is managed. \par
}{
Definition at line {\b 136} of file {\b Grammar.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GrammaticalElement} & MCHEmul::Assembler::GrammaticalElement::operator= (const {\b GrammaticalElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACRR}
{\bkmkend AAAAAAACRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual size_t MCHEmul::Assembler::GrammaticalElement::size (const {\b Semantic} *  {\i s}) const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACRS}
{\bkmkend AAAAAAACRS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the size of the grammatical element in bytes. By default the bytes are calculated and then the size. \par
}{
Reimplemented in {\b MCHEmul::Assembler::InstructionElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACRT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 120} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _actionOn\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_actionOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Assembler::GrammaticalElement::_actionOn}}
\par
{\bkmkstart AAAAAAACRU}
{\bkmkend AAAAAAACRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b Grammar.hpp}.}\par
}
{\xe \v _codeBytes\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_codeBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b UByte}> MCHEmul::Assembler::GrammaticalElement::_codeBytes{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRV}
{\bkmkend AAAAAAACRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 152} of file {\b Grammar.hpp}.}\par
}
{\xe \v _error\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ErrorType} MCHEmul::Assembler::GrammaticalElement::_error{\f2 [mutable]}}}
\par
{\bkmkstart AAAAAAACRW}
{\bkmkend AAAAAAACRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To define whether it has or not some mistake inside, it could be modified even consulting data. \par
}{
Definition at line {\b 148} of file {\b Grammar.hpp}.}\par
}
{\xe \v _id\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Assembler::GrammaticalElement::_id}}
\par
{\bkmkstart AAAAAAACRX}
{\bkmkend AAAAAAACRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 140} of file {\b Grammar.hpp}.}\par
}
{\xe \v _line\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Assembler::GrammaticalElement::_line}}
\par
{\bkmkstart AAAAAAACRY}
{\bkmkend AAAAAAACRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b Grammar.hpp}.}\par
}
{\xe \v _nextElement\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_nextElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GrammaticalElement}* MCHEmul::Assembler::GrammaticalElement::_nextElement}}
\par
{\bkmkstart AAAAAAACRZ}
{\bkmkend AAAAAAACRZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The next gramatical element linked. \par
}{
Definition at line {\b 144} of file {\b Grammar.hpp}.}\par
}
{\xe \v _previousElement\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_previousElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GrammaticalElement}* MCHEmul::Assembler::GrammaticalElement::_previousElement}}
\par
{\bkmkstart AAAAAAACSA}
{\bkmkend AAAAAAACSA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The previous gramatical element linked. \par
}{
Definition at line {\b 146} of file {\b Grammar.hpp}.}\par
}
{\xe \v _type\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Type} MCHEmul::Assembler::GrammaticalElement::_type}}
\par
{\bkmkstart AAAAAAACSB}
{\bkmkend AAAAAAACSB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::GraphicalChip Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip}
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
\par
{
{\f2 #include <GraphicalChip.hpp>}}\par
Inheritance diagram for MCHEmul::GraphicalChip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_graphical_chip__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::GraphicalChip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_graphical_chip__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GraphicalChip} (int {\b id}, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~GraphicalChip} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b ScreenMemory} * {\b screenMemory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenMemory} * {\b screenMemory} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b graphicsReady} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setGraphicsReady} (bool gR)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ScreenMemory} * {\b createScreenMemory} ()=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenMemory} * {\b _screenMemory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _graphicsReady}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GraphicalChip} is very connected with a {\b Screen}. \par
The graphical chip uses the {\b ScreenMemory} to write. \par
The same object will be taken by th {\b Screen} to finaly put the graphics out to the display. \par
The instance of the {\b ScreenMemory} object used is created in the method "createScreenMemory ()" that has to be overload. \par
When a graphic is ready (complete) to be sent to the screen, the method "setGraphicsReady (true)" should be invoked. \par
The {\b Screen}, when output the raphics to the display invokes back the method "setGraphicsReady (false)". \par
}{
Definition at line {\b 30} of file {\b GraphicalChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GraphicalChip\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:GraphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::GraphicalChip::GraphicalChip (int  {\i id}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b GraphicalChip.hpp}.}\par
}
{\xe \v ~GraphicalChip\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:~GraphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::GraphicalChip::~GraphicalChip (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b GraphicalChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createScreenMemory\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:createScreenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b ScreenMemory} * MCHEmul::GraphicalChip::createScreenMemory (){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invoked from initialize to create the right screen memory. \par
}}
{\xe \v graphicsReady\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:graphicsReady}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::GraphicalChip::graphicsReady () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b GraphicalChip.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::GraphicalChip::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b C64::VICII} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v screenMemory\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:screenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScreenMemory} * MCHEmul::GraphicalChip::screenMemory (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b GraphicalChip.hpp}.}\par
}
{\xe \v screenMemory\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:screenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b ScreenMemory} * MCHEmul::GraphicalChip::screenMemory () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b GraphicalChip.hpp}.}\par
}
{\xe \v setGraphicsReady\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:setGraphicsReady}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::GraphicalChip::setGraphicsReady (bool  {\i gR}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b GraphicalChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _graphicsReady\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:_graphicsReady}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::GraphicalChip::_graphicsReady{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b GraphicalChip.hpp}.}\par
}
{\xe \v _screenMemory\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:_screenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScreenMemory}* MCHEmul::GraphicalChip::_screenMemory{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b GraphicalChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b GraphicalChip.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::INC_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::INC_General}
{\xe \v F6500::INC_General}
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::INC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_i_n_c___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::INC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_i_n_c___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b INC_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b INC_General}: To aggregate common steps in every INC instruction. \par
}{
Definition at line {\b 304} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v INC_General\:F6500::INC_General}
{\xe \v F6500::INC_General\:INC_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::INC_General::INC_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 307} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::INC_General}
{\xe \v F6500::INC_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::INC_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::IncludeCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::IncludeCommandParser}
{\xe \v MCHEmul::Assembler::IncludeCommandParser}
{\bkmkstart AAAAAAACSC}
{\bkmkend AAAAAAACSC}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::IncludeCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_include_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::IncludeCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_include_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IncludeCommandParser} (unsigned char s='#')\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *c) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser a file inclusion. The symbol defining that can be changed. \par
}{
Definition at line {\b 94} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IncludeCommandParser\:MCHEmul::Assembler::IncludeCommandParser}
{\xe \v MCHEmul::Assembler::IncludeCommandParser\:IncludeCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::IncludeCommandParser::IncludeCommandParser (unsigned char  {\i s} = {\f2 '#'}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSD}
{\bkmkend AAAAAAACSD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::IncludeCommandParser}
{\xe \v MCHEmul::Assembler::IncludeCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::IncludeCommandParser::canParse (const std::string &  {\i l}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPN}
{\bkmkend AAAAAAACPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 102} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::IncludeCommandParser}
{\xe \v MCHEmul::Assembler::IncludeCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::IncludeCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPW}
{\bkmkend AAAAAAACPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::InputOSSystem Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::InputOSSystem}
{\xe \v C64::InputOSSystem}
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
\par
{
{\f2 #include <OSIO.hpp>}}\par
Inheritance diagram for C64::InputOSSystem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_input_o_s_system__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::InputOSSystem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_input_o_s_system__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InputOSSystem} (const {\b MCHEmul::Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b linkToChips} (const {\b MCHEmul::Chips} &c) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _ID} = 2\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b C64::InputOSSystem} is very related with the chip {\b CIA1}. \par
The events that happen in the OS have to be transmitted to that chip for them to be accesible for the rest of the computer elements. \par
}{
Definition at line {\b 26} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InputOSSystem\:C64::InputOSSystem}
{\xe \v C64::InputOSSystem\:InputOSSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::InputOSSystem::InputOSSystem (const {\b MCHEmul::Attributes} &  {\i attrs} = {\f2 \{\~ \}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v linkToChips\:C64::InputOSSystem}
{\xe \v C64::InputOSSystem\:linkToChips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void C64::InputOSSystem::linkToChips (const {\b MCHEmul::Chips} &  {\i c}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To link to the right chips. The IO device never owns the chips. By default all chips are linked. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::InputOSSystem}
{\xe \v C64::InputOSSystem\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int C64::InputOSSystem::_ID = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b OSIO.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::InputOSSystem Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem}
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
\par
{
{\f2 #include <OSIO.hpp>}}\par
Inheritance diagram for MCHEmul::InputOSSystem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_input_o_s_system__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::InputOSSystem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_input_o_s_system__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InputOSSystem} (int {\b id}, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b quitRequested} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b SDL_JoyAxisEvents} = std::vector< SDL_JoyAxisEvent >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b whenKeyPressed} (SDL_Scancode)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b whenKeyReleased} (SDL_Scancode)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b whenJoystickMoved} (const {\b SDL_JoyAxisEvents} &)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b whenJoystickButtonPressed} (SDL_JoyButtonEvent)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b whenJoystickButtonReleased} (SDL_JoyButtonEvent)=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _quitRequested}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the generation of inputs from the OS. \par
}{
Definition at line {\b 23} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v SDL_JoyAxisEvents\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:SDL_JoyAxisEvents}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::InputOSSystem::SDL_JoyAxisEvents} =  std::vector <SDL_JoyAxisEvent>{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InputOSSystem\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:InputOSSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::InputOSSystem::InputOSSystem (int  {\i id}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::InputOSSystem::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the device. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABPZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v quitRequested\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:quitRequested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::InputOSSystem::quitRequested () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b OSIO.hpp}.}\par
}
{\xe \v simulate\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::InputOSSystem::simulate (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Algorithm, invoking the protected methods defined. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v whenJoystickButtonPressed\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:whenJoystickButtonPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::InputOSSystem::whenJoystickButtonPressed (SDL_JoyButtonEvent ){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
What to do when the joystick button is pressed. \par
}}
{\xe \v whenJoystickButtonReleased\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:whenJoystickButtonReleased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::InputOSSystem::whenJoystickButtonReleased (SDL_JoyButtonEvent ){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
What to do when the joystick button is released. \par
}}
{\xe \v whenJoystickMoved\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:whenJoystickMoved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::InputOSSystem::whenJoystickMoved (const {\b SDL_JoyAxisEvents} & ){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
What to do when the joystick is moved. Take care that the events in the joystick have to be managed as a hole, because may of them can happen at the same time: e.g. when the joystick is moved in two axes simultaneosly. \par
}}
{\xe \v whenKeyPressed\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:whenKeyPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::InputOSSystem::whenKeyPressed (SDL_Scancode ){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
What to do when a key has been pressed. \par
}}
{\xe \v whenKeyReleased\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:whenKeyReleased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::InputOSSystem::whenKeyReleased (SDL_Scancode ){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
What to do when a key has been released. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _quitRequested\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:_quitRequested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::InputOSSystem::_quitRequested{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b OSIO.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::Instruction Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::Instruction}
{\xe \v F6500::Instruction}
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::Instruction:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::Instruction:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_absolute} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_zeroPage} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_absoluteX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_absoluteY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_zeroPageX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_zeroPageY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_indirectZeroPageX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_indirectZeroPageY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_indirect} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_inmediate} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_absolute} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_zeroPage} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_absoluteX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_absoluteY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_relative} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_zeroPageX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_zeroPageY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_indirectZeroPageX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_indirectZeroPageY} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Most of 6500 instruction inherits from this class because it includes diffrent access for any addrss mode. Always little-endian format and no more than 2 bytes for and address are values taken. \par
}{
Definition at line {\b 24} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Instruction\:F6500::Instruction}
{\xe \v F6500::Instruction\:Instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::Instruction::Instruction (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v address_absolute\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_absolute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_absolute (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2 parameters representing an address. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a200c88e5a9642d29d1a05d5bdeb3cca7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_absoluteX\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_absoluteX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_absoluteX (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2 parameters representing a base address. The final one is got adding the X register to the base. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a84564b51e93735f9168c140d65e856e3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_absoluteY\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_absoluteY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_absoluteY (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2 parameters representing a base address. The final one is got adding the Y register to the base. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a1c947fc95e524984c76a5808522ae80e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_indirect\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_indirect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_indirect (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2 parameters representint a base addreess. The final one is got at the position of that first base address. \par
}}
{\xe \v address_indirectZeroPageX\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_indirectZeroPageX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_indirectZeroPageX (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter representing a base address in page 0. The final one is got from the position in page 0 result of adding the X register to the base. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a06be01ccbf0c409819572d9cb6bc7b3f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_indirectZeroPageY\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_indirectZeroPageY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_indirectZeroPageY (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter representing a base address in page 0. The final one is got from the position in page 0 result of adding the X register to position found in the base. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_ab46ef4cf214245aa7d3ff75bc5769264_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_zeroPage\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_zeroPage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_zeroPage (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter representing an address in the page 0. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a9d5bf43bec88cc365b8527bdfce2382b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_zeroPageX\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_zeroPageX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_zeroPageX (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter representing a base address in page 0. The final one is got adding the X register to the base. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_ae948b408260616fc67dfb1c4a0cc22d3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_zeroPageY\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_zeroPageY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_zeroPageY (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter representing a base address in page 0. The final one is got adding the Y register to the base. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a550dcfea2e3677bc3c2884f67f1eeef9_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_absolute\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_absolute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_absolute (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a6ac1e32ee4e114a14d244aa83f391782_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_absoluteX\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_absoluteX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_absoluteX (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_aaad6c21a20539f0e8dad8791bcac23c0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_absoluteY\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_absoluteY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_absoluteY (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a567cb6bddb3dc359d02fccde15011759_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_indirectZeroPageX\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_indirectZeroPageX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_indirectZeroPageX (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_aece62f93531b34cbe8ecd99c249030e0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_indirectZeroPageY\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_indirectZeroPageY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_indirectZeroPageY (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_aaec87199ef5f8cbf52a2b0f0a132f92f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_inmediate\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_inmediate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_inmediate (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter with the value. \par
}}
{\xe \v value_relative\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_relative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_relative (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter that can be negative value. It us used in jumps. \par
}}
{\xe \v value_zeroPage\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_zeroPage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_zeroPage (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a8b042f8d4645bb49419a25b201123483_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_zeroPageX\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_zeroPageX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_zeroPageX (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a3f47b44d2da8080346ce906e4390645c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_zeroPageY\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_zeroPageY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_zeroPageY (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a62cbe9b05a382d52202fb46eccf97611_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Instruction Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction}
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
\par
{
{\f2 #include <Instruction.hpp>}}\par
Inheritance diagram for MCHEmul::Instruction:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_instruction__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Instruction:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_instruction__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Structure}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} (const {\b Instruction} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} & {\b operator=} (const {\b Instruction} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b code} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b memoryPositions} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b clockCycles} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b additionalClockCycles} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b iTemplate} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Structure} & {\b internalStructure} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b matchesWith} (const std::string &i, std::vector< std::string > &prms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UBytes} & {\b parameters} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UBytes} {\b parameters} (size_t p, size_t nP=1, bool bE=true) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b parametersAsString} (size_t p, size_t nP=1, bool bE=true) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b execute} (const {\b UBytes} &p, {\b CPU} *c, {\b Memory} *m, {\b Stack} *stk)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Structure} {\b analyzeInstruction} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b executeImpl} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPU} * {\b cpu} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} * {\b cpu} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Memory} * {\b memory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b memory} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Stack} * {\b stack} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Stack} * {\b stack} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b _code} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b _memoryPositions} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b _clockCycles} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _iTemplate}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Structure} {\b _iStructure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _additionalCycles}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Instruction} &i)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a instruction executed by a {\b CPU}. \par
}{
Definition at line {\b 27} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Instruction\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:Instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Instruction (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Instruction\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:Instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Instruction (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t})}}
\par
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{: The internal code of the instruction. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mp} \cell }{: The number of memory positions (in number of ubytes) occupied by the instruction (and params). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cc} \cell }{: The number of clock cyles the instruction uses to be executed (usually). \par
 Some ocassions, some instructions under certain circunstances can take longer than expected. \par
 \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
for so: _additionalClockCycles (method and variable). \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i t} \cell }{: The template of the instruction. \par
 The way it is defined is key for it to be read and understood by the parsers. \par
 The parameters should be within [] with two additional data: \par
 The type of the parameter, and the number of bytes that parameter occupies. \par
 Regarding the type: # means number, $ means address and & means relative jump (\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
type of parameter). \par
}}}}
{\xe \v Instruction\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:Instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Instruction (const {\b Instruction} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v additionalClockCycles\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:additionalClockCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Instruction::additionalClockCycles () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b Instruction.hpp}.}\par
}
{\xe \v analyzeInstruction\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:analyzeInstruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Structure} MCHEmul::Instruction::analyzeInstruction () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To analyze the structure of the instruction. \par
}}
{\xe \v asString\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Instruction::asString () const}}
\par
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v clockCycles\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:clockCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Instruction::clockCycles () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b Instruction.hpp}.}\par
}
{\xe \v code\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Instruction::code () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b Instruction.hpp}.}\par
}
{\xe \v cpu\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU} * MCHEmul::Instruction::cpu (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 145} of file {\b Instruction.hpp}.}\par
}
{\xe \v cpu\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPU} * MCHEmul::Instruction::cpu () const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b Instruction.hpp}.}\par
}
{\xe \v execute\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:execute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Instruction::execute (const {\b UBytes} &  {\i p}, {\b CPU} *  {\i c}, {\b Memory} *  {\i m}, {\b Stack} *  {\i stk})}}
\par
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To execute the instruction. It has to be redefined. \par
It returns true if everything is ok, \par
}}
{\xe \v executeImpl\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:executeImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Instruction::executeImpl (){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The implementation of the execution. It has to be redefined. \par
}}
{\xe \v internalStructure\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:internalStructure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Structure} & MCHEmul::Instruction::internalStructure () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b Instruction.hpp}.}\par
}
{\xe \v iTemplate\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:iTemplate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string MCHEmul::Instruction::iTemplate () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b Instruction.hpp}.}\par
}
{\xe \v matchesWith\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:matchesWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Instruction::matchesWith (const std::string &  {\i i}, std::vector< std::string > &  {\i prms})}}
\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know whether the instruction template matches of not with the example received. \par
Returns true when matches, and false when it doesn't. \par
When matches the parameter prms received is also filled. \par
When doesn't the parameter prms will have trash!. \par
}}
{\xe \v memory\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory} * MCHEmul::Instruction::memory (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b Instruction.hpp}.}\par
}
{\xe \v memory\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Memory} * MCHEmul::Instruction::memory () const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b Instruction.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_instruction_a32706ddfc9c7729c5fa5e826d2cc230f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v memoryPositions\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:memoryPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Instruction::memoryPositions () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b Instruction.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Instruction} & MCHEmul::Instruction::operator= (const {\b Instruction} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parameters\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UBytes} & MCHEmul::Instruction::parameters () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b Instruction.hpp}.}\par
}
{\xe \v parameters\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UBytes} MCHEmul::Instruction::parameters (size_t  {\i p}, size_t  {\i nP} = {\f2 1}, bool  {\i bE} = {\f2 true}) const}}
\par
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parametersAsString\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:parametersAsString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Instruction::parametersAsString (size_t  {\i p}, size_t  {\i nP} = {\f2 1}, bool  {\i bE} = {\f2 true}) const}}
\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v stack\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Stack} * MCHEmul::Instruction::stack (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b Instruction.hpp}.}\par
}
{\xe \v stack\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Stack} * MCHEmul::Instruction::stack () const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Instruction} &  {\i i}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _additionalCycles\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:_additionalCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Instruction::_additionalCycles{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b Instruction.hpp}.}\par
}
{\xe \v _clockCycles\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:_clockCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Instruction::_clockCycles = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b Instruction.hpp}.}\par
}
{\xe \v _code\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Instruction::_code = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b Instruction.hpp}.}\par
}
{\xe \v _iStructure\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:_iStructure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Structure} MCHEmul::Instruction::_iStructure{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b Instruction.hpp}.}\par
}
{\xe \v _iTemplate\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:_iTemplate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Instruction::_iTemplate{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 161} of file {\b Instruction.hpp}.}\par
}
{\xe \v _memoryPositions\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:_memoryPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Instruction::_memoryPositions = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Instruction.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::InstructionCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::InstructionCommandParser}
{\xe \v MCHEmul::Assembler::InstructionCommandParser}
{\bkmkstart AAAAAAACSE}
{\bkmkend AAAAAAACSE}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::InstructionCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_instruction_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::InstructionCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_instruction_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InstructionCommandParser} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *s) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser an instruction. \par
}{
Definition at line {\b 204} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InstructionCommandParser\:MCHEmul::Assembler::InstructionCommandParser}
{\xe \v MCHEmul::Assembler::InstructionCommandParser\:InstructionCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::InstructionCommandParser::InstructionCommandParser (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSF}
{\bkmkend AAAAAAACSF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 207} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::InstructionCommandParser}
{\xe \v MCHEmul::Assembler::InstructionCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::InstructionCommandParser::canParse (const std::string &  {\i l}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPR}
{\bkmkend AAAAAAACPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v initialize\:MCHEmul::Assembler::InstructionCommandParser}
{\xe \v MCHEmul::Assembler::InstructionCommandParser\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::InstructionCommandParser::initialize (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPV}
{\bkmkend AAAAAAACPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maybe one of them could need it. \par
}{
Reimplemented from {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 212} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::InstructionCommandParser}
{\xe \v MCHEmul::Assembler::InstructionCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::InstructionCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACQA}
{\bkmkend AAAAAAACQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::InstructionElement Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement}
{\bkmkstart AAAAAAACSG}
{\bkmkend AAAAAAACSG}
\par
{
{\f2 #include <Grammar.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::InstructionElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_instruction_element__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::InstructionElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_instruction_element__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InstructionElement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InstructionElement} (const {\b InstructionElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InstructionElement} & {\b operator=} (const {\b InstructionElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b size} (const {\b Semantic} *s) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasAnyLabelAsParameter} (const {\b Semantic} *s) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< size_t > {\b labelParameters} (const {\b Semantic} *s) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Instruction} * > {\b _possibleInstructions}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b _parameters}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} * {\b _selectedInstruction}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
explanation at the beggining of the file. An instruction is just also a set of bytes in memory. \par
}}}{
Definition at line {\b 197} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InstructionElement\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:InstructionElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::InstructionElement::InstructionElement (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSH}
{\bkmkend AAAAAAACSH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b Grammar.hpp}.}\par
}
{\xe \v InstructionElement\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:InstructionElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::InstructionElement::InstructionElement (const {\b InstructionElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACSI}
{\bkmkend AAAAAAACSI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v hasAnyLabelAsParameter\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:hasAnyLabelAsParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::InstructionElement::hasAnyLabelAsParameter (const {\b Semantic} *  {\i s}) const}}
\par
{\bkmkstart AAAAAAACSJ}
{\bkmkend AAAAAAACSJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know whether any of the parameters could be or not a label. \par
}}
{\xe \v labelParameters\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:labelParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< size_t > MCHEmul::Assembler::InstructionElement::labelParameters (const {\b Semantic} *  {\i s}) const}}
\par
{\bkmkstart AAAAAAACSK}
{\bkmkend AAAAAAACSK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know the list of the the parameters that could be a label. \par
}}
{\xe \v operator=\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InstructionElement} & MCHEmul::Assembler::InstructionElement::operator= (const {\b InstructionElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACSL}
{\bkmkend AAAAAAACSL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual size_t MCHEmul::Assembler::InstructionElement::size (const {\b Semantic} *  {\i s}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACRT}
{\bkmkend AAAAAAACRT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the size of the grammatical element in bytes. By default the bytes are calculated and then the size. \par
}{
Reimplemented from {\b MCHEmul::Assembler::GrammaticalElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACRS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _parameters\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:_parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<std::string> MCHEmul::Assembler::InstructionElement::_parameters}}
\par
{\bkmkstart AAAAAAACSM}
{\bkmkend AAAAAAACSM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 218} of file {\b Grammar.hpp}.}\par
}
{\xe \v _possibleInstructions\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:_possibleInstructions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b Instruction}*> MCHEmul::Assembler::InstructionElement::_possibleInstructions}}
\par
{\bkmkstart AAAAAAACSN}
{\bkmkend AAAAAAACSN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 217} of file {\b Grammar.hpp}.}\par
}
{\xe \v _selectedInstruction\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:_selectedInstruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Instruction}* MCHEmul::Assembler::InstructionElement::_selectedInstruction{\f2 [mutable]}}}
\par
{\bkmkstart AAAAAAACSO}
{\bkmkend AAAAAAACSO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 219} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::IODevice Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice}
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
\par
{
{\f2 #include <IO.hpp>}}\par
Inheritance diagram for MCHEmul::IODevice:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_o_device__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Type} \{ {\b _INPUT} = 0
, {\b _OUTPUT}
, {\b _INPUTOUTPUT}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} ({\b Type} t, int {\b id}, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} (const {\b IODevice} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} & {\b operator=} (const {\b IODevice} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IODevice} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Type} {\b type} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} & {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b attribute} (const std::string &aN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b linkToChips} (const {\b Chips} &c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Chips} & {\b chips} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b IOPeripherals} & {\b peripherals} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsPeripheral} (int {\b id}) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b addPeripheral} ({\b IOPeripheral} *p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removePeripheral} (int {\b id})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Type} {\b _type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chips} {\b _chips}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} {\b _attributes} = \{ \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripherals} {\b _peripherals}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b IODevice} &d)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class {\b IODevice} represents anything connected to any {\b Chip} of the motherboard. \par
The ports (RS232, Serial, IEEE, etc...) are typically elements comnnected to communication chips but also the screen or the keyboard. \par
Connected to a device there might be different peripherials. \par
For some specific devices (like screen or keyboard) the peripheral connected is "implicit" and there is no other way to add other different, but it has to be opened to other possibilities! \par
}{
Definition at line {\b 30} of file {\b IO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Type\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b MCHEmul::IODevice::Type}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _INPUT\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_INPUT}
{\qr _INPUT{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
\cell }{\cell }{\row }
{\xe \v _OUTPUT\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_OUTPUT}
{\qr _OUTPUT{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
\cell }{\cell }{\row }
{\xe \v _INPUTOUTPUT\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_INPUTOUTPUT}
{\qr _INPUTOUTPUT{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 33} of file {\b IO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IODevice\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:IODevice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IODevice::IODevice (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IODevice\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:IODevice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IODevice::IODevice ({\b Type}  {\i t}, int  {\i id}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}})}}
\par
{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IODevice\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:IODevice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IODevice::IODevice (const {\b IODevice} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~IODevice\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:~IODevice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::IODevice::~IODevice (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The device doesn't own the chips, only work with them. The device doesn't own the peripherals either. \par
}{
Definition at line {\b 45} of file {\b IO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addPeripheral\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:addPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::IODevice::addPeripheral ({\b IOPeripheral} *  {\i p}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To connect a peripheral. If either there had been a peripheral with the same id already connected or the peripheral were not valid, nothing would happen. \par
The method can be overloaded to check (e.g) compability before adding it. \par
}{
Reimplemented in {\b C64::UserIOPort} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v attribute\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::IODevice::attribute (const std::string &  {\i aN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b IO.hpp}.}\par
}
{\xe \v attributes\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} & MCHEmul::IODevice::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b IO.hpp}.}\par
}
{\xe \v chips\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:chips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Chips} & MCHEmul::IODevice::chips () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b IO.hpp}.}\par
}
{\xe \v existsPeripheral\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:existsPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::IODevice::existsPeripheral (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b IO.hpp}.}\par
}
{\xe \v id\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::IODevice::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b IO.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::IODevice::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the device. \par
}{
Reimplemented in {\b MCHEmul::InputOSSystem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABPY \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::Screen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABTA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v lastError\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::IODevice::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the last error happend (after initialize or simulate methods). \par
}{
Definition at line {\b 89} of file {\b IO.hpp}.}\par
}
{\xe \v linkToChips\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:linkToChips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::IODevice::linkToChips (const {\b Chips} &  {\i c}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To link to the right chips. The IO device never owns the chips. By default all chips are linked. \par
}{
Reimplemented in {\b MCHEmul::Screen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABTC \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b C64::InputOSSystem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 63} of file {\b IO.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IODevice} & MCHEmul::IODevice::operator= (const {\b IODevice} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v peripherals\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:peripherals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b IOPeripherals} & MCHEmul::IODevice::peripherals () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b IO.hpp}.}\par
}
{\xe \v removePeripheral\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:removePeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::IODevice::removePeripheral (int  {\i id})}}
\par
{\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To remove a Peripheral. if the peripheral doesn't exist nothing happens. \par
}}
{\xe \v simulate\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::IODevice::simulate (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To emulate the way it works. \par
Return true, if everything was ok. \par
}{
Reimplemented in {\b MCHEmul::InputOSSystem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQB \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::Screen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABTG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v type\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Type} MCHEmul::IODevice::type () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b IO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b IODevice} &  {\i d}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _attributes\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} MCHEmul::IODevice::_attributes = \{ \}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b IO.hpp}.}\par
}
{\xe \v _chips\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_chips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Chips} MCHEmul::IODevice::_chips{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b IO.hpp}.}\par
}
{\xe \v _id\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int MCHEmul::IODevice::_id{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b IO.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::IODevice::_lastError{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b IO.hpp}.}\par
}
{\xe \v _peripherals\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_peripherals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IOPeripherals} MCHEmul::IODevice::_peripherals{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b IO.hpp}.}\par
}
{\xe \v _type\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Type} MCHEmul::IODevice::_type{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b IO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b IO.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::IOPeripheral Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral}
{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
\par
{
{\f2 #include <IOPeripheral.hpp>}}\par
Inheritance diagram for MCHEmul::IOPeripheral:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_o_peripheral__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::IOPeripheral:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_o_peripheral__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheral} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheral} (int {\b id}, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheral} (const {\b IOPeripheral} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheral} & {\b operator=} (const {\b IOPeripheral} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IOPeripheral} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} & {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b attribute} (const std::string &aN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b IODevice} * {\b device} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} * {\b device} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ()=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b IODevice}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} {\b _attributes} = \{ \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} * {\b _device}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b IOPeripheral} &d)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b IOPeripheral} represents an element connected to a {\b IODevice}. \par
For some IODevices the number and type (and manufacturers) of elements that can be connected might be wide and different. \par
And the simulation of each can even be very different. \par
This is the reason to represent them in a separate class. \par
}{
Definition at line {\b 27} of file {\b IOPeripheral.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IOPeripheral\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:IOPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IOPeripheral::IOPeripheral (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IOPeripheral\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:IOPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IOPeripheral::IOPeripheral (int  {\i id}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set when attached. \par
}{
Definition at line {\b 34} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v IOPeripheral\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:IOPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IOPeripheral::IOPeripheral (const {\b IOPeripheral} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~IOPeripheral\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:~IOPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::IOPeripheral::~IOPeripheral (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b IOPeripheral.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attribute\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::IOPeripheral::attribute (const std::string &  {\i aN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v attributes\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} & MCHEmul::IOPeripheral::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v device\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IODevice} * MCHEmul::IOPeripheral::device (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v device\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b IODevice} * MCHEmul::IOPeripheral::device () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v id\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::IOPeripheral::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::IOPeripheral::initialize (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the peripheral. The initialization should return true when everything is ok, and false in other case. \par
}{
Implemented in {\b C64::UserIONoPeripheral} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IOPeripheral} & MCHEmul::IOPeripheral::operator= (const {\b IOPeripheral} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v simulate\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::IOPeripheral::simulate (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To emulate the way it works. \par
Should return true if everything was ok. \par
}{
Implemented in {\b C64::UserIONoPeripheral} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b IOPeripheral} &  {\i d}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _attributes\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} MCHEmul::IOPeripheral::_attributes = \{ \}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v _device\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IODevice}* MCHEmul::IOPeripheral::_device{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Accesed from {\b IODevice} when a peripherial is added! \par
}{
Definition at line {\b 73} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v _id\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int MCHEmul::IOPeripheral::_id{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v IODevice\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:IODevice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend MCHEmul::IOPeripheral::IODevice}}
\par
{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b IOPeripheral.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b IOPeripheral.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::IOPeripheralBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::IOPeripheralBuilder}
{\xe \v C64::IOPeripheralBuilder}
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
\par
{
{\f2 #include <IOPBuilder.hpp>}}\par
Inheritance diagram for C64::IOPeripheralBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_i_o_peripheral_builder__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::IOPeripheralBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_i_o_peripheral_builder__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheralBuilder} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::IOPeripheral} * {\b createPeripheral} (int id, const {\b MCHEmul::Attributes} &prms) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It can be even extende to add new peripherals. \par
}{
Definition at line {\b 22} of file {\b IOPBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IOPeripheralBuilder\:C64::IOPeripheralBuilder}
{\xe \v C64::IOPeripheralBuilder\:IOPeripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::IOPeripheralBuilder::IOPeripheralBuilder (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b IOPBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createPeripheral\:C64::IOPeripheralBuilder}
{\xe \v C64::IOPeripheralBuilder\:createPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::IOPeripheral} * C64::IOPeripheralBuilder::createPeripheral (int  {\i id}, const {\b MCHEmul::Attributes} &  {\i prms}) const{\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method must be overloaded to include any new type of peripherals. \par
}{
Implements {\b MCHEmul::IOPeripheralBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b IOPBuilder.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::IOPeripheralBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder}
{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
\par
{
{\f2 #include <IOPBuilder.hpp>}}\par
Inheritance diagram for MCHEmul::IOPeripheralBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_o_peripheral_builder__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheralBuilder} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheralBuilder} (const {\b IOPeripheralBuilder} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheralBuilder} & {\b operator=} (const {\b IOPeripheralBuilder} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IOPeripheralBuilder} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheral} * {\b peripheral} (int id, const {\b Attributes} &attrs) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b IOPeripheral} * {\b createPeripheral} (int id, const {\b Attributes} &prms) const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripherals} {\b _peripherals}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This builder is to create any type of peripherical that might be connected to the computer simulated. \par
The builder is the owner of the periphericals created, and they will be deleted as this object is also deleted. \par
}{
Definition at line {\b 25} of file {\b IOPBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IOPeripheralBuilder\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:IOPeripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IOPeripheralBuilder::IOPeripheralBuilder (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IOPeripheralBuilder\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:IOPeripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IOPeripheralBuilder::IOPeripheralBuilder (const {\b IOPeripheralBuilder} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~IOPeripheralBuilder\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:~IOPeripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::IOPeripheralBuilder::~IOPeripheralBuilder (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b IOPBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createPeripheral\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:createPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b IOPeripheral} * MCHEmul::IOPeripheralBuilder::createPeripheral (int  {\i id}, const {\b Attributes} &  {\i prms}) const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method must be overloaded to include any new type of peripherals. \par
}{
Implemented in {\b C64::IOPeripheralBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IOPeripheralBuilder} & MCHEmul::IOPeripheralBuilder::operator= (const {\b IOPeripheralBuilder} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v peripheral\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:peripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IOPeripheral} * MCHEmul::IOPeripheralBuilder::peripheral (int  {\i id}, const {\b Attributes} &  {\i attrs}) const}}
\par
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the peripherical requeted already existed (one with the same id) a reference to it would be returned, otherwise it sill created...if any! \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _peripherals\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:_peripherals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IOPeripherals} MCHEmul::IOPeripheralBuilder::_peripherals{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b IOPBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b IOPBuilder.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::IPAddress Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress}
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
\par
{
{\f2 #include <IPAddress.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IPAddress} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IPAddress} (unsigned char a, unsigned char b, unsigned char c, unsigned char d, unsigned short p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IPAddress} (const std::string &ip)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IPAddress} (const {\b IPAddress} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IPAddress} & {\b operator=} (const {\b IPAddress} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b byte1} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b byte2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b byte3} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b byte4} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b port} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b ipAsString} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b error} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b IPAddress} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b IPAddress} &a) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b IPAddress} &a)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IP {\b Address}. V4 Format. Can have an error when creating from strring. \par
}{
Definition at line {\b 22} of file {\b IPAddress.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IPAddress\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:IPAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IPAddress::IPAddress (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b IPAddress.hpp}.}\par
}
{\xe \v IPAddress\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:IPAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IPAddress::IPAddress (unsigned char  {\i a}, unsigned char  {\i b}, unsigned char  {\i c}, unsigned char  {\i d}, unsigned short  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b IPAddress.hpp}.}\par
}
{\xe \v IPAddress\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:IPAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IPAddress::IPAddress (const std::string &  {\i ip})}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IPAddress\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:IPAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IPAddress::IPAddress (const {\b IPAddress} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asString\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::IPAddress::asString () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b IPAddress.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_p_address_a93318dd6cf00cbb4a20b9ec47bd4a5b9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v byte1\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:byte1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::IPAddress::byte1 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The parts of the ip address \par
}{
Definition at line {\b 40} of file {\b IPAddress.hpp}.}\par
}
{\xe \v byte2\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:byte2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::IPAddress::byte2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b IPAddress.hpp}.}\par
}
{\xe \v byte3\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:byte3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::IPAddress::byte3 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b IPAddress.hpp}.}\par
}
{\xe \v byte4\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:byte4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::IPAddress::byte4 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b IPAddress.hpp}.}\par
}
{\xe \v error\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::IPAddress::error () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b IPAddress.hpp}.}\par
}
{\xe \v ipAsString\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:ipAsString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::IPAddress::ipAsString () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b IPAddress.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_p_address_ada639a2780dbca99614fd0ec955eea4b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::IPAddress::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To make it more readable whether there is an error. \par
}{
Definition at line {\b 60} of file {\b IPAddress.hpp}.}\par
}
{\xe \v operator!=\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b MCHEmul::IPAddress::operator!}= (const {\b IPAddress} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b IPAddress.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IPAddress} & MCHEmul::IPAddress::operator= (const {\b IPAddress} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::IPAddress::operator== (const {\b IPAddress} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b IPAddress.hpp}.}\par
}
{\xe \v port\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short MCHEmul::IPAddress::port () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b IPAddress.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b IPAddress} &  {\i a}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b IPAddress.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b IPAddress.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::IRQInterrupt Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::IRQInterrupt}
{\xe \v F6500::IRQInterrupt}
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
\par
{
{\f2 #include <IRQInterrupt.hpp>}}\par
Inheritance diagram for F6500::IRQInterrupt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_i_r_q_interrupt__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::IRQInterrupt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_i_r_q_interrupt__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IRQInterrupt} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _ID} = 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isTime} ({\b MCHEmul::CPU} *c) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b executeOverImpl} ({\b MCHEmul::CPU} *c, unsigned int &nC) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Maskarable Interrupt. It could be avoided using the bit I of the status flag. \par
}{
Definition at line {\b 22} of file {\b IRQInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IRQInterrupt\:F6500::IRQInterrupt}
{\xe \v F6500::IRQInterrupt\:IRQInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::IRQInterrupt::IRQInterrupt (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b IRQInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOverImpl\:F6500::IRQInterrupt}
{\xe \v F6500::IRQInterrupt\:executeOverImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void F6500::IRQInterrupt::executeOverImpl ({\b MCHEmul::CPU} *  {\i c}, unsigned int &  {\i nC}){\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To really execute the interrupt. \par
 This must be overloaded by the real interrupt. \par
}{
Implements {\b MCHEmul::CPUInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABDN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isTime\:F6500::IRQInterrupt}
{\xe \v F6500::IRQInterrupt\:isTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool F6500::IRQInterrupt::isTime ({\b MCHEmul::CPU} *  {\i c}) const{\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only when the status flag B allows it. It is a Maskarable Interrupt. \par
}{
Implements {\b MCHEmul::CPUInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABDP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:F6500::IRQInterrupt}
{\xe \v F6500::IRQInterrupt\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int F6500::IRQInterrupt::_ID = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b IRQInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b IRQInterrupt.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::LabelCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::LabelCommandParser}
{\xe \v MCHEmul::Assembler::LabelCommandParser}
{\bkmkstart AAAAAAACSP}
{\bkmkend AAAAAAACSP}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::LabelCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_label_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::LabelCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_label_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LabelCommandParser} (unsigned char s=':')\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *s) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser a label. \par
}{
Definition at line {\b 157} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LabelCommandParser\:MCHEmul::Assembler::LabelCommandParser}
{\xe \v MCHEmul::Assembler::LabelCommandParser\:LabelCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::LabelCommandParser::LabelCommandParser (unsigned char  {\i s} = {\f2 ':'}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSQ}
{\bkmkend AAAAAAACSQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::LabelCommandParser}
{\xe \v MCHEmul::Assembler::LabelCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::LabelCommandParser::canParse (const std::string &  {\i l}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPQ}
{\bkmkend AAAAAAACPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 169} of file {\b Parser.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_label_command_parser_a213a3173bab02eed6cac1ad99b4fe217_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::Assembler::LabelCommandParser}
{\xe \v MCHEmul::Assembler::LabelCommandParser\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::LabelCommandParser::initialize (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPU}
{\bkmkend AAAAAAACPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maybe one of them could need it. \par
}{
Reimplemented from {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 166} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::LabelCommandParser}
{\xe \v MCHEmul::Assembler::LabelCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::LabelCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPZ}
{\bkmkend AAAAAAACPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::LabelElement Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::LabelElement}
{\xe \v MCHEmul::Assembler::LabelElement}
{\bkmkstart AAAAAAACSR}
{\bkmkend AAAAAAACSR}
\par
{
{\f2 #include <Grammar.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::LabelElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_label_element__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::LabelElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_label_element__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LabelElement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LabelElement} (const {\b LabelElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LabelElement} & {\b operator=} (const {\b LabelElement} &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _name}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
explanation at the beggining of the file. \par
}}}{
Definition at line {\b 164} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LabelElement\:MCHEmul::Assembler::LabelElement}
{\xe \v MCHEmul::Assembler::LabelElement\:LabelElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::LabelElement::LabelElement (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSS}
{\bkmkend AAAAAAACSS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b Grammar.hpp}.}\par
}
{\xe \v LabelElement\:MCHEmul::Assembler::LabelElement}
{\xe \v MCHEmul::Assembler::LabelElement\:LabelElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::LabelElement::LabelElement (const {\b LabelElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACST}
{\bkmkend AAAAAAACST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:MCHEmul::Assembler::LabelElement}
{\xe \v MCHEmul::Assembler::LabelElement\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LabelElement} & MCHEmul::Assembler::LabelElement::operator= (const {\b LabelElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACSU}
{\bkmkend AAAAAAACSU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _name\:MCHEmul::Assembler::LabelElement}
{\xe \v MCHEmul::Assembler::LabelElement\:_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Assembler::LabelElement::_name}}
\par
{\bkmkstart AAAAAAACSV}
{\bkmkend AAAAAAACSV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 175} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::LDA_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::LDA_General}
{\xe \v F6500::LDA_General}
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::LDA_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_a___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::LDA_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_a___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LDA_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b LDA_General}: To aggregate common steps in every LDA instruction. \par
}{
Definition at line {\b 335} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LDA_General\:F6500::LDA_General}
{\xe \v F6500::LDA_General\:LDA_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::LDA_General::LDA_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 338} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::LDA_General}
{\xe \v F6500::LDA_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::LDA_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::LDX_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::LDX_General}
{\xe \v F6500::LDX_General}
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::LDX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_x___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::LDX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_x___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LDX_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b LDX_General}: To aggregate common steps in every LDX instruction. \par
}{
Definition at line {\b 357} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LDX_General\:F6500::LDX_General}
{\xe \v F6500::LDX_General\:LDX_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::LDX_General::LDX_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 360} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::LDX_General}
{\xe \v F6500::LDX_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::LDX_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::LDY_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::LDY_General}
{\xe \v F6500::LDY_General}
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::LDY_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_y___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::LDY_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_y___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LDY_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b LDY_General}: To aggregate common steps in every LDY instruction. \par
}{
Definition at line {\b 376} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LDY_General\:F6500::LDY_General}
{\xe \v F6500::LDY_General\:LDY_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::LDY_General::LDY_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 379} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::LDY_General}
{\xe \v F6500::LDY_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::LDY_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::LSR_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::LSR_General}
{\xe \v F6500::LSR_General}
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::LSR_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_s_r___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::LSR_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_s_r___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LSR_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b LSR_General}: To aggregate common steps in every LSR instruction. \par
}{
Definition at line {\b 395} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LSR_General\:F6500::LSR_General}
{\xe \v F6500::LSR_General\:LSR_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::LSR_General::LSR_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 398} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::LSR_General}
{\xe \v F6500::LSR_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::LSR_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::Macro Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro}
{\bkmkstart AAAAAAACSW}
{\bkmkend AAAAAAACSW}
\par
{
{\f2 #include <Grammar.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Macro} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Macro} (const std::string &n, const std::string &e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Macro} (const {\b Macro} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Macro} & {\b operator=} (const {\b Macro} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b name} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b equivalent} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ErrorType} {\b error} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< {\b UByte} > & {\b value} (const {\b Macros} &ms) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 47} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Macro\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:Macro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Macro::Macro (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSX}
{\bkmkend AAAAAAACSX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Grammar.hpp}.}\par
}
{\xe \v Macro\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:Macro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Macro::Macro (const std::string &  {\i n}, const std::string &  {\i e}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSY}
{\bkmkend AAAAAAACSY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b Grammar.hpp}.}\par
}
{\xe \v Macro\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:Macro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Macro::Macro (const {\b Macro} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACSZ}
{\bkmkend AAAAAAACSZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v equivalent\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:equivalent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::Assembler::Macro::equivalent () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTA}
{\bkmkend AAAAAAACTA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b Grammar.hpp}.}\par
}
{\xe \v error\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ErrorType} MCHEmul::Assembler::Macro::error () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTB}
{\bkmkend AAAAAAACTB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b Grammar.hpp}.}\par
}
{\xe \v name\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::Assembler::Macro::name () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTC}
{\bkmkend AAAAAAACTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b Grammar.hpp}.}\par
}
{\xe \v operator!\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::Macro::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTD}
{\bkmkend AAAAAAACTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To make more visual the analysis of the status of macro. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculated already?\par
}{
Definition at line {\b 80} of file {\b Grammar.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_macro_aed324c5b4bef778f159cd333f5e03ade_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Macro} & MCHEmul::Assembler::Macro::operator= (const {\b Macro} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACTE}
{\bkmkend AAAAAAACTE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< {\b UByte} > & MCHEmul::Assembler::Macro::value (const {\b Macros} &  {\i ms}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTF}
{\bkmkend AAAAAAACTF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the value of the macro taking into account potential relations with other macros. \par
The first time it is invoked the very real value is calculated if possible. \par
The variable _error will point whether there was and error in the calculus. \par
}{
Definition at line {\b 76} of file {\b Grammar.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_macro_a03c8a569df97a731517cb97f2572c1f8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::MacroCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::MacroCommandParser}
{\xe \v MCHEmul::Assembler::MacroCommandParser}
{\bkmkstart AAAAAAACTG}
{\bkmkend AAAAAAACTG}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::MacroCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_macro_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::MacroCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_macro_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MacroCommandParser} (unsigned char s='=')\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *s) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned char {\b _symbol} = '='\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser a macro. The symbol defining the separation between definition and value can be redefined. \par
}{
Definition at line {\b 112} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MacroCommandParser\:MCHEmul::Assembler::MacroCommandParser}
{\xe \v MCHEmul::Assembler::MacroCommandParser\:MacroCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::MacroCommandParser::MacroCommandParser (unsigned char  {\i s} = {\f2 '='}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTH}
{\bkmkend AAAAAAACTH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::MacroCommandParser}
{\xe \v MCHEmul::Assembler::MacroCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::MacroCommandParser::canParse (const std::string &  {\i l}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPO}
{\bkmkend AAAAAAACPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 120} of file {\b Parser.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_macro_command_parser_a3605d61309f0b17bb8956de0165ee179_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v parse\:MCHEmul::Assembler::MacroCommandParser}
{\xe \v MCHEmul::Assembler::MacroCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::MacroCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPX}
{\bkmkend AAAAAAACPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _symbol\:MCHEmul::Assembler::MacroCommandParser}
{\xe \v MCHEmul::Assembler::MacroCommandParser\:_symbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::Assembler::MacroCommandParser::_symbol = '='{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACTI}
{\bkmkend AAAAAAACTI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::Memory Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::Memory}
{\xe \v C64::Memory}
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
\par
{
{\f2 #include <Memory.hpp>}}\par
Inheritance diagram for C64::Memory:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_memory__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::Memory:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_memory__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVICIIView} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _RAM} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BASICROM} = 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _CHARROM} = 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _KERNELROM} = 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _PAGEZERO_SUBSET} = 100\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _STACK_SUBSET} = 101\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _RAM0_SUBSET} = 102\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BASICROM_SUBSET} = 103\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BASICRAM_SUBSET} = 104\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _RAM1_SUBSET} = 105\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _CHARROM_SUBSET} = 106\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _VICREGS_SUBSET} = 107\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _SIDREGS_SUBSET} = 108\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _COLOR_SUBSET} = 109\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _CIA1_SUBSET} = 110\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _CIA2_SUBSET} = 111\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _IO1_SUBSET} = 112\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _IO2_SUBSET} = 113\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _KERNELROM_SUBSET} = 114\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _KERNELRAM_SUBSET} = 115\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK0RAM0_SUBSET} = 200\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK0CHARROM_SUBSET} = 201\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK0RAM1_SUBSET} = 202\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK1RAM_SUBSET} = 203\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK2RAM0_SUBSET} = 204\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK2CHARROM_SUBSET} = 205\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK2RAM1_SUBSET} = 206\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK3RAM_SUBSET} = 207\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _CPU_VIEW} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _VICII_VIEW} = 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The memory itself for the commodore 64... \par
}{
Definition at line {\b 22} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Memory\:C64::Memory}
{\xe \v C64::Memory\:Memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::Memory::Memory ()}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::Memory}
{\xe \v C64::Memory\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool C64::Memory::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To activate the right subsets in the CPU view. \par
}{
Reimplemented from {\b MCHEmul::Memory} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v setVICIIView\:C64::Memory}
{\xe \v C64::Memory\:setVICIIView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::Memory::setVICIIView (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To set the {\b VICII} view, useb by the {\b VICII}. \par
}{
Definition at line {\b 66} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _BANK0CHARROM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK0CHARROM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK0CHARROM_SUBSET = 201{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK0RAM0_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK0RAM0_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK0RAM0_SUBSET = 200{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK0RAM1_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK0RAM1_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK0RAM1_SUBSET = 202{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK1RAM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK1RAM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK1RAM_SUBSET = 203{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK2CHARROM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK2CHARROM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK2CHARROM_SUBSET = 205{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK2RAM0_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK2RAM0_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK2RAM0_SUBSET = 204{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK2RAM1_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK2RAM1_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK2RAM1_SUBSET = 206{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK3RAM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK3RAM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK3RAM_SUBSET = 207{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b Memory.hpp}.}\par
}
{\xe \v _BASICRAM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BASICRAM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BASICRAM_SUBSET = 104{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b Memory.hpp}.}\par
}
{\xe \v _BASICROM\:C64::Memory}
{\xe \v C64::Memory\:_BASICROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BASICROM = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b Memory.hpp}.}\par
}
{\xe \v _BASICROM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BASICROM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BASICROM_SUBSET = 103{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b Memory.hpp}.}\par
}
{\xe \v _CHARROM\:C64::Memory}
{\xe \v C64::Memory\:_CHARROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_CHARROM = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b Memory.hpp}.}\par
}
{\xe \v _CHARROM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_CHARROM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_CHARROM_SUBSET = 106{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b Memory.hpp}.}\par
}
{\xe \v _CIA1_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_CIA1_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_CIA1_SUBSET = 110{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b Memory.hpp}.}\par
}
{\xe \v _CIA2_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_CIA2_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_CIA2_SUBSET = 111{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b Memory.hpp}.}\par
}
{\xe \v _COLOR_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_COLOR_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_COLOR_SUBSET = 109{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b Memory.hpp}.}\par
}
{\xe \v _CPU_VIEW\:C64::Memory}
{\xe \v C64::Memory\:_CPU_VIEW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_CPU_VIEW = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b Memory.hpp}.}\par
}
{\xe \v _IO1_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_IO1_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_IO1_SUBSET = 112{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b Memory.hpp}.}\par
}
{\xe \v _IO2_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_IO2_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_IO2_SUBSET = 113{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Memory.hpp}.}\par
}
{\xe \v _KERNELRAM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_KERNELRAM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_KERNELRAM_SUBSET = 115{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b Memory.hpp}.}\par
}
{\xe \v _KERNELROM\:C64::Memory}
{\xe \v C64::Memory\:_KERNELROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_KERNELROM = 3{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b Memory.hpp}.}\par
}
{\xe \v _KERNELROM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_KERNELROM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_KERNELROM_SUBSET = 114{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b Memory.hpp}.}\par
}
{\xe \v _PAGEZERO_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_PAGEZERO_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_PAGEZERO_SUBSET = 100{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b Memory.hpp}.}\par
}
{\xe \v _RAM\:C64::Memory}
{\xe \v C64::Memory\:_RAM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_RAM = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b Memory.hpp}.}\par
}
{\xe \v _RAM0_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_RAM0_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_RAM0_SUBSET = 102{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b Memory.hpp}.}\par
}
{\xe \v _RAM1_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_RAM1_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_RAM1_SUBSET = 105{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b Memory.hpp}.}\par
}
{\xe \v _SIDREGS_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_SIDREGS_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_SIDREGS_SUBSET = 108{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b Memory.hpp}.}\par
}
{\xe \v _STACK_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_STACK_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_STACK_SUBSET = 101{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b Memory.hpp}.}\par
}
{\xe \v _VICII_VIEW\:C64::Memory}
{\xe \v C64::Memory\:_VICII_VIEW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_VICII_VIEW = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b Memory.hpp}.}\par
}
{\xe \v _VICREGS_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_VICREGS_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_VICREGS_SUBSET = 107{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b Memory.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Memory Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Memory}
{\xe \v MCHEmul::Memory}
{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
\par
{
{\f2 #include <Memory.hpp>}}\par
Inheritance diagram for MCHEmul::Memory:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Memory:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Content}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} (const {\b Content} &cnt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} (const {\b Memory} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} & {\b operator=} (const {\b Memory} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Memory} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorages} & {\b phisicalStorages} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsPhisicalStorage} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorage} * {\b phisicalStorage} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} * {\b phisicalStorage} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorageSubsets} & {\b Subsets} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsSubset} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorageSubset} * {\b subset} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} * {\b subset} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MemoryViews} & {\b views} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsView} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MemoryView} * {\b view} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} * {\b view} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MemoryView} * {\b activeView} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} * {\b activeView} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setActiveView} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isIn} (const {\b Address} &a, int &dt) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Stack} * {\b stack} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Stack} * {\b stack} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCPUView} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UByte} & {\b value} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const {\b UByte} &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b values} (const {\b Address} &a, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const {\b UBytes} &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b bytes} (const {\b Address} &a, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const std::vector< {\b UByte} > &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadInto} (const std::string &fN, const {\b Address} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetErrors} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Stack} * {\b lookForStack} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MemoryView} * {\b lookForCPUView} ()=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Content} {\b _content}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} * {\b _activeView}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Stack} * {\b _stack}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} * {\b _cpuView}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Memory} &m)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A memory is just an agregation of eveytthing above: phisical storages, subsets and views. \par
A view has to de declared as the active one. \par
All accesses will be done throught out that active view. \par
This gives the user the possible to have different "views" of the memory in different moments of the execution of the main cycle from, e.g. different elements in the {\b CPU}. \par
}{
Definition at line {\b 293} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Memory\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:Memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::Memory (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Memory\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:Memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::Memory (const {\b Content} &  {\i cnt})}}
\par
{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Memory\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:Memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::Memory (const {\b Memory} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Memory\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:~Memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::~Memory ()}}
\par
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v activeView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:activeView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView} * MCHEmul::Memory::activeView (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 401} of file {\b Memory.hpp}.}\par
}
{\xe \v activeView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:activeView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MemoryView} * MCHEmul::Memory::activeView () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 399} of file {\b Memory.hpp}.}\par
}
{\xe \v bytes\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b UByte} > MCHEmul::Memory::bytes (const {\b Address} &  {\i a}, size_t  {\i nB}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 429} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a036a65fb88cdb72dd63748b304527d83_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a036a65fb88cdb72dd63748b304527d83_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsPhisicalStorage\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:existsPhisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::existsPhisicalStorage (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 373} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ab294be0897a52fb9528d16acd7e696e3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsSubset\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:existsSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::existsSubset (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 382} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a9edb93cabefc3871a2cb0d41a8daabcd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:existsView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::existsView (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 391} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a7428fe90a5918913c9829af09a37907a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a7428fe90a5918913c9829af09a37907a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Memory::initialize (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It can be overloaded later, to set the specific content of specific zones. \par
By default only subsets have to be initialized, and all of them become active and also active for reading. \par
}{
Reimplemented in {\b C64::Memory} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 436} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ae86228095efa537b295ee8059aba7946_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isIn\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:isIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::isIn (const {\b Address} &  {\i a}, int &  {\i dt}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 406} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_aa5a8838b4fb5a73e3175ea38bdbbcc30_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_aa5a8838b4fb5a73e3175ea38bdbbcc30_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v lastError\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Memory::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the last error happend (usually at construction level) \par
}{
Definition at line {\b 443} of file {\b Memory.hpp}.}\par
}
{\xe \v loadInto\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:loadInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::loadInto (const std::string &  {\i fN}, const {\b Address} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 439} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_aaf28a195f180da4795746ab51c135070_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_aaf28a195f180da4795746ab51c135070_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v lookForCPUView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:lookForCPUView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MemoryView} * MCHEmul::Memory::lookForCPUView (){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ac8e522f499e969320701fdb1d06c637f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v lookForStack\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:lookForStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b Stack} * MCHEmul::Memory::lookForStack (){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_af9cb45e51cbfadb536877df42b5e51f4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory} & MCHEmul::Memory::operator= (const {\b Memory} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v phisicalStorage\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorage} * MCHEmul::Memory::phisicalStorage (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 377} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a54c429d2971e105d742f7fef6e74076a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v phisicalStorage\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorage} * MCHEmul::Memory::phisicalStorage (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 375} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a86143be6b3cc1a95f9d99d76f3814da6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v phisicalStorages\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:phisicalStorages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorages} & MCHEmul::Memory::phisicalStorages () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 371} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a1f4c92d7372028ef49c682d8b49b8e69_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v resetErrors\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:resetErrors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Memory::resetErrors (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 445} of file {\b Memory.hpp}.}\par
}
{\xe \v set\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Memory::set (const {\b Address} &  {\i a}, const std::vector< {\b UByte} > &  {\i v}, bool  {\i f} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 431} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a56171dad06eb8b4c72f99f60fe478e45_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Memory::set (const {\b Address} &  {\i a}, const {\b UByte} &  {\i v}, bool  {\i f} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{To force even when it is a rom. \cell }
{\row }
}
}{
Definition at line {\b 423} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a4b67f0da6600c11c3641134d0617860b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a4b67f0da6600c11c3641134d0617860b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Memory::set (const {\b Address} &  {\i a}, const {\b UBytes} &  {\i v}, bool  {\i f} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 427} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_adbd620564981bb4dbd40eb1c9511c81e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setActiveView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:setActiveView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Memory::setActiveView (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 403} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a7f3385216cdb963b345abc250d927ed9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setCPUView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:setCPUView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Memory::setCPUView (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To set the {\b CPU} view. This is important for the right {\b CPU} behivour. \par
}{
Definition at line {\b 418} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a69948361a4afe1cbf632b2541c136925_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v stack\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Stack} * MCHEmul::Memory::stack (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 413} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a16012beda33bac5b86094470b4d71477_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v stack\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Stack} * MCHEmul::Memory::stack () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the stack space reserve in the memory. This is something every implementation must define. \par
}{
Definition at line {\b 411} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a8db3a2f0eabf3254e9e6c52e183f8517_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a8db3a2f0eabf3254e9e6c52e183f8517_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subset\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:subset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorageSubset} * MCHEmul::Memory::subset (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 386} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a94ce6e3017290eaaa633898896c1cfb1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subset\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:subset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorageSubset} * MCHEmul::Memory::subset (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 384} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a223ed1aacea29bf69f3c1780b83bb30e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Subsets\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:Subsets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorageSubsets} & MCHEmul::Memory::Subsets () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 380} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a6fd72110868fc963c12aee3fb2f98e55_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UByte} & MCHEmul::Memory::value (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 421} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ad4321644dcebd71bd231f1e9d77c158f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ad4321644dcebd71bd231f1e9d77c158f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v values\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::Memory::values (const {\b Address} &  {\i a}, size_t  {\i nB}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 425} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ac147db5af50628440739732ead9e2f01_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ac147db5af50628440739732ead9e2f01_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v view\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:view}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView} * MCHEmul::Memory::view (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 395} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a183be49bca41775ec13133b79ddee315_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v view\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:view}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MemoryView} * MCHEmul::Memory::view (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 393} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a49b480a4471583d77b53274b82cee3a1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a49b480a4471583d77b53274b82cee3a1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v views\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:views}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MemoryViews} & MCHEmul::Memory::views () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 389} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_aad9162029831812736339fa28debbe9c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Memory} &  {\i m}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _activeView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:_activeView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView}* MCHEmul::Memory::_activeView{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 458} of file {\b Memory.hpp}.}\par
}
{\xe \v _content\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:_content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Content} MCHEmul::Memory::_content{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 455} of file {\b Memory.hpp}.}\par
}
{\xe \v _cpuView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:_cpuView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView}* MCHEmul::Memory::_cpuView{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 460} of file {\b Memory.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Memory::_lastError{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 461} of file {\b Memory.hpp}.}\par
}
{\xe \v _stack\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:_stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Stack}* MCHEmul::Memory::_stack{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 459} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Memory.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::MemoryView Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView}
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
\par
{
{\f2 #include <Memory.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} (int {\b id}, {\b PhisicalStorageSubsets} ss)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} (const {\b MemoryView} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MemoryView} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} & {\b operator=} (const {\b MemoryView} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorageSubsets} & {\b subsets} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsSubset} (int {\b id}) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorageSubset} * {\b subset} (int {\b id}) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} * {\b subset} (int {\b id})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isIn} (const {\b Address} &a, int &dt) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const {\b UByte} &d, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UByte} & {\b value} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b values} (const {\b Address} &a, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const {\b UBytes} &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b bytes} (const {\b Address} &a, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const std::vector< {\b UByte} > &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadInto} (const std::string &fN, const {\b Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubsets} {\b _subsets}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b MemoryView} &mv)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A memory view represents a set of subsets over phisical storage (one or many). \par
The subsets can combine either RAM or ROM access and can also overlap each other. \par
}{
Definition at line {\b 222} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MemoryView\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:MemoryView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::MemoryView::MemoryView (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MemoryView\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:MemoryView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::MemoryView::MemoryView (int  {\i id}, {\b PhisicalStorageSubsets}  {\i ss}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The memory view is not the owner of the subsets. \par
}{
Definition at line {\b 228} of file {\b Memory.hpp}.}\par
}
{\xe \v MemoryView\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:MemoryView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::MemoryView::MemoryView (const {\b MemoryView} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~MemoryView\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:~MemoryView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::MemoryView::~MemoryView (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 234} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v bytes\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b UByte} > MCHEmul::MemoryView::bytes (const {\b Address} &  {\i a}, size_t  {\i nB}) const}}
\par
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_ae95e450d9ae5a5c698dbb91acc97d67c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsSubset\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:existsSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::MemoryView::existsSubset (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 245} of file {\b Memory.hpp}.}\par
}
{\xe \v id\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::MemoryView::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 239} of file {\b Memory.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::MemoryView::initialize (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To init the memory view. It might be overloaded. By default the "defaultData" value is assigned. \par
}{
Definition at line {\b 270} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_a204de1b662289fc0433e30ccbd616955_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_a204de1b662289fc0433e30ccbd616955_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isIn\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:isIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::MemoryView::isIn (const {\b Address} &  {\i a}, int &  {\i dt}) const}}
\par
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v loadInto\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:loadInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::MemoryView::loadInto (const std::string &  {\i fN}, const {\b Address} &  {\i a})}}
\par
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loaded into the first subset holding the address parameter. \par
}}
{\xe \v operator=\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView} & MCHEmul::MemoryView::operator= (const {\b MemoryView} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v set\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::MemoryView::set (const {\b Address} &  {\i a}, const std::vector< {\b UByte} > &  {\i v}, bool  {\i f} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v set\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::MemoryView::set (const {\b Address} &  {\i a}, const {\b UByte} &  {\i d}, bool  {\i f} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If there had been several subsets behind, the write operation would happen on the first writtable subset possible. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_af58a87df666524b2d2ee39336309dbc4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::MemoryView::set (const {\b Address} &  {\i a}, const {\b UBytes} &  {\i v}, bool  {\i f} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 263} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_a0071e08663e0eb5a3ac2879d536264a6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subset\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:subset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorageSubset} * MCHEmul::MemoryView::subset (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 249} of file {\b Memory.hpp}.}\par
}
{\xe \v subset\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:subset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorageSubset} * MCHEmul::MemoryView::subset (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 247} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_a66070b636ff775a1607996f0a65d3f09_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_a66070b636ff775a1607996f0a65d3f09_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subsets\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:subsets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorageSubsets} & MCHEmul::MemoryView::subsets () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 243} of file {\b Memory.hpp}.}\par
}
{\xe \v value\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UByte} & MCHEmul::MemoryView::value (const {\b Address} &  {\i a}) const}}
\par
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If there had been several subsets behind, the read operation would happen on the first readable subset possible. \par
}}
{\xe \v values\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::MemoryView::values (const {\b Address} &  {\i a}, size_t  {\i nB}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 261} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_a220e052a1c9cb802da7337838f2d3798_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b MemoryView} &  {\i mv}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _id\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::MemoryView::_id{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b Memory.hpp}.}\par
}
{\xe \v _subsets\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:_subsets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorageSubsets} MCHEmul::MemoryView::_subsets{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 280} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Memory.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::MessageBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder}
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
\par
{
{\f2 #include <Message.hpp>}}\par
Inheritance diagram for MCHEmul::MessageBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_message_builder__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageBuilder} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageBuilder} (const {\b MessageBuilder} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageBuilder} & {\b operator=} (const {\b MessageBuilder} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MessageBuilder} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b CommunicationMessage} * {\b createMessage} (const std::string &)=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b verifyStructure} (const std::string &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Attributes} {\b attributesFromStr} (const std::string &str) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A builder class to create the messages. \par
An instance of this class is created in the {\b Computer}. \par
The structure of the message should be as follow: \par
1 byte (char) indicating the code of the message. \par
1 byte (char) indicating the number of parameters after. \par
a string indicating the ip (and port) origin of the message. X bytes with the parameters of the message. Usually that parameters are in the form NAMEATTR=VALUE. \par
That parameters should be separated using commas. \par
Neither names nor values can have neither equal nor comma sign in the middle. \par
}{
Definition at line {\b 85} of file {\b Message.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MessageBuilder\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:MessageBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::MessageBuilder::MessageBuilder (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b Message.hpp}.}\par
}
{\xe \v MessageBuilder\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:MessageBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::MessageBuilder::MessageBuilder (const {\b MessageBuilder} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To avoid later uncontrolable behaviours. \par
}}
{\xe \v ~MessageBuilder\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:~MessageBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::MessageBuilder::~MessageBuilder (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b Message.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attributesFromStr\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:attributesFromStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Attributes} MCHEmul::MessageBuilder::attributesFromStr (const std::string &  {\i str}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create the list of the parameters any message will need from a string. \par
}}
{\xe \v createMessage\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:createMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b CommunicationMessage} * MCHEmul::MessageBuilder::createMessage (const std::string & ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b MCHEmul::StandardMessageBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABYV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MessageBuilder} & MCHEmul::MessageBuilder::operator= (const {\b MessageBuilder} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v verifyStructure\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:verifyStructure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::MessageBuilder::verifyStructure (const std::string &  {\i str}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To verify the right structure of the message rerceived. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b Message.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::NMIInterrupt Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::NMIInterrupt}
{\xe \v F6500::NMIInterrupt}
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
\par
{
{\f2 #include <NMIInterrupt.hpp>}}\par
Inheritance diagram for F6500::NMIInterrupt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_n_m_i_interrupt__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::NMIInterrupt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_n_m_i_interrupt__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NMIInterrupt} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _ID} = 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isTime} ({\b MCHEmul::CPU} *c) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b executeOverImpl} ({\b MCHEmul::CPU} *c, unsigned int &nC) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A non Maskarable Interrupt. Any time it is invoked it has to be executed. \par
}{
Definition at line {\b 22} of file {\b NMIInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v NMIInterrupt\:F6500::NMIInterrupt}
{\xe \v F6500::NMIInterrupt\:NMIInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::NMIInterrupt::NMIInterrupt (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b NMIInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOverImpl\:F6500::NMIInterrupt}
{\xe \v F6500::NMIInterrupt\:executeOverImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void F6500::NMIInterrupt::executeOverImpl ({\b MCHEmul::CPU} *  {\i c}, unsigned int &  {\i nC}){\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To really execute the interrupt. \par
 This must be overloaded by the real interrupt. \par
}{
Implements {\b MCHEmul::CPUInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABDN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isTime\:F6500::NMIInterrupt}
{\xe \v F6500::NMIInterrupt\:isTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool F6500::NMIInterrupt::isTime ({\b MCHEmul::CPU} *  {\i c}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always. It is a Non Maskarable Interrupt. \par
}{
Implements {\b MCHEmul::CPUInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABDP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 33} of file {\b NMIInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:F6500::NMIInterrupt}
{\xe \v F6500::NMIInterrupt\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int F6500::NMIInterrupt::_ID = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b NMIInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b NMIInterrupt.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::NoChip Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::NoChip}
{\xe \v MCHEmul::NoChip}
{\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
\par
{
{\f2 #include <Chip.hpp>}}\par
Inheritance diagram for MCHEmul::NoChip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_no_chip__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::NoChip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_no_chip__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NoChip} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ({\b CPU} *) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A no chip. \par
}{
Definition at line {\b 93} of file {\b Chip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v NoChip\:MCHEmul::NoChip}
{\xe \v MCHEmul::NoChip\:NoChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::NoChip::NoChip (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b Chip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:MCHEmul::NoChip}
{\xe \v MCHEmul::NoChip\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::NoChip::initialize (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 100} of file {\b Chip.hpp}.}\par
}
{\xe \v simulate\:MCHEmul::NoChip}
{\xe \v MCHEmul::NoChip\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::NoChip::simulate ({\b CPU} * ){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate th behaviour of the chip. It has to be defined per chip. \par
Returns true if everything was ok, and false in any other circunstance. \par
 The last error could be recovered from the variable _lastError in that case. \par
The clock cyclees is added. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 103} of file {\b Chip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Chip.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::ORA_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::ORA_General}
{\xe \v F6500::ORA_General}
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::ORA_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_o_r_a___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::ORA_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_o_r_a___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ORA_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ORA_General}: To aggregate common steps in every ORA instruction. \par
}{
Definition at line {\b 417} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ORA_General\:F6500::ORA_General}
{\xe \v F6500::ORA_General\:ORA_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::ORA_General::ORA_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 420} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::ORA_General}
{\xe \v F6500::ORA_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::ORA_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UInt::PackagedBCDFormatManager Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UInt::PackagedBCDFormatManager}
{\xe \v MCHEmul::UInt::PackagedBCDFormatManager}
{\bkmkstart AAAAAAACNG}
{\bkmkend AAAAAAACNG}
\par
{
{\f2 #include <UInt.hpp>}}\par
Inheritance diagram for MCHEmul::UInt::PackagedBCDFormatManager:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_packaged_b_c_d_format_manager__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::UInt::PackagedBCDFormatManager:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_packaged_b_c_d_format_manager__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b add} (const {\b UInt} &u1, const {\b UInt} &u2, bool cIn) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b substract} (const {\b UInt} &u1, const {\b UInt} &u2, bool cIn) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b asUnsignedInt} (const {\b UInt} &u) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b fromUnsignedInt} (unsigned int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b fromInt} (int n)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For _PACKAGEDBCD format. \par
}{
Definition at line {\b 69} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add\:MCHEmul::UInt::PackagedBCDFormatManager}
{\xe \v MCHEmul::UInt::PackagedBCDFormatManager\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::PackagedBCDFormatManager::add (const {\b UInt} & , const {\b UInt} & , bool ) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMX}
{\bkmkend AAAAAAACMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The way the add is executed depends on the format. \par
}{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v asUnsignedInt\:MCHEmul::UInt::PackagedBCDFormatManager}
{\xe \v MCHEmul::UInt::PackagedBCDFormatManager\:asUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual unsigned int MCHEmul::UInt::PackagedBCDFormatManager::asUnsignedInt (const {\b UInt} &  {\i u}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMY}
{\bkmkend AAAAAAACMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v fromInt\:MCHEmul::UInt::PackagedBCDFormatManager}
{\xe \v MCHEmul::UInt::PackagedBCDFormatManager\:fromInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::PackagedBCDFormatManager::fromInt (int  {\i n}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMZ}
{\bkmkend AAAAAAACMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v fromUnsignedInt\:MCHEmul::UInt::PackagedBCDFormatManager}
{\xe \v MCHEmul::UInt::PackagedBCDFormatManager\:fromUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::PackagedBCDFormatManager::fromUnsignedInt (unsigned int  {\i n}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACNA}
{\bkmkend AAAAAAACNA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v substract\:MCHEmul::UInt::PackagedBCDFormatManager}
{\xe \v MCHEmul::UInt::PackagedBCDFormatManager\:substract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::PackagedBCDFormatManager::substract (const {\b UInt} & , const {\b UInt} & , bool ) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACNB}
{\bkmkend AAAAAAACNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The same for substracting. \par
}{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UInt.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Instruction::Structure::Parameter Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter}
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
\par
{
{\f2 #include <Instruction.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Type} \{ {\b _DATA} = 0
, {\b _DIR}
, {\b _RELJUMP}
, {\b _ABSJUMP}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parameter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parameter} ({\b Type} tp, size_t nB)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parameter} (const {\b Parameter} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parameter} & {\b operator=} (const {\b Parameter} &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Type} {\b _type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b _numberBytes}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::map< unsigned char, {\b Type} > {\b _TYPES}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 34} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Type\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b MCHEmul::Instruction::Structure::Parameter::Type}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _DATA\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_DATA}
{\qr _DATA{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
\cell }{\cell }{\row }
{\xe \v _DIR\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_DIR}
{\qr _DIR{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
\cell }{\cell }{\row }
{\xe \v _RELJUMP\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_RELJUMP}
{\qr _RELJUMP{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
\cell }{\cell }{\row }
{\xe \v _ABSJUMP\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_ABSJUMP}
{\qr _ABSJUMP{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 36} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Parameter\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:Parameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Structure::Parameter::Parameter (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b Instruction.hpp}.}\par
}
{\xe \v Parameter\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:Parameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Structure::Parameter::Parameter ({\b Type}  {\i tp}, size_t  {\i nB}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Instruction.hpp}.}\par
}
{\xe \v Parameter\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:Parameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Structure::Parameter::Parameter (const {\b Parameter} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Parameter} & MCHEmul::Instruction::Structure::Parameter::operator= (const {\b Parameter} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _numberBytes\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_numberBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::Instruction::Structure::Parameter::_numberBytes}}
\par
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Instruction.hpp}.}\par
}
{\xe \v _type\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Type} MCHEmul::Instruction::Structure::Parameter::_type}}
\par
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b Instruction.hpp}.}\par
}
{\xe \v _TYPES\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_TYPES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<unsigned char, {\b Type}> MCHEmul::Instruction::Structure::Parameter::_TYPES{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To link a char with the type. It used in many places into the code. \par
}{
Definition at line {\b 40} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Instruction.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::Parser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser}
{\bkmkstart AAAAAAACTJ}
{\bkmkend AAAAAAACTJ}
\par
{
{\f2 #include <Parser.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} (const {\b CPU} *c, const {\b CommandParsers} &lP=\{ new {\b CommentCommandParser}, new {\b IncludeCommandParser}, new {\b MacroCommandParser}, new {\b StartingPointCommandParser}, new {\b LabelCommandParser}, new {\b BytesCommandParser}, new {\b InstructionCommandParser} \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} ({\b Parser} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} & {\b operator=} (const {\b Parser} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Parser} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPU} * {\b cpu} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CommandParsers} & {\b commandParsers} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b commentSymbol} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Semantic} * {\b parse} (const std::string &fN, const std::string &fA="") const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Errors} {\b errors} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Now it is time to define the parser itself. \par
To convert a file text (or text) into an internal structure. \par
The parser is a line parser. That is, it is only able to parser a line. \par
There can be added specific instruction parsers but always a comment command parser must exist. \par
It is used to determine whether a line finishes or not. \par
}{
Definition at line {\b 228} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Parser\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:Parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Parser::Parser (const {\b CPU} *  {\i c}, const {\b CommandParsers} &  {\i lP} = {\f2 \{\~ new\~ {\b CommentCommandParser},\~ new\~ {\b IncludeCommandParser},\~ new\~ {\b MacroCommandParser},\~ new\~ {\b StartingPointCommandParser},\~ new\~ {\b LabelCommandParser},\~ new\~ {\b BytesCommandParser},\~ new\~ {\b InstructionCommandParser}\~ \}})}}
\par
{\bkmkstart AAAAAAACTK}
{\bkmkend AAAAAAACTK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Parser\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:Parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Parser::Parser ({\b Parser} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACTL}
{\bkmkend AAAAAAACTL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Parser\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:~Parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Parser::~Parser (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTM}
{\bkmkend AAAAAAACTM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The parser doesn't own the instructions but the {\b CPU}, but the line parsers. \par
}{
Definition at line {\b 242} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v commandParsers\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:commandParsers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CommandParsers} & MCHEmul::Assembler::Parser::commandParsers () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTN}
{\bkmkend AAAAAAACTN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 247} of file {\b Parser.hpp}.}\par
}
{\xe \v commentSymbol\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:commentSymbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::Assembler::Parser::commentSymbol () const}}
\par
{\bkmkstart AAAAAAACTO}
{\bkmkend AAAAAAACTO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cpu\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPU} * MCHEmul::Assembler::Parser::cpu () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTP}
{\bkmkend AAAAAAACTP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 245} of file {\b Parser.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_parser_ad01dabf028bb41a8b8f08db70c2c1060_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v errors\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:errors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Errors} MCHEmul::Assembler::Parser::errors () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTQ}
{\bkmkend AAAAAAACTQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 282} of file {\b Parser.hpp}.}\par
}
{\xe \v operator!\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::Parser::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTR}
{\bkmkend AAAAAAACTR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify checking whether there was or not an error parsing. \par
}{
Definition at line {\b 286} of file {\b Parser.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Parser} & MCHEmul::Assembler::Parser::operator= (const {\b Parser} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACTS}
{\bkmkend AAAAAAACTS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Semantic} * MCHEmul::Assembler::Parser::parse (const std::string &  {\i fN}, const std::string &  {\i fA} = {\f2 ""}) const}}
\par
{\bkmkstart AAAAAAACTT}
{\bkmkend AAAAAAACTT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type of code that is is accepted: The example has been written using the machine languaje of the Commodore 64 ; Simple test that everything works \par
; By Ignacio Cea \par
\par
; MACROS \par
FOREGROUND = $D020 \par
BACKGROUND = $D021 \par
\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
= $C000 \par
\par
; Now the code \par
\par
START: LDA #$00 ;Load accumulator \par
 STA BACKGROUND \par
 STA FOREGROUND \par
 BNE START \par
\par
; Very simple Rules: ; Means comment. After that, nothing will be taken into account. \par
MACROS & LABELS are represented using characteres (upper and lower case) and numbers, but never starting with number. \par
NUMBERS AND DIRECTIONS can be represented using decimal, octal (starting with 0) and hexadecimal (with $) numbers. \par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
= xxxx will identify the address from which the code after will be inserted!\par}
The method can receive also another file with "actions" to execute over any line. \par
This action must be simply number. How to interpret them should be determine later. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::PeerCommunicationChannel Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel}
{\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
\par
{
{\f2 #include <Channel.hpp>}}\par
Collaboration diagram for MCHEmul::PeerCommunicationChannel:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_peer_communication_channel__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PeerCommunicationChannel} (unsigned short p, unsigned int nC, const {\b IPAddress} &a={\b IPAddress}())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PeerCommunicationChannel} (const {\b PeerCommunicationChannel} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PeerCommunicationChannel} & {\b operator=} (const {\b PeerCommunicationChannel} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~PeerCommunicationChannel} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b listenAtPort} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b simulatenousConnections} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b IPAddress} & {\b connectedTo} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isChannelInitiated} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isChannelConnected} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b finalize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b receive} (std::string &str, {\b IPAddress} &from)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b send} (const std::string &str, const {\b IPAddress} &to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b send} (const {\b CommunicationMessage} &msg, const {\b IPAddress} &to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b send} (const std::string &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b send} (const {\b CommunicationMessage} &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _listenAtPort}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _simultaneousConnections}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b IPAddress} {\b _connectedTo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
RakNet::RakPeerInterface * {\b _peer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _channelInitialized}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _channelConnected}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class {\b PeerCommunicationChannel} allows the communication between pieces of the emulator. e.g. emulator and any external tool. \par
It could be useful e.g. to run in debug mode the emulator or to know which is the status of the computer. \par
}{
Definition at line {\b 28} of file {\b Channel.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PeerCommunicationChannel\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:PeerCommunicationChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PeerCommunicationChannel::PeerCommunicationChannel (unsigned short  {\i p}, unsigned int  {\i nC}, const {\b IPAddress} &  {\i a} = {\f2 {\b IPAddress}()})}}
\par
{\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create the communication channel, but not to open it. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{: The communication channel needs to listen at a specific port. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nC} \cell }{: The default number of communications supported. 1 default for a pure peer comm. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i to} \cell }{: The direction this peer is connected to, if any. It could be nothing! \cell }
{\row }
}
}}
{\xe \v PeerCommunicationChannel\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:PeerCommunicationChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PeerCommunicationChannel::PeerCommunicationChannel (const {\b PeerCommunicationChannel} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~PeerCommunicationChannel\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:~PeerCommunicationChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::PeerCommunicationChannel::~PeerCommunicationChannel (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v connectedTo\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:connectedTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b IPAddress} & MCHEmul::PeerCommunicationChannel::connectedTo () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Channel.hpp}.}\par
}
{\xe \v finalize\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:finalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::finalize ()}}
\par
{\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v initialize\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::initialize ()}}
\par
{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v isChannelConnected\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:isChannelConnected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::isChannelConnected (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b Channel.hpp}.}\par
}
{\xe \v isChannelInitiated\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:isChannelInitiated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::isChannelInitiated (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Channel.hpp}.}\par
}
{\xe \v lastError\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::PeerCommunicationChannel::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b Channel.hpp}.}\par
}
{\xe \v listenAtPort\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:listenAtPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short MCHEmul::PeerCommunicationChannel::listenAtPort () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Channel.hpp}.}\par
}
{\xe \v operator!\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b Channel.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PeerCommunicationChannel} & MCHEmul::PeerCommunicationChannel::operator= (const {\b PeerCommunicationChannel} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v receive\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:receive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::receive (std::string &  {\i str}, {\b IPAddress} &  {\i from})}}
\par
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Receiving a communication. \\ \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true when the communication has been well managed. In that case "str" will hold the string received and "from" the address of the machine sending it through. \par
}}}}
{\xe \v send\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::send (const {\b CommunicationMessage} &  {\i msg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Channel.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_peer_communication_channel_a74da350ef516bac9f35251de065301b6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v send\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::send (const {\b CommunicationMessage} &  {\i msg}, const {\b IPAddress} &  {\i to}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b Channel.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_peer_communication_channel_a2e68bb7ea211abfcaa9abc320a988795_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v send\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::send (const std::string &  {\i str}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To send a communication to the connected machine if any. Otherwise an error is generated. \par
}{
Definition at line {\b 74} of file {\b Channel.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_peer_communication_channel_ae52999bb409bd0075fe7aa3826e7d7d0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v send\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::send (const std::string &  {\i str}, const {\b IPAddress} &  {\i to})}}
\par
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To send a communication to another machine. The parameters needed are tyhe string to send it accross and the address of the machine to ssend it to. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true is everything went ok. \par
}}}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_peer_communication_channel_a92aa0323f108365115aac97107395e11_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v simulatenousConnections\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:simulatenousConnections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short MCHEmul::PeerCommunicationChannel::simulatenousConnections () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b Channel.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _channelConnected\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_channelConnected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::_channelConnected{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b Channel.hpp}.}\par
}
{\xe \v _channelInitialized\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_channelInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::_channelInitialized{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b Channel.hpp}.}\par
}
{\xe \v _connectedTo\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_connectedTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b IPAddress} MCHEmul::PeerCommunicationChannel::_connectedTo{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b Channel.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::PeerCommunicationChannel::_lastError{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b Channel.hpp}.}\par
}
{\xe \v _listenAtPort\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_listenAtPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short MCHEmul::PeerCommunicationChannel::_listenAtPort{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b Channel.hpp}.}\par
}
{\xe \v _peer\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_peer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
RakNet::RakPeerInterface* MCHEmul::PeerCommunicationChannel::_peer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b Channel.hpp}.}\par
}
{\xe \v _simultaneousConnections\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_simultaneousConnections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short MCHEmul::PeerCommunicationChannel::_simultaneousConnections{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b Channel.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b Channel.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::PhisicalStorage Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage}
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
\par
{
{\f2 #include <Memory.hpp>}}\par
Collaboration diagram for MCHEmul::PhisicalStorage:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Type} \{ {\b _ROM}
, {\b _RAM}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} (int {\b id}, {\b Type} t, size_t s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} (const {\b PhisicalStorage} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} & {\b operator=} (const {\b PhisicalStorage} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Type} {\b type} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canBeWriten} (bool f=false) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b PhisicalStorageSubset}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b UByte} {\b _DEFAULTVALUE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (size_t pB, const {\b UByte} &d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UByte} & {\b value} (size_t pB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b values} (size_t pB, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (size_t pB, const {\b UBytes} &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b bytes} (size_t pB, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (size_t pB, const std::vector< {\b UByte} > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadInto} (const std::string &fN, size_t p=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b _id} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Type} {\b _type} = {\b Type::_RAM}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b MCHEmul::UByte} > {\b _data}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents what phisically speaking the memoy is: \par
Just a place to keep info. \par
It can be either RAM or ROM depending whether is possible to modify data. \par
The phisical storage can only be accesed through a subset, controlling the boundaries of the phisical storage. \par
}{
Definition at line {\b 34} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Type\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b MCHEmul::PhisicalStorage::Type}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _ROM\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:_ROM}
{\qr _ROM{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
\cell }{\cell }{\row }
{\xe \v _RAM\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:_RAM}
{\qr _RAM{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 42} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PhisicalStorage\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:PhisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PhisicalStorage::PhisicalStorage (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PhisicalStorage\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:PhisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PhisicalStorage::PhisicalStorage (int  {\i id}, {\b Type}  {\i t}, size_t  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Memory.hpp}.}\par
}
{\xe \v PhisicalStorage\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:PhisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PhisicalStorage::PhisicalStorage (const {\b PhisicalStorage} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v bytes\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b UByte} > MCHEmul::PhisicalStorage::bytes (size_t  {\i pB}, size_t  {\i nB}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_a18943dc577b5276972b642bc34f5e2cf_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v canBeWriten\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:canBeWriten}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorage::canBeWriten (bool  {\i f} = {\f2 false}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{force the writting. \cell }
{\row }
}
}{
Definition at line {\b 62} of file {\b Memory.hpp}.}\par
}
{\xe \v id\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::PhisicalStorage::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Memory.hpp}.}\par
}
{\xe \v loadInto\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:loadInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorage::loadInto (const std::string &  {\i fN}, size_t  {\i p} = {\f2 0}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Load the info, as many bytes as possible, from a specific byte of the memory. If nothing is said, the info is load from he vey first bye. \par
}}
{\xe \v operator=\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorage} & MCHEmul::PhisicalStorage::operator= (const {\b PhisicalStorage} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v set\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorage::set (size_t  {\i pB}, const std::vector< {\b UByte} > &  {\i v}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_aaa2a7b109b6f079a4981af035dd7ae42_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorage::set (size_t  {\i pB}, const {\b UByte} &  {\i d}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Managing the content of the memory. \par
Take into account that whether it is a RAM or a ROM is not controlled here. \par
It is something that has to be guarantteed by the subsets built on top of this. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very real write type access.\par
}{
Definition at line {\b 73} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_a5fe8aaaced4e084c132f795186bb2609_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorage::set (size_t  {\i pB}, const {\b UBytes} &  {\i v}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_a9c5129fd3b20511defe52306de1cc615_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::PhisicalStorage::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b Memory.hpp}.}\par
}
{\xe \v type\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Type} MCHEmul::PhisicalStorage::type () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b Memory.hpp}.}\par
}
{\xe \v value\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UByte} & MCHEmul::PhisicalStorage::value (size_t  {\i pB}) const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very real read type access.\par
}{
Definition at line {\b 75} of file {\b Memory.hpp}.}\par
}
{\xe \v values\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::PhisicalStorage::values (size_t  {\i pB}, size_t  {\i nB}) const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_a5180c00677242ea924fc42d66a3f529f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _data\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b MCHEmul::UByte}> MCHEmul::PhisicalStorage::_data{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b Memory.hpp}.}\par
}
{\xe \v _DEFAULTVALUE\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:_DEFAULTVALUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::PhisicalStorage::_DEFAULTVALUE{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The default value which is used to initialize the memory, can be changed. \par
}{
Definition at line {\b 38} of file {\b Memory.hpp}.}\par
}
{\xe \v _id\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int MCHEmul::PhisicalStorage::_id = -1{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Memory.hpp}.}\par
}
{\xe \v _type\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Type} MCHEmul::PhisicalStorage::_type = {\b Type::_RAM}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b Memory.hpp}.}\par
}
{\xe \v PhisicalStorageSubset\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:PhisicalStorageSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend MCHEmul::PhisicalStorage::PhisicalStorageSubset}}
\par
{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Memory.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::PhisicalStorageSubset Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset}
{\bkmkstart AAAAAAACAY}
{\bkmkend AAAAAAACAY}
\par
{
{\f2 #include <Memory.hpp>}}\par
Inheritance diagram for MCHEmul::PhisicalStorageSubset:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::PhisicalStorageSubset:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} (int {\b id}, {\b PhisicalStorage} *pS, size_t pp, const {\b Address} &a, size_t s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} (const {\b PhisicalStorageSubset} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~PhisicalStorageSubset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} & {\b operator=} (const {\b PhisicalStorageSubset} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorage} * {\b phisicalStorage} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} * {\b phisicalStorage} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage::Type} {\b type} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Address} & {\b initialAddress} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b active} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setActive} (bool a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b activeForReading} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setActiveForReading} (bool aR)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canBeWriten} (bool f) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isIn} (const {\b Address} &a, int &dt) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const {\b UByte} &d, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UByte} & {\b value} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b values} (const {\b Address} &a, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const {\b UBytes} &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b bytes} (const {\b Address} &a, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const std::vector< {\b UByte} > &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b load} (const std::string &fN, size_t sA, bool bE=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadInto} (const std::string &fN, const {\b Address} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadInto} (const std::string &fN)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fixDefaultValues} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b MemoryView}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setValue} (size_t nB, const {\b UByte} &d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b UByte} & {\b readValue} (size_t nB) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b _id} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} * {\b _phisicalStorage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b _initialPhisicalPosition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b _initialAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b _size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _active}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _activeForReading}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b MCHEmul::UByte} > {\b _defaultData}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b PhisicalStorageSubset} &ps)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a subset of the physical storage. \par
Many subsets can be created over the same physical location. \par
}{
Definition at line {\b 100} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PhisicalStorageSubset\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:PhisicalStorageSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PhisicalStorageSubset::PhisicalStorageSubset (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACAZ}
{\bkmkend AAAAAAACAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PhisicalStorageSubset\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:PhisicalStorageSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PhisicalStorageSubset::PhisicalStorageSubset (int  {\i id}, {\b PhisicalStorage} *  {\i pS}, size_t  {\i pp}, const {\b Address} &  {\i a}, size_t  {\i s})}}
\par
{\bkmkstart AAAAAAACBA}
{\bkmkend AAAAAAACBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It is guarantteed that it must a subset within the boundaries of the phisical storage behind. \par
Otherwise the view will be have the same size than that. \par
The reference to the phisical storage can't be null at all. \par
 The subset is not the owner of the phisical storage. \par
THe phisical storage can be either active or inactive. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pp} \cell }{link a phisical \cell }
{\row }
}
}}
{\xe \v PhisicalStorageSubset\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:PhisicalStorageSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PhisicalStorageSubset::PhisicalStorageSubset (const {\b PhisicalStorageSubset} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACBB}
{\bkmkend AAAAAAACBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~PhisicalStorageSubset\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:~PhisicalStorageSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::PhisicalStorageSubset::~PhisicalStorageSubset (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACBC}
{\bkmkend AAAAAAACBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nothing to do by default.\par
}{
Definition at line {\b 116} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v active\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:active}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::active () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBD}
{\bkmkend AAAAAAACBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b Memory.hpp}.}\par
}
{\xe \v activeForReading\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:activeForReading}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::activeForReading () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b Memory.hpp}.}\par
}
{\xe \v bytes\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b UByte} > MCHEmul::PhisicalStorageSubset::bytes (const {\b Address} &  {\i a}, size_t  {\i nB}) const}}
\par
{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When some of the requested position is out the boundaries, an empty map is returned. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_aa129f427a12142e5018f2e2723b01a82_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v canBeWriten\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:canBeWriten}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::canBeWriten (bool  {\i f}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBG}
{\bkmkend AAAAAAACBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a07b8984d68102d268ca4b62913219e7f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a07b8984d68102d268ca4b62913219e7f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fixDefaultValues\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:fixDefaultValues}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorageSubset::fixDefaultValues (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBH}
{\bkmkend AAAAAAACBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To keep the values for fither initialization. \par
}{
Definition at line {\b 185} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a153d0d6580e4a949af9a5e9d0c963408_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v id\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::PhisicalStorageSubset::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBI}
{\bkmkend AAAAAAACBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Id for the view. It is diiferent than the id of the phisical storage behind. \par
}{
Definition at line {\b 122} of file {\b Memory.hpp}.}\par
}
{\xe \v initialAddress\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:initialAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Address} & MCHEmul::PhisicalStorageSubset::initialAddress () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBJ}
{\bkmkend AAAAAAACBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_af5df1745a7a25571923c409533a47d85_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::PhisicalStorageSubset::initialize (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To init the memory. It might be overloaded. By default the "defaultData" value is assigned. It doesn't matter whether the subset is or not active. \par
}{
Reimplemented in {\b C64::CIA1Registers} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::CIA2Registers} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::VICIIRegisters} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQI \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::Stack} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACBK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 170} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_add052e8acc48c2dc020b091a740b91c7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isIn\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:isIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::isIn (const {\b Address} &  {\i a}, int &  {\i dt}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBL}
{\bkmkend AAAAAAACBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The address may only be "in" when the subset is active. \par
}{
Definition at line {\b 148} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_ab5f145065b365ee0d9c14860eb44a1a3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_ab5f145065b365ee0d9c14860eb44a1a3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v load\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:load}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::load (const std::string &  {\i fN}, size_t  {\i sA}, bool  {\i bE} = {\f2 true})}}
\par
{\bkmkstart AAAAAAACBM}
{\bkmkend AAAAAAACBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First "sA" bytes of the file defining the address where to load the bytes. It is also necessary to define whether that address is or not big endian. \par
}}
{\xe \v loadInto\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:loadInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::loadInto (const std::string &  {\i fN}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBN}
{\bkmkend AAAAAAACBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The address where to load things into is always the initial address of the memory. \par
}{
Definition at line {\b 181} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_afeba8c79926f2fba8f3b28ac03e95a51_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v loadInto\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:loadInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::loadInto (const std::string &  {\i fN}, const {\b Address} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBO}
{\bkmkend AAAAAAACBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Everything from the memory position received. \par
}{
Definition at line {\b 177} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a69bdca5529e55d27606fafb806f20301_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a69bdca5529e55d27606fafb806f20301_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorageSubset} & MCHEmul::PhisicalStorageSubset::operator= (const {\b PhisicalStorageSubset} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACBP}
{\bkmkend AAAAAAACBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v phisicalStorage\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorage} * MCHEmul::PhisicalStorageSubset::phisicalStorage (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBQ}
{\bkmkend AAAAAAACBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b Memory.hpp}.}\par
}
{\xe \v phisicalStorage\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorage} * MCHEmul::PhisicalStorageSubset::phisicalStorage () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBR}
{\bkmkend AAAAAAACBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b Memory.hpp}.}\par
}
{\xe \v readValue\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:readValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const {\b UByte} & MCHEmul::PhisicalStorageSubset::readValue (size_t  {\i nB}) const{\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACBS}
{\bkmkend AAAAAAACBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 197} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_aceff286e4b286b3dfb15db4b0fabcd46_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_aceff286e4b286b3dfb15db4b0fabcd46_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorageSubset::set (const {\b Address} &  {\i a}, const std::vector< {\b UByte} > &  {\i v}, bool  {\i f} = {\f2 false})}}
\par
{\bkmkstart AAAAAAACBT}
{\bkmkend AAAAAAACBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v set\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorageSubset::set (const {\b Address} &  {\i a}, const {\b UByte} &  {\i d}, bool  {\i f} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBU}
{\bkmkend AAAAAAACBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The internal method "setValue" is invoked when possible. When the address requested is not "in" the subset, nothing happens. \par
}{
Definition at line {\b 153} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_af6f3e0e996fa65db1b6a4fdb4a89fbbb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_af6f3e0e996fa65db1b6a4fdb4a89fbbb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorageSubset::set (const {\b Address} &  {\i a}, const {\b UBytes} &  {\i v}, bool  {\i f} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBV}
{\bkmkend AAAAAAACBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a1c7bb0e3ee5749b87581313882ca68fe_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setActive\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:setActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorageSubset::setActive (bool  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBW}
{\bkmkend AAAAAAACBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b Memory.hpp}.}\par
}
{\xe \v setActiveForReading\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:setActiveForReading}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorageSubset::setActiveForReading (bool  {\i aR}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBX}
{\bkmkend AAAAAAACBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b Memory.hpp}.}\par
}
{\xe \v setValue\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:setValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::PhisicalStorageSubset::setValue (size_t  {\i nB}, const {\b UByte} &  {\i d}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACBY}
{\bkmkend AAAAAAACBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
They could be overeloaded for specific subsets: Chips registers,... By default, the instructions are transmitted to the physical storage. At this point there is guaranteed that the byte requested exist in the phisical storage. The number of register (relative) with in the phisical storage is received. \par
}{
Definition at line {\b 195} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_af20632928476477041fa71cd4a0d64d1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_af20632928476477041fa71cd4a0d64d1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::PhisicalStorageSubset::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBZ}
{\bkmkend AAAAAAACBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b Memory.hpp}.}\par
}
{\xe \v type\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorage::Type} MCHEmul::PhisicalStorageSubset::type () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCA}
{\bkmkend AAAAAAACCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a95d9d90a126d77b0c9c267d81972da95_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a95d9d90a126d77b0c9c267d81972da95_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UByte} & MCHEmul::PhisicalStorageSubset::value (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCB}
{\bkmkend AAAAAAACCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The internal method "readValue" is invoked when possible. When the address requested is not "in" the subset, -0 is returned. \par
}{
Definition at line {\b 157} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_aed9ce60cb6a01905e430606e4ddac55c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_aed9ce60cb6a01905e430606e4ddac55c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v values\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::PhisicalStorageSubset::values (const {\b Address} &  {\i a}, size_t  {\i nB}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCC}
{\bkmkend AAAAAAACCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a94ed29e6e921f2bc74135b22b383be72_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a94ed29e6e921f2bc74135b22b383be72_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b PhisicalStorageSubset} &  {\i ps}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACCD}
{\bkmkend AAAAAAACCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _active\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_active}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::_active{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCE}
{\bkmkend AAAAAAACCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 211} of file {\b Memory.hpp}.}\par
}
{\xe \v _activeForReading\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_activeForReading}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::_activeForReading{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCF}
{\bkmkend AAAAAAACCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b Memory.hpp}.}\par
}
{\xe \v _defaultData\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_defaultData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b MCHEmul::UByte}> MCHEmul::PhisicalStorageSubset::_defaultData{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCG}
{\bkmkend AAAAAAACCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 213} of file {\b Memory.hpp}.}\par
}
{\xe \v _id\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int MCHEmul::PhisicalStorageSubset::_id = -1{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCH}
{\bkmkend AAAAAAACCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 201} of file {\b Memory.hpp}.}\par
}
{\xe \v _initialAddress\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_initialAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::PhisicalStorageSubset::_initialAddress{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCI}
{\bkmkend AAAAAAACCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Which address does the initial position defined above represent ? \par
}{
Definition at line {\b 206} of file {\b Memory.hpp}.}\par
}
{\xe \v _initialPhisicalPosition\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_initialPhisicalPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::PhisicalStorageSubset::_initialPhisicalPosition{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCJ}
{\bkmkend AAAAAAACCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The position on the phisical storage, this subset is connected to. \par
}{
Definition at line {\b 204} of file {\b Memory.hpp}.}\par
}
{\xe \v _phisicalStorage\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorage}* MCHEmul::PhisicalStorageSubset::_phisicalStorage{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCK}
{\bkmkend AAAAAAACCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b Memory.hpp}.}\par
}
{\xe \v _size\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::PhisicalStorageSubset::_size{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCL}
{\bkmkend AAAAAAACCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
How many bytes of info does this subset represent? \par
}{
Definition at line {\b 208} of file {\b Memory.hpp}.}\par
}
{\xe \v MemoryView\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:MemoryView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend MCHEmul::PhisicalStorageSubset::MemoryView}}
\par
{\bkmkstart AAAAAAACCM}
{\bkmkend AAAAAAACCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Memory.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::ProgramCounter Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter}
{\bkmkstart AAAAAAACCN}
{\bkmkend AAAAAAACCN}
\par
{
{\f2 #include <ProgramCounter.hpp>}}\par
Inheritance diagram for MCHEmul::ProgramCounter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::ProgramCounter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} (size_t sz)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} (const {\b ProgramCounter} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} & {\b operator=} (const {\b ProgramCounter} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b asAddress} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAddress} (const {\b Address} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b increment} (size_t n=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b decrement} (size_t n=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} {\b operator+} (size_t n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} & {\b operator+=} (size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} {\b operator-} (size_t n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} & {\b operator-=} (size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} ({\b UByte::OutputFormat} oF) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b ProgramCounter} &pc)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The program counter is an special register within any {\b CPU}, keeping an address inside that is incremented or decremented as the program is executed. \par
}{
Definition at line {\b 23} of file {\b ProgramCounter.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ProgramCounter\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:ProgramCounter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::ProgramCounter::ProgramCounter (size_t  {\i sz}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCO}
{\bkmkend AAAAAAACCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b ProgramCounter.hpp}.}\par
}
{\xe \v ProgramCounter\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:ProgramCounter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::ProgramCounter::ProgramCounter (const {\b ProgramCounter} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACCP}
{\bkmkend AAAAAAACCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asAddress\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:asAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::ProgramCounter::asAddress () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCQ}
{\bkmkend AAAAAAACCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a37f6d97a9a28f686911eaa804c25813c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a37f6d97a9a28f686911eaa804c25813c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asString\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::ProgramCounter::asString ({\b UByte::OutputFormat}  {\i oF}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCR}
{\bkmkend AAAAAAACCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_afa46699ae0f9236f4bd411c549ece6d3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_afa46699ae0f9236f4bd411c549ece6d3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v decrement\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:decrement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ProgramCounter::decrement (size_t  {\i n} = {\f2 1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCS}
{\bkmkend AAAAAAACCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a300dddf55abc81115157f449e1dcad76_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a300dddf55abc81115157f449e1dcad76_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v increment\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:increment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ProgramCounter::increment (size_t  {\i n} = {\f2 1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCT}
{\bkmkend AAAAAAACCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_aa0a210c1950d4ec3a0f4dadf14b599aa_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_aa0a210c1950d4ec3a0f4dadf14b599aa_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ProgramCounter::initialize (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCU}
{\bkmkend AAAAAAACCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a2432a6271d74859b75cf911ffd879646_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!=\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::ProgramCounter::operator!= (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCV}
{\bkmkend AAAAAAACCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a47c8cd077a4efceee5ceabc7542d0dfe_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} MCHEmul::ProgramCounter::operator+ (size_t  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCW}
{\bkmkend AAAAAAACCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a3da67432f3dc05ea54ae28b4db0e8936_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} & MCHEmul::ProgramCounter::operator+= (size_t  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCX}
{\bkmkend AAAAAAACCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a6f48b74c791c3920bd6e008dd1225aa8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} MCHEmul::ProgramCounter::operator- (size_t  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCY}
{\bkmkend AAAAAAACCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a6e4f87a22062e9839c22c81c23341455_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-=\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} & MCHEmul::ProgramCounter::operator-= (size_t  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCZ}
{\bkmkend AAAAAAACCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a83319dd60a1d4abdef9b784c098d71bd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::ProgramCounter::operator< (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDA}
{\bkmkend AAAAAAACDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_af61ca6b4ac51660df9721c8ca4acd749_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<=\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::ProgramCounter::operator<= (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDB}
{\bkmkend AAAAAAACDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a4957772843354b05b252f6197c40749e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} & MCHEmul::ProgramCounter::operator= (const {\b ProgramCounter} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACDC}
{\bkmkend AAAAAAACDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::ProgramCounter::operator== (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDD}
{\bkmkend AAAAAAACDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a5f4b26061f9a2d470ccc07e4e8cb243d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator>\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::ProgramCounter::operator> (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDE}
{\bkmkend AAAAAAACDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a5921d8bfd55bae5fefd33b8fcf7e7c64_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator>=\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::ProgramCounter::operator>= (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDF}
{\bkmkend AAAAAAACDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_ac0f071a36524a5ce8e645a918fb26ff3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setAddress\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:setAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ProgramCounter::setAddress (const {\b Address} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDG}
{\bkmkend AAAAAAACDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a2ed19e71f6a49c25fde7b13bb29d2126_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a2ed19e71f6a49c25fde7b13bb29d2126_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b ProgramCounter} &  {\i pc}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACDH}
{\bkmkend AAAAAAACDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b ProgramCounter.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::VICII::Raster Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::VICII::Raster}
{\xe \v C64::VICII::Raster}
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
\par
{
{\f2 #include <VICII.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Raster} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Raster} (const {\b Raster} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Raster} & {\b operator=} (const {\b Raster} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Raster} (const {\b RasterData} &vD, const {\b RasterData} &hD)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b RasterData} & {\b vData} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RasterData} & {\b vData} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b RasterData} & {\b hData} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RasterData} & {\b hData} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentLine} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentLineAtBase0} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentColumn} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentColumnAtBase0} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInPotentialBadLine} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInVBlank} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInLastVBlank} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInVisibleZone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b currentVisiblePosition} (unsigned short &x, unsigned short &y) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInDisplayZone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b firstScreenPosition} (unsigned short &x, unsigned short &y, bool o=false) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b currentScreenPosition} (unsigned short &x, unsigned short &y) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b screenPositions} (unsigned short &x1, unsigned short &y1, unsigned short &x2, unsigned short &y2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b visibleLines} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b visibleColumns} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reduceDisplayZone} (bool v, bool h)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveCycles} (unsigned short nC)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned short {\b _FIRSTBADLINE} = 0x33\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned short {\b _LASTBADLINE} = 0xfa\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Raster} simulates the set of sequential horizontal lines that, in a CRT monitor, draws an image in the screen. \par
}{
Definition at line {\b 138} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Raster\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:Raster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::Raster::Raster (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Raster\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:Raster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::Raster::Raster (const {\b Raster} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Raster\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:Raster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::Raster::Raster (const {\b RasterData} &  {\i vD}, const {\b RasterData} &  {\i hD}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 150} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v currentColumn\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:currentColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::Raster::currentColumn () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a60ce4d0a456d5fd74f96cbb4fabce915_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentColumnAtBase0\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:currentColumnAtBase0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::Raster::currentColumnAtBase0 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a37d5f6a38e74961bfb9d6708e50455d1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentLine\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:currentLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::Raster::currentLine () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 163} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a763c998ab4887751a2fd6c1d859ab005_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentLineAtBase0\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:currentLineAtBase0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::Raster::currentLineAtBase0 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_aa32038bd6509576afe13f99af8180362_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentScreenPosition\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:currentScreenPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::Raster::currentScreenPosition (unsigned short &  {\i x}, unsigned short &  {\i y}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 193} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a344a9be2d1b044b3391669223d6d412d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentVisiblePosition\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:currentVisiblePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::Raster::currentVisiblePosition (unsigned short &  {\i x}, unsigned short &  {\i y}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 185} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a60801b608ceab266864bf15e9607fc19_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v firstScreenPosition\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:firstScreenPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::Raster::firstScreenPosition (unsigned short &  {\i x}, unsigned short &  {\i y}, bool  {\i o} = {\f2 false}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 191} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a164ab566772b70d1c3156cdb7f9d892a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v hData\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:hData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RasterData} & C64::VICII::Raster::hData (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b VICII.hpp}.}\par
}
{\xe \v hData\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:hData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b RasterData} & C64::VICII::Raster::hData () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b VICII.hpp}.}\par
}
{\xe \v initialize\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::Raster::initialize (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 214} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a1a1f4dc4457948cb28df42ac34799e1c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInDisplayZone\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:isInDisplayZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::Raster::isInDisplayZone () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 188} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_ae506e602ca4a1f19e39c44e8f9f4c379_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInLastVBlank\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:isInLastVBlank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::Raster::isInLastVBlank () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 180} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_aaf2a6bfbc53f0700b6833de465275d10_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInPotentialBadLine\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:isInPotentialBadLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::Raster::isInPotentialBadLine () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is not complete. It would have to consider the position of the vertical scroll and also whether the display is or not disconnected. \par
}{
Definition at line {\b 174} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a1a0555d2c47e5a34364b72cae0b60146_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInVBlank\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:isInVBlank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::Raster::isInVBlank () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_ae9f1d4a3d2f9bd19700e173b5ea844f8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInVisibleZone\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:isInVisibleZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::Raster::isInVisibleZone () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 183} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_afb593aa36edda6f25c07488fe5965749_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v moveCycles\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:moveCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::Raster::moveCycles (unsigned short  {\i nC}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true when the raster goes to the next line. The Parameter is the number of cycles to move the raster. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
columuns = piexels per cycle.\par
}{
Definition at line {\b 209} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_ac04f64107a4bb730c6d14328816771b6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Raster} & C64::VICII::Raster::operator= (const {\b Raster} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reduceDisplayZone\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:reduceDisplayZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::Raster::reduceDisplayZone (bool  {\i v}, bool  {\i h}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 204} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_aab0e6f04e1835fcdc62f510f6d404c35_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v screenPositions\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:screenPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::Raster::screenPositions (unsigned short &  {\i x1}, unsigned short &  {\i y1}, unsigned short &  {\i x2}, unsigned short &  {\i y2}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 195} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a3a3d52909185e8a37afa805787726c08_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v vData\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:vData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RasterData} & C64::VICII::Raster::vData (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 156} of file {\b VICII.hpp}.}\par
}
{\xe \v vData\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:vData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b RasterData} & C64::VICII::Raster::vData () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b VICII.hpp}.}\par
}
{\xe \v visibleColumns\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:visibleColumns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::Raster::visibleColumns () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 201} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_ae5125c6b2050c7b015e1729d479494e0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v visibleLines\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:visibleLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::Raster::visibleLines () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_ab95bf391f680ffa344ee255594f2c31b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _FIRSTBADLINE\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:_FIRSTBADLINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::Raster::_FIRSTBADLINE = 0x33{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b VICII.hpp}.}\par
}
{\xe \v _LASTBADLINE\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:_LASTBADLINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::Raster::_LASTBADLINE = 0xfa{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b VICII.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::VICII::RasterData Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData}
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
\par
{
{\f2 #include <VICII.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RasterData} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RasterData} (unsigned short fp, unsigned short fvp, unsigned short fdp, unsigned short ldp, unsigned short lvp, unsigned short lp, unsigned short mp, unsigned short pr1, unsigned short pr2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RasterData} (const {\b RasterData} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RasterData} & {\b operator=} (const {\b RasterData} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentPosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentPositionAtBase0} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInBlankZone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInLastBlankZone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInVisibleZone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentVisiblePosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b visiblePositions} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInDisplayZone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b firstScreenPosition} (bool o=false) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b lastScreenPosition} (bool o=false) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentScreenPosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b screenPositions} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b add} (unsigned short i)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b next} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reduceDisplayZone} (bool s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isDisplayZoneReduced} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b toBase0} (unsigned short m) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _firstPosition} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _firstVisiblePosition} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _firstDisplayPosition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _originalFirstDisplayPosition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _lastDisplayPosition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _originalLastDisplayPosition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _lastVisiblePosition} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _lastPosition} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _maxPositions} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _positionsToReduce1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _positionsToReduce2} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _firstPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _firstVisiblePosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _firstDisplayPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _originalFirstDisplayPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _lastDisplayPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _originalLastDisplayPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _lastVisiblePosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _lastPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _currentPosition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _currentPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _displayZoneReducted}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b RasterData} describes the infomation the raster need to move across the screen. \par
}{
Definition at line {\b 28} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v RasterData\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:RasterData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::RasterData::RasterData (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v RasterData\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:RasterData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::RasterData::RasterData (unsigned short  {\i fp}, unsigned short  {\i fvp}, unsigned short  {\i fdp}, unsigned short  {\i ldp}, unsigned short  {\i lvp}, unsigned short  {\i lp}, unsigned short  {\i mp}, unsigned short  {\i pr1}, unsigned short  {\i pr2})}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v RasterData\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:RasterData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::RasterData::RasterData (const {\b RasterData} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::add (unsigned short  {\i i})}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true when the limit of the raster is reached. The parameter is the number of positions to increment the rasterData. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a63e5f5a995d1f5abb81a6ab693baaecb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:currentPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::currentPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_ad5d80774aef3ca3ca06f33c8bda054d6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentPositionAtBase0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:currentPositionAtBase0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::currentPositionAtBase0 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a6cecf7df8641e0404055f2b493ba7d31_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentScreenPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:currentScreenPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::currentScreenPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a07700f08dba3eccdb615e7d1441160b2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentVisiblePosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:currentVisiblePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::currentVisiblePosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a0e24632b25e42b9f5d3e96809cf27de8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v firstScreenPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:firstScreenPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::firstScreenPosition (bool  {\i o} = {\f2 false}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
o == true when the original display position has to be taken into account. false by default. \par
}{
Definition at line {\b 77} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a0414d48a489e6e9aba7fedb63e230a77_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::RasterData::initialize (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a8b2aa4283dd4ee43ba98bed012a7263e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isDisplayZoneReduced\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:isDisplayZoneReduced}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::isDisplayZoneReduced () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b VICII.hpp}.}\par
}
{\xe \v isInBlankZone\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:isInBlankZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::isInBlankZone () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_aa7294d516acfb335034f6f7ac91fb474_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInDisplayZone\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:isInDisplayZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::isInDisplayZone () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Doesn't take into account potential reductions in the size. \par
}{
Definition at line {\b 72} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a619ff1c5a901c73b0f84387715379e20_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInLastBlankZone\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:isInLastBlankZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::isInLastBlankZone () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_aa6d4f46fdaa81bfbd8ddb3f3d403dbf8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInVisibleZone\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:isInVisibleZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::isInVisibleZone () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_ab5f4092f394079068440354f4d33a86e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v lastScreenPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:lastScreenPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::lastScreenPosition (bool  {\i o} = {\f2 false}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a7a8571339a03d46435ab42ad619d2558_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v next\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::next (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_ac8a7d7a6b48bece35248ae6f26c8179b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_ac8a7d7a6b48bece35248ae6f26c8179b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RasterData} & C64::VICII::RasterData::operator= (const {\b RasterData} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reduceDisplayZone\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:reduceDisplayZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::RasterData::reduceDisplayZone (bool  {\i s})}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The display zone will reduced in both sides by half of the _positionsToReduce value. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_ab62ed76a5d8833e76aafd96edf57544c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v screenPositions\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:screenPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::screenPositions () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b VICII.hpp}.}\par
}
{\xe \v toBase0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:toBase0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::toBase0 (unsigned short  {\i m}) const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal method used return a value considering the firrst position as 0. \par
}{
Definition at line {\b 102} of file {\b VICII.hpp}.}\par
}
{\xe \v visiblePositions\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:visiblePositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::visiblePositions () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a39ea66cf6eaa1482b02832ba4378e742_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _currentPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_currentPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_currentPosition{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b VICII.hpp}.}\par
}
{\xe \v _currentPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_currentPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_currentPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b VICII.hpp}.}\par
}
{\xe \v _displayZoneReducted\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_displayZoneReducted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::_displayZoneReducted{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b VICII.hpp}.}\par
}
{\xe \v _firstDisplayPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_firstDisplayPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_firstDisplayPosition{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b VICII.hpp}.}\par
}
{\xe \v _firstDisplayPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_firstDisplayPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_firstDisplayPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 123} of file {\b VICII.hpp}.}\par
}
{\xe \v _firstPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_firstPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_firstPosition = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b VICII.hpp}.}\par
}
{\xe \v _firstPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_firstPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_firstPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b VICII.hpp}.}\par
}
{\xe \v _firstVisiblePosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_firstVisiblePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_firstVisiblePosition = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b VICII.hpp}.}\par
}
{\xe \v _firstVisiblePosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_firstVisiblePosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_firstVisiblePosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b VICII.hpp}.}\par
}
{\xe \v _lastDisplayPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_lastDisplayPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_lastDisplayPosition{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b VICII.hpp}.}\par
}
{\xe \v _lastDisplayPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_lastDisplayPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_lastDisplayPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b VICII.hpp}.}\par
}
{\xe \v _lastPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_lastPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_lastPosition = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b VICII.hpp}.}\par
}
{\xe \v _lastPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_lastPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_lastPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b VICII.hpp}.}\par
}
{\xe \v _lastVisiblePosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_lastVisiblePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_lastVisiblePosition = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b VICII.hpp}.}\par
}
{\xe \v _lastVisiblePosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_lastVisiblePosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_lastVisiblePosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b VICII.hpp}.}\par
}
{\xe \v _maxPositions\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_maxPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_maxPositions = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b VICII.hpp}.}\par
}
{\xe \v _originalFirstDisplayPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_originalFirstDisplayPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_originalFirstDisplayPosition{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b VICII.hpp}.}\par
}
{\xe \v _originalFirstDisplayPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_originalFirstDisplayPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_originalFirstDisplayPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b VICII.hpp}.}\par
}
{\xe \v _originalLastDisplayPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_originalLastDisplayPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_originalLastDisplayPosition{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b VICII.hpp}.}\par
}
{\xe \v _originalLastDisplayPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_originalLastDisplayPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_originalLastDisplayPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b VICII.hpp}.}\par
}
{\xe \v _positionsToReduce1\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_positionsToReduce1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_positionsToReduce1 = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b VICII.hpp}.}\par
}
{\xe \v _positionsToReduce2\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_positionsToReduce2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_positionsToReduce2 = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b VICII.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Register Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Register}
{\xe \v MCHEmul::Register}
{\bkmkstart AAAAAAACDI}
{\bkmkend AAAAAAACDI}
\par
{
{\f2 #include <Register.hpp>}}\par
Inheritance diagram for MCHEmul::Register:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Register:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} (int {\b id}, const std::string &n, const {\b UBytes} &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} (int {\b id}, const std::string &n, const std::vector< {\b UByte} > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} (const {\b Register} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} & {\b operator=} (const {\b Register} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b name} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UBytes} & {\b values} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< {\b UByte} > & {\b bytes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b asUInt} (bool bE) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b asAddress} (bool bE) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b accept} (const {\b UBytes} &v) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const std::vector< {\b UByte} > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b UBytes} &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Register} &r)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b Register} &r) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b Register} &r) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator[]} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} ({\b UByte::OutputFormat} oF, char s, size_t l=0) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b _name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b _values}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Register} &r)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A register is an internal storage area within any {\b CPU}. Depending on the {\b CPU}'s architecture, the length of a register can vary. \par
}{
Definition at line {\b 25} of file {\b Register.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Register\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:Register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Register::Register (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACDJ}
{\bkmkend AAAAAAACDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Register\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:Register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Register::Register (int  {\i id}, const std::string &  {\i n}, const {\b UBytes} &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDK}
{\bkmkend AAAAAAACDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i v} \cell }{variable \cell }
{\row }
}
}{
Definition at line {\b 30} of file {\b Register.hpp}.}\par
}
{\xe \v Register\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:Register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Register::Register (int  {\i id}, const std::string &  {\i n}, const std::vector< {\b UByte} > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDL}
{\bkmkend AAAAAAACDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i v} \cell }{variable \cell }
{\row }
}
}{
Definition at line {\b 34} of file {\b Register.hpp}.}\par
}
{\xe \v Register\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:Register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Register::Register (const {\b Register} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACDM}
{\bkmkend AAAAAAACDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v accept\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Register::accept (const {\b UBytes} &  {\i v}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDN}
{\bkmkend AAAAAAACDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The values can be accepted only if they have the same length than the register. \par
}{
Definition at line {\b 64} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a710bcc78e23deb68902c0973e2b0bc9b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a710bcc78e23deb68902c0973e2b0bc9b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asAddress\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:asAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::Register::asAddress (bool  {\i bE}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDO}
{\bkmkend AAAAAAACDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b Register.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a8e709601ac945687c3a813beed70c206_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asString\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Register::asString ({\b UByte::OutputFormat}  {\i oF}, char  {\i s}, size_t  {\i l} = {\f2 0}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDP}
{\bkmkend AAAAAAACDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i s} \cell }{separator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i l} \cell }{Minimum length per {\b UByte} \cell }
{\row }
}
}{
Definition at line {\b 84} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_af13dcc80f643840968e556cac3dc763e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asUInt\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:asUInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::Register::asUInt (bool  {\i bE}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDQ}
{\bkmkend AAAAAAACDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b Register.hpp}.}\par
}
{\xe \v bytes\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< {\b UByte} > & MCHEmul::Register::bytes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDR}
{\bkmkend AAAAAAACDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_afd5cacb72bd02974510772d87a4b7314_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_afd5cacb72bd02974510772d87a4b7314_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v id\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::Register::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Register.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Register::initialize (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDT}
{\bkmkend AAAAAAACDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize. \par
}{
Definition at line {\b 43} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a6d7eba569d72c9df7e2b26dab372553f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a6d7eba569d72c9df7e2b26dab372553f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v name\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::Register::name () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDU}
{\bkmkend AAAAAAACDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b Register.hpp}.}\par
}
{\xe \v operator!=\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Register::operator!= (const {\b Register} &  {\i r}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDV}
{\bkmkend AAAAAAACDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Register.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Register} & MCHEmul::Register::operator= (const {\b Register} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACDW}
{\bkmkend AAAAAAACDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Register::operator== (const {\b Register} &  {\i r}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDX}
{\bkmkend AAAAAAACDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Register.hpp}.}\par
}
{\xe \v operator[]\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::Register::operator[] (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDY}
{\bkmkend AAAAAAACDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b Register.hpp}.}\par
}
{\xe \v set\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Register::set (const {\b Register} &  {\i r}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDZ}
{\bkmkend AAAAAAACDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the values from another register, only if they can be accepted. \par
}{
Definition at line {\b 73} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_aef98a70b6004a92fcf9d11d84dd16912_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Register::set (const std::vector< {\b UByte} > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEA}
{\bkmkend AAAAAAACEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set values only if they can be accepted. \par
}{
Definition at line {\b 68} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a391d4d4664456f5c02495686d1863ce4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a391d4d4664456f5c02495686d1863ce4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Register::set (const {\b UBytes} &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEB}
{\bkmkend AAAAAAACEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_ad6cbb5c24ed0c16421e0e350e26a7d34_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::Register::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEC}
{\bkmkend AAAAAAACEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_afc012e0bff4fdaf9e725d52e1d52e52c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_afc012e0bff4fdaf9e725d52e1d52e52c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v values\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UBytes} & MCHEmul::Register::values () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACED}
{\bkmkend AAAAAAACED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b Register.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_ac64fce41d57ca96dc59c4c88da8832a2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Register} &  {\i r}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACEE}
{\bkmkend AAAAAAACEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _id\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int MCHEmul::Register::_id{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEF}
{\bkmkend AAAAAAACEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Register.hpp}.}\par
}
{\xe \v _name\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string MCHEmul::Register::_name{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEG}
{\bkmkend AAAAAAACEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b Register.hpp}.}\par
}
{\xe \v _values\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:_values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::Register::_values{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEH}
{\bkmkend AAAAAAACEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b Register.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Register.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::ROL_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::ROL_General}
{\xe \v F6500::ROL_General}
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::ROL_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_r_o_l___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::ROL_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_r_o_l___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ROL_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ROL_General}: To aggregate common steps in every ROL instruction. \par
}{
Definition at line {\b 451} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ROL_General\:F6500::ROL_General}
{\xe \v F6500::ROL_General\:ROL_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::ROL_General::ROL_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 454} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::ROL_General}
{\xe \v F6500::ROL_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::ROL_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::ROR_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::ROR_General}
{\xe \v F6500::ROR_General}
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::ROR_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_r_o_r___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::ROR_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_r_o_r___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ROR_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ROR_General}: To aggregate common steps in every ROR instruction. \par
}{
Definition at line {\b 470} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ROR_General\:F6500::ROR_General}
{\xe \v F6500::ROR_General\:ROR_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::ROR_General::ROR_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 473} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::ROR_General}
{\xe \v F6500::ROR_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::ROR_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::SBC_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::SBC_General}
{\xe \v F6500::SBC_General}
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::SBC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_b_c___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::SBC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_b_c___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SBC_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SBC_General}: To aggregate common steps in every SBC instruction. \par
}{
Definition at line {\b 495} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SBC_General\:F6500::SBC_General}
{\xe \v F6500::SBC_General\:SBC_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::SBC_General::SBC_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 498} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::SBC_General}
{\xe \v F6500::SBC_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::SBC_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::Screen Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::Screen}
{\xe \v C64::Screen}
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
\par
{
{\f2 #include <Screen.hpp>}}\par
Inheritance diagram for C64::Screen:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_screen__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::Screen:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_screen__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Screen} (double hz, int w, int h, const {\b MCHEmul::Attributes} &attrs=\{ \})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _ID} = 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 22} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Screen\:C64::Screen}
{\xe \v C64::Screen\:Screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::Screen::Screen (double  {\i hz}, int  {\i w}, int  {\i h}, const {\b MCHEmul::Attributes} &  {\i attrs} = {\f2 \{\~ \}})}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::Screen}
{\xe \v C64::Screen\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Screen::_ID = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b Screen.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Screen Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Screen}
{\xe \v MCHEmul::Screen}
{\bkmkstart AAAAAAACEI}
{\bkmkend AAAAAAACEI}
\par
{
{\f2 #include <Screen.hpp>}}\par
Inheritance diagram for MCHEmul::Screen:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_screen__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Screen:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_screen__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Screen} (const std::string &n, int {\b id}, unsigned int sc, unsigned int sr, unsigned int vF, double hz, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Screen} (const {\b Screen} *)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Screen} & {\b operator=} (const {\b Screen} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Screen} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b linkToChips} (const {\b Chips} &c) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b GraphicalChip} * {\b graphicalChip} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GraphicalChip} * {\b graphicalChip} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b screenName} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b screenColumns} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b screenRows} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b visibilityFactor} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b hertzs} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b _screenName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b _screenColumns}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b _screenRows}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b _visibilityFactor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b _hertzs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GraphicalChip} * {\b _graphicalChip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SDL_Window * {\b _window}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SDL_Renderer * {\b _renderer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SDL_Texture * {\b _texture}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b _refreshRate}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the very typical output device of any computer: The {\b Screen}. \par
}{
Definition at line {\b 24} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Screen\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:Screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Screen::Screen (const std::string &  {\i n}, int  {\i id}, unsigned int  {\i sc}, unsigned int  {\i sr}, unsigned int  {\i vF}, double  {\i hz}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}})}}
\par
{\bkmkstart AAAAAAACEJ}
{\bkmkend AAAAAAACEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates the instance of the window. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i n} \cell }{: The title of the windo to show. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i id} \cell }{: The id of the device. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{: The list of the chips related with this device. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sc} \cell }{: The number of columns of the screen. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sr} \cell }{: The number of rows of the screen. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vF} \cell }{: The visibility factor. That is hw many visible pixels represents a pixel in the computer. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nC} \cell }{: The number of colors. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hz} \cell }{: The speed of the refresh in Hz. \cell }
{\row }
}
}}
{\xe \v Screen\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:Screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Screen::Screen (const {\b Screen} * ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACEK}
{\bkmkend AAAAAAACEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Screen\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:~Screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::Screen::~Screen (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACEL}
{\bkmkend AAAAAAACEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v graphicalChip\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:graphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GraphicalChip} * MCHEmul::Screen::graphicalChip (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEM}
{\bkmkend AAAAAAACEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b Screen.hpp}.}\par
}
{\xe \v graphicalChip\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:graphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b GraphicalChip} * MCHEmul::Screen::graphicalChip () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEN}
{\bkmkend AAAAAAACEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The reference to the graphical chip. \par
}{
Definition at line {\b 51} of file {\b Screen.hpp}.}\par
}
{\xe \v hertzs\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:hertzs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double MCHEmul::Screen::hertzs () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEO}
{\bkmkend AAAAAAACEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b Screen.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Screen::initialize (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the device. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABPZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 68} of file {\b Screen.hpp}.}\par
}
{\xe \v linkToChips\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:linkToChips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Screen::linkToChips (const {\b Chips} &  {\i c}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To link to the right chips. The IO device never owns the chips. By default all chips are linked. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Screen} & MCHEmul::Screen::operator= (const {\b Screen} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACEP}
{\bkmkend AAAAAAACEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v screenColumns\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:screenColumns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Screen::screenColumns () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEQ}
{\bkmkend AAAAAAACEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b Screen.hpp}.}\par
}
{\xe \v screenName\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:screenName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string MCHEmul::Screen::screenName () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACER}
{\bkmkend AAAAAAACER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the value of all parameters. \par
}{
Definition at line {\b 57} of file {\b Screen.hpp}.}\par
}
{\xe \v screenRows\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:screenRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Screen::screenRows () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACES}
{\bkmkend AAAAAAACES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b Screen.hpp}.}\par
}
{\xe \v simulate\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Screen::simulate (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the screen using the info of the frame. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v visibilityFactor\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:visibilityFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Screen::visibilityFactor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACET}
{\bkmkend AAAAAAACET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _graphicalChip\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_graphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GraphicalChip}* MCHEmul::Screen::_graphicalChip{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEU}
{\bkmkend AAAAAAACEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set when initialize after assigning the chips. The graphical chip managing the graphical memory. That the screen displays. \par
}{
Definition at line {\b 85} of file {\b Screen.hpp}.}\par
}
{\xe \v _hertzs\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_hertzs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double MCHEmul::Screen::_hertzs{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEV}
{\bkmkend AAAAAAACEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b Screen.hpp}.}\par
}
{\xe \v _refreshRate\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_refreshRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MCHEmul::Screen::_refreshRate{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEW}
{\bkmkend AAAAAAACEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
At construction time, to speed up calculus. \par
}{
Definition at line {\b 93} of file {\b Screen.hpp}.}\par
}
{\xe \v _renderer\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_renderer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SDL_Renderer* MCHEmul::Screen::_renderer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEX}
{\bkmkend AAAAAAACEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b Screen.hpp}.}\par
}
{\xe \v _screenColumns\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_screenColumns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Screen::_screenColumns{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEY}
{\bkmkend AAAAAAACEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Screen.hpp}.}\par
}
{\xe \v _screenName\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_screenName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string MCHEmul::Screen::_screenName{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEZ}
{\bkmkend AAAAAAACEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b Screen.hpp}.}\par
}
{\xe \v _screenRows\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_screenRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Screen::_screenRows{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFA}
{\bkmkend AAAAAAACFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b Screen.hpp}.}\par
}
{\xe \v _texture\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_texture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SDL_Texture* MCHEmul::Screen::_texture{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFB}
{\bkmkend AAAAAAACFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Screen.hpp}.}\par
}
{\xe \v _visibilityFactor\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_visibilityFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Screen::_visibilityFactor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFC}
{\bkmkend AAAAAAACFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Screen.hpp}.}\par
}
{\xe \v _window\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_window}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SDL_Window* MCHEmul::Screen::_window{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFD}
{\bkmkend AAAAAAACFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Screen.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::ScreenMemory Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory}
{\bkmkstart AAAAAAACFE}
{\bkmkend AAAAAAACFE}
\par
{
{\f2 #include <ScreenMemory.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenMemory} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenMemory} (size_t c, size_t r, unsigned int *p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenMemory} (const {\b ScreenMemory} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenMemory} & {\b operator=} (const {\b ScreenMemory} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ScreenMemory} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b columns} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b rows} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int * {\b frameData} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPixel} (size_t x, size_t y, unsigned int color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHorizontalLine} (size_t x, size_t y, size_t nP, unsigned int color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVerticalLine} (size_t x, size_t y, size_t nP, unsigned int color)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It represents a the memory where all things to be sent to the screen are store. \par
It is actually a matrix of unsigned int, representing each one the color of a pixel in the screen. \par
}{
Definition at line {\b 22} of file {\b ScreenMemory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ScreenMemory\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:ScreenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::ScreenMemory::ScreenMemory (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACFF}
{\bkmkend AAAAAAACFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ScreenMemory\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:ScreenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::ScreenMemory::ScreenMemory (size_t  {\i c}, size_t  {\i r}, unsigned int *  {\i p})}}
\par
{\bkmkstart AAAAAAACFG}
{\bkmkend AAAAAAACFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ScreenMemory\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:ScreenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::ScreenMemory::ScreenMemory (const {\b ScreenMemory} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACFH}
{\bkmkend AAAAAAACFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~ScreenMemory\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:~ScreenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::ScreenMemory::~ScreenMemory (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFI}
{\bkmkend AAAAAAACFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b ScreenMemory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v columns\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:columns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::ScreenMemory::columns () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFJ}
{\bkmkend AAAAAAACFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b ScreenMemory.hpp}.}\par
}
{\xe \v frameData\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:frameData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int * MCHEmul::ScreenMemory::frameData () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFK}
{\bkmkend AAAAAAACFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b ScreenMemory.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScreenMemory} & MCHEmul::ScreenMemory::operator= (const {\b ScreenMemory} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACFL}
{\bkmkend AAAAAAACFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rows\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:rows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::ScreenMemory::rows () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFM}
{\bkmkend AAAAAAACFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b ScreenMemory.hpp}.}\par
}
{\xe \v setHorizontalLine\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:setHorizontalLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ScreenMemory::setHorizontalLine (size_t  {\i x}, size_t  {\i y}, size_t  {\i nP}, unsigned int  {\i color}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFN}
{\bkmkend AAAAAAACFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b ScreenMemory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_screen_memory_a0b58f09381a138dbcc90f66f6a25074f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setPixel\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:setPixel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ScreenMemory::setPixel (size_t  {\i x}, size_t  {\i y}, unsigned int  {\i color}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFO}
{\bkmkend AAAAAAACFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b ScreenMemory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_screen_memory_a600ff5a6b2b617c853f25a3655a01c51_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setVerticalLine\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:setVerticalLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ScreenMemory::setVerticalLine (size_t  {\i x}, size_t  {\i y}, size_t  {\i nP}, unsigned int  {\i color}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFP}
{\bkmkend AAAAAAACFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b ScreenMemory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_screen_memory_a6fa40cc84aa0c1f0e38282515dd715ff_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b ScreenMemory.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::ScreenNTSC Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::ScreenNTSC}
{\xe \v C64::ScreenNTSC}
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
\par
{
{\f2 #include <Screen.hpp>}}\par
Inheritance diagram for C64::ScreenNTSC:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_screen_n_t_s_c__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::ScreenNTSC:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_screen_n_t_s_c__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenNTSC} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 29} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ScreenNTSC\:C64::ScreenNTSC}
{\xe \v C64::ScreenNTSC\:ScreenNTSC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::ScreenNTSC::ScreenNTSC (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b Screen.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::ScreenPAL Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::ScreenPAL}
{\xe \v C64::ScreenPAL}
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
\par
{
{\f2 #include <Screen.hpp>}}\par
Inheritance diagram for C64::ScreenPAL:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_screen_p_a_l__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::ScreenPAL:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_screen_p_a_l__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenPAL} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 38} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ScreenPAL\:C64::ScreenPAL}
{\xe \v C64::ScreenPAL\:ScreenPAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::ScreenPAL::ScreenPAL (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b Screen.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::Semantic Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic}
{\bkmkstart AAAAAAACTU}
{\bkmkend AAAAAAACTU}
\par
{
{\f2 #include <Grammar.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Semantic} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Semantic} (const {\b Semantic} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Semantic} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Semantic} & {\b operator=} (const {\b Semantic} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Macros} & {\b macros} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addMacro} (const {\b Macro} &m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b StartingPointElements} & {\b startingPoints} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartingPointElement} * {\b addNewStartingPoint} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addGrammaticalElement} ({\b GrammaticalElement} *g)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b GrammaticalElement} * {\b lastGrammaticalElementAdded} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GrammaticalElement} * {\b lastGrammaticalElementAdded} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ErrorType} {\b error} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addFrom} (const {\b Semantic} *s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsLabel} (const std::string &l) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b addressForLabel} (const std::string &l) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< const {\b LabelElement} * > {\b labels} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< std::string, {\b Address} > {\b labelAddresses} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b CommandParser}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 261} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Semantic\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:Semantic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Semantic::Semantic (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTV}
{\bkmkend AAAAAAACTV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 266} of file {\b Grammar.hpp}.}\par
}
{\xe \v Semantic\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:Semantic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Semantic::Semantic (const {\b Semantic} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACTW}
{\bkmkend AAAAAAACTW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Semantic\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:~Semantic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Semantic::~Semantic (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTX}
{\bkmkend AAAAAAACTX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 273} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addFrom\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:addFrom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::Semantic::addFrom (const {\b Semantic} *  {\i s})}}
\par
{\bkmkstart AAAAAAACTY}
{\bkmkend AAAAAAACTY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The semantic can add elements from other (macros are also added). \par
}}
{\xe \v addGrammaticalElement\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:addGrammaticalElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::Semantic::addGrammaticalElement ({\b GrammaticalElement} *  {\i g})}}
\par
{\bkmkstart AAAAAAACTZ}
{\bkmkend AAAAAAACTZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v addMacro\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:addMacro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::Semantic::addMacro (const {\b Macro} &  {\i m})}}
\par
{\bkmkstart AAAAAAACUA}
{\bkmkend AAAAAAACUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v addNewStartingPoint\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:addNewStartingPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StartingPointElement} * MCHEmul::Assembler::Semantic::addNewStartingPoint ()}}
\par
{\bkmkstart AAAAAAACUB}
{\bkmkend AAAAAAACUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v addressForLabel\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:addressForLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::Assembler::Semantic::addressForLabel (const std::string &  {\i l}) const}}
\par
{\bkmkstart AAAAAAACUC}
{\bkmkend AAAAAAACUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To determine the distance of an {\b Address} with that label. If the label has't been defined in the semantic, 0 is returnd but it wouldn't mean anything. \par
}}
{\xe \v error\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ErrorType} MCHEmul::Assembler::Semantic::error () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUD}
{\bkmkend AAAAAAACUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 291} of file {\b Grammar.hpp}.}\par
}
{\xe \v existsLabel\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:existsLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::Semantic::existsLabel (const std::string &  {\i l}) const}}
\par
{\bkmkstart AAAAAAACUE}
{\bkmkend AAAAAAACUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To verify whether exists a label. \par
}}
{\xe \v labelAddresses\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:labelAddresses}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map< std::string, {\b Address} > MCHEmul::Assembler::Semantic::labelAddresses () const}}
\par
{\bkmkstart AAAAAAACUF}
{\bkmkend AAAAAAACUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
to get the list of labels and addrresses associated. \par
}}
{\xe \v labels\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:labels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< const {\b LabelElement} * > MCHEmul::Assembler::Semantic::labels () const}}
\par
{\bkmkstart AAAAAAACUG}
{\bkmkend AAAAAAACUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the list of all labels. \par
}}
{\xe \v lastGrammaticalElementAdded\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:lastGrammaticalElementAdded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GrammaticalElement} * MCHEmul::Assembler::Semantic::lastGrammaticalElementAdded (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUH}
{\bkmkend AAAAAAACUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 288} of file {\b Grammar.hpp}.}\par
}
{\xe \v lastGrammaticalElementAdded\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:lastGrammaticalElementAdded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b GrammaticalElement} * MCHEmul::Assembler::Semantic::lastGrammaticalElementAdded () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUI}
{\bkmkend AAAAAAACUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 286} of file {\b Grammar.hpp}.}\par
}
{\xe \v macros\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:macros}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Macros} & MCHEmul::Assembler::Semantic::macros () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUJ}
{\bkmkend AAAAAAACUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b Grammar.hpp}.}\par
}
{\xe \v operator!\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::Semantic::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUK}
{\bkmkend AAAAAAACUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the analysis of the macro. \par
}{
Definition at line {\b 295} of file {\b Grammar.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Semantic} & MCHEmul::Assembler::Semantic::operator= (const {\b Semantic} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACUL}
{\bkmkend AAAAAAACUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v startingPoints\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:startingPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b StartingPointElements} & MCHEmul::Assembler::Semantic::startingPoints () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUM}
{\bkmkend AAAAAAACUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 282} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v CommandParser\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:CommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend MCHEmul::Assembler::Semantic::CommandParser}}
\par
{\bkmkstart AAAAAAACUN}
{\bkmkend AAAAAAACUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 264} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::SpecialFunctionsChip Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::SpecialFunctionsChip}
{\xe \v C64::SpecialFunctionsChip}
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
\par
{
{\f2 #include <SFChip.hpp>}}\par
Inheritance diagram for C64::SpecialFunctionsChip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_special_functions_chip__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::SpecialFunctionsChip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_special_functions_chip__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SpecialFunctionsChip} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ({\b MCHEmul::CPU} *cpu) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _ID} = 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 21} of file {\b SFChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SpecialFunctionsChip\:C64::SpecialFunctionsChip}
{\xe \v C64::SpecialFunctionsChip\:SpecialFunctionsChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::SpecialFunctionsChip::SpecialFunctionsChip (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b SFChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::SpecialFunctionsChip}
{\xe \v C64::SpecialFunctionsChip\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool C64::SpecialFunctionsChip::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v simulate\:C64::SpecialFunctionsChip}
{\xe \v C64::SpecialFunctionsChip\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool C64::SpecialFunctionsChip::simulate ({\b MCHEmul::CPU} * ){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate th behaviour of the chip. It has to be defined per chip. \par
Returns true if everything was ok, and false in any other circunstance. \par
 The last error could be recovered from the variable _lastError in that case. \par
The clock cyclees is added. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::SpecialFunctionsChip}
{\xe \v C64::SpecialFunctionsChip\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int C64::SpecialFunctionsChip::_ID = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b SFChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b SFChip.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::STA_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::STA_General}
{\xe \v F6500::STA_General}
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::STA_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_a___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::STA_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_a___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b STA_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b STA_General}: To aggregate common steps in every STA instruction. \par
}{
Definition at line {\b 526} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v STA_General\:F6500::STA_General}
{\xe \v F6500::STA_General\:STA_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::STA_General::STA_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 529} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::STA_General}
{\xe \v F6500::STA_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::STA_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Stack Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Stack}
{\xe \v MCHEmul::Stack}
{\bkmkstart AAAAAAACFQ}
{\bkmkend AAAAAAACFQ}
\par
{
{\f2 #include <Stack.hpp>}}\par
Inheritance diagram for MCHEmul::Stack:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_stack__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Stack:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_stack__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Stack} (int {\b id}, {\b PhisicalStorage} *ps, size_t pp, const {\b Address} &iA, size_t s, bool b=true, bool e=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b position} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPosition} (int p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push} (const {\b UBytes} &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b pull} (size_t nV)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b stackOverflow} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Stack} &s)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 21} of file {\b Stack.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Stack\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:Stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Stack::Stack (int  {\i id}, {\b PhisicalStorage} *  {\i ps}, size_t  {\i pp}, const {\b Address} &  {\i iA}, size_t  {\i s}, bool  {\i b} = {\f2 true}, bool  {\i e} = {\f2 true}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFR}
{\bkmkend AAAAAAACFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor: {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i b} \cell }{: From the end of the memory to the beggining or the other way around \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e} \cell }{: Poining always to the empty place or pointing to the last position kept. \cell }
{\row }
}
}{
Definition at line {\b 29} of file {\b Stack.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Stack::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACBK}
{\bkmkend AAAAAAACBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To init the memory. It might be overloaded. By default the "defaultData" value is assigned. It doesn't matter whether the subset is or not active. \par
}{
Reimplemented from {\b MCHEmul::PhisicalStorageSubset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v position\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::Stack::position () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFS}
{\bkmkend AAAAAAACFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b Stack.hpp}.}\par
}
{\xe \v pull\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:pull}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::Stack::pull (size_t  {\i nV})}}
\par
{\bkmkstart AAAAAAACFT}
{\bkmkend AAAAAAACFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v push\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Stack::push (const {\b UBytes} &  {\i v})}}
\par
{\bkmkstart AAAAAAACFU}
{\bkmkend AAAAAAACFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setPosition\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:setPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Stack::setPosition (int  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFV}
{\bkmkend AAAAAAACFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Take care using this method. No checks are done on regards to the speed. And it is not the same a back-stack than a foward one. \par
}{
Definition at line {\b 40} of file {\b Stack.hpp}.}\par
}
{\xe \v stackOverflow\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:stackOverflow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Stack::stackOverflow () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFW}
{\bkmkend AAAAAAACFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It is set to true when something happens after push or pull actions. \par
}{
Definition at line {\b 49} of file {\b Stack.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Stack} &  {\i s}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACFX}
{\bkmkend AAAAAAACFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Stack.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::StandardCommandBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::StandardCommandBuilder}
{\xe \v MCHEmul::StandardCommandBuilder}
{\bkmkstart AAAAAAACFY}
{\bkmkend AAAAAAACFY}
\par
{
{\f2 #include <CommandBuilder.hpp>}}\par
Inheritance diagram for MCHEmul::StandardCommandBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_standard_command_builder__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::StandardCommandBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_standard_command_builder__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Command} * {\b createEmptyCommand} (const std::string &cmdName) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very basic command builer creates the basic commands. \par
}{
Definition at line {\b 39} of file {\b CommandBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createEmptyCommand\:MCHEmul::StandardCommandBuilder}
{\xe \v MCHEmul::StandardCommandBuilder\:createEmptyCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b Command} * MCHEmul::StandardCommandBuilder::createEmptyCommand (const std::string &  {\i cmdName}) const{\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::CommandBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABIW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b CommandBuilder.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::StandardMessageBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::StandardMessageBuilder}
{\xe \v MCHEmul::StandardMessageBuilder}
{\bkmkstart AAAAAAACFZ}
{\bkmkend AAAAAAACFZ}
\par
{
{\f2 #include <StdMessages.hpp>}}\par
Inheritance diagram for MCHEmul::StandardMessageBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_standard_message_builder__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::StandardMessageBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_standard_message_builder__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StandardMessageBuilder} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b CommunicationMessage} * {\b createMessage} (const std::string &str) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The standard message builder. \par
This class instantiates the default message supported by the standard {\b MCHEmul} library. \par
}{
Definition at line {\b 23} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v StandardMessageBuilder\:MCHEmul::StandardMessageBuilder}
{\xe \v MCHEmul::StandardMessageBuilder\:StandardMessageBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::StandardMessageBuilder::StandardMessageBuilder (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGA}
{\bkmkend AAAAAAACGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createMessage\:MCHEmul::StandardMessageBuilder}
{\xe \v MCHEmul::StandardMessageBuilder\:createMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b CommunicationMessage} * MCHEmul::StandardMessageBuilder::createMessage (const std::string &  {\i str}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::MessageBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABYU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b StdMessages.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::StartingPointCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::StartingPointCommandParser}
{\xe \v MCHEmul::Assembler::StartingPointCommandParser}
{\bkmkstart AAAAAAACUO}
{\bkmkend AAAAAAACUO}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::StartingPointCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_starting_point_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::StartingPointCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_starting_point_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartingPointCommandParser} (unsigned char s='=')\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *s) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser an address macro. The symbol defining the separation between definition and value can be redefined. Qhen parser the address assigned is incremented. \par
}{
Definition at line {\b 132} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v StartingPointCommandParser\:MCHEmul::Assembler::StartingPointCommandParser}
{\xe \v MCHEmul::Assembler::StartingPointCommandParser\:StartingPointCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::StartingPointCommandParser::StartingPointCommandParser (unsigned char  {\i s} = {\f2 '='}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUP}
{\bkmkend AAAAAAACUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::StartingPointCommandParser}
{\xe \v MCHEmul::Assembler::StartingPointCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::StartingPointCommandParser::canParse (const std::string &  {\i l}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPP}
{\bkmkend AAAAAAACPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 144} of file {\b Parser.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_starting_point_command_parser_add2b6e6fafe28125d429514cf5d7d203_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::Assembler::StartingPointCommandParser}
{\xe \v MCHEmul::Assembler::StartingPointCommandParser\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::StartingPointCommandParser::initialize (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPT}
{\bkmkend AAAAAAACPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maybe one of them could need it. \par
}{
Reimplemented from {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 141} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::StartingPointCommandParser}
{\xe \v MCHEmul::Assembler::StartingPointCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::StartingPointCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPY}
{\bkmkend AAAAAAACPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACPD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::StartingPointElement Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::StartingPointElement}
{\xe \v MCHEmul::Assembler::StartingPointElement}
{\bkmkstart AAAAAAACUQ}
{\bkmkend AAAAAAACUQ}
\par
{
{\f2 #include <Grammar.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::StartingPointElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_starting_point_element__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::StartingPointElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_starting_point_element__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartingPointElement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartingPointElement} (const {\b StartingPointElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartingPointElement} & {\b operator=} (const {\b StartingPointElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Address} {\b address} (const {\b Semantic} *s) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _value}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
explanation at the beggining of the file. \par
}}}{
Definition at line {\b 232} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v StartingPointElement\:MCHEmul::Assembler::StartingPointElement}
{\xe \v MCHEmul::Assembler::StartingPointElement\:StartingPointElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::StartingPointElement::StartingPointElement (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUR}
{\bkmkend AAAAAAACUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 234} of file {\b Grammar.hpp}.}\par
}
{\xe \v StartingPointElement\:MCHEmul::Assembler::StartingPointElement}
{\xe \v MCHEmul::Assembler::StartingPointElement\:StartingPointElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::StartingPointElement::StartingPointElement (const {\b StartingPointElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACUS}
{\bkmkend AAAAAAACUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v address\:MCHEmul::Assembler::StartingPointElement}
{\xe \v MCHEmul::Assembler::StartingPointElement\:address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b Address} MCHEmul::Assembler::StartingPointElement::address (const {\b Semantic} *  {\i s}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACRL}
{\bkmkend AAAAAAACRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know the address of the grammatical element. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
, big Endian implicit.\par
}{
Reimplemented from {\b MCHEmul::Assembler::GrammaticalElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACRK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 243} of file {\b Grammar.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_starting_point_element_a6842f2ea721af17220cda990be2515b9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Assembler::StartingPointElement}
{\xe \v MCHEmul::Assembler::StartingPointElement\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StartingPointElement} & MCHEmul::Assembler::StartingPointElement::operator= (const {\b StartingPointElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACUT}
{\bkmkend AAAAAAACUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _value\:MCHEmul::Assembler::StartingPointElement}
{\xe \v MCHEmul::Assembler::StartingPointElement\:_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Assembler::StartingPointElement::_value}}
\par
{\bkmkstart AAAAAAACUU}
{\bkmkend AAAAAAACUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 246} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::StatusRegister Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister}
{\bkmkstart AAAAAAACGB}
{\bkmkend AAAAAAACGB}
\par
{
{\f2 #include <StatusRegister.hpp>}}\par
Inheritance diagram for MCHEmul::StatusRegister:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::StatusRegister:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b BitNames} = std::map< std::string, int >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StatusRegister} (size_t nB, const {\b BitNames} &bN)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StatusRegister} (const {\b StatusRegister} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StatusRegister} & {\b operator=} (const {\b StatusRegister} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b BitNames} & {\b bitNames} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsBitStatus} (const std::string &bN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b bitStatus} (const std::string &bN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBitStatus} (const std::string &bN, bool s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UBytes} & {\b values} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< {\b UByte} > & {\b bytes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b valuesWithout} (const std::vector< std::string > &bN)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const std::vector< {\b UByte} > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b UBytes} &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b StatusRegister} &r)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In the register avery bit could have a different meaning. \par
}{
Definition at line {\b 22} of file {\b StatusRegister.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v BitNames\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:BitNames}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::StatusRegister::BitNames} =  std::map <std::string, int>}}
\par
{\bkmkstart AAAAAAACGC}
{\bkmkend AAAAAAACGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b StatusRegister.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v StatusRegister\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:StatusRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::StatusRegister::StatusRegister (size_t  {\i nB}, const {\b BitNames} &  {\i bN}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGD}
{\bkmkend AAAAAAACGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b StatusRegister.hpp}.}\par
}
{\xe \v StatusRegister\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:StatusRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::StatusRegister::StatusRegister (const {\b StatusRegister} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACGE}
{\bkmkend AAAAAAACGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asString\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::StatusRegister::asString () const}}
\par
{\bkmkstart AAAAAAACGF}
{\bkmkend AAAAAAACGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bitNames\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:bitNames}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b BitNames} & MCHEmul::StatusRegister::bitNames () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGG}
{\bkmkend AAAAAAACGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b StatusRegister.hpp}.}\par
}
{\xe \v bitStatus\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:bitStatus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::StatusRegister::bitStatus (const std::string &  {\i bN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGH}
{\bkmkend AAAAAAACGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Take care using these methods, no check about the name used are don for speed reasons. \par
}{
Definition at line {\b 44} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_aed0762785e1eb7c313f5363c28dd28c7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bytes\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< {\b UByte} > & MCHEmul::StatusRegister::bytes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGI}
{\bkmkend AAAAAAACGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_acdb36c8eee632df662155ed2e49772e7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsBitStatus\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:existsBitStatus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::StatusRegister::existsBitStatus (const std::string &  {\i bN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGJ}
{\bkmkend AAAAAAACGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b StatusRegister.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::StatusRegister::initialize (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGK}
{\bkmkend AAAAAAACGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a34c637ea437ce75e65d3ea8524353542_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StatusRegister} & MCHEmul::StatusRegister::operator= (const {\b StatusRegister} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACGL}
{\bkmkend AAAAAAACGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v set\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::StatusRegister::set (const std::vector< {\b UByte} > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGM}
{\bkmkend AAAAAAACGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a6ba184706ff7a78294dae0c3b481a242_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::StatusRegister::set (const {\b UBytes} &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGN}
{\bkmkend AAAAAAACGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a57f310b336ee5f65551e11de0683a9d9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setBitStatus\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:setBitStatus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::StatusRegister::setBitStatus (const std::string &  {\i bN}, bool  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGO}
{\bkmkend AAAAAAACGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a8ddec9ec56dba64dc1180dad06185d9e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v values\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UBytes} & MCHEmul::StatusRegister::values () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGP}
{\bkmkend AAAAAAACGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a13d609342da424f52c633cd40fd2362b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v valuesWithout\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:valuesWithout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::StatusRegister::valuesWithout (const std::vector< std::string > &  {\i bN})}}
\par
{\bkmkstart AAAAAAACGQ}
{\bkmkend AAAAAAACGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b StatusRegister} &  {\i r}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACGR}
{\bkmkend AAAAAAACGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b StatusRegister.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b StatusRegister.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Instruction::Structure Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure}
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
\par
{
{\f2 #include <Instruction.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Parameter}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Structure} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Structure} (const std::string &t, const std::string &wM, const std::vector< {\b Parameter} > &prms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Structure} (const {\b Structure} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Structure} & {\b operator=} (const {\b Structure} &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _error}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _templateWithNoParameters}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _waterMark}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _waterMarkPlus}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Parameter} > {\b _parameters}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the internal structure of a instruction. It is quite useful to be managed later by the parsers! \par
}{
Definition at line {\b 32} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Structure\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:Structure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Structure::Structure (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b Instruction.hpp}.}\par
}
{\xe \v Structure\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:Structure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Structure::Structure (const std::string &  {\i t}, const std::string &  {\i wM}, const std::vector< {\b Parameter} > &  {\i prms}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b Instruction.hpp}.}\par
}
{\xe \v Structure\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:Structure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Structure::Structure (const {\b Structure} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Structure} & MCHEmul::Instruction::Structure::operator= (const {\b Structure} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _error\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Instruction::Structure::_error}}
\par
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To indicate whether there was or not a mistake after the analysis of the instruction... In that error-case the _templateWithNoParameters will hold either "-" (instruction error) or "?" (parameter error). \par
}{
Definition at line {\b 74} of file {\b Instruction.hpp}.}\par
}
{\xe \v _parameters\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:_parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b Parameter}> MCHEmul::Instruction::Structure::_parameters}}
\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Instruction.hpp}.}\par
}
{\xe \v _templateWithNoParameters\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:_templateWithNoParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Instruction::Structure::_templateWithNoParameters}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b Instruction.hpp}.}\par
}
{\xe \v _waterMark\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:_waterMark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Instruction::Structure::_waterMark}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Instruction.hpp}.}\par
}
{\xe \v _waterMarkPlus\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:_waterMarkPlus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Instruction::Structure::_waterMarkPlus}}
\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Instruction.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::STX_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::STX_General}
{\xe \v F6500::STX_General}
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::STX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_x___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::STX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_x___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b STX_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b STX_General}: To aggregate common steps in every STX instruction. \par
}{
Definition at line {\b 547} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v STX_General\:F6500::STX_General}
{\xe \v F6500::STX_General\:STX_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::STX_General::STX_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 550} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::STX_General}
{\xe \v F6500::STX_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::STX_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::STY_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::STY_General}
{\xe \v F6500::STY_General}
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::STY_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_y___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::STY_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_y___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b STY_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b STY_General}: To aggregate common steps in every STY instruction. \par
}{
Definition at line {\b 564} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v STY_General\:F6500::STY_General}
{\xe \v F6500::STY_General\:STY_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::STY_General::STY_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 567} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::STY_General}
{\xe \v F6500::STY_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::STY_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UByte Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UByte}
{\xe \v MCHEmul::UByte}
{\bkmkstart AAAAAAACGS}
{\bkmkend AAAAAAACGS}
\par
{
{\f2 #include <UByte.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b OutputFormat} \{ {\b _DECIMAL}
, {\b _BINARY}
, {\b _OCTAL}
, {\b _HEXA}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} (unsigned char v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} (const {\b UByte} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator=} (const {\b UByte} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b value} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b bit} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBit} (size_t p, bool s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b LSNibble} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b MSNibble} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b complement} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shiftLeftC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b shiftLeft} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shiftRightC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b shiftRight} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rotateLeftC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b rotateLeft} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rotateRightC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b rotateRight} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b bitAdding} (const {\b UByte} &u, bool cin, bool &cout, bool &o) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator&} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator&=} (const {\b UByte} &u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator|} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator|=} (const {\b UByte} &u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator^} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator^=} (const {\b UByte} &u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator~} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator[]} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator<<} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator>>} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} ({\b OutputFormat} oF, size_t l=0) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b size} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b sizeBits} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _0} = 0x00\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _1} = 0x01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _FF} = 0xff\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _0F} = 0x0f\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _F0} = 0xf0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _80} = 0x80\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _09} = 0x09\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _90} = 0x90\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _09N} = ~{\b _09} + 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _90N} = ~{\b _90} + 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _06} = 0x06\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _60} = 0x60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _06N} = ~{\b _06} + {\b _1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _60N} = ~{\b _60} + {\b _1}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b UByte} &u)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing the minimum piece of addressable info in a computer. MSB is the bit 7, LSB is the bit 0. Read bits from right to left. \par
}{
Definition at line {\b 24} of file {\b UByte.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v OutputFormat\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:OutputFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b MCHEmul::UByte::OutputFormat}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAACGT}
{\bkmkend AAAAAAACGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _DECIMAL\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_DECIMAL}
{\qr _DECIMAL{\bkmkstart AAAAAAACGU}
{\bkmkend AAAAAAACGU}
\cell }{\cell }{\row }
{\xe \v _BINARY\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_BINARY}
{\qr _BINARY{\bkmkstart AAAAAAACGV}
{\bkmkend AAAAAAACGV}
\cell }{\cell }{\row }
{\xe \v _OCTAL\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_OCTAL}
{\qr _OCTAL{\bkmkstart AAAAAAACGW}
{\bkmkend AAAAAAACGW}
\cell }{\cell }{\row }
{\xe \v _HEXA\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_HEXA}
{\qr _HEXA{\bkmkstart AAAAAAACGX}
{\bkmkend AAAAAAACGX}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 27} of file {\b UByte.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v UByte\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:UByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UByte::UByte (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGY}
{\bkmkend AAAAAAACGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b UByte.hpp}.}\par
}
{\xe \v UByte\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:UByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UByte::UByte (unsigned char  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGZ}
{\bkmkend AAAAAAACGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b UByte.hpp}.}\par
}
{\xe \v UByte\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:UByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UByte::UByte (const {\b UByte} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACHA}
{\bkmkend AAAAAAACHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asString\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::UByte::asString ({\b OutputFormat}  {\i oF}, size_t  {\i l} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAACHB}
{\bkmkend AAAAAAACHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i l} \cell }{Minimum length. \cell }
{\row }
}
}}
{\xe \v bit\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:bit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::bit (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHC}
{\bkmkend AAAAAAACHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you requested for a bit bigger than sizeBits, the crash is guaranteed. No checks are done to increase the speed. \par
}{
Definition at line {\b 73} of file {\b UByte.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_ad00c1228bc2fbb11f54e397f862c77d4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bitAdding\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:bitAdding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::bitAdding (const {\b UByte} &  {\i u}, bool  {\i cin}, bool &  {\i cout}, bool &  {\i o}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHD}
{\bkmkend AAAAAAACHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Just to do a bit adding. But very interesting method. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i u} \cell }{The byte to add. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cin} \cell }{Is there any carry at the beginning to take into account? \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cout} \cell }{It is actualized whether a carry is generated from the adding. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i o} \cell }{Is is actualized whether an overflow is generated, that is when the MSBits of inputs are equal and different from the output. \cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
instead {\b UByte::_1} to guaranttee it is online.\par
unsigned short = 2 bytes long.\par
cut it.\par
}{
Definition at line {\b 156} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a59a815aa4e01f3e9c7fc45bea9fa49f5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v complement\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:complement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::complement () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHE}
{\bkmkend AAAAAAACHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To calculate the complement (bits 0 to 1 and the other way around). \par
}{
Definition at line {\b 84} of file {\b UByte.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a4735d2470f263a206dd316325524e63e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v LSNibble\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:LSNibble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::LSNibble () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHF}
{\bkmkend AAAAAAACHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b UByte.hpp}.}\par
}
{\xe \v MSNibble\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:MSNibble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::MSNibble () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHG}
{\bkmkend AAAAAAACHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b UByte.hpp}.}\par
}
{\xe \v operator!=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator!= (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHH}
{\bkmkend AAAAAAACHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b UByte.hpp}.}\par
}
{\xe \v operator&\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator&}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::operator& (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHI}
{\bkmkend AAAAAAACHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 123} of file {\b UByte.hpp}.}\par
}
{\xe \v operator&=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator&=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::operator&= (const {\b UByte} &  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHJ}
{\bkmkend AAAAAAACHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b UByte.hpp}.}\par
}
{\xe \v operator<\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator< (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHK}
{\bkmkend AAAAAAACHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b UByte.hpp}.}\par
}
{\xe \v operator<<\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::operator<< (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHL}
{\bkmkend AAAAAAACHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 140} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_ac386c477bb018876918a8a266a05e7e8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator<= (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHM}
{\bkmkend AAAAAAACHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 120} of file {\b UByte.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::operator= (const {\b UByte} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACHN}
{\bkmkend AAAAAAACHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator== (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHO}
{\bkmkend AAAAAAACHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b UByte.hpp}.}\par
}
{\xe \v operator>\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator> (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHP}
{\bkmkend AAAAAAACHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b UByte.hpp}.}\par
}
{\xe \v operator>=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator>= (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHQ}
{\bkmkend AAAAAAACHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b UByte.hpp}.}\par
}
{\xe \v operator>>\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::operator>> (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHR}
{\bkmkend AAAAAAACHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_ab9b8b8d957ad445e13eeedd03786bfde_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator[]\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator[] (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHS}
{\bkmkend AAAAAAACHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_aa4efd0e14568ef52f1056c83e4315ee2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator^\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator^}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::operator^ (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHT}
{\bkmkend AAAAAAACHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b UByte.hpp}.}\par
}
{\xe \v operator^=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator^=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::operator^= (const {\b UByte} &  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHU}
{\bkmkend AAAAAAACHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b UByte.hpp}.}\par
}
{\xe \v operator|\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::operator| (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHV}
{\bkmkend AAAAAAACHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b UByte.hpp}.}\par
}
{\xe \v operator|=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator|=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::operator|= (const {\b UByte} &  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHW}
{\bkmkend AAAAAAACHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b UByte.hpp}.}\par
}
{\xe \v operator~\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator~}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::operator~ () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHX}
{\bkmkend AAAAAAACHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a6fda0b5a0881ff1a17af7f15dc3b6839_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rotateLeft\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:rotateLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::rotateLeft (size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACHY}
{\bkmkend AAAAAAACHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{without carry flag \cell }
{\row }
}
}}
{\xe \v rotateLeftC\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:rotateLeftC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::rotateLeftC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACHZ}
{\bkmkend AAAAAAACHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{carry flag \cell }
{\row }
}
}}
{\xe \v rotateRight\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:rotateRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::rotateRight (size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACIA}
{\bkmkend AAAAAAACIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rotateRightC\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:rotateRightC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::rotateRightC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACIB}
{\bkmkend AAAAAAACIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setBit\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:setBit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UByte::setBit (size_t  {\i p}, bool  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIC}
{\bkmkend AAAAAAACIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b UByte.hpp}.}\par
}
{\xe \v shiftLeft\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:shiftLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::shiftLeft (size_t  {\i p} = {\f2 1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACID}
{\bkmkend AAAAAAACID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a4c999ba07989d95512306a08fa2371f8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a4c999ba07989d95512306a08fa2371f8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftLeftC\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:shiftLeftC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::shiftLeftC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACIE}
{\bkmkend AAAAAAACIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{carry flag \cell }
{\row }
}
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a9d041167514be07bd773e13c966c24d7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftRight\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:shiftRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::shiftRight (size_t  {\i p} = {\f2 1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIF}
{\bkmkend AAAAAAACIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a59f283bc83e142563dc79fe0dc563012_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a59f283bc83e142563dc79fe0dc563012_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftRightC\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:shiftRightC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::shiftRightC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACIG}
{\bkmkend AAAAAAACIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a0926228fa4243b2ec132ade2a122c9ab_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static size_t MCHEmul::UByte::size (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIH}
{\bkmkend AAAAAAACIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
COmmon to every UByt. \par
}{
Definition at line {\b 63} of file {\b UByte.hpp}.}\par
}
{\xe \v sizeBits\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:sizeBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static size_t MCHEmul::UByte::sizeBits (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACII}
{\bkmkend AAAAAAACII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b UByte.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a256a022714d442b93208eff11967e44c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::UByte::value () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIJ}
{\bkmkend AAAAAAACIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b UByte.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b UByte} &  {\i u}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACIK}
{\bkmkend AAAAAAACIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b UByte.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _0\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_0 = 0x00{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIL}
{\bkmkend AAAAAAACIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b UByte.hpp}.}\par
}
{\xe \v _06\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_06}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_06 = 0x06{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIM}
{\bkmkend AAAAAAACIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b UByte.hpp}.}\par
}
{\xe \v _06N\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_06N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_06N = ~{\b _06} + {\b _1}{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIN}
{\bkmkend AAAAAAACIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b UByte.hpp}.}\par
}
{\xe \v _09\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_09}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_09 = 0x09{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIO}
{\bkmkend AAAAAAACIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b UByte.hpp}.}\par
}
{\xe \v _09N\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_09N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_09N = ~{\b _09} + 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIP}
{\bkmkend AAAAAAACIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b UByte.hpp}.}\par
}
{\xe \v _0F\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_0F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_0F = 0x0f{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIQ}
{\bkmkend AAAAAAACIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b UByte.hpp}.}\par
}
{\xe \v _1\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_1 = 0x01{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIR}
{\bkmkend AAAAAAACIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b UByte.hpp}.}\par
}
{\xe \v _60\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_60}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_60 = 0x60{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIS}
{\bkmkend AAAAAAACIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b UByte.hpp}.}\par
}
{\xe \v _60N\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_60N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_60N = ~{\b _60} + {\b _1}{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIT}
{\bkmkend AAAAAAACIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b UByte.hpp}.}\par
}
{\xe \v _80\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_80}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_80 = 0x80{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIU}
{\bkmkend AAAAAAACIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b UByte.hpp}.}\par
}
{\xe \v _90\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_90}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_90 = 0x90{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIV}
{\bkmkend AAAAAAACIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b UByte.hpp}.}\par
}
{\xe \v _90N\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_90N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_90N = ~{\b _90} + 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIW}
{\bkmkend AAAAAAACIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b UByte.hpp}.}\par
}
{\xe \v _F0\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_F0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_F0 = 0xf0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIX}
{\bkmkend AAAAAAACIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b UByte.hpp}.}\par
}
{\xe \v _FF\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_FF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_FF = 0xff{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIY}
{\bkmkend AAAAAAACIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b UByte.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UByte.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UBytes Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes}
{\bkmkstart AAAAAAACIZ}
{\bkmkend AAAAAAACIZ}
\par
{
{\f2 #include <UBytes.hpp>}}\par
Collaboration diagram for MCHEmul::UBytes:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} (const std::vector< {\b UByte} > &v, bool bE=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} (const {\b UBytes} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b operator=} (const {\b UBytes} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b sizeBits} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinLength} (size_t l, bool r=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UByte} & {\b value} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b value} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< {\b UByte} > & {\b bytes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b LSUBytes} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b MSUBytes} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b bit} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBit} (size_t p, bool s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b to0} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b toFF} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b complement} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shiftLeftC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b shiftLeft} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shiftRightC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b shiftRight} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rotateLeftC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b rotateLeft} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rotateRightC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b rotateRight} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b bitAdding} (const {\b UBytes} &u, bool cin, bool &cout, bool &o) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b reverse} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b UBytes} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b UBytes} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator[]} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator[]} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b operator<<} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b operator>>} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} ({\b UByte::OutputFormat} oF, char s, size_t l=0) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b UBytes} {\b _E}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b UBytes} &u)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing a set of {\b UByte}. \par
}{
Definition at line {\b 23} of file {\b UBytes.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v UBytes\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:UBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UBytes::UBytes (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJA}
{\bkmkend AAAAAAACJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b UBytes.hpp}.}\par
}
{\xe \v UBytes\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:UBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UBytes::UBytes (const std::vector< {\b UByte} > &  {\i v}, bool  {\i bE} = {\f2 true}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJB}
{\bkmkend AAAAAAACJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a46f7572e931f16a2daf1eaf8516782f8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v UBytes\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:UBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UBytes::UBytes (const {\b UBytes} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACJC}
{\bkmkend AAAAAAACJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asString\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::UBytes::asString ({\b UByte::OutputFormat}  {\i oF}, char  {\i s}, size_t  {\i l} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAACJD}
{\bkmkend AAAAAAACJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i s} \cell }{separator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i l} \cell }{Minimum length per {\b UByte} \cell }
{\row }
}
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a569d44bb0910bf5b70751eea6c237481_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bit\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:bit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::bit (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJE}
{\bkmkend AAAAAAACJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you requested for a bit bigger than sizeBits, the crash is guaranteed. No checks are done to increase the speed. \par
}{
Definition at line {\b 63} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ab64194ba0a31b71cd5c52058f82dbd69_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ab64194ba0a31b71cd5c52058f82dbd69_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bitAdding\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:bitAdding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::UBytes::bitAdding (const {\b UBytes} &  {\i u}, bool  {\i cin}, bool &  {\i cout}, bool &  {\i o}) const}}
\par
{\bkmkstart AAAAAAACJF}
{\bkmkend AAAAAAACJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Just to do a bit adding. But very interesting method. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i u} \cell }{The bytes to add. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cin} \cell }{Is there any carry at the beginning to take into account? \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cout} \cell }{It is actualized whether a carry is generated from the adding. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i o} \cell }{Is is actualized whether an overflow is generated, that is when the MSBits of inputs are equal and different from the output. \cell }
{\row }
}
}}
{\xe \v bytes\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< {\b UByte} > & MCHEmul::UBytes::bytes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJG}
{\bkmkend AAAAAAACJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b UBytes.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a9b529aaf9012ace5c489db4b4415f66b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v complement\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:complement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::UBytes::complement () const}}
\par
{\bkmkstart AAAAAAACJH}
{\bkmkend AAAAAAACJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ad4023a65a636e7aeb237a56fbb95553f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v LSUBytes\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:LSUBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::UBytes::LSUBytes (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJI}
{\bkmkend AAAAAAACJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a5ccb09b87bc7d1d2bf1980e9d6cb14a7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a5ccb09b87bc7d1d2bf1980e9d6cb14a7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v MSUBytes\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:MSUBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::UBytes::MSUBytes (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJJ}
{\bkmkend AAAAAAACJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a08eb7d9b22435525b5df0404f82d4cab_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a08eb7d9b22435525b5df0404f82d4cab_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!=\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::operator!= (const {\b UBytes} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJK}
{\bkmkend AAAAAAACJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b UBytes.hpp}.}\par
}
{\xe \v operator<<\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} & MCHEmul::UBytes::operator<< (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJL}
{\bkmkend AAAAAAACJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_aa6c50511aa80ea0fe8abdf132310842d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} & MCHEmul::UBytes::operator= (const {\b UBytes} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACJM}
{\bkmkend AAAAAAACJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::operator== (const {\b UBytes} &  {\i u}) const}}
\par
{\bkmkstart AAAAAAACJN}
{\bkmkend AAAAAAACJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>>\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} & MCHEmul::UBytes::operator>> (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJO}
{\bkmkend AAAAAAACJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ab4d82f6dc5c8e1a9a07a1c377a40cf3c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator[]\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UBytes::operator[] (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJP}
{\bkmkend AAAAAAACJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a84220d00737f71e13e085fb0fe10ff3a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator[]\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UBytes::operator[] (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJQ}
{\bkmkend AAAAAAACJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a15119f55479a4be269628cdf3d316da0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v reverse\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:reverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::UBytes::reverse () const}}
\par
{\bkmkstart AAAAAAACJR}
{\bkmkend AAAAAAACJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a73e113bf27773f2a857fc7bea9841852_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rotateLeft\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:rotateLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} & MCHEmul::UBytes::rotateLeft (size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACJS}
{\bkmkend AAAAAAACJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rotateLeftC\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:rotateLeftC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::rotateLeftC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACJT}
{\bkmkend AAAAAAACJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rotateRight\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:rotateRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} & MCHEmul::UBytes::rotateRight (size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACJU}
{\bkmkend AAAAAAACJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rotateRightC\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:rotateRightC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::rotateRightC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACJV}
{\bkmkend AAAAAAACJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setBit\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:setBit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UBytes::setBit (size_t  {\i p}, bool  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJW}
{\bkmkend AAAAAAACJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a407367e314e9c6f743b508c7f5290a35_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a407367e314e9c6f743b508c7f5290a35_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setMinLength\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:setMinLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UBytes::setMinLength (size_t  {\i l}, bool  {\i r} = {\f2 true})}}
\par
{\bkmkstart AAAAAAACJX}
{\bkmkend AAAAAAACJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i r} \cell }{right or not? where to introduce the additional byte. \cell }
{\row }
}
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ad2c051f71547ffdd77a312cc4b9c30f3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftLeft\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:shiftLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} & MCHEmul::UBytes::shiftLeft (size_t  {\i p} = {\f2 1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJY}
{\bkmkend AAAAAAACJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a41fa4ee71cdb19180fc83f940bed1289_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a41fa4ee71cdb19180fc83f940bed1289_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftLeftC\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:shiftLeftC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::shiftLeftC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACJZ}
{\bkmkend AAAAAAACJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{value to introduce. \cell }
{\row }
}
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a8e361d84aa0a85d1fc2cda324c8ae48c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftRight\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:shiftRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} & MCHEmul::UBytes::shiftRight (size_t  {\i p} = {\f2 1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKA}
{\bkmkend AAAAAAACKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_aa1b0011cbd21bec559680bfaf8fe447f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_aa1b0011cbd21bec559680bfaf8fe447f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftRightC\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:shiftRightC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::shiftRightC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACKB}
{\bkmkend AAAAAAACKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ab341011b5d5a164af709e95a1d63c9ae_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::UBytes::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKC}
{\bkmkend AAAAAAACKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b UBytes.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a0a0201f78ada888f8475c2782ba8cd1e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sizeBits\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:sizeBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::UBytes::sizeBits () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKD}
{\bkmkend AAAAAAACKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a788832acadf3399299f9cafaac860d7b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a788832acadf3399299f9cafaac860d7b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v to0\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:to0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UBytes::to0 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKE}
{\bkmkend AAAAAAACKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b UBytes.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a4013593b66dfe6d120de1b7fed986565_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v toFF\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:toFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UBytes::toFF (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKF}
{\bkmkend AAAAAAACKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b UBytes.hpp}.}\par
}
{\xe \v value\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UBytes::value (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKG}
{\bkmkend AAAAAAACKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b UBytes.hpp}.}\par
}
{\xe \v value\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UByte} & MCHEmul::UBytes::value (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKH}
{\bkmkend AAAAAAACKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b UBytes.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_af70c05c4b1952a11a61ef1e35830ca5b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b UBytes} &  {\i u}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACKI}
{\bkmkend AAAAAAACKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b UBytes.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _E\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:_E}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UBytes} MCHEmul::UBytes::_E{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKJ}
{\bkmkend AAAAAAACKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b UBytes.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UBytes.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UInt Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UInt}
{\xe \v MCHEmul::UInt}
{\bkmkstart AAAAAAACKK}
{\bkmkend AAAAAAACKK}
\par
{
{\f2 #include <UInt.hpp>}}\par
Collaboration diagram for MCHEmul::UInt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BinaryFormatManager}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FormatManager}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FormatManagers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PackagedBCDFormatManager}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} (const {\b UBytes} &u, bool bE=true, unsigned char f={\b _BINARY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} (const std::vector< {\b UByte} > &u, bool bE=true, unsigned char f={\b _BINARY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} (const {\b UInt} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} & {\b operator=} (const {\b UInt} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b format} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b sizeBits} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b negative} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b positive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b carry} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetCarry} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b overflow} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetOverflow} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinLength} (size_t l)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UBytes} & {\b values} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< {\b UByte} > & {\b bytes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b LSUInt} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b MSUInt} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b add} (const {\b UInt} &u, bool iC=false) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b complement} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b complement_2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b substract} (const {\b UInt} &u, bool iC=true) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b multiply} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b operator+} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} & {\b operator+=} (const {\b UInt} &u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b operator-} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b operator-} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} & {\b operator-=} (const {\b UInt} &u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b operator*} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} & {\b operator*=} (const {\b UInt} &u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator[]} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator[]} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} ({\b UByte::OutputFormat} oF, char s, size_t l=0) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b asUnsignedInt} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b asInt} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b UInt} {\b fromUnsignedInt} (unsigned int n, unsigned char f={\b _BINARY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b UInt} {\b fromInt} (int n, unsigned char f={\b _BINARY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b UInt} {\b fromStr} (const std::string &s, unsigned char f={\b _BINARY})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _BINARY} = 0x00\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _PACKAGEDBCD} = 0x01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::map< unsigned char, {\b FormatManager} * > {\b _formatManagers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b UInt} {\b _0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b UInt} {\b _1}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b UInt} &u)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing a Integer, with and without sign. \par
It might by said that this class represents actually {\b CPU}'s ALU (Arithmetic Logic Unit) as well. \par
A number is represented by several {\b UBytes}. Those {\b UBytes} can be given either in big-endian format or low-endian one. \par
That number can be represented in many different formats. \par
The _BINARY one is the default and the most commonly used. \par
The type of format used in many computers at 80's was the packaged BCD. \par
The class is prepared to support additional formats further than those two ones. It can be extended somehow. See later. \par
The negative numbers are always kept and "understood" using complement 2. \par
The basic operation in an {\b UInt} is "adding". The rest are always refer to this one. \par
}{
Definition at line {\b 33} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v UInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:UInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::UInt (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKL}
{\bkmkend AAAAAAACKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b UInt.hpp}.}\par
}
{\xe \v UInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:UInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::UInt (const {\b UBytes} &  {\i u}, bool  {\i bE} = {\f2 true}, unsigned char  {\i f} = {\f2 {\b _BINARY}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKM}
{\bkmkend AAAAAAACKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always kept in Big-endian format. Negative numbers are complement_2. \par
}{
Definition at line {\b 126} of file {\b UInt.hpp}.}\par
}
{\xe \v UInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:UInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::UInt (const std::vector< {\b UByte} > &  {\i u}, bool  {\i bE} = {\f2 true}, unsigned char  {\i f} = {\f2 {\b _BINARY}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKN}
{\bkmkend AAAAAAACKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b UInt.hpp}.}\par
}
{\xe \v UInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:UInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::UInt (const {\b UInt} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACKO}
{\bkmkend AAAAAAACKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::add (const {\b UInt} &  {\i u}, bool  {\i iC} = {\f2 false}) const}}
\par
{\bkmkstart AAAAAAACKP}
{\bkmkend AAAAAAACKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a7c793a74c21a2f4d55d7a248f7923c45_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:asInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::UInt::asInt () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKQ}
{\bkmkend AAAAAAACKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 227} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a69895a56a3f5089dc0fae7c3256bcd8d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asString\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::UInt::asString ({\b UByte::OutputFormat}  {\i oF}, char  {\i s}, size_t  {\i l} = {\f2 0}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKR}
{\bkmkend AAAAAAACKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i s} \cell }{separator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i l} \cell }{Minimum length per {\b UByte} \cell }
{\row }
}
}{
Definition at line {\b 222} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a8d39849593b56ff98bee006dc488f78c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a8d39849593b56ff98bee006dc488f78c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asUnsignedInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:asUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::UInt::asUnsignedInt () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKS}
{\bkmkend AAAAAAACKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_adf1f7d84c1647993854f8f969ca2e046_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_adf1f7d84c1647993854f8f969ca2e046_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bytes\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< {\b UByte} > & MCHEmul::UInt::bytes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKT}
{\bkmkend AAAAAAACKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_ab50dc6a66f9443223c709414cd8cc6c2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_ab50dc6a66f9443223c709414cd8cc6c2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v carry\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:carry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::carry () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKU}
{\bkmkend AAAAAAACKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These 2 flags are set after operations. \par
}{
Definition at line {\b 155} of file {\b UInt.hpp}.}\par
}
{\xe \v complement\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:complement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::complement () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKV}
{\bkmkend AAAAAAACKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a8b4523ec9dab7d4b77fed1effa0c707a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a8b4523ec9dab7d4b77fed1effa0c707a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v complement_2\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:complement_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::complement_2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKW}
{\bkmkend AAAAAAACKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 180} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a6560087cf01e093c17e2e7999fdf3ceb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a6560087cf01e093c17e2e7999fdf3ceb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v format\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:format}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::UInt::format () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKX}
{\bkmkend AAAAAAACKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b UInt.hpp}.}\par
}
{\xe \v fromInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:fromInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b UInt} MCHEmul::UInt::fromInt (int  {\i n}, unsigned char  {\i f} = {\f2 {\b _BINARY}}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKY}
{\bkmkend AAAAAAACKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 232} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_af202e81e55b0ed33844c69fca3386987_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_af202e81e55b0ed33844c69fca3386987_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fromStr\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:fromStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b UInt} MCHEmul::UInt::fromStr (const std::string &  {\i s}, unsigned char  {\i f} = {\f2 {\b _BINARY}}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKZ}
{\bkmkend AAAAAAACKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v fromUnsignedInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:fromUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b UInt} MCHEmul::UInt::fromUnsignedInt (unsigned int  {\i n}, unsigned char  {\i f} = {\f2 {\b _BINARY}}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACLA}
{\bkmkend AAAAAAACLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 230} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a250354dac605e024f2a5f9fcec55fed0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a250354dac605e024f2a5f9fcec55fed0_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v LSUInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:LSUInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::LSUInt (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLB}
{\bkmkend AAAAAAACLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 172} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a83f10c95ae097b359aac068193bee8c6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v MSUInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:MSUInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::MSUInt (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLC}
{\bkmkend AAAAAAACLC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_ae391b6179d8dd69d9ac771c003f0a210_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v multiply\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:multiply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::multiply (const {\b UInt} &  {\i u}) const}}
\par
{\bkmkstart AAAAAAACLD}
{\bkmkend AAAAAAACLD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_ab5af424a2989e7abf391ffc9d9e974b7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v negative\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:negative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::negative () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLE}
{\bkmkend AAAAAAACLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a82fd7c37e7e192031cc4918c86a22c41_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a82fd7c37e7e192031cc4918c86a22c41_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::operator!= (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLF}
{\bkmkend AAAAAAACLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 188} of file {\b UInt.hpp}.}\par
}
{\xe \v operator*\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::operator* (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLG}
{\bkmkend AAAAAAACLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_adf15164451cbe8f24df871bf35d6511f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} & MCHEmul::UInt::operator*= (const {\b UInt} &  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLH}
{\bkmkend AAAAAAACLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 214} of file {\b UInt.hpp}.}\par
}
{\xe \v operator+\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::operator+ (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLI}
{\bkmkend AAAAAAACLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a292f7be53607321b32d2e5a53ba2f0cd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} & MCHEmul::UInt::operator+= (const {\b UInt} &  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLJ}
{\bkmkend AAAAAAACLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 204} of file {\b UInt.hpp}.}\par
}
{\xe \v operator-\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::operator- () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLK}
{\bkmkend AAAAAAACLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 206} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a8ac5fdf971f0305b2a3d97a5decabb20_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::operator- (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLL}
{\bkmkend AAAAAAACLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 208} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a1ed7bfdfcbb3fac32be79470ddb8c00d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} & MCHEmul::UInt::operator-= (const {\b UInt} &  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLM}
{\bkmkend AAAAAAACLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 210} of file {\b UInt.hpp}.}\par
}
{\xe \v operator<\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::operator< (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLN}
{\bkmkend AAAAAAACLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 197} of file {\b UInt.hpp}.}\par
}
{\xe \v operator<=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::operator<= (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLO}
{\bkmkend AAAAAAACLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b UInt.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} & MCHEmul::UInt::operator= (const {\b UInt} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACLP}
{\bkmkend AAAAAAACLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::operator== (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLQ}
{\bkmkend AAAAAAACLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b UInt.hpp}.}\par
}
{\xe \v operator>\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::operator> (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLR}
{\bkmkend AAAAAAACLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It is bigger when the difference between two quantities is positive and then the carry generated is 1. \par
}{
Definition at line {\b 193} of file {\b UInt.hpp}.}\par
}
{\xe \v operator>=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::operator>= (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLS}
{\bkmkend AAAAAAACLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 195} of file {\b UInt.hpp}.}\par
}
{\xe \v operator[]\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UInt::operator[] (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLT}
{\bkmkend AAAAAAACLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 219} of file {\b UInt.hpp}.}\par
}
{\xe \v operator[]\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UInt::operator[] (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLU}
{\bkmkend AAAAAAACLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 217} of file {\b UInt.hpp}.}\par
}
{\xe \v overflow\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:overflow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::overflow () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLV}
{\bkmkend AAAAAAACLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b UInt.hpp}.}\par
}
{\xe \v positive\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:positive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::positive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLW}
{\bkmkend AAAAAAACLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_ae56c8ff272c39138e55551f9311a1f05_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v resetCarry\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:resetCarry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UInt::resetCarry (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLX}
{\bkmkend AAAAAAACLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b UInt.hpp}.}\par
}
{\xe \v resetOverflow\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:resetOverflow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UInt::resetOverflow (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLY}
{\bkmkend AAAAAAACLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 161} of file {\b UInt.hpp}.}\par
}
{\xe \v setMinLength\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:setMinLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UInt::setMinLength (size_t  {\i l}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLZ}
{\bkmkend AAAAAAACLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
_0 at the left.\par
}{
Definition at line {\b 164} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a0b31f9c6b80e4f014f0ecb872af107a1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::UInt::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMA}
{\bkmkend AAAAAAACMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a24cfc763638097abb54c8440eb30e2b0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a24cfc763638097abb54c8440eb30e2b0_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sizeBits\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:sizeBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::UInt::sizeBits () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMB}
{\bkmkend AAAAAAACMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a2b9ffcdf5f9256fe6236b9da2d0e5816_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v substract\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:substract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::substract (const {\b UInt} &  {\i u}, bool  {\i iC} = {\f2 true}) const}}
\par
{\bkmkstart AAAAAAACMC}
{\bkmkend AAAAAAACMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_af8a803438cca87bd626776844d27cd48_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v values\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UBytes} & MCHEmul::UInt::values () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMD}
{\bkmkend AAAAAAACMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b UInt.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_aa0f3a57c9a16e1716dfb8621fc0a95df_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b UInt} &  {\i u}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACME}
{\bkmkend AAAAAAACME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 236} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _0\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt} MCHEmul::UInt::_0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMF}
{\bkmkend AAAAAAACMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very basic numbers, represented in binary. \par
}{
Definition at line {\b 115} of file {\b UInt.hpp}.}\par
}
{\xe \v _1\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt} MCHEmul::UInt::_1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMG}
{\bkmkend AAAAAAACMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b UInt.hpp}.}\par
}
{\xe \v _BINARY\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:_BINARY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UInt::_BINARY = 0x00{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMH}
{\bkmkend AAAAAAACMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The default one . \par
}{
Definition at line {\b 83} of file {\b UInt.hpp}.}\par
}
{\xe \v _formatManagers\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:_formatManagers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<unsigned char, {\b FormatManager}*> MCHEmul::UInt::_formatManagers{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMI}
{\bkmkend AAAAAAACMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The different format managers are kept in a public static map. The map is loaded with the basic formaters (BINARY and BCD), buy others can be added if needed. \par
}{
Definition at line {\b 112} of file {\b UInt.hpp}.}\par
}
{\xe \v _PACKAGEDBCD\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:_PACKAGEDBCD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UInt::_PACKAGEDBCD = 0x01{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMJ}
{\bkmkend AAAAAAACMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
...and also the Packaged BCD very common in 80's computers \par
}{
Definition at line {\b 85} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UInt.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::UserIONoPeripheral Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::UserIONoPeripheral}
{\xe \v C64::UserIONoPeripheral}
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
\par
{
{\f2 #include <UserPeripherals.hpp>}}\par
Inheritance diagram for C64::UserIONoPeripheral:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_user_i_o_no_peripheral__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::UserIONoPeripheral:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_user_i_o_no_peripheral__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UserIONoPeripheral} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _ID} = -1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a no device, just for simulation purposes. This is the one created when no other is defined for the commodore 64. \par
}{
Definition at line {\b 32} of file {\b UserPeripherals.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v UserIONoPeripheral\:C64::UserIONoPeripheral}
{\xe \v C64::UserIONoPeripheral\:UserIONoPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::UserIONoPeripheral::UserIONoPeripheral (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b UserPeripherals.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::UserIONoPeripheral}
{\xe \v C64::UserIONoPeripheral\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool C64::UserIONoPeripheral::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the peripheral. The initialization should return true when everything is ok, and false in other case. \par
}{
Implements {\b MCHEmul::IOPeripheral} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v simulate\:C64::UserIONoPeripheral}
{\xe \v C64::UserIONoPeripheral\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool C64::UserIONoPeripheral::simulate (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To emulate the way it works. \par
Should return true if everything was ok. \par
}{
Implements {\b MCHEmul::IOPeripheral} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::UserIONoPeripheral}
{\xe \v C64::UserIONoPeripheral\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::UserIONoPeripheral::_ID = -1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b UserPeripherals.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b UserPeripherals.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::UserIOPeripheral Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::UserIOPeripheral}
{\xe \v C64::UserIOPeripheral}
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
\par
{
{\f2 #include <UserPeripherals.hpp>}}\par
Inheritance diagram for C64::UserIOPeripheral:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_user_i_o_peripheral__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::UserIOPeripheral:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_user_i_o_peripheral__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UserIOPeripheral} (int {\b id})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents any peripheral connected to the User Port. \par
}{
Definition at line {\b 22} of file {\b UserPeripherals.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v UserIOPeripheral\:C64::UserIOPeripheral}
{\xe \v C64::UserIOPeripheral\:UserIOPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::UserIOPeripheral::UserIOPeripheral (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b UserPeripherals.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b UserPeripherals.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::UserIOPort Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::UserIOPort}
{\xe \v C64::UserIOPort}
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
\par
{
{\f2 #include <UserPort.hpp>}}\par
Inheritance diagram for C64::UserIOPort:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_user_i_o_port__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::UserIOPort:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_user_i_o_port__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UserIOPort} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b addPeripheral} ({\b MCHEmul::IOPeripheral} *p) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _ID} = 3\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class represents the {\b UserIOPort}. \par
}{
Definition at line {\b 24} of file {\b UserPort.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v UserIOPort\:C64::UserIOPort}
{\xe \v C64::UserIOPort\:UserIOPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::UserIOPort::UserIOPort ()}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addPeripheral\:C64::UserIOPort}
{\xe \v C64::UserIOPort\:addPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void C64::UserIOPort::addPeripheral ({\b MCHEmul::IOPeripheral} *  {\i p}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It verifies before adding it that whether the Peripherial is a UserIOPeripherial, as they are the only ones compatible with this type of Port. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::UserIOPort}
{\xe \v C64::UserIOPort\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::UserIOPort::_ID = 3{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b UserPort.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b UserPort.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::VICII Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::VICII}
{\xe \v C64::VICII}
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
\par
{
{\f2 #include <VICII.hpp>}}\par
Inheritance diagram for C64::VICII:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::VICII:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Raster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RasterData}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VICII} (const {\b RasterData} &vd, const {\b RasterData} &hd, const {\b MCHEmul::Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~VICII} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b bank} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBank} (unsigned char bk)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ({\b MCHEmul::CPU} *cpu) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _ID} = 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned short {\b _GRAPHMAXCHARLINES} = 25\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned short {\b _GRAPHMAXCHARCOLUMNS} = 40\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned short {\b _GRAPHMAXBITMAPCOLUMNS} = 320\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned short {\b _GRAPHMAXBITMAPROWS} = 200\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _CPUCYCLESWHENREADGRAPHS} = 40\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b MCHEmul::Address} {\b _COLORMEMORY}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The chip that takes care of anything around the graphics in Commodore 64. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b GraphicalChip}. \par
}}}{
Definition at line {\b 24} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v VICII\:C64::VICII}
{\xe \v C64::VICII\:VICII}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::VICII (const {\b RasterData} &  {\i vd}, const {\b RasterData} &  {\i hd}, const {\b MCHEmul::Attributes} &  {\i attrs} = {\f2 \{\~ \}})}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specific classes for PAL & NTSC have been created giving this data as default. \par
}}
{\xe \v ~VICII\:C64::VICII}
{\xe \v C64::VICII\:~VICII}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::~VICII ()}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v bank\:C64::VICII}
{\xe \v C64::VICII\:bank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::bank () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To change and get the bank. \par
}{
Definition at line {\b 241} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_a6ed0683e01b203fffea51ee3a333e78c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_a6ed0683e01b203fffea51ee3a333e78c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:C64::VICII}
{\xe \v C64::VICII\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool C64::VICII::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Reimplemented from {\b MCHEmul::GraphicalChip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v setBank\:C64::VICII}
{\xe \v C64::VICII\:setBank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::setBank (unsigned char  {\i bk}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 243} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_af0eb6c544a59218110b5ab8b61c0a2f2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_af0eb6c544a59218110b5ab8b61c0a2f2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v simulate\:C64::VICII}
{\xe \v C64::VICII\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool C64::VICII::simulate ({\b MCHEmul::CPU} * ){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate th behaviour of the chip. It has to be defined per chip. \par
Returns true if everything was ok, and false in any other circunstance. \par
 The last error could be recovered from the variable _lastError in that case. \par
The clock cyclees is added. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _COLORMEMORY\:C64::VICII}
{\xe \v C64::VICII\:_COLORMEMORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::Address} C64::VICII::_COLORMEMORY{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static address. The color memory cann't be changed. \par
}{
Definition at line {\b 233} of file {\b VICII.hpp}.}\par
}
{\xe \v _CPUCYCLESWHENREADGRAPHS\:C64::VICII}
{\xe \v C64::VICII\:_CPUCYCLESWHENREADGRAPHS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int C64::VICII::_CPUCYCLESWHENREADGRAPHS = 40{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CPU Cycles when the graphics are read. \par
}{
Definition at line {\b 230} of file {\b VICII.hpp}.}\par
}
{\xe \v _GRAPHMAXBITMAPCOLUMNS\:C64::VICII}
{\xe \v C64::VICII\:_GRAPHMAXBITMAPCOLUMNS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::_GRAPHMAXBITMAPCOLUMNS = 320{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 226} of file {\b VICII.hpp}.}\par
}
{\xe \v _GRAPHMAXBITMAPROWS\:C64::VICII}
{\xe \v C64::VICII\:_GRAPHMAXBITMAPROWS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::_GRAPHMAXBITMAPROWS = 200{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 227} of file {\b VICII.hpp}.}\par
}
{\xe \v _GRAPHMAXCHARCOLUMNS\:C64::VICII}
{\xe \v C64::VICII\:_GRAPHMAXCHARCOLUMNS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::_GRAPHMAXCHARCOLUMNS = 40{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b VICII.hpp}.}\par
}
{\xe \v _GRAPHMAXCHARLINES\:C64::VICII}
{\xe \v C64::VICII\:_GRAPHMAXCHARLINES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::_GRAPHMAXCHARLINES = 25{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data about the size of the screen \par
}{
Definition at line {\b 224} of file {\b VICII.hpp}.}\par
}
{\xe \v _ID\:C64::VICII}
{\xe \v C64::VICII\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int C64::VICII::_ID = 4{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 221} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b VICII.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::VICII_NTSC Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::VICII_NTSC}
{\xe \v C64::VICII_NTSC}
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
\par
{
{\f2 #include <VICII.hpp>}}\par
Inheritance diagram for C64::VICII_NTSC:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i___n_t_s_c__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::VICII_NTSC:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i___n_t_s_c__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VICII_NTSC} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b RasterData} {\b _VRASTERDATA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b RasterData} {\b _HRASTERDATA}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The version para NTSC systems. \par
}{
Definition at line {\b 331} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v VICII_NTSC\:C64::VICII_NTSC}
{\xe \v C64::VICII_NTSC\:VICII_NTSC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII_NTSC::VICII_NTSC ()}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _HRASTERDATA\:C64::VICII_NTSC}
{\xe \v C64::VICII_NTSC\:_HRASTERDATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b RasterData} C64::VICII_NTSC::_HRASTERDATA{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 335} of file {\b VICII.hpp}.}\par
}
{\xe \v _VRASTERDATA\:C64::VICII_NTSC}
{\xe \v C64::VICII_NTSC\:_VRASTERDATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b RasterData} C64::VICII_NTSC::_VRASTERDATA{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 334} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b VICII.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::VICII_PAL Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::VICII_PAL}
{\xe \v C64::VICII_PAL}
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
\par
{
{\f2 #include <VICII.hpp>}}\par
Inheritance diagram for C64::VICII_PAL:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i___p_a_l__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::VICII_PAL:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i___p_a_l__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VICII_PAL} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b RasterData} {\b _VRASTERDATA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b RasterData} {\b _HRASTERDATA}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The version para PAL systems. \par
}{
Definition at line {\b 341} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v VICII_PAL\:C64::VICII_PAL}
{\xe \v C64::VICII_PAL\:VICII_PAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII_PAL::VICII_PAL ()}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _HRASTERDATA\:C64::VICII_PAL}
{\xe \v C64::VICII_PAL\:_HRASTERDATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b RasterData} C64::VICII_PAL::_HRASTERDATA{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 345} of file {\b VICII.hpp}.}\par
}
{\xe \v _VRASTERDATA\:C64::VICII_PAL}
{\xe \v C64::VICII_PAL\:_VRASTERDATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b RasterData} C64::VICII_PAL::_VRASTERDATA{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 344} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b VICII.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::VICIIRegisters Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters}
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
\par
{
{\f2 #include <VICIIRegisters.hpp>}}\par
Inheritance diagram for C64::VICIIRegisters:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_registers__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::VICIIRegisters:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_registers__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b GraphicMode} \{ {\b _CHARMODE} = 0
, {\b _MULTICOLORCHARMODE}
, {\b _BITMAPMODE}
, {\b _MULTICOLORBITMAPMODE}
, {\b _EXTENDEDBACKGROUNDMODE}
, {\b _ILLEGALMODE}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VICIIRegisters} (int {\b id}, {\b MCHEmul::PhisicalStorage} *ps)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b borderColor} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b backgroundColor} (size_t p=0) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b spriteXCoord} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b spriteYCoord} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b spriteColor} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b spriteSharedColor} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteEnable} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteDoubleWidth} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteDoubleHeight} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteToForegroundPriority} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b verticalScrollPosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b horizontalScrollPosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b textDisplay25RowsActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b textDisplay40ColumnsActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b screenSameColorBorderActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b videoResetActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b graphicBitModeActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b graphicExtendedColorTextModeActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b graphicMulticolorTextModeActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GraphicMode} {\b graphicModeActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rasterIRQActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteCollisionWithDataIRQActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteCollisionsIRQActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b lightPenIRQActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b IRQRasterLineAt} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MCHEmul::Address} {\b charDataMemory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MCHEmul::Address} {\b screenMemory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MCHEmul::Address} {\b bitmapMemory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentRasterLine} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCurrentRasterLine} (unsigned short rL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentLightPenHorizontalPosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentLightPenVerticalPosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCurrentLightPenPosition} (unsigned char x, unsigned char y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rasterAtIRQLine} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRasterAtLine} (bool rL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spritesCollisionWithDataHappened} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpritesCollisionWithData} (bool c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteCollisionWithDataHappened} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpriteCollisionWithDataHappened} (size_t p, bool c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spritesCollisionHappened} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpritesCollision} (bool c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteCollisionHappened} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpriteCollision} (size_t p, bool c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b lightPenOnScreenHappened} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLightPenOnScreen} (bool l)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b vicIItoGenerateIRQ} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVicIItoGenerateIRQ} (bool v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b bank} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBank} (unsigned char bk)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In the {\b VICII} Registers, there are a couple of records that behave different when they are read that when they are written. \par
}{
Definition at line {\b 25} of file {\b VICIIRegisters.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v GraphicMode\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:GraphicMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b C64::VICIIRegisters::GraphicMode}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _CHARMODE\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:_CHARMODE}
{\qr _CHARMODE{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
\cell }{\cell }{\row }
{\xe \v _MULTICOLORCHARMODE\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:_MULTICOLORCHARMODE}
{\qr _MULTICOLORCHARMODE{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
\cell }{\cell }{\row }
{\xe \v _BITMAPMODE\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:_BITMAPMODE}
{\qr _BITMAPMODE{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
\cell }{\cell }{\row }
{\xe \v _MULTICOLORBITMAPMODE\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:_MULTICOLORBITMAPMODE}
{\qr _MULTICOLORBITMAPMODE{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
\cell }{\cell }{\row }
{\xe \v _EXTENDEDBACKGROUNDMODE\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:_EXTENDEDBACKGROUNDMODE}
{\qr _EXTENDEDBACKGROUNDMODE{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
\cell }{\cell }{\row }
{\xe \v _ILLEGALMODE\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:_ILLEGALMODE}
{\qr _ILLEGALMODE{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 28} of file {\b VICIIRegisters.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v VICIIRegisters\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:VICIIRegisters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICIIRegisters::VICIIRegisters (int  {\i id}, {\b MCHEmul::PhisicalStorage} *  {\i ps}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b VICIIRegisters.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v backgroundColor\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:backgroundColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::backgroundColor (size_t  {\i p} = {\f2 0}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v bank\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:bank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::bank () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v bitmapMemory\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:bitmapMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::Address} C64::VICIIRegisters::bitmapMemory () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v borderColor\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:borderColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::borderColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v charDataMemory\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:charDataMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::Address} C64::VICIIRegisters::charDataMemory () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VICII} Only addresses 16k.\par
}{
Definition at line {\b 109} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v currentLightPenHorizontalPosition\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:currentLightPenHorizontalPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICIIRegisters::currentLightPenHorizontalPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v currentLightPenVerticalPosition\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:currentLightPenVerticalPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICIIRegisters::currentLightPenVerticalPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v currentRasterLine\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:currentRasterLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICIIRegisters::currentRasterLine () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v graphicBitModeActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:graphicBitModeActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::graphicBitModeActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v graphicExtendedColorTextModeActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:graphicExtendedColorTextModeActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::graphicExtendedColorTextModeActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v graphicModeActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:graphicModeActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GraphicMode} C64::VICIIRegisters::graphicModeActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v graphicMulticolorTextModeActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:graphicMulticolorTextModeActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::graphicMulticolorTextModeActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v horizontalScrollPosition\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:horizontalScrollPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::horizontalScrollPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v initialize\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void C64::VICIIRegisters::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To init the memory. It might be overloaded. By default the "defaultData" value is assigned. It doesn't matter whether the subset is or not active. \par
}{
Reimplemented from {\b MCHEmul::PhisicalStorageSubset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v IRQRasterLineAt\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:IRQRasterLineAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICIIRegisters::IRQRasterLineAt () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v lightPenIRQActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:lightPenIRQActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::lightPenIRQActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v lightPenOnScreenHappened\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:lightPenOnScreenHappened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::lightPenOnScreenHappened () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v rasterAtIRQLine\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:rasterAtIRQLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::rasterAtIRQLine () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v rasterIRQActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:rasterIRQActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::rasterIRQActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v screenMemory\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:screenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::Address} C64::VICIIRegisters::screenMemory () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v screenSameColorBorderActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:screenSameColorBorderActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::screenSameColorBorderActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setBank\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setBank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setBank (unsigned char  {\i bk}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setCurrentLightPenPosition\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setCurrentLightPenPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setCurrentLightPenPosition (unsigned char  {\i x}, unsigned char  {\i y}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setCurrentRasterLine\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setCurrentRasterLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setCurrentRasterLine (unsigned short  {\i rL}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setLightPenOnScreen\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setLightPenOnScreen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setLightPenOnScreen (bool  {\i l}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setRasterAtLine\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setRasterAtLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setRasterAtLine (bool  {\i rL}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setSpriteCollision\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setSpriteCollision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setSpriteCollision (size_t  {\i p}, bool  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setSpriteCollisionWithDataHappened\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setSpriteCollisionWithDataHappened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setSpriteCollisionWithDataHappened (size_t  {\i p}, bool  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setSpritesCollision\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setSpritesCollision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setSpritesCollision (bool  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 145} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setSpritesCollisionWithData\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setSpritesCollisionWithData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setSpritesCollisionWithData (bool  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setVicIItoGenerateIRQ\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setVicIItoGenerateIRQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setVicIItoGenerateIRQ (bool  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteCollisionHappened\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteCollisionHappened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteCollisionHappened (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteCollisionsIRQActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteCollisionsIRQActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteCollisionsIRQActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteCollisionWithDataHappened\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteCollisionWithDataHappened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteCollisionWithDataHappened (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteCollisionWithDataIRQActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteCollisionWithDataIRQActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteCollisionWithDataIRQActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteColor\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::spriteColor (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteDoubleHeight\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteDoubleHeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteDoubleHeight (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteDoubleWidth\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteDoubleWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteDoubleWidth (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteEnable\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteEnable (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spritesCollisionHappened\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spritesCollisionHappened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spritesCollisionHappened () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spritesCollisionWithDataHappened\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spritesCollisionWithDataHappened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spritesCollisionWithDataHappened () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteSharedColor\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteSharedColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::spriteSharedColor (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteToForegroundPriority\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteToForegroundPriority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteToForegroundPriority (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteXCoord\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteXCoord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICIIRegisters::spriteXCoord (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteYCoord\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteYCoord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::spriteYCoord (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v textDisplay25RowsActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:textDisplay25RowsActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::textDisplay25RowsActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v textDisplay40ColumnsActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:textDisplay40ColumnsActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::textDisplay40ColumnsActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v verticalScrollPosition\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:verticalScrollPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::verticalScrollPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v vicIItoGenerateIRQ\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:vicIItoGenerateIRQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::vicIItoGenerateIRQ () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v videoResetActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:videoResetActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::videoResetActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b VICIIRegisters.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b VICIIRegisters.hpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Compiler.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Compiler.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Compiler.hpp}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Incs.hpp>}\par
{\f2 #include <ASSEMBLER/Grammar.hpp>}\par
{\f2 #include <ASSEMBLER/Parser.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::ByteCodeLine}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::ByteCode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::Compiler}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul::Assembler}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Compiler.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Compiler.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Compiler.hpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __ASSEMBLER_COMPILER__}\par
00015 {\cf21 #define __ASSEMBLER_COMPILER__}\par
00016 \par
00017 {\cf21 #include <CORE/Incs.hpp>}\par
00018 {\cf21 #include <ASSEMBLER/Grammar.hpp>}\par
00019 {\cf21 #include <ASSEMBLER/Parser.hpp>}\par
00020 \par
00021 {\cf17 namespace }MCHEmul\par
00022 \{\par
00023     {\cf17 namespace }Assembler\par
00024     \{\par
00026         {\cf17 struct }ByteCodeLine final\par
00027         \{\par
00028             ByteCodeLine ()\par
00029                 : _address (\{ 0x00 \}), _bytes (), _label ({\cf22 ""}), _instruction ({\cf17 nullptr}), _actionOn (0)\par
00030                             \{ \}\par
00031 \par
00032             ByteCodeLine ({\cf17 const} Address& a, {\cf17 const} std::vector <UByte>& b, {\cf17 const} std::string& n, \par
00033                     {\cf17 const} Instruction* i, {\cf18 unsigned} {\cf18 int} act)\par
00034                 : _address (a), _bytes (b), _label (n), _instruction (i), _actionOn (act)\par
00035                             \{ \}\par
00036 \par
00037             ByteCodeLine ({\cf17 const} ByteCodeLine&) = {\cf19 default};\par
00038 \par
00039             ByteCodeLine& operator = ({\cf17 const} ByteCodeLine&) = {\cf19 default};\par
00040 \par
00041             {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} ByteCodeLine& c);\par
00042 \par
00043             Address _address;\par
00044             std::vector <UByte> _bytes;\par
00045             std::string _label;\par
00046             {\cf17 const} Instruction* _instruction;\par
00047             {\cf18 unsigned} {\cf18 int} _actionOn;\par
00048         \};\par
00049 \par
00051         {\cf17 struct }ByteCode final\par
00052         \{\par
00053             ByteCode () = {\cf19 default};\par
00054 \par
00055             ByteCode ({\cf17 const} ByteCode&) = {\cf19 default};\par
00056 \par
00057             ByteCode& operator = ({\cf17 const} ByteCode&) = {\cf19 default};\par
00058 \par
00061             std::vector <UByte> asSetOfBytes (Address& iA) {\cf17 const};\par
00062 \par
00065             std::map <Address, unsigned int> listOfActions () {\cf17 const};\par
00066 \par
00068             {\cf18 void} loadIntoMemory (Memory* m);\par
00069 \par
00070             {\cf17 static} ByteCode createFromMemory ({\cf17 const} Address& a, {\cf18 unsigned} {\cf18 int} b, Memory* m, CPU* cpu);\par
00071 \par
00072             std::vector <ByteCodeLine> _lines;\par
00073         \};\par
00074 \par
00078         {\cf17 class }Compiler final\par
00079         \{\par
00080             {\cf17 public}:\par
00081             Compiler ({\cf17 const} Parser& p)\par
00082                 : _parser (p)\par
00083                             \{ \}\par
00084 \par
00089             ByteCode compile ({\cf17 const} std::string& fN) {\cf17 const};\par
00090 \par
00091             {\cf17 const} CPU* cpu (){\cf17  const}\par
00092 {\cf17                             }\{ {\cf19 return} (_parser.cpu ()); \}\par
00093 \par
00094             Errors errors (){\cf17  const}\par
00095 {\cf17                             }\{ {\cf19 return} (_errors); \}\par
00096 \par
00098             {\cf18 bool} operator ! (){\cf17  const}\par
00099 {\cf17                             }\{ {\cf19 return} (!_errors.empty ()); \}\par
00100 \par
00101             {\cf17 private}:\par
00102             {\cf17 const} Parser& _parser;\par
00103 \par
00104             {\cf20 // Implementation}\par
00105             {\cf17 mutable} Errors _errors;\par
00106         \};\par
00107     \}\par
00108 \}\par
00109 \par
00110 {\cf21 #endif}\par
00111   \par
00112 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Error.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Error.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Error.hpp}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::Error}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul::Assembler}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Assembler::Errors} = std::vector< Error >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b MCHEmul::Assembler::ErrorType} \{ {\b MCHEmul::Assembler::_NOERROR} = 0
, {\b MCHEmul::Assembler::_MACROBADDEFINED}
, {\b MCHEmul::Assembler::_MACRONOTDEFINED}
, {\b MCHEmul::Assembler::_LABELNOTVALID}
, {\b MCHEmul::Assembler::_LABELNOTDEFINED}
, {\b MCHEmul::Assembler::_BYTESNOTVALID}
, {\b MCHEmul::Assembler::_INSTRUCTIONNOTVALID}
, {\b MCHEmul::Assembler::_INSTRUCTIONNOTDEFINED}
, {\b MCHEmul::Assembler::_STARTINGPOINTNOTVALID}
, {\b MCHEmul::Assembler::_GRAMARELEMENTNOTVALID}
, {\b MCHEmul::Assembler::_STARTINGPOINTNOTDEFINED}
, {\b MCHEmul::Assembler::_DUPLICATEMACRO}
, {\b MCHEmul::Assembler::_SEMANTICERROR}
, {\b MCHEmul::Assembler::_FILEEMPTY}
, {\b MCHEmul::Assembler::_PARSERNOTFOUND}
 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Error.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Error.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Error.hpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __ASSEMBLER_ERROR__}\par
00015 {\cf21 #define __ASSEMBLER_ERROR__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00021     {\cf17 namespace }Assembler\par
00022     \{\par
00024         {\cf17 enum class} ErrorType\par
00025         \{ \par
00026             _NOERROR = 0, \par
00027             {\cf20 // Related with Macros}\par
00028             _MACROBADDEFINED, \par
00029             _MACRONOTDEFINED, \par
00030             {\cf20 // Related with Semantic Elements}\par
00031             _LABELNOTVALID,\par
00032             _LABELNOTDEFINED,\par
00033             _BYTESNOTVALID,\par
00034             _INSTRUCTIONNOTVALID,\par
00035             _INSTRUCTIONNOTDEFINED,\par
00036             _STARTINGPOINTNOTVALID,\par
00037             {\cf20 // Related with Semantic structure}\par
00038             _GRAMARELEMENTNOTVALID, \par
00039             _STARTINGPOINTNOTDEFINED,\par
00040             _DUPLICATEMACRO,\par
00041             _SEMANTICERROR,\par
00042             {\cf20 // Related with Parser errors}\par
00043             _FILEEMPTY, \par
00044             _PARSERNOTFOUND, \par
00045         \};\par
00046 \par
00048         {\cf17 struct }Error\par
00049         \{\par
00050             Error ()\par
00051                 : _type (ErrorType::_NOERROR), \par
00052                   _file ({\cf22 ""}),\par
00053                   _line (0), _column (0)\par
00054                             \{ \}\par
00055 \par
00056             Error (ErrorType eT, {\cf17 const} std::string& f, {\cf18 unsigned} {\cf18 int} l, {\cf18 unsigned} {\cf18 int} c)\par
00057                 : _type (eT), _file (f), _line (l), _column (c)\par
00058                             \{ \}\par
00059 \par
00060             Error ({\cf17 const} Error&) = {\cf19 default};\par
00061 \par
00062             Error& operator = ({\cf17 const} Error&) = {\cf19 default};\par
00063 \par
00064             {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Error& e);\par
00065 \par
00066             ErrorType _type;\par
00067             std::string _file;\par
00068             {\cf18 unsigned} {\cf18 int} _line;\par
00069             {\cf18 unsigned} {\cf18 int} _column;\par
00070         \};\par
00071 \par
00072         {\cf17 using} Errors = std::vector <Error>;\par
00073     \}\par
00074 \}\par
00075 \par
00076 {\cf21 #endif}\par
00077   \par
00078 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Grammar.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Grammar.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Grammar.hpp}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <ASSEMBLER/Error.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::Macro}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::GrammaticalElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::LabelElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::BytesInMemoryElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::InstructionElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::StartingPointElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::Semantic}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul::Assembler}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Assembler::Macros} = std::map< std::string, Macro >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Assembler::StartingPointElements} = std::vector< StartingPointElement * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Grammar.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Grammar.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Grammar.hpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00031 {\cf21 #ifndef __ASSEMBLER_GRAMMAR__}\par
00032 {\cf21 #define __ASSEMBLER_GRAMMAR__}\par
00033 \par
00034 {\cf21 #include <CORE/incs.hpp>}\par
00035 {\cf21 #include <ASSEMBLER/Error.hpp>}\par
00036 \par
00037 {\cf17 namespace }MCHEmul\par
00038 \{\par
00039     {\cf17 namespace }Assembler\par
00040     \{\par
00045         {\cf17 class }Macro;\par
00046         {\cf17 using} Macros = std::map <std::string, Macro>;\par
00047         {\cf17 class }Macro\par
00048         \{\par
00049             {\cf17 public}:\par
00050             Macro ()\par
00051                 : _name ({\cf22 ""}), _equivalent ({\cf22 ""}),\par
00052                   _value (\{ \}), \par
00053                   _error (ErrorType::_NOERROR) \par
00054                                 \{ \}\par
00055 \par
00056             Macro ({\cf17 const} std::string& n, {\cf17 const} std::string& e)\par
00057                 : _name (n), _equivalent (e),\par
00058                   _value (\{ \}),\par
00059                   _error (ErrorType::_NOERROR)\par
00060                             \{ \}\par
00061 \par
00062             Macro ({\cf17 const} Macro&) = {\cf19 default};\par
00063 \par
00064             Macro& operator = ({\cf17 const} Macro&) = {\cf19 default};\par
00065 \par
00066             {\cf17 const} std::string& name (){\cf17  const}\par
00067 {\cf17                             }\{ {\cf19 return} (_name); \}\par
00068             {\cf17 const} std::string& equivalent (){\cf17  const}\par
00069 {\cf17                             }\{ {\cf19 return} (_equivalent); \}\par
00070             ErrorType error (){\cf17  const}\par
00071 {\cf17                             }\{ {\cf19 return} (_error); \}\par
00072 \par
00076             {\cf17 const} std::vector <UByte>& value ({\cf17 const} Macros& ms){\cf17  const}\par
00077 {\cf17                             }\{ {\cf19 return} (_value.empty () ? _value = calculateValue (_equivalent, ms) : _value ); \}\par
00078 \par
00080             {\cf18 bool} operator ! (){\cf17  const}\par
00081 {\cf17                             }\{ value (\{ \}) ; {\cf19 return} (_error != ErrorType::_NOERROR); \}\par
00082 \par
00083             {\cf17 private}:\par
00086             std::vector <UByte> calculateValue ({\cf17 const} std::string& e, {\cf17 const} Macros& ms) {\cf17 const};\par
00087 \par
00088             {\cf17 private}:\par
00090             {\cf17 const} std::string _name;\par
00092             {\cf17 const} std::string _equivalent; \par
00093 \par
00094             {\cf20 // Implementation}\par
00095             {\cf17 mutable} std::vector <UByte> _value;\par
00096             {\cf17 mutable} ErrorType _error;\par
00097         \};\par
00098 \par
00100         {\cf17 class }Semantic;\par
00101         {\cf17 struct }GrammaticalElement\par
00102         \{\par
00103             {\cf17 enum} Type \{ _LABEL = 0, _BYTESINMEMORY, _INSTRUCTION, _STARTINGPOINT  \};\par
00104 \par
00105             GrammaticalElement ()\par
00106                 : _type (_BYTESINMEMORY), _id (0), _line (0), _actionOn (0),\par
00107                   _nextElement (nullptr), _previousElement (nullptr),\par
00108                   _error (ErrorType::_NOERROR), _codeBytes ()\par
00109                             \{ \}\par
00110 \par
00111             GrammaticalElement ({\cf17 const} GrammaticalElement&) = {\cf19 default};\par
00112 \par
00113             GrammaticalElement& operator = ({\cf17 const} GrammaticalElement&) = {\cf19 default};\par
00114 \par
00115             {\cf17 virtual} ~GrammaticalElement ()\par
00116                             \{ {\cf17 delete} (_nextElement);  \}\par
00117 \par
00120             {\cf17 virtual} {\cf18 size_t} size ({\cf17 const} Semantic* s){\cf17  const }\par
00121 {\cf17                             }\{ {\cf19 return} (0); \}\par
00122 \par
00126             std::vector <UByte> codeBytes ({\cf17 const} Semantic* s, {\cf18 bool} bE = {\cf17 true}){\cf17  const}\par
00127 {\cf17                             }\{ {\cf19 return} (_codeBytes.empty () ? _codeBytes = calculateCodeBytes (s, bE) : _codeBytes); \}\par
00128 \par
00130             {\cf17 virtual} Address address ({\cf17 const} MCHEmul::Assembler::Semantic* s) {\cf17 const};\par
00131 \par
00132             ErrorType error (){\cf17  const}\par
00133 {\cf17                             }\{ {\cf19 return} (_error); \}\par
00134 \par
00136             {\cf18 bool} operator ! (){\cf17  const}\par
00137 {\cf17                             }\{ {\cf19 return} (_error != ErrorType::_NOERROR); \}\par
00138 \par
00139             Type _type;\par
00140             {\cf18 unsigned} {\cf18 int} _id; {\cf20 // Sequential...}\par
00141             {\cf18 unsigned} {\cf18 int} _line; {\cf20 // The line where the definition appears...}\par
00142             {\cf18 unsigned} {\cf18 int} _actionOn; {\cf20 // It might be understand by the compiler...}\par
00144 {\cf20 }            GrammaticalElement* _nextElement; {\cf20 // Could be nullptr (in the last gramatical element of a semantic block)}\par
00146 {\cf20 }            GrammaticalElement* _previousElement; {\cf20 // It could also be nullptr (in the first gramatical element of a semantic block)}\par
00148 {\cf20 }            {\cf17 mutable} ErrorType _error;\par
00149             \par
00150             {\cf17 protected}:\par
00151             {\cf20 // Implementation}\par
00152             {\cf17 mutable} std::vector <UByte> _codeBytes;\par
00153 \par
00154             {\cf17 protected}:\par
00156             {\cf17 virtual} std::vector <UByte> calculateCodeBytes ({\cf17 const} Semantic* s, {\cf18 bool} bE = {\cf17 true}){\cf17  const}\par
00157 {\cf17                             }\{ {\cf19 return} (std::vector <UByte> ()); \}\par
00158 \par
00159             {\cf20 // Implementation}\par
00160             std::vector <UByte> bytesFromExpression ({\cf17 const} std::string& e, {\cf17 const} Macros& ms, {\cf18 bool}& er) {\cf17 const};\par
00161         \};\par
00162 \par
00164         {\cf17 struct }LabelElement final : {\cf17 public} GrammaticalElement\par
00165         \{\par
00166             LabelElement ()\par
00167                 : GrammaticalElement (), \par
00168                   _name ()\par
00169                             \{ _type = Type::_LABEL; \}\par
00170 \par
00171             LabelElement ({\cf17 const} LabelElement&) = {\cf19 default};\par
00172 \par
00173             LabelElement& operator = ({\cf17 const} LabelElement&) = {\cf19 default};\par
00174 \par
00175             std::string _name;\par
00176         \};\par
00177 \par
00179         {\cf17 struct }BytesInMemoryElement : {\cf17 public} GrammaticalElement\par
00180         \{\par
00181             BytesInMemoryElement ()\par
00182                 : GrammaticalElement (), _elements ()\par
00183                             \{ _type = Type::_BYTESINMEMORY; \}\par
00184 \par
00185             BytesInMemoryElement ({\cf17 const} BytesInMemoryElement&) = {\cf19 default};\par
00186 \par
00187             BytesInMemoryElement& operator = ({\cf17 const} BytesInMemoryElement&) = {\cf19 default};\par
00188 \par
00189             std::vector <std::string> _elements;\par
00190 \par
00191             {\cf17 private}:\par
00192             {\cf17 virtual} std::vector <UByte> calculateCodeBytes ({\cf17 const} Semantic* s, {\cf18 bool} bE = {\cf17 true}) {\cf17 const override};\par
00193         \};\par
00194 \par
00197         {\cf17 struct }InstructionElement final : {\cf17 public} GrammaticalElement\par
00198         \{\par
00199             InstructionElement ()\par
00200                 : GrammaticalElement (), \par
00201                   _possibleInstructions (),\par
00202                   _parameters (),\par
00203                   _selectedInstruction (nullptr)\par
00204                             \{ _type = Type::_INSTRUCTION; \}\par
00205 \par
00206             InstructionElement ({\cf17 const} InstructionElement&) = {\cf19 default};\par
00207 \par
00208             InstructionElement& operator = ({\cf17 const} InstructionElement&) = {\cf19 default};\par
00209 \par
00210             {\cf17 virtual} {\cf18 size_t} size ({\cf17 const} Semantic* s) {\cf17 const}; \par
00211 \par
00213             {\cf18 bool} hasAnyLabelAsParameter ({\cf17 const} Semantic* s) {\cf17 const};\par
00215             std::vector <size_t> labelParameters ({\cf17 const} Semantic* s) {\cf17 const};\par
00216 \par
00217             std::vector <Instruction*> _possibleInstructions;\par
00218             std::vector <std::string> _parameters;\par
00219             {\cf17 mutable} Instruction* _selectedInstruction;\par
00220 \par
00221             {\cf17 private}:\par
00224             {\cf17 virtual} std::vector <UByte> calculateCodeBytes ({\cf17 const} Semantic* s, {\cf18 bool} bE = {\cf17 true}) {\cf17 const override};\par
00225 \par
00226             {\cf20 // Implementation}\par
00227             std::vector <UByte> calculateCodeBytesForInstruction \par
00228                 ({\cf17 const} Instruction* inst, {\cf17 const} Semantic* s, {\cf18 bool} bE = {\cf17 true}) {\cf17 const};\par
00229         \};\par
00230 \par
00232         {\cf17 struct }StartingPointElement final : {\cf17 public} GrammaticalElement\par
00233         \{\par
00234             StartingPointElement ()\par
00235                 : GrammaticalElement (), \par
00236                   _value ()\par
00237                             \{ _type = Type::_STARTINGPOINT; \}\par
00238 \par
00239             StartingPointElement ({\cf17 const} StartingPointElement&) = {\cf19 default};\par
00240 \par
00241             StartingPointElement& operator = ({\cf17 const} StartingPointElement&) = {\cf19 default};\par
00242 \par
00243             {\cf17 virtual} Address address ({\cf17 const} Semantic* s){\cf17  const override}\par
00244 {\cf17                             }\{ {\cf19 return} (Address (codeBytes (s ))); \}\par
00245 \par
00246             std::string _value;\par
00247 \par
00248             {\cf17 private}:\par
00249             {\cf17 virtual} std::vector <UByte> calculateCodeBytes ({\cf17 const} Semantic* s, {\cf18 bool} bE = {\cf17 true}) {\cf17 const override};\par
00250         \};\par
00251 \par
00253         {\cf17 using} StartingPointElements = std::vector <StartingPointElement*>;\par
00254 \par
00260         {\cf17 class }CommandParser;\par
00261         {\cf17 class }Semantic\par
00262         \{\par
00263             {\cf17 public}:\par
00264             {\cf17 friend} CommandParser;\par
00265 \par
00266             Semantic ()\par
00267                 : _macros (), _startingPoints (), \par
00268                   _error (ErrorType::_NOERROR), _lastGrammaticalElementAdded (nullptr)\par
00269                             \{ \}\par
00270 \par
00271             Semantic ({\cf17 const} Semantic&) = {\cf17 delete};\par
00272 \par
00273             ~Semantic ()\par
00274                             \{ {\cf19 for} ({\cf17 auto} i : _startingPoints) {\cf17 delete} (i); \}\par
00275 \par
00276             Semantic& operator = ({\cf17 const} Semantic&) = {\cf17 delete};\par
00277 \par
00278             {\cf20 // Managing the semantic...}\par
00279             {\cf17 const} Macros& macros (){\cf17  const}\par
00280 {\cf17                             }\{ {\cf19 return} (_macros); \}\par
00281             {\cf18 void} addMacro ({\cf17 const} Macro& m);\par
00282             {\cf17 const} StartingPointElements& startingPoints (){\cf17  const}\par
00283 {\cf17                             }\{ {\cf19 return} (_startingPoints); \}\par
00284             StartingPointElement* addNewStartingPoint ();\par
00285             {\cf18 void} addGrammaticalElement (GrammaticalElement* g);\par
00286             {\cf17 const} GrammaticalElement* lastGrammaticalElementAdded (){\cf17  const}\par
00287 {\cf17                             }\{ {\cf19 return} (_lastGrammaticalElementAdded); \}\par
00288             GrammaticalElement* lastGrammaticalElementAdded ()\par
00289                             \{ {\cf19 return} (_lastGrammaticalElementAdded); \}\par
00290 \par
00291             ErrorType error (){\cf17  const}\par
00292 {\cf17                             }\{ {\cf19 return} (_error); \}\par
00293 \par
00295             {\cf18 bool} operator ! (){\cf17  const}\par
00296 {\cf17                             }\{ {\cf19 return} (_error != ErrorType::_NOERROR); \}\par
00297 \par
00299             {\cf18 void} addFrom ({\cf17 const} Semantic* s);\par
00300 \par
00302             {\cf18 bool} existsLabel ({\cf17 const} std::string& l) {\cf17 const};\par
00305             Address addressForLabel ({\cf17 const} std::string& l) {\cf17 const};\par
00307             std::vector <const LabelElement*> labels () {\cf17 const};\par
00309             std::map <std::string, Address> labelAddresses () {\cf17 const};\par
00310 \par
00311             {\cf17 private}:\par
00312             Macros _macros;\par
00313             StartingPointElements _startingPoints;\par
00314 \par
00315             {\cf20 // Implementation}\par
00316             {\cf17 mutable} ErrorType _error;\par
00317             {\cf17 mutable} GrammaticalElement* _lastGrammaticalElementAdded;\par
00318         \};\par
00319     \}\par
00320 \}\par
00321 \par
00322 {\cf21 #endif}\par
00323   \par
00324 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/incs.hpp}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ASSEMBLER/Error.hpp>}\par
{\f2 #include <ASSEMBLER/Grammar.hpp>}\par
{\f2 #include <ASSEMBLER/Parser.hpp>}\par
{\f2 #include <ASSEMBLER/Compiler.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/incs.hpp}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __ASSEMBLER_INCS__}\par
00015 {\cf21 #define __ASSEMBLER_INCS__}\par
00016 \par
00017 {\cf21 #include <ASSEMBLER/Error.hpp>}\par
00018 {\cf21 #include <ASSEMBLER/Grammar.hpp>}\par
00019 {\cf21 #include <ASSEMBLER/Parser.hpp>}\par
00020 {\cf21 #include <ASSEMBLER/Compiler.hpp>}\par
00021 \par
00022 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/incs.hpp}
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/incs.hpp>}\par
{\f2 #include <C64/global.hpp>}\par
{\f2 #include <C64/C64.hpp>}\par
{\f2 #include <C64/Memory.hpp>}\par
{\f2 #include <C64/VICII.hpp>}\par
{\f2 #include <C64/VICIIRegisters.hpp>}\par
{\f2 #include <C64/CIATimer.hpp>}\par
{\f2 #include <C64/CIAClock.hpp>}\par
{\f2 #include <C64/CIA1.hpp>}\par
{\f2 #include <C64/CIA1Registers.hpp>}\par
{\f2 #include <C64/CIA2.hpp>}\par
{\f2 #include <C64/CIA2Registers.hpp>}\par
{\f2 #include <C64/Screen.hpp>}\par
{\f2 #include <C64/OSIO.hpp>}\par
{\f2 #include <C64/UserPort.hpp>}\par
{\f2 #include <C64/UserPeripherals.hpp>}\par
{\f2 #include <C64/IOPBuilder.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/incs.hpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_INCS__}\par
00015 {\cf21 #define __C64_INCS__}\par
00016 \par
00017 {\cf21 #include <F6500/incs.hpp>}\par
00018 {\cf21 #include <C64/global.hpp>}\par
00019 {\cf21 #include <C64/C64.hpp>}\par
00020 {\cf21 #include <C64/Memory.hpp>}\par
00021 {\cf21 #include <C64/VICII.hpp>}\par
00022 {\cf21 #include <C64/VICIIRegisters.hpp>}\par
00023 {\cf21 #include <C64/CIATimer.hpp>}\par
00024 {\cf21 #include <C64/CIAClock.hpp>}\par
00025 {\cf21 #include <C64/CIA1.hpp>}\par
00026 {\cf21 #include <C64/CIA1Registers.hpp>}\par
00027 {\cf21 #include <C64/CIA2.hpp>}\par
00028 {\cf21 #include <C64/CIA2Registers.hpp>}\par
00029 {\cf21 #include <C64/Screen.hpp>}\par
00030 {\cf21 #include <C64/OSIO.hpp>}\par
00031 {\cf21 #include <C64/UserPort.hpp>}\par
00032 {\cf21 #include <C64/UserPeripherals.hpp>}\par
00033 {\cf21 #include <C64/IOPBuilder.hpp>}\par
00034 \par
00035 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/incs.hpp}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <COMMS/IPAddress.hpp>}\par
{\f2 #include <COMMS/Message.hpp>}\par
{\f2 #include <COMMS/Channel.hpp>}\par
{\f2 #include <COMMS/System.hpp>}\par
{\f2 #include <COMMS/StdMessages.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/incs.hpp}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __COMMS_INCS__}\par
00015 {\cf21 #define __COMMS_INCS__}\par
00016 \par
00017 {\cf21 #include <COMMS/IPAddress.hpp>}\par
00018 {\cf21 #include <COMMS/Message.hpp>}\par
00019 {\cf21 #include <COMMS/Channel.hpp>}\par
00020 {\cf21 #include <COMMS/System.hpp>}\par
00021 {\cf21 #include <COMMS/StdMessages.hpp>}\par
00022 \par
00023 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CONSOLE/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CONSOLE/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CONSOLE/incs.hpp}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CONSOLE/Console.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CONSOLE/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CONSOLE/incs.hpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __CONSOLE_INCS__}\par
00015 {\cf21 #define __CONSOLE_INCS__}\par
00016 \par
00017 {\cf21 #include <CONSOLE/Console.hpp>}\par
00018 \par
00019 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/incs.hpp}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/Address.hpp>}\par
{\f2 #include <CORE/Chip.hpp>}\par
{\f2 #include <CORE/Computer.hpp>}\par
{\f2 #include <CORE/CPU.hpp>}\par
{\f2 #include <CORE/CPUArchitecture.hpp>}\par
{\f2 #include <CORE/CPUInterrupt.hpp>}\par
{\f2 #include <CORE/Memory.hpp>}\par
{\f2 #include <CORE/ProgramCounter.hpp>}\par
{\f2 #include <CORE/Register.hpp>}\par
{\f2 #include <CORE/Stack.hpp>}\par
{\f2 #include <CORE/StatusRegister.hpp>}\par
{\f2 #include <CORE/UByte.hpp>}\par
{\f2 #include <CORE/UBytes.hpp>}\par
{\f2 #include <CORE/UInt.hpp>}\par
{\f2 #include <CORE/Instruction.hpp>}\par
{\f2 #include <CORE/IO.hpp>}\par
{\f2 #include <CORE/Screen.hpp>}\par
{\f2 #include <CORE/ScreenMemory.hpp>}\par
{\f2 #include <CORE/OSIO.hpp>}\par
{\f2 #include <CORE/IOPeripheral.hpp>}\par
{\f2 #include <CORE/IOPBuilder.hpp>}\par
{\f2 #include <CORE/Command.hpp>}\par
{\f2 #include <CORE/CommandBuilder.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/incs.hpp}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_INCS__}\par
00015 {\cf21 #define __MCHEMUL_INCS__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/Address.hpp>}\par
00019 {\cf21 #include <CORE/Chip.hpp>}\par
00020 {\cf21 #include <CORE/Computer.hpp>}\par
00021 {\cf21 #include <CORE/CPU.hpp>}\par
00022 {\cf21 #include <CORE/CPUArchitecture.hpp>}\par
00023 {\cf21 #include <CORE/CPUInterrupt.hpp>}\par
00024 {\cf21 #include <CORE/Memory.hpp>}\par
00025 {\cf21 #include <CORE/ProgramCounter.hpp>}\par
00026 {\cf21 #include <CORE/Register.hpp>}\par
00027 {\cf21 #include <CORE/Stack.hpp>}\par
00028 {\cf21 #include <CORE/StatusRegister.hpp>}\par
00029 {\cf21 #include <CORE/UByte.hpp>}\par
00030 {\cf21 #include <CORE/UBytes.hpp>}\par
00031 {\cf21 #include <CORE/UInt.hpp>}\par
00032 {\cf21 #include <CORE/Instruction.hpp>}\par
00033 {\cf21 #include <CORE/IO.hpp>}\par
00034 {\cf21 #include <CORE/Screen.hpp>}\par
00035 {\cf21 #include <CORE/ScreenMemory.hpp>}\par
00036 {\cf21 #include <CORE/OSIO.hpp>}\par
00037 {\cf21 #include <CORE/IOPeripheral.hpp>}\par
00038 {\cf21 #include <CORE/IOPBuilder.hpp>}\par
00039 {\cf21 #include <CORE/Command.hpp>}\par
00040 {\cf21 #include <CORE/CommandBuilder.hpp>}\par
00041 \par
00042 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/EMULATORS/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/EMULATORS/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/EMULATORS/incs.hpp}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/incs.hpp>}\par
{\f2 #include <EMULATORS/Emulator.hpp>}\par
{\f2 #include <EMULATORS/C64Emulator.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/EMULATORS/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/EMULATORS/incs.hpp}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64EMULATOR_INCS__}\par
00015 {\cf21 #define __C64EMULATOR_INCS__}\par
00016 \par
00017 {\cf21 #include <C64/incs.hpp>}\par
00018 {\cf21 #include <EMULATORS/Emulator.hpp>}\par
00019 {\cf21 #include <EMULATORS/C64Emulator.hpp>}\par
00020 \par
00021 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/incs.hpp}
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <F6500/C6500.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
{\f2 #include <F6500/IRQInterrupt.hpp>}\par
{\f2 #include <F6500/NMIInterrupt.hpp>}\par
{\f2 #include <F6500/Instructions.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/incs.hpp}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __F6500_INCS__}\par
00015 {\cf21 #define __F6500_INCS__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <F6500/C6500.hpp>}\par
00019 {\cf21 #include <F6500/C6510.hpp>}\par
00020 {\cf21 #include <F6500/IRQInterrupt.hpp>}\par
00021 {\cf21 #include <F6500/NMIInterrupt.hpp>}\par
00022 {\cf21 #include <F6500/Instructions.hpp>}\par
00023 \par
00024 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Parser.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Parser.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Parser.hpp}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Incs.hpp>}\par
{\f2 #include <ASSEMBLER/Grammar.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::CommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::CommentCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::IncludeCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::MacroCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::StartingPointCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::LabelCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::BytesCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::InstructionCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::Parser}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul::Assembler}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Assembler::CommandParsers} = std::vector< CommandParser * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Parser.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Parser.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Parser.hpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __ASSEMBLER_PARSER__}\par
00015 {\cf21 #define __ASSEMBLER_PARSER__}\par
00016 \par
00017 {\cf21 #include <CORE/Incs.hpp>}\par
00018 {\cf21 #include <ASSEMBLER/Grammar.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00022     {\cf17 namespace }Assembler\par
00023     \{\par
00028         {\cf17 class }Parser;\par
00029         {\cf17 class }CommandParser\par
00030         \{\par
00031             {\cf17 public}:\par
00032             {\cf17 friend} Parser;\par
00033 \par
00034             CommandParser ()\par
00035                 : _cpu (nullptr), _parser (nullptr)\par
00036                             \{ \}\par
00037 \par
00038             {\cf17 virtual} ~CommandParser ()\par
00039                             \{ \}\par
00040 \par
00041             {\cf17 const} CPU* cpu (){\cf17  const}\par
00042 {\cf17                             }\{ {\cf19 return} (_cpu); \}\par
00043             {\cf17 const} Parser* parser (){\cf17  const}\par
00044 {\cf17                             }\{ {\cf19 return} (_parser); \}\par
00045 \par
00047             {\cf17 virtual} {\cf18 void} initialize ()\par
00048                             \{ \}\par
00049 \par
00051             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l) {\cf17 const} = 0;\par
00054             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* s) {\cf17 const} = 0;\par
00055 \par
00057             {\cf18 void} setCPU ({\cf17 const} CPU* c)\par
00058                             \{ assert (c != {\cf17 nullptr}); _cpu = c; \}\par
00059             {\cf18 void} setParser ({\cf17 const} Parser* p)\par
00060                             \{ assert (p!= {\cf17 nullptr}); _parser = p; \}\par
00061 \par
00062             {\cf17 protected}:\par
00063             {\cf17 const} CPU* _cpu;\par
00064             {\cf17 const} Parser* _parser;\par
00065         \};\par
00066 \par
00068         {\cf17 using} CommandParsers = std::vector <CommandParser*>;\par
00069 \par
00072         {\cf17 class }CommentCommandParser final : {\cf17 public} CommandParser\par
00073         \{\par
00074             {\cf17 public}:\par
00075             CommentCommandParser ({\cf18 unsigned} {\cf18 char} s = {\cf23 ';'})\par
00076                 : CommandParser (),\par
00077                   _symbol (s)\par
00078                             \{ \}\par
00079 \par
00080             {\cf18 unsigned} {\cf18 char} symbol (){\cf17  const}\par
00081 {\cf17                             }\{ {\cf19 return} (_symbol); \}\par
00082 \par
00083             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l){\cf17  const override}\par
00084 {\cf17                             }\{ {\cf19 return} (l [0] == _symbol); \}\par
00085             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int}, Semantic*){\cf17  const override}\par
00086 {\cf17                             }\{ l = {\cf22 ""}; \}\par
00087 \par
00088             {\cf17 private}:\par
00089             {\cf17 const} {\cf18 unsigned} {\cf18 char} _symbol = {\cf23 ';'}; {\cf20 // Adjusted at construction level}\par
00090         \};\par
00091 \par
00094         {\cf17 class }IncludeCommandParser final : {\cf17 public} CommandParser\par
00095         \{\par
00096             {\cf17 public}:\par
00097             IncludeCommandParser ({\cf18 unsigned} {\cf18 char} s = {\cf23 '#'})\par
00098                 : CommandParser (),\par
00099                   _symbol (s)\par
00100                             \{ \}\par
00101 \par
00102             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l){\cf17  const override}\par
00103 {\cf17                             }\{ {\cf19 return} (l [0] == _symbol); \}\par
00104             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* c) {\cf17 const override};\par
00105 \par
00106             {\cf17 private}:\par
00107             {\cf17 const} {\cf18 unsigned} {\cf18 char} _symbol = {\cf23 '#'}; {\cf20 // Adjusted at construction level}\par
00108         \};\par
00109 \par
00112         {\cf17 class }MacroCommandParser : {\cf17 public} CommandParser\par
00113         \{\par
00114             {\cf17 public}:\par
00115             MacroCommandParser ({\cf18 unsigned} {\cf18 char} s = {\cf23 '='})\par
00116                 : CommandParser (),\par
00117                   _symbol (s)\par
00118                             \{ \}\par
00119 \par
00120             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l){\cf17  const override}\par
00121 {\cf17                             }\{ {\cf18 size_t} eP = l.find (_symbol); \par
00122                               {\cf19 return} (eP != std::string::npos && validLabel (trim (l.substr (0, eP)))); \}\par
00123             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* s) {\cf17 const override};\par
00124 \par
00125             {\cf17 protected}:\par
00126             {\cf17 const} {\cf18 unsigned} {\cf18 char} _symbol = {\cf23 '='};\par
00127         \};\par
00128 \par
00132         {\cf17 class }StartingPointCommandParser final : {\cf17 public} CommandParser\par
00133         \{\par
00134             {\cf17 public}:\par
00135             StartingPointCommandParser ({\cf18 unsigned} {\cf18 char} s = {\cf23 '='})\par
00136                 : CommandParser (),\par
00137                   _symbol (s),\par
00138                   _lastStartingPointId (0)\par
00139                             \{ \}\par
00140 \par
00141             {\cf17 virtual} {\cf18 void} initialize (){\cf17  override}\par
00142 {\cf17                             }\{ _lastStartingPointId = 0; \}\par
00143 \par
00144             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l){\cf17  const override}\par
00145 {\cf17                             }\{ {\cf18 size_t} eP = l.find (_symbol); \par
00146                               {\cf19 return} (eP != std::string::npos && trim (l.substr (0, eP)) == {\cf22 "*"}); \}\par
00147             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* s) {\cf17 const override};\par
00148 \par
00149             {\cf17 private}:\par
00150             {\cf17 const} {\cf18 unsigned} {\cf18 char} _symbol = {\cf23 '='};\par
00151 \par
00152             {\cf20 // Implementation}\par
00153             {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastStartingPointId;\par
00154         \};\par
00155 \par
00157         {\cf17 class }LabelCommandParser final : {\cf17 public} CommandParser\par
00158         \{\par
00159             {\cf17 public}:\par
00160             LabelCommandParser ({\cf18 unsigned} {\cf18 char} s = {\cf23 ':'})\par
00161                 : CommandParser (),\par
00162                   _symbol (s),\par
00163                   _lastLabelId (0)\par
00164                             \{ \}\par
00165 \par
00166             {\cf17 virtual} {\cf18 void} initialize (){\cf17  override}\par
00167 {\cf17                             }\{ _lastLabelId = 0; \}\par
00168 \par
00169             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l){\cf17  const override}\par
00170 {\cf17                             }\{ {\cf18 size_t} eP = l.find (_symbol); \par
00171                               {\cf19 return} (eP != std::string::npos && validLabel (trim (l.substr (0, eP)))); \}\par
00172             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* s) {\cf17 const override};\par
00173 \par
00174             {\cf17 private}:\par
00175             {\cf17 const} {\cf18 unsigned} {\cf18 char} _symbol = {\cf23 ':'};\par
00176 \par
00177             {\cf20 // Implementation}\par
00178             {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastLabelId;\par
00179         \};\par
00180 \par
00182         {\cf17 class }BytesCommandParser final : {\cf17 public} CommandParser\par
00183         \{\par
00184             {\cf17 public}:\par
00185             BytesCommandParser ()\par
00186                 : CommandParser (),\par
00187                   _lastBytesId (0)\par
00188                             \{ \}\par
00189 \par
00190             {\cf17 virtual} {\cf18 void} initialize (){\cf17  override}\par
00191 {\cf17                             }\{ _lastBytesId = 0; \}\par
00192 \par
00193             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l){\cf17  const override}\par
00194 {\cf17                             }\{ {\cf18 size_t} eP = l.find ({\cf23 ' '}); \par
00195                               {\cf19 return} (eP != std::string::npos && upper (trim (l.substr (0, eP))) == {\cf22 "BYTES"}); \}\par
00196             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* s) {\cf17 const override};\par
00197 \par
00198             {\cf17 private}:\par
00199             {\cf20 // Implementation}\par
00200             {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastBytesId;\par
00201         \};\par
00202 \par
00204         {\cf17 class }InstructionCommandParser final : {\cf17 public} CommandParser\par
00205         \{\par
00206             {\cf17 public}:\par
00207             InstructionCommandParser ()\par
00208                 : CommandParser (),\par
00209                   _lastInstructionId (0)\par
00210                             \{ \}\par
00211 \par
00212             {\cf17 virtual} {\cf18 void} initialize (){\cf17  override}\par
00213 {\cf17                             }\{ _lastInstructionId = 0; \}\par
00214 \par
00215             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l) {\cf17 const override};\par
00216             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* s) {\cf17 const override};\par
00217 \par
00218             {\cf17 private}:\par
00219             {\cf20 // Implementation}\par
00220             {\cf17 mutable} {\cf18 unsigned} {\cf18 char} _lastInstructionId;\par
00221         \};\par
00222 \par
00228         {\cf17 class }Parser final\par
00229         \{\par
00230             {\cf17 public}:\par
00231             Parser ({\cf17 const} CPU* c, {\cf17 const} CommandParsers& lP = {\cf20 // With the standard line parsers...}\par
00232                     \{ {\cf17 new} CommentCommandParser, {\cf17 new} IncludeCommandParser, \par
00233                       {\cf17 new} MacroCommandParser, {\cf17 new} StartingPointCommandParser, \par
00234                       {\cf17 new} LabelCommandParser, {\cf17 new} BytesCommandParser,\par
00235                       {\cf17 new} InstructionCommandParser \});\par
00236 \par
00237             Parser (Parser&) = {\cf17 delete};\par
00238 \par
00239             Parser& operator = ({\cf17 const} Parser&) = {\cf17 delete};\par
00240 \par
00242             ~Parser ()\par
00243                             \{ {\cf19 for} ({\cf17 auto} i : _commandParsers) {\cf17 delete} (i); \}\par
00244 \par
00245             {\cf17 const} CPU* cpu (){\cf17  const}\par
00246 {\cf17                             }\{ {\cf19 return} (_cpu); \}\par
00247             {\cf17 const} CommandParsers& commandParsers (){\cf17  const}\par
00248 {\cf17                             }\{ {\cf19 return} (_commandParsers); \}\par
00249             {\cf18 unsigned} {\cf18 char} commentSymbol () {\cf17 const};\par
00250 \par
00280             Semantic* parse ({\cf17 const} std::string& fN, {\cf17 const} std::string& fA = {\cf22 ""}) {\cf17 const};\par
00281 \par
00282             Errors errors (){\cf17  const}\par
00283 {\cf17                             }\{ {\cf19 return} (_errors); \}\par
00284 \par
00286             {\cf18 bool} operator ! (){\cf17  const}\par
00287 {\cf17                             }\{ {\cf19 return} (!_errors.empty ()); \}\par
00288 \par
00289             {\cf17 private}:\par
00291             std::vector <std::string> readLines ({\cf17 const} std::string& fN) {\cf17 const};\par
00292 \par
00293             {\cf17 private}:\par
00294             {\cf17 const} CPU* _cpu;\par
00295             CommandParsers _commandParsers;\par
00296 \par
00297             {\cf20 // Implementation}\par
00298             {\cf17 mutable} Errors _errors;\par
00299             {\cf17 mutable} {\cf18 unsigned} {\cf18 char} _commentSymbol;\par
00300         \};\par
00301     \}\par
00302 \}\par
00303 \par
00304 {\cf21 #endif}\par
00305   \par
00306 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/C64.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/C64.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/C64.hpp}
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/Screen.hpp>}\par
{\f2 #include <C64/UserPeripherals.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::Commodore64}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/C64.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/C64.hpp}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_C64__}\par
00015 {\cf21 #define __C64_C64__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <C64/Screen.hpp>}\par
00019 {\cf21 #include <C64/UserPeripherals.hpp>}\par
00020 \par
00021 {\cf17 namespace }C64\par
00022 \{\par
00028     {\cf17 class }Commodore64 final : {\cf17 public} MCHEmul::Computer\par
00029     \{\par
00030         {\cf17 public}:\par
00031         {\cf17 enum class} VisualSystem \{ _NTSC, _PAL \};\par
00032 \par
00033         Commodore64 (VisualSystem vS = VisualSystem::_PAL );\par
00034 \par
00035         {\cf17 virtual} {\cf18 bool} connect (MCHEmul::IOPeripheral* p, MCHEmul::IODevice* d) {\cf17 override};\par
00036 \par
00037         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00038 \par
00039         {\cf17 private}:\par
00040         {\cf20 // Implementation}\par
00041         {\cf17 static} MCHEmul::Chips standardChips (VisualSystem vS);\par
00042         {\cf17 static} MCHEmul::IODevices standardDevices (VisualSystem vS);\par
00043 \par
00044         {\cf17 protected}:\par
00046         VisualSystem _visualSystem;\par
00048         MCHEmul::Attributes _parameters;\par
00049     \};\par
00050 \}\par
00051 \par
00052 {\cf21 #endif}\par
00053   \par
00054 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/CIA1.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA1.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA1.hpp}
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/CIA1Registers.hpp>}\par
{\f2 #include <C64/CIATimer.hpp>}\par
{\f2 #include <C64/CIAClock.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::CIA1}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIA1.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA1.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA1.hpp}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_CIA1__}\par
00015 {\cf21 #define __C64_CIA1__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <C64/CIA1Registers.hpp>}\par
00019 {\cf21 #include <C64/CIATimer.hpp>}\par
00020 {\cf21 #include <C64/CIAClock.hpp>}\par
00021 \par
00022 {\cf17 namespace }C64\par
00023 \{\par
00024     {\cf17 class }InputOSSystem;\par
00025 \par
00028     {\cf17 class }CIA1 : {\cf17 public} MCHEmul::Chip\par
00029     \{\par
00030         {\cf17 public}:\par
00031         {\cf17 friend} InputOSSystem;\par
00032 \par
00033         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _ID = 2;\par
00034 \par
00035         CIA1 ()\par
00036             : MCHEmul::Chip (_ID,\par
00037                 \{ \{ {\cf22 "Name"}, {\cf22 "CIA1"} \},\par
00038                   \{ {\cf22 "Code"}, {\cf22 "6526/6526A/8521"} \},\par
00039                   \{ {\cf22 "Manufacturer"}, {\cf22 "Commodore Business Machines CBM"} \},\par
00040                   \{ {\cf22 "Year"}, {\cf22 "1980"} \} \}),\par
00041               _CIA1Registers ({\cf17 nullptr}),\par
00042               _timerA (0), _timerB (1), _clock (0)\par
00043                             \{ \}\par
00044 \par
00045         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00046 \par
00047         {\cf17 virtual} {\cf18 bool} simulate (MCHEmul::CPU* cpu) {\cf17 override};\par
00048 \par
00049         {\cf17 private}:\par
00050         {\cf20 // These methods are invoked from InputOSSystem...  }\par
00051         {\cf20 // To manage the joystick}\par
00052         {\cf18 unsigned} {\cf18 char} joystick2Status (){\cf17  const}\par
00053 {\cf17                             }\{ {\cf19 return} (_CIA1Registers -> joystick2Status ()); \}\par
00054         {\cf18 void} setJoystick2Status ({\cf18 unsigned} {\cf18 char} js)\par
00055                             \{ _CIA1Registers -> setJoystick2Status (js); \}\par
00056 \par
00057         {\cf20 // To manage status of the data ports}\par
00058         {\cf18 bool} keyboardStatusMatrix ({\cf18 size_t} r, {\cf18 size_t} c){\cf17  const}\par
00059 {\cf17                             }\{ {\cf19 return} (_CIA1Registers -> keyboardStatusMatrix (r, c)); \}\par
00060         {\cf17 const} MCHEmul::UByte& keyboardStatusMatrix ({\cf18 size_t} r){\cf17  const}\par
00061 {\cf17                             }\{ {\cf19 return} (_CIA1Registers -> keyboardStatusMatrix (r)); \}\par
00062         {\cf18 void} setKeyboardStatusMatrix ({\cf18 size_t} r, {\cf18 size_t} c, {\cf18 bool} s)\par
00063                             \{ _CIA1Registers -> setKeyboardStatusMatrix (r, c, s); \}\par
00064         {\cf18 void} setKeyboardStatusMatrix ({\cf18 size_t} r, {\cf17 const} MCHEmul::UByte& u)\par
00065                             \{ _CIA1Registers -> setKeyboardStatusMatrix (r, u); \}\par
00066 \par
00067         {\cf17 private}:\par
00068         C64::CIA1Registers* _CIA1Registers;\par
00070         CIATimer _timerA, _timerB;\par
00071         CIAClock _clock;\par
00072     \};\par
00073 \}\par
00074 \par
00075 {\cf21 #endif}\par
00076   \par
00077 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/CIA1Registers.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA1Registers.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA1Registers.hpp}
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::CIA1Registers}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIA1Registers.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA1Registers.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA1Registers.hpp}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_CIA1REGISTERS__}\par
00015 {\cf21 #define __C64_CIA1REGISTERS__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00021     {\cf17 class }CIA1;\par
00022     {\cf17 class }CIATimer;\par
00023     {\cf17 class }CIAClock;\par
00024 \par
00027     {\cf17 class }CIA1Registers final : {\cf17 public} MCHEmul::PhisicalStorageSubset\par
00028     \{\par
00029         {\cf17 public}:\par
00030         {\cf17 friend} CIA1;\par
00031 \par
00032         CIA1Registers ({\cf18 int} {\cf18 id}, MCHEmul::PhisicalStorage* pS);\par
00033 \par
00034         {\cf17 virtual} {\cf18 void} initialize () {\cf17 override};\par
00035 \par
00036         {\cf17 private}:\par
00037         {\cf17 virtual} {\cf18 void} setValue ({\cf18 size_t} p, {\cf17 const} MCHEmul::UByte& v) {\cf17 override};\par
00038         {\cf17 virtual} {\cf17 const} MCHEmul::UByte& readValue ({\cf18 size_t} p) {\cf17 const override};\par
00039 \par
00040         {\cf20 // Implementation}\par
00041         {\cf18 void} initializeInternalValues ();\par
00042 \par
00043         {\cf20 // This methods are invoked from CIA chip...}\par
00045 {\cf20 }        {\cf18 unsigned} {\cf18 char} joystick2Status (){\cf17  const}\par
00046 {\cf17                             }\{ {\cf19 return} (_joystick2Status); \}\par
00047         {\cf18 void} setJoystick2Status ({\cf18 unsigned} {\cf18 char} js)\par
00048                             \{ _joystick2Status = js; \}\par
00049 \par
00052         {\cf18 bool} keyboardStatusMatrix ({\cf18 size_t} r, {\cf18 size_t} c){\cf17  const}\par
00053 {\cf17                             }\{ {\cf19 return} (_keyboardStatusMatrix [r].bit (c)); \}\par
00054         {\cf17 const} MCHEmul::UByte& keyboardStatusMatrix ({\cf18 size_t} r){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} (_keyboardStatusMatrix [r]); \}\par
00056         {\cf18 void} setKeyboardStatusMatrix ({\cf18 size_t} r, {\cf18 size_t} c, {\cf18 bool} s)\par
00057                             \{ _keyboardStatusMatrix [r].setBit (c, s); \}\par
00058         {\cf18 void} setKeyboardStatusMatrix ({\cf18 size_t} r, {\cf17 const} MCHEmul::UByte& u)\par
00059                             \{ _keyboardStatusMatrix [r] = u; \}\par
00060 \par
00062         {\cf18 void} lookAtTimers (CIATimer* tA, CIATimer* tB)\par
00063                             \{ _timerA = tA, _timerB = tB; \}\par
00065         {\cf18 void} lookAtClock (CIAClock* c)\par
00066                             \{ _clock = c; \}\par
00067 \par
00068         {\cf17 private}:\par
00070         {\cf18 unsigned} {\cf18 char} _joystick2Status;\par
00073         MCHEmul::UByte _keyboardStatusMatrix [8];\par
00074         {\cf20 // Reference to the timers...}\par
00075         CIATimer* _timerA;\par
00076         CIATimer* _timerB;\par
00077         {\cf20 // Reference to the clock...}\par
00078         CIAClock* _clock;\par
00079 \par
00080         {\cf20 // Implementation}\par
00081         {\cf18 unsigned} {\cf18 char} _keyboardRowToRead; {\cf20 // bit = 0, means row to be read!}\par
00082         {\cf18 unsigned} {\cf18 char} _dataPortADir, _dataPortBDir;\par
00083 \par
00084         {\cf17 mutable} MCHEmul::UByte _lastValueRead;\par
00085     \};\par
00086 \}\par
00087 \par
00088 {\cf21 #endif}\par
00089   \par
00090 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/CIA2.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA2.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA2.hpp}
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/CIA2Registers.hpp>}\par
{\f2 #include <C64/CIATimer.hpp>}\par
{\f2 #include <C64/CIAClock.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::CIA2}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIA2.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA2.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA2.hpp}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_CIA2__}\par
00015 {\cf21 #define __C64_CIA2__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <C64/CIA2Registers.hpp>}\par
00019 {\cf21 #include <C64/CIATimer.hpp>}\par
00020 {\cf21 #include <C64/CIAClock.hpp>}\par
00021 \par
00022 {\cf17 namespace }C64\par
00023 \{\par
00024     {\cf17 class }VICII;\par
00025     {\cf17 class }Commodore64;\par
00026 \par
00028     {\cf17 class }CIA2 : {\cf17 public} MCHEmul::Chip\par
00029     \{\par
00030         {\cf17 public}:\par
00031         {\cf17 friend} Commodore64;\par
00032 \par
00033         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _ID = 3;\par
00034 \par
00035         CIA2 ()\par
00036             : MCHEmul::Chip (_ID,\par
00037                 \{ \{ {\cf22 "Name"}, {\cf22 "CIA2"} \},\par
00038                   \{ {\cf22 "Code"}, {\cf22 "6526/6526A/8521"} \},\par
00039                   \{ {\cf22 "Manufacturer"}, {\cf22 "Commodore Business Machines CBM"} \},\par
00040                   \{ {\cf22 "Year"}, {\cf22 "1980"} \} \}),\par
00041               _CIA2Registers ({\cf17 nullptr}),\par
00042               _timerA (0), _timerB (1), _clock (0)\par
00043                             \{ \}\par
00044 \par
00045         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00046 \par
00047         {\cf17 virtual} {\cf18 bool} simulate (MCHEmul::CPU* cpu) {\cf17 override};\par
00048 \par
00049         {\cf17 private}:\par
00050         C64::CIA2Registers* _CIA2Registers;\par
00052         VICII* _VICIIRef;\par
00053         CIATimer _timerA, _timerB;\par
00054         CIAClock _clock;\par
00055 \par
00056         {\cf20 // Implementation}\par
00057         {\cf18 unsigned} {\cf18 int} _lastClockCycles;\par
00058     \};\par
00059 \}\par
00060 \par
00061 {\cf21 #endif}\par
00062   \par
00063 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/CIA2Registers.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA2Registers.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA2Registers.hpp}
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::CIA2Registers}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIA2Registers.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA2Registers.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA2Registers.hpp}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_CIA2REGISTERS__}\par
00015 {\cf21 #define __C64_CIA2REGISTERS__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00021     {\cf17 class }CIA2;\par
00022     {\cf17 class }CIATimer;\par
00023     {\cf17 class }CIAClock;\par
00024 \par
00027     {\cf17 class }CIA2Registers final : {\cf17 public} MCHEmul::PhisicalStorageSubset\par
00028     \{\par
00029         {\cf17 public}:\par
00030         {\cf17 friend} CIA2;\par
00031 \par
00032         CIA2Registers ({\cf18 int} {\cf18 id}, MCHEmul::PhisicalStorage* pS);\par
00033 \par
00034         {\cf18 unsigned} {\cf18 char} VICIIBank (){\cf17  const}\par
00035 {\cf17                             }\{ {\cf19 return} (_VICBank); \}\par
00036 \par
00037         {\cf17 virtual} {\cf18 void} initialize () {\cf17 override};\par
00038 \par
00039         {\cf17 private}:\par
00040         {\cf17 virtual} {\cf18 void} setValue ({\cf18 size_t} p, {\cf17 const} MCHEmul::UByte& v) {\cf17 override};\par
00041         {\cf17 virtual} {\cf17 const} MCHEmul::UByte& readValue ({\cf18 size_t} p) {\cf17 const override};\par
00042 \par
00043         {\cf20 // Implementation}\par
00044         {\cf18 void} initializeInternalValues ();\par
00045 \par
00046         {\cf20 // This methods are invoked from CIA chip...}\par
00048 {\cf20 }        {\cf18 void} lookAtTimers (CIATimer* tA, CIATimer* tB)\par
00049                             \{ _timerA = tA, _timerB = tB; \}\par
00051         {\cf18 void} lookAtClock (CIAClock* c)\par
00052                             \{ _clock = c; \}\par
00053 \par
00054         {\cf17 private}:\par
00055         {\cf20 // Reference to the timers...}\par
00056         CIATimer* _timerA;\par
00057         CIATimer* _timerB;\par
00058         {\cf20 // Reference to the clock...}\par
00059         CIAClock* _clock;\par
00060 \par
00062         {\cf18 unsigned} {\cf18 char} _VICBank;\par
00063 \par
00064         {\cf20 // Implementation}\par
00065         {\cf17 mutable} MCHEmul::UByte _lastValueRead;\par
00066     \};\par
00067 \}\par
00068 \par
00069 {\cf21 #endif}\par
00070   \par
00071 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/CIAClock.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIAClock.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIAClock.hpp}
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/global.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::CIAClock}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIAClock.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIAClock.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIAClock.hpp}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_CIACLOCK__}\par
00015 {\cf21 #define __C64_CIACLOCK__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <C64/global.hpp>}\par
00019 \par
00020 {\cf17 namespace }C64\par
00021 \{\par
00022     {\cf17 class }CIAClock\par
00023     \{\par
00024         {\cf17 public}:\par
00025         CIAClock ({\cf18 int} {\cf18 id} )\par
00026             : _id (id) \par
00027                             \{ initialize (); \}\par
00028 \par
00030         {\cf17 virtual} {\cf18 void} initialize ();\par
00031 \par
00032         {\cf18 int} id (){\cf17  const}\par
00033 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00034 \par
00037         {\cf18 bool} reachesAlarm (){\cf17  const}\par
00038 {\cf17                             }\{ {\cf19 return} (_reachesAlarm); \}\par
00039 \par
00040         {\cf18 bool} IRQEnabled (){\cf17  const}\par
00041 {\cf17                             }\{ {\cf19 return} (_IRQEnabled); \}\par
00042         {\cf18 void} setIRQEnabled ({\cf18 bool} e)\par
00043                             \{ _IRQEnabled = e; \}\par
00044         {\cf18 bool} IRQRequested (){\cf17  const}\par
00045 {\cf17                             }\{ {\cf18 bool} r = _IRQRequested; _IRQRequested = {\cf17 false}; {\cf19 return} (r); \}\par
00046 \par
00049         {\cf18 void} setAlarmHours ({\cf18 unsigned} {\cf18 char} h)\par
00050                             \{ _stopped = {\cf17 true}, _alarmHours = h; \}\par
00051         {\cf18 void} setAlarmMinutes ({\cf18 unsigned} {\cf18 char} m)\par
00052                             \{ _alarmMinutes = m; \}\par
00053         {\cf18 void} setAlarmSeconds ({\cf18 unsigned} {\cf18 char} s)\par
00054                             \{ _alarmSeconds = s; \}\par
00055         {\cf18 void} setAlarmTenthSeconds ({\cf18 unsigned} {\cf18 char} ts)\par
00056                             \{ _alarmTenthsSecond = ts; _stopped = {\cf17 true};\}\par
00057 \par
00058         {\cf18 void} setHours ({\cf18 unsigned} {\cf18 char} h)\par
00059                             \{ _stopped = {\cf17 true}, _hours = h; \}\par
00060         {\cf18 void} setMinutes ({\cf18 unsigned} {\cf18 char} m)\par
00061                             \{ _minutes = m; \}\par
00062         {\cf18 void} setSeconds ({\cf18 unsigned} {\cf18 char} s)\par
00063                             \{ _seconds = s; \}\par
00064         {\cf18 void} setTenthSeconds ({\cf18 unsigned} {\cf18 char} ts)\par
00065                             \{ _tenthsSecond = ts; _stopped = {\cf17 true};\}\par
00066 \par
00070         {\cf18 unsigned} {\cf18 char} hours (){\cf17  const}\par
00071 {\cf17                             }\{ _timeLatched = {\cf17 true}; {\cf19 return} (_hours); \}\par
00072         {\cf18 unsigned} {\cf18 char} minutes (){\cf17  const}\par
00073 {\cf17                             }\{ {\cf19 return} (_timeLatched ? _minutesL : _minutes); \}\par
00074         {\cf18 unsigned} {\cf18 char} seconds (){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_timeLatched ? _secondsL : _seconds); \}\par
00076         {\cf18 unsigned} {\cf18 char} tenthsSecond (){\cf17  const}\par
00077 {\cf17                             }\{ {\cf18 unsigned} {\cf18 char} r = _timeLatched ? _tenthsSecondL : _tenthsSecond; _timeLatched = {\cf17 false}; {\cf19 return} (r); \}\par
00078 \par
00083         {\cf18 void} simulate (MCHEmul::CPU* cpu);\par
00084 \par
00085         {\cf17 private}:\par
00086         {\cf20 // Managing the timer...}\par
00088 {\cf20 }        {\cf18 void} actualizeTime ();\par
00089 \par
00090         {\cf17 private}:\par
00091         {\cf18 int} _id;\par
00092 \par
00093         {\cf20 // The variables that define a timer...}\par
00094         {\cf18 bool} _IRQEnabled;\par
00095         {\cf18 unsigned} {\cf18 char} _alarmHours, _alarmMinutes, _alarmSeconds, _alarmTenthsSecond;\par
00096 \par
00097         {\cf20 // It is actualized continiously thorugh the method actualizeTime...}\par
00098         {\cf20 // The time counts only hours in the day...}\par
00099         Time _time;\par
00100 \par
00101         {\cf20 // Implementation}\par
00103 {\cf20 }        {\cf18 unsigned} {\cf18 int} _lastClockCycles;\par
00105         {\cf18 unsigned} {\cf18 char} _hours, _minutes, _seconds, _tenthsSecond;\par
00109         {\cf17 mutable} {\cf18 unsigned} {\cf18 char} _minutesL, _secondsL, _tenthsSecondL;\par
00110         {\cf17 mutable} {\cf18 bool} _timeLatched;\par
00112         {\cf17 mutable} {\cf18 bool} _stopped;\par
00114         {\cf18 bool} _reachesAlarm;\par
00116         {\cf17 mutable} {\cf18 bool} _IRQRequested;\par
00117     \};\par
00118 \}\par
00119 \par
00120 {\cf21 #endif}\par
00121   \par
00122 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/CIATimer.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIATimer.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIATimer.hpp}
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/global.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::CIATimer}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIATimer.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIATimer.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIATimer.hpp}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_CIATIMER__}\par
00015 {\cf21 #define __C64_CIATIMER__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <C64/global.hpp>}\par
00019 \par
00020 {\cf17 namespace }C64\par
00021 \{\par
00022     {\cf17 class }CIATimer\par
00023     \{\par
00024         {\cf17 public}:\par
00026         {\cf17 enum class} RunMode\par
00027         \{\par
00028             _RESTART = 0,           {\cf20 // The timer restarts once it reaches 0}\par
00029             _ONETIME                {\cf20 // The timer stops when it reaches 0 (becomes not enabled)}\par
00030         \};                        \par
00031 \par
00033         {\cf17 enum class} CountMode\par
00034         \{\par
00035             {\cf20 // The names are related directly with numbers to simplify later and quicker conversions...}\par
00036             _PROCESSORCYCLES = 0,       {\cf20 // Processor cycle }\par
00037             _SIGNALSONCNTLINE = 1,      {\cf20 // Signal present on the CNT line at pin 4 of User Port }\par
00038             _TIMERCOUNTSDOWNTO0 = 2,    {\cf20 // When other Timer reaches 0}\par
00039             _0ONCNTPULSES = 3           {\cf20 // When other Timer reaches 0 and _SIGNALSONCNTLINE in this timer is also on}\par
00040             {\cf20 // These two last types of timers helps to generate long time timers...}\par
00041         \};\par
00042 \par
00052         CIATimer ({\cf18 int} {\cf18 id} )\par
00053             : _id (id) \par
00054                             \{ initialize (); \}\par
00055 \par
00057         {\cf17 virtual} {\cf18 void} initialize ();\par
00058 \par
00059         {\cf18 int} id (){\cf17  const}\par
00060 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00061 \par
00062         {\cf20 // Managing the type...}\par
00063         RunMode runMode (){\cf17  const}\par
00064 {\cf17                             }\{ {\cf19 return} (_runMode); \}\par
00065         {\cf18 void} setRunMode (RunMode rm)\par
00066                             \{ _runMode = rm; \}\par
00067         CountMode countMode (){\cf17  const}\par
00068 {\cf17                             }\{ {\cf19 return} (_countMode); \}\par
00069         {\cf18 void} setCountMode (CountMode cm)\par
00070                             \{ _countMode = cm; \}\par
00071 \par
00074         {\cf18 bool} reaches0 (){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_reaches0); \}\par
00076 \par
00077         {\cf20 // Managing the status...}\par
00078         {\cf18 bool} enabled (){\cf17  const}\par
00079 {\cf17                             }\{ {\cf19 return} (_enabled); \}\par
00080         {\cf18 void} setEnabled ({\cf18 bool} e)\par
00081                             \{ _enabled = e; \}\par
00082 \par
00083         {\cf18 bool} IRQEnabled (){\cf17  const}\par
00084 {\cf17                             }\{ {\cf19 return} (_IRQEnabled); \}\par
00085         {\cf18 void} setIRQEnabled ({\cf18 bool} e)\par
00086                             \{ _IRQEnabled = e; \}\par
00087         {\cf18 bool} IRQRequested (){\cf17  const}\par
00088 {\cf17                             }\{ {\cf18 bool} r = _IRQRequested; _IRQRequested = {\cf17 false}; {\cf19 return} (r); \}\par
00089 \par
00090         {\cf20 // Managing the values...}\par
00092 {\cf20 }        {\cf18 unsigned} {\cf18 short} initialValue (){\cf17  const}\par
00093 {\cf17                             }\{ {\cf19 return} (_initialValue); \}\par
00094         {\cf18 void} setInitialValue ({\cf18 unsigned} {\cf18 char} iV)\par
00095                             \{ _initialValue = iV; _currentValue = _initialValue; \}\par
00097         {\cf18 unsigned} {\cf18 short} currentValue (){\cf17  const}\par
00098 {\cf17                             }\{ {\cf19 return} (_currentValue); \}\par
00100         {\cf18 void} reset ()\par
00101                             \{ _currentValue = _initialValue; \}\par
00102 \par
00105         {\cf18 void} simulate (MCHEmul::CPU* cpu, CIATimer* t = {\cf17 nullptr});\par
00106 \par
00107         {\cf17 private}:\par
00108         {\cf20 // Managing the timer...}\par
00118 {\cf20 }        {\cf18 bool} countDown (MCHEmul::CPU* cpu, CIATimer* t = {\cf17 nullptr});\par
00119 \par
00120         {\cf17 private}:\par
00121         {\cf18 int} _id;\par
00122 \par
00123         {\cf20 // The variables that define a timer...}\par
00124         RunMode _runMode;\par
00125         CountMode _countMode;\par
00126         {\cf18 bool} _enabled;\par
00127         {\cf18 bool} _IRQEnabled;\par
00128         {\cf18 unsigned} {\cf18 short} _initialValue;\par
00129 \par
00130         {\cf20 // It is actualized continiously through the method actualizeTime...}\par
00131         {\cf20 // The time counts only hours in the day...}\par
00132         Time _time;\par
00133 \par
00134         {\cf20 // Implementation}\par
00136 {\cf20 }        {\cf18 unsigned} {\cf18 short} _currentValue; \par
00138         {\cf18 unsigned} {\cf18 int} _lastClockCycles;\par
00140         {\cf18 bool} _reaches0;\par
00142         {\cf17 mutable} {\cf18 bool} _IRQRequested;\par
00143     \};\par
00144 \}\par
00145 \par
00146 {\cf21 #endif}\par
00147   \par
00148 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/ColorMemory.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/ColorMemory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/ColorMemory.hpp}
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::ColorRAMMemory}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ColorMemory.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/ColorMemory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/ColorMemory.hpp}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_COLORMEMORY__}\par
00015 {\cf21 #define __C64_COLORMEMORY__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00022     {\cf17 class }ColorRAMMemory final : {\cf17 public} MCHEmul::PhisicalStorageSubset\par
00023     \{\par
00024         {\cf17 public}:\par
00025         ColorRAMMemory ({\cf18 int} {\cf18 id}, MCHEmul::PhisicalStorage* ps)\par
00026             : MCHEmul::PhisicalStorageSubset (id, ps, 0xd800, MCHEmul::Address (\{ 0x00, 0xd8 \}, {\cf17 false}), 0x0400),\par
00027               _lastValue (MCHEmul::PhisicalStorage::_DEFAULTVALUE)\par
00028                             \{ \}\par
00029 \par
00030         {\cf17 private}:\par
00033         {\cf17 virtual} {\cf17 const} MCHEmul::UByte& readValue ({\cf18 size_t} p){\cf17  const override}\par
00034 {\cf17                             }\{ {\cf19 return} (_lastValue = MCHEmul::PhisicalStorageSubset::readValue (p) & 0x0f | \par
00035                                 ({\cf18 unsigned} {\cf18 char}) ((rand () % 0x10) << 4)); \}\par
00036 \par
00037         {\cf17 private}:\par
00038         {\cf20 // Implementation}\par
00039         {\cf17 mutable} MCHEmul::UByte _lastValue;\par
00040     \};\par
00041 \}\par
00042 \par
00043 {\cf21 #endif}\par
00044   \par
00045 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/global.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/global.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/global.hpp}
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <chrono>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b C64::Duration} = std::chrono::duration< unsigned long, std::deci >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b C64::Time} = std::chrono::time_point< std::chrono::steady_clock, Duration >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b C64::actualizeGlobalTime} ()\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
global.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/global.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/global.hpp}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_GLOBAL__}\par
00015 {\cf21 #define __C64_GLOBAL__}\par
00016 \par
00017 {\cf21 #include <chrono>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00022     {\cf17 using} Duration = std::chrono::duration <unsigned long, std::deci>;\par
00023     {\cf17 using} Time = std::chrono::time_point <std::chrono::steady_clock, Duration>;\par
00024 \par
00026     {\cf17 static} {\cf17 const} Time _STARTINGTIME = std::chrono::time_point_cast <Duration> (std::chrono::steady_clock::now ());\par
00028     {\cf17 static} Time _NOW = std::chrono::time_point_cast <Duration> (std::chrono::steady_clock::now ());\par
00030     {\cf17 static} Duration _TENTHSSECONDPAST = Duration ();\par
00031 \par
00033     {\cf18 void} actualizeGlobalTime ();\par
00034 \}\par
00035 \par
00036 {\cf21 #endif}\par
00037   \par
00038 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/global.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/global.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/global.hpp}
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <assert.h>}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
{\f2 #include <map>}\par
{\f2 #include <ostream>}\par
{\f2 #include <iostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Attributes} = std::map< std::string, std::string >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b MCHEmul::operator<<} (std::ostream &o, const Attributes &attrs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::ltrim} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::rtrim} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::trim} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::upper} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::lower} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::noSpaces} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::onlyAlphanumeric} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::noneOf} (const std::string &s, const std::string &chrs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::removeAllFrom} (const std::string &s, std::vector< std::string > &strs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b MCHEmul::getElementsFrom} (const std::string &txt, unsigned char ch, size_t nE=std::numeric_limits< size_t >::max())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MCHEmul::validLabel} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MCHEmul::validBytesOctal} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MCHEmul::validBytesHexadecimal} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MCHEmul::validBytesDecimal} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MCHEmul::validBytes} (const std::string &s)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
global.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/global.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/global.hpp}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_GLOBAL__}\par
00015 {\cf21 #define __MCHEMUL_GLOBAL__}\par
00016 \par
00017 {\cf21 #include <assert.h>}\par
00018 {\cf21 #include <string>}\par
00019 {\cf21 #include <vector>}\par
00020 {\cf21 #include <map>}\par
00021 {\cf21 #include <ostream>}\par
00022 {\cf21 #include <iostream>}\par
00023 \par
00024 {\cf17 namespace }MCHEmul\par
00025 \{\par
00027     {\cf17 using} Attributes = std::map <std::string, std::string>;\par
00029     {\cf17 static} {\cf17 const} std::string AttributedNotDefined = {\cf22 ""};\par
00031     std::ostream& operator << (std::ostream& o, {\cf17 const} Attributes& attrs);\par
00032 \par
00034     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _NOERROR                      = 0;\par
00035     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _INIT_ERROR                   = 1;\par
00036     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _CPU_ERROR                    = 2;\par
00037     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _CHIP_ERROR                   = 3;\par
00038     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _DEVICE_ERROR                 = 4;\par
00039     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _COMMSNOTOPENED_ERROR         = 5;\par
00040     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _COMMSCHANNELNOTOPENED_ERROR  = 6;\par
00041     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _COMMSINTNOTCREATED_ERROR     = 7;\par
00042     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _CHANNELREADERROR_ERROR       = 8;\par
00043     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _CHANNELWRITEERROR_ERROR      = 9;\par
00044 \par
00046     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _MAXBYTESMANAGED              = 2;\par
00047 \par
00049     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _DEBUGNOTHING                 = 0;\par
00050     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _DEBUGERRORS                  = 1;\par
00051     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _DEBUGERRORANDWARNINGS        = 2;\par
00052     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _DEBUGALL                     = 3;\par
00053     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _DEBUGTRACEINTERNALS          = 4;\par
00054 \par
00056     {\cf17 static} {\cf17 const} std::string _SPACES (20, {\cf23 ' '});\par
00057     {\cf17 static} {\cf17 const} std::string _CEROS (20, {\cf23 '0'});\par
00058     {\cf17 static} {\cf17 const} std::string _TABS (20, {\cf23 '\\t'});\par
00059 \par
00061     std::string ltrim ({\cf17 const} std::string& s);\par
00062     std::string rtrim ({\cf17 const} std::string& s);\par
00063     std::string trim ({\cf17 const} std::string& s);\par
00064     std::string upper ({\cf17 const} std::string& s);\par
00065     std::string lower ({\cf17 const} std::string& s);\par
00066     std::string noSpaces ({\cf17 const} std::string& s);\par
00067     std::string onlyAlphanumeric ({\cf17 const} std::string& s);\par
00068     std::string noneOf ({\cf17 const} std::string& s, {\cf17 const} std::string& chrs);\par
00069     std::string removeAllFrom ({\cf17 const} std::string& s, std::vector <std::string>& strs);\par
00070     std::vector <std::string> getElementsFrom ({\cf17 const} std::string& txt, {\cf18 unsigned} {\cf18 char} ch, \par
00071         {\cf18 size_t} nE = std::numeric_limits <size_t>::max ());\par
00072 \par
00075     {\cf18 bool} validLabel ({\cf17 const} std::string& s); \par
00076     {\cf18 bool} validBytesOctal ({\cf17 const} std::string& s); \par
00077     {\cf18 bool} validBytesHexadecimal ({\cf17 const} std::string& s); \par
00078     {\cf18 bool} validBytesDecimal ({\cf17 const} std::string& s); \par
00079     {\cf18 bool} validBytes ({\cf17 const} std::string& s); \par
00080 \}\par
00081 \par
00082 {\cf21 #endif}\par
00083   \par
00084 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/IOPBuilder.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/IOPBuilder.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/IOPBuilder.hpp}
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::IOPeripheralBuilder}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IOPBuilder.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/IOPBuilder.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/IOPBuilder.hpp}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_IOPBUILDER__}\par
00015 {\cf21 #define __C64_IOPBUILDER__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00022     {\cf17 class }IOPeripheralBuilder : {\cf17 public} MCHEmul::IOPeripheralBuilder\par
00023     \{\par
00024         {\cf17 public}:\par
00025         IOPeripheralBuilder ()\par
00026             : MCHEmul::IOPeripheralBuilder ()\par
00027                 \{ \}\par
00028 \par
00029         {\cf17 protected}:\par
00031         {\cf17 virtual} MCHEmul::IOPeripheral* createPeripheral ({\cf18 int} {\cf18 id}, {\cf17 const} MCHEmul::Attributes& prms) {\cf17 const override};\par
00032     \};\par
00033 \}\par
00034 \par
00035 {\cf21 #endif}\par
00036   \par
00037 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/IOPBuilder.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/IOPBuilder.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/IOPBuilder.hpp}
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/IOPeripheral.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::IOPeripheralBuilder}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IOPBuilder.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/IOPBuilder.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/IOPBuilder.hpp}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_IOPBUILDER__}\par
00015 {\cf21 #define __MCHEMUL_IOPBUILDER__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/IOPeripheral.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00025     {\cf17 class }IOPeripheralBuilder\par
00026     \{\par
00027         {\cf17 public}:\par
00028         IOPeripheralBuilder () = {\cf19 default};\par
00029 \par
00030         IOPeripheralBuilder ({\cf17 const} IOPeripheralBuilder&) = {\cf17 delete};\par
00031 \par
00032         IOPeripheralBuilder& operator = ({\cf17 const} IOPeripheralBuilder&) = {\cf17 delete};\par
00033 \par
00034         {\cf17 virtual} ~IOPeripheralBuilder () \par
00035                             \{ {\cf19 for} ({\cf17 auto} i : _peripherals) {\cf17 delete} (i.second); \}\par
00036 \par
00039         IOPeripheral* peripheral ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& attrs) {\cf17 const};\par
00040 \par
00041         {\cf17 protected}:\par
00043         {\cf17 virtual} IOPeripheral* createPeripheral ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& prms) {\cf17 const} = 0;\par
00044 \par
00045         {\cf17 protected}:\par
00046         {\cf17 mutable} IOPeripherals _peripherals;\par
00047     \};\par
00048 \}\par
00049 \par
00050 {\cf21 #endif}\par
00051   \par
00052 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/Memory.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/Memory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/Memory.hpp}
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::Memory}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Memory.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/Memory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/Memory.hpp}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_MEMORY__}\par
00015 {\cf21 #define __C64_MEMORY__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00022     {\cf17 class }Memory final : {\cf17 public} MCHEmul::Memory\par
00023     \{\par
00024         {\cf17 public}:\par
00025         {\cf20 // Phisical Storages}\par
00026         {\cf17 static} {\cf17 const} {\cf18 int} _RAM                   = 0;\par
00027         {\cf17 static} {\cf17 const} {\cf18 int} _BASICROM              = 1;\par
00028         {\cf17 static} {\cf17 const} {\cf18 int} _CHARROM               = 2;\par
00029         {\cf17 static} {\cf17 const} {\cf18 int} _KERNELROM             = 3;\par
00030 \par
00031         {\cf20 // Subsets}\par
00032         {\cf20 // Fom CPU}\par
00033         {\cf17 static} {\cf17 const} {\cf18 int} _PAGEZERO_SUBSET       = 100;\par
00034         {\cf17 static} {\cf17 const} {\cf18 int} _STACK_SUBSET          = 101;\par
00035         {\cf17 static} {\cf17 const} {\cf18 int} _RAM0_SUBSET           = 102;\par
00036         {\cf17 static} {\cf17 const} {\cf18 int} _BASICROM_SUBSET       = 103;\par
00037         {\cf17 static} {\cf17 const} {\cf18 int} _BASICRAM_SUBSET       = 104;\par
00038         {\cf17 static} {\cf17 const} {\cf18 int} _RAM1_SUBSET           = 105;\par
00039         {\cf17 static} {\cf17 const} {\cf18 int} _CHARROM_SUBSET        = 106;\par
00040         {\cf17 static} {\cf17 const} {\cf18 int} _VICREGS_SUBSET        = 107;\par
00041         {\cf17 static} {\cf17 const} {\cf18 int} _SIDREGS_SUBSET        = 108;\par
00042         {\cf17 static} {\cf17 const} {\cf18 int} _COLOR_SUBSET          = 109;\par
00043         {\cf17 static} {\cf17 const} {\cf18 int} _CIA1_SUBSET           = 110;\par
00044         {\cf17 static} {\cf17 const} {\cf18 int} _CIA2_SUBSET           = 111;\par
00045         {\cf17 static} {\cf17 const} {\cf18 int} _IO1_SUBSET            = 112;\par
00046         {\cf17 static} {\cf17 const} {\cf18 int} _IO2_SUBSET            = 113;\par
00047         {\cf17 static} {\cf17 const} {\cf18 int} _KERNELROM_SUBSET      = 114;\par
00048         {\cf17 static} {\cf17 const} {\cf18 int} _KERNELRAM_SUBSET      = 115;\par
00049         {\cf20 // From VICII}\par
00050         {\cf17 static} {\cf17 const} {\cf18 int} _BANK0RAM0_SUBSET      = 200;\par
00051         {\cf17 static} {\cf17 const} {\cf18 int} _BANK0CHARROM_SUBSET   = 201;\par
00052         {\cf17 static} {\cf17 const} {\cf18 int} _BANK0RAM1_SUBSET      = 202;\par
00053         {\cf17 static} {\cf17 const} {\cf18 int} _BANK1RAM_SUBSET       = 203;\par
00054         {\cf17 static} {\cf17 const} {\cf18 int} _BANK2RAM0_SUBSET      = 204;\par
00055         {\cf17 static} {\cf17 const} {\cf18 int} _BANK2CHARROM_SUBSET   = 205;\par
00056         {\cf17 static} {\cf17 const} {\cf18 int} _BANK2RAM1_SUBSET      = 206;\par
00057         {\cf17 static} {\cf17 const} {\cf18 int} _BANK3RAM_SUBSET       = 207;\par
00058 \par
00059         {\cf20 // Views}\par
00060         {\cf17 static} {\cf17 const} {\cf18 int} _CPU_VIEW              = 0;\par
00061         {\cf17 static} {\cf17 const} {\cf18 int} _VICII_VIEW            = 1;\par
00062 \par
00063         Memory ();\par
00064 \par
00066         {\cf18 void} setVICIIView ()\par
00067                             \{ _activeView = (_VICIIView == {\cf17 nullptr}) ? (_VICIIView = lookForVICIIView ()) : _VICIIView; \}\par
00068 \par
00070         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00071 \par
00072         {\cf17 private}:\par
00073         {\cf17 virtual} MCHEmul::Stack* lookForStack (){\cf17  override}\par
00074 {\cf17                             }\{ {\cf19 return} ({\cf17 dynamic_cast <}MCHEmul::Stack*{\cf17 >} (subset (_STACK_SUBSET))); \}\par
00075         {\cf17 virtual} MCHEmul::MemoryView* lookForCPUView (){\cf17  override}\par
00076 {\cf17                             }\{ {\cf19 return} (view (_CPU_VIEW)); \}\par
00077         MCHEmul::MemoryView* lookForVICIIView ()\par
00078                             \{ {\cf19 return} (view (_VICII_VIEW)); \}\par
00079 \par
00080         {\cf17 static} MCHEmul::Memory::Content standardMemoryContent ();\par
00081 \par
00082         {\cf17 private}:\par
00083         MCHEmul::MemoryView* _VICIIView;\par
00084     \};\par
00085 \}\par
00086 \par
00087 {\cf21 #endif}\par
00088   \par
00089 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Memory.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Memory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Memory.hpp}
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/Address.hpp>}\par
{\f2 #include <CORE/UByte.hpp>}\par
{\f2 #include <CORE/UBytes.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::PhisicalStorage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::PhisicalStorageSubset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::MemoryView}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Memory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Memory::Content}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::PhisicalStorages} = std::map< int, PhisicalStorage * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::PhisicalStorageSubsets} = std::map< int, PhisicalStorageSubset * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::PhisicalStorageSubsetsList} = std::vector< PhisicalStorageSubset * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::MemoryViews} = std::map< int, MemoryView * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Memory.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Memory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Memory.hpp}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00016 {\cf21 #ifndef __MCHEMUL_MEMORY__}\par
00017 {\cf21 #define __MCHEMUL_MEMORY__}\par
00018 \par
00019 {\cf21 #include <CORE/global.hpp>}\par
00020 {\cf21 #include <CORE/Address.hpp>}\par
00021 {\cf21 #include <CORE/UByte.hpp>}\par
00022 {\cf21 #include <CORE/UBytes.hpp>}\par
00023 \par
00024 {\cf17 namespace }MCHEmul\par
00025 \{\par
00026     {\cf17 class }PhisicalStorageSubset;\par
00027     {\cf17 class }MemoryView;\par
00028     {\cf17 class }Stack;\par
00029 \par
00034     {\cf17 class }PhisicalStorage final\par
00035     \{\par
00036         {\cf17 public}:\par
00038         {\cf17 static} UByte _DEFAULTVALUE;\par
00039 \par
00040         {\cf17 friend} PhisicalStorageSubset;\par
00041 \par
00042         {\cf17 enum class} Type \{ _ROM, _RAM \};\par
00043 \par
00044         PhisicalStorage () = {\cf17 delete};\par
00045 \par
00046         PhisicalStorage ({\cf18 int} {\cf18 id}, Type t, {\cf18 size_t} s)\par
00047             : _id (id), _type (t), \par
00048               _data (s, UByte::_0)\par
00049                             \{ \}\par
00050 \par
00051         PhisicalStorage ({\cf17 const} PhisicalStorage&) = {\cf19 default};\par
00052 \par
00053         PhisicalStorage& operator = ({\cf17 const} PhisicalStorage&) = {\cf19 default};\par
00054 \par
00055         {\cf18 int} id (){\cf17  const}\par
00056 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00057         Type type (){\cf17  const}\par
00058 {\cf17                             }\{ {\cf19 return} (_type); \}\par
00059         {\cf18 size_t} size (){\cf17  const}\par
00060 {\cf17                             }\{ {\cf19 return} (_data.size ()); \}\par
00061         \par
00062         {\cf18 bool} canBeWriten ({\cf18 bool} f = {\cf17 false} ){\cf17  const}\par
00063 {\cf17                             }\{ {\cf19 return} (_type == Type::_RAM || (_type == Type::_ROM && f)); \}\par
00064 \par
00065         {\cf17 protected}:\par
00066         {\cf20 // This methods can only be invoked from PhisicalMemorySubset class}\par
00067         {\cf20 // IMPORTANT NOTE: }\par
00068         {\cf20 // They go direclty to the memory and can be dangerous for the stability of the system!}\par
00069 \par
00073         {\cf18 void} set ({\cf18 size_t} pB, {\cf17 const} UByte& d)\par
00074                             \{ _data [pB] = d; \}\par
00075         {\cf17 const} UByte& value ({\cf18 size_t} pB){\cf17  const}\par
00076 {\cf17                             }\{ {\cf19 return} (_data [pB]); \}\par
00077         UBytes values ({\cf18 size_t} pB, {\cf18 size_t} nB){\cf17  const}\par
00078 {\cf17                             }\{ {\cf19 return} (UBytes (bytes (pB, nB))); \}\par
00079         {\cf18 void} set ({\cf18 size_t} pB, {\cf17 const} UBytes& v)\par
00080                             \{ set (pB, v.bytes ()); \}\par
00081         std::vector <UByte> bytes ({\cf18 size_t} pB, {\cf18 size_t} nB) {\cf17 const};\par
00082         {\cf18 void} set ({\cf18 size_t} pB, {\cf17 const} std::vector <UByte>& v)\par
00083                             \{ {\cf19 for} ({\cf18 size_t} i = 0; i < v.size (); i++) set (pB + i, v [i]); \}\par
00084 \par
00087         {\cf18 bool} loadInto ({\cf17 const} std::string& fN, {\cf18 size_t} p = 0);\par
00088 \par
00089         {\cf17 protected}:\par
00090         {\cf17 const} {\cf18 int} _id = -1; {\cf20 // Modified at construction level}\par
00091         {\cf17 const} Type _type = Type::_RAM; {\cf20 // Modified also at construction level}\par
00092         std::vector <MCHEmul::UByte> _data;\par
00093     \};\par
00094 \par
00096     {\cf17 using} PhisicalStorages = std::map <int, PhisicalStorage*>;\par
00097 \par
00100     {\cf17 class }PhisicalStorageSubset\par
00101     \{\par
00102         {\cf17 public}:\par
00103         {\cf17 friend} MemoryView;\par
00104 \par
00105         PhisicalStorageSubset () = {\cf17 delete};\par
00106 \par
00112         PhisicalStorageSubset ({\cf18 int} {\cf18 id}, PhisicalStorage* pS, {\cf18 size_t} pp , {\cf17 const} Address& a, {\cf18 size_t} s);\par
00113 \par
00114         PhisicalStorageSubset ({\cf17 const} PhisicalStorageSubset&) = {\cf19 default};\par
00115 \par
00116         {\cf17 virtual} ~PhisicalStorageSubset () \par
00117                             \{  \}\par
00118 \par
00119         PhisicalStorageSubset& operator = ({\cf17 const} PhisicalStorageSubset&) = {\cf19 default};\par
00120 \par
00122         {\cf18 int} id (){\cf17  const}\par
00123 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00124         {\cf17 const} PhisicalStorage* phisicalStorage (){\cf17  const}\par
00125 {\cf17                             }\{ {\cf19 return} (_phisicalStorage); \}\par
00126         PhisicalStorage* phisicalStorage ()\par
00127                             \{ {\cf19 return} (_phisicalStorage); \}\par
00128         PhisicalStorage::Type type (){\cf17  const}\par
00129 {\cf17                             }\{ {\cf19 return} (_phisicalStorage -> type ()); \}\par
00130         {\cf17 const} Address& initialAddress (){\cf17  const}\par
00131 {\cf17                             }\{ {\cf19 return} (_initialAddress); \}\par
00132         {\cf18 size_t} size (){\cf17  const}\par
00133 {\cf17                             }\{ {\cf19 return} (_size); \}\par
00134         \par
00135         {\cf18 bool} active (){\cf17  const}\par
00136 {\cf17                             }\{ {\cf19 return} (_active); \}\par
00137         {\cf18 void} setActive ({\cf18 bool} a)\par
00138                             \{ _active = a; \}\par
00139         {\cf18 bool} activeForReading (){\cf17  const}\par
00140 {\cf17                             }\{ {\cf19 return} (_activeForReading); \}\par
00141         {\cf18 void} setActiveForReading ({\cf18 bool} aR)\par
00142                             \{ _activeForReading = aR; \}\par
00143 \par
00144         {\cf18 bool} canBeWriten ({\cf18 bool} f){\cf17  const}\par
00145 {\cf17                             }\{ {\cf19 return} (_active && _phisicalStorage -> canBeWriten (f)); \}\par
00146 \par
00148         {\cf18 bool} isIn ({\cf17 const} Address& a, {\cf18 int}& dt){\cf17  const}\par
00149 {\cf17                             }\{ {\cf19 return} (_active && (a >= _initialAddress && (dt = _initialAddress.distanceWith (a)) < ({\cf18 int}) _size)); \}\par
00150 \par
00153         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} UByte& d, {\cf18 bool} f = {\cf17 false})\par
00154                             \{ {\cf18 int} dt = 0; {\cf19 if} (_phisicalStorage -> canBeWriten (f) && isIn (a, dt)) setValue (dt, d); \}\par
00157         {\cf17 const} UByte& value ({\cf17 const} Address& a){\cf17  const}\par
00158 {\cf17                             }\{ {\cf18 int} dt = 0; {\cf19 return} (_activeForReading && (isIn (a, dt)) \par
00159                                 ? readValue (dt) : PhisicalStorage::_DEFAULTVALUE); \}\par
00160         UBytes values ({\cf17 const} Address& a, {\cf18 size_t} nB){\cf17  const}\par
00161 {\cf17                             }\{ {\cf19 return} (UBytes (bytes (a, nB))); \}\par
00162         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} UBytes& v, {\cf18 bool} f = {\cf17 false})\par
00163                             \{ set (a, v.bytes (), f); \}\par
00165         std::vector <UByte> bytes ({\cf17 const} Address& a, {\cf18 size_t} nB) {\cf17 const};\par
00166         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} std::vector <UByte>& v, {\cf18 bool} f = {\cf17 false});\par
00167 \par
00170         {\cf17 virtual} {\cf18 void} initialize ()\par
00171                             \{ {\cf19 for} ({\cf18 size_t} i = 0; i < _size; i++) setValue (i, _defaultData [i]); \}\par
00172 \par
00175         {\cf18 bool} load ({\cf17 const} std::string& fN, {\cf18 size_t} sA, {\cf18 bool} bE = {\cf17 true});\par
00177         {\cf18 bool} loadInto ({\cf17 const} std::string& fN, {\cf17 const} Address& a)\par
00178                             \{ {\cf19 return} ((a >= _initialAddress) \par
00179                                 ? _phisicalStorage -> loadInto (fN, _initialAddress.distanceWith (a)) : {\cf17 false}); \}\par
00181         {\cf18 bool} loadInto ({\cf17 const} std::string& fN)\par
00182                             \{ {\cf19 return} (loadInto (fN, initialAddress ())); \}\par
00183 \par
00185         {\cf18 void} fixDefaultValues ()\par
00186                             \{ _defaultData = _phisicalStorage -> values (_initialPhisicalPosition, _size).bytes (); \}\par
00187 \par
00188         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} PhisicalStorageSubset& ps);\par
00189 \par
00190         {\cf17 protected}:\par
00195         {\cf17 virtual} {\cf18 void} setValue ({\cf18 size_t} nB, {\cf17 const} UByte& d)\par
00196                             \{ _phisicalStorage -> set (nB + _initialPhisicalPosition, d); \}\par
00197         {\cf17 virtual} {\cf17 const} UByte& readValue ({\cf18 size_t} nB){\cf17  const}\par
00198 {\cf17                             }\{ {\cf19 return} (_phisicalStorage -> value (nB + _initialPhisicalPosition)); \}\par
00199 \par
00200         {\cf17 protected}:\par
00201         {\cf17 const} {\cf18 int} _id = -1; \par
00202         PhisicalStorage* _phisicalStorage;\par
00204         {\cf18 size_t} _initialPhisicalPosition;\par
00206         Address _initialAddress;\par
00208         {\cf18 size_t} _size;\par
00209 \par
00210         {\cf20 // Implementation}\par
00211         {\cf18 bool} _active;\par
00212         {\cf18 bool} _activeForReading;\par
00213         std::vector <MCHEmul::UByte> _defaultData;\par
00214     \};\par
00215 \par
00217     {\cf17 using} PhisicalStorageSubsets = std::map <int, PhisicalStorageSubset*>;\par
00218     {\cf17 using} PhisicalStorageSubsetsList = std::vector <PhisicalStorageSubset*>;\par
00219 \par
00222     {\cf17 class }MemoryView\par
00223     \{\par
00224         {\cf17 public}:\par
00225         MemoryView () = {\cf17 delete};\par
00226 \par
00228         MemoryView ({\cf18 int} {\cf18 id}, PhisicalStorageSubsets ss)\par
00229             : _id (id), _subsets (ss)\par
00230                             \{ \}\par
00231 \par
00232         MemoryView ({\cf17 const} MemoryView&) = {\cf19 default};\par
00233 \par
00234         {\cf17 virtual} ~MemoryView ()\par
00235                             \{ \}\par
00236 \par
00237         MemoryView& operator = ({\cf17 const} MemoryView&) = {\cf19 default};\par
00238 \par
00239         {\cf18 int} id (){\cf17  const}\par
00240 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00241 \par
00242         {\cf20 // To manage the subsets...}\par
00243         {\cf17 const} PhisicalStorageSubsets& subsets (){\cf17  const}\par
00244 {\cf17                             }\{ {\cf19 return} (_subsets); \}\par
00245         {\cf18 bool} existsSubset ({\cf18 int} {\cf18 id}){\cf17  const}\par
00246 {\cf17                             }\{ {\cf19 return} (_subsets.find ({\cf18 id}) != _subsets.end ()); \}\par
00247         {\cf17 const} PhisicalStorageSubset* subset ({\cf18 int} {\cf18 id}){\cf17  const}\par
00248 {\cf17                             }\{ {\cf19 return} (({\cf17 const} PhisicalStorageSubset*) (((MemoryView*) ({\cf17 this})) -> subset ({\cf18 id}))); \}\par
00249         PhisicalStorageSubset* subset ({\cf18 int} {\cf18 id})\par
00250                             \{ PhisicalStorageSubsets::const_iterator i = _subsets.find ({\cf18 id}); \par
00251                                 {\cf19 return} ((i != _subsets.end ()) ? (*i).second : {\cf17 nullptr}); \}\par
00252         \par
00253         {\cf18 bool} isIn ({\cf17 const} Address& a, {\cf18 int} & dt) {\cf17 const};\par
00254 \par
00257         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} UByte& d, {\cf18 bool} f = {\cf17 false});\par
00260         {\cf17 const} UByte& value ({\cf17 const} Address& a) {\cf17 const};\par
00261         UBytes values ({\cf17 const} Address& a, {\cf18 size_t} nB){\cf17  const}\par
00262 {\cf17                             }\{ {\cf19 return} (UBytes (bytes (a, nB))); \}\par
00263         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} UBytes& v, {\cf18 bool} f = {\cf17 false})\par
00264                             \{ set (a, v.bytes (), f); \}\par
00265         std::vector <UByte> bytes ({\cf17 const} Address& a, {\cf18 size_t} nB) {\cf17 const};\par
00266         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} std::vector <UByte>& v, {\cf18 bool} f = {\cf17 false});\par
00267 \par
00270         {\cf17 virtual} {\cf18 void} initialize () \par
00271                             \{ {\cf19 for} ({\cf17 auto} i : _subsets) i.second -> initialize (); \}\par
00272 \par
00274         {\cf18 bool} loadInto ({\cf17 const} std::string& fN, {\cf17 const} Address& a);\par
00275 \par
00276         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} MemoryView& mv);\par
00277 \par
00278         {\cf17 protected}:\par
00279         {\cf18 int} _id;\par
00280         PhisicalStorageSubsets _subsets;\par
00281     \};\par
00282 \par
00284     {\cf17 using} MemoryViews = std::map <int, MemoryView*>;\par
00285 \par
00293     {\cf17 class }Memory\par
00294     \{\par
00295         {\cf17 public}:\par
00297         {\cf17 class }Content final\par
00298         \{\par
00299             {\cf17 public}:\par
00300             Content ()\par
00301                 : _phisicalStorages (), _subsets (), _views (),\par
00302                   _error (true)\par
00303                             \{ \}\par
00304 \par
00305             Content ({\cf17 const} Content&) = {\cf19 default};\par
00306 \par
00307             ~Content () = {\cf19 default};\par
00308 \par
00309             Content& operator = ({\cf17 const} Content&) = {\cf19 default};\par
00310 \par
00312             {\cf18 bool} verifyCoherence () {\cf17 const};\par
00313 \par
00314             {\cf17 const} PhisicalStorages& phisicalStorages (){\cf17  const}\par
00315 {\cf17                             }\{ {\cf19 return} (_phisicalStorages); \}\par
00316             {\cf18 bool} existsPhisicalStorage ({\cf18 int} {\cf18 id}){\cf17  const}\par
00317 {\cf17                             }\{ {\cf19 return} (_phisicalStorages.find ({\cf18 id}) != _phisicalStorages.end ()); \}\par
00318             {\cf17 const} PhisicalStorage* phisicalStorage ({\cf18 int} {\cf18 id}){\cf17  const}\par
00319 {\cf17                             }\{ {\cf19 return} (({\cf17 const} PhisicalStorage*) (((Content*) ({\cf17 this})) -> phisicalStorage ({\cf18 id}))); \}\par
00320             PhisicalStorage* phisicalStorage ({\cf18 int} {\cf18 id})\par
00321                             \{ PhisicalStorages::const_iterator i = _phisicalStorages.find ({\cf18 id}); \par
00322                                 {\cf19 return} ((i != _phisicalStorages.end ()) ? (*i).second : {\cf17 nullptr}); \}\par
00323 \par
00324             {\cf17 const} PhisicalStorageSubsets& Subsets ( ){\cf17  const}\par
00325 {\cf17                             }\{ {\cf19 return} (_subsets); \}\par
00326             {\cf18 bool} existsSubset ({\cf18 int} {\cf18 id}){\cf17  const}\par
00327 {\cf17                             }\{ {\cf19 return} (_subsets.find ({\cf18 id}) != _subsets.end ()); \}\par
00328             {\cf17 const} PhisicalStorageSubset* subset ({\cf18 int} {\cf18 id}){\cf17  const}\par
00329 {\cf17                             }\{ {\cf19 return} (({\cf17 const} PhisicalStorageSubset*) (((Content*) ({\cf17 this})) -> subset ({\cf18 id}))); \}\par
00330             PhisicalStorageSubset* subset ({\cf18 int} {\cf18 id})\par
00331                             \{ PhisicalStorageSubsets::const_iterator i = _subsets.find ({\cf18 id}); \par
00332                                 {\cf19 return} ((i != _subsets.end ()) ? (*i).second : {\cf17 nullptr}); \}\par
00333 \par
00334             {\cf17 const} MemoryViews& views (){\cf17  const}\par
00335 {\cf17                             }\{ {\cf19 return} (_views); \}\par
00336             {\cf18 bool} existsView ({\cf18 int} {\cf18 id}){\cf17  const}\par
00337 {\cf17                             }\{ {\cf19 return} (_views.find ({\cf18 id}) != _views.end ()); \}\par
00338             {\cf17 const} MemoryView* view ({\cf18 int} {\cf18 id}){\cf17  const}\par
00339 {\cf17                             }\{ {\cf19 return} (({\cf17 const} MemoryView*) (((Content*) ({\cf17 this})) -> view ({\cf18 id}))); \}\par
00340             MemoryView* view ({\cf18 int} {\cf18 id})\par
00341                             \{ MemoryViews::const_iterator i = _views.find ({\cf18 id}); \par
00342                                 {\cf19 return} ((i != _views.end ()) ? (*i).second : {\cf17 nullptr}); \}\par
00343             MemoryView* firstView (){\cf17  const}\par
00344 {\cf17                             }\{ {\cf19 return} ((*_views.begin ()).second); \}\par
00345 \par
00346             {\cf18 bool} initialize ();\par
00347 \par
00348             {\cf18 bool} error (){\cf17  const}\par
00349 {\cf17                             }\{ {\cf19 return} (_error); \}\par
00350 \par
00352             PhisicalStorages _phisicalStorages;\par
00353             PhisicalStorageSubsets _subsets;\par
00354             MemoryViews _views;\par
00355 \par
00356             {\cf17 private}:\par
00357             {\cf20 // Implementation}\par
00358             {\cf17 mutable} {\cf18 bool} _error;\par
00359         \};\par
00360 \par
00361         Memory () = {\cf17 delete};\par
00362 \par
00363         Memory ({\cf17 const} Content& cnt);\par
00364 \par
00365         Memory ({\cf17 const} Memory&) = {\cf19 default};\par
00366 \par
00367         Memory& operator = ({\cf17 const} Memory&) = {\cf19 default};\par
00368 \par
00369         ~Memory ();\par
00370 \par
00371         {\cf17 const} PhisicalStorages& phisicalStorages (){\cf17  const}\par
00372 {\cf17                             }\{ {\cf19 return} (_content.phisicalStorages ()); \}\par
00373         {\cf18 bool} existsPhisicalStorage ({\cf18 int} {\cf18 id}){\cf17  const}\par
00374 {\cf17                             }\{ {\cf19 return} (_content.existsPhisicalStorage ({\cf18 id})); \} \par
00375         {\cf17 const} PhisicalStorage* phisicalStorage ({\cf18 int} {\cf18 id}){\cf17  const}\par
00376 {\cf17                             }\{ {\cf19 return} (_content.phisicalStorage ({\cf18 id})); \}\par
00377         PhisicalStorage* phisicalStorage ({\cf18 int} {\cf18 id})\par
00378                             \{ {\cf19 return} (_content.phisicalStorage ({\cf18 id})); \}\par
00379 \par
00380         {\cf17 const} PhisicalStorageSubsets& Subsets (){\cf17  const}\par
00381 {\cf17                             }\{ {\cf19 return} (_content.Subsets ()); \}\par
00382         {\cf18 bool} existsSubset ({\cf18 int} {\cf18 id}){\cf17  const}\par
00383 {\cf17                             }\{ {\cf19 return} (_content.existsSubset ({\cf18 id})); \}\par
00384         {\cf17 const} PhisicalStorageSubset* subset ({\cf18 int} {\cf18 id}){\cf17  const}\par
00385 {\cf17                             }\{ {\cf19 return} (_content.subset ({\cf18 id})); \}\par
00386         PhisicalStorageSubset* subset ({\cf18 int} {\cf18 id})\par
00387                             \{ {\cf19 return} (_content.subset ({\cf18 id})); \}\par
00388 \par
00389         {\cf17 const} MemoryViews& views (){\cf17  const}\par
00390 {\cf17                             }\{ {\cf19 return} (_content.views ()); \}\par
00391         {\cf18 bool} existsView ({\cf18 int} {\cf18 id}){\cf17  const}\par
00392 {\cf17                             }\{ {\cf19 return} (_content.existsView ({\cf18 id})); \}\par
00393         {\cf17 const} MemoryView* view ({\cf18 int} {\cf18 id}){\cf17  const}\par
00394 {\cf17                             }\{ {\cf19 return} (_content.view ({\cf18 id}));  \}\par
00395         MemoryView* view ({\cf18 int} {\cf18 id})\par
00396                             \{ {\cf19 return} (_content.view ({\cf18 id}));  \}\par
00397 \par
00398         {\cf20 // Managing the active view of the memory...}\par
00399         {\cf17 const} MemoryView* activeView (){\cf17  const}\par
00400 {\cf17                             }\{ {\cf19 return} (_activeView); \}\par
00401         MemoryView* activeView ()\par
00402                             \{ {\cf19 return} (_activeView); \}\par
00403         {\cf18 void} setActiveView ({\cf18 int} {\cf18 id})\par
00404                             \{ {\cf19 if} (existsView ({\cf18 id})) _activeView = view ({\cf18 id}); \}\par
00405 \par
00406         {\cf18 bool} isIn ({\cf17 const} Address& a, {\cf18 int} & dt){\cf17  const}\par
00407 {\cf17                             }\{ {\cf19 return} (_activeView -> isIn (a, dt)); \}\par
00408 \par
00411         {\cf17 const} Stack* stack (){\cf17  const}\par
00412 {\cf17                             }\{ {\cf19 return} (({\cf17 const} Stack*) (((Memory*) ({\cf17 this})) -> stack ())); \}\par
00413         Stack* stack () \par
00414                             \{ {\cf19 return} ((_stack == {\cf17 nullptr}) ? (_stack = lookForStack ()) : _stack); \}\par
00415 \par
00418         {\cf18 void} setCPUView ()\par
00419                             \{ _activeView = (_cpuView == {\cf17 nullptr}) ? (_cpuView = lookForCPUView ()) : _cpuView; \}\par
00420 \par
00421         {\cf17 const} UByte& value ({\cf17 const} Address& a){\cf17  const}\par
00422 {\cf17                             }\{ {\cf19 return} (_activeView -> value (a)); \}\par
00423         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} UByte& v, {\cf18 bool} f = {\cf17 false} )\par
00424                             \{ _activeView -> set (a, v, f); \}\par
00425         UBytes values ({\cf17 const} Address& a, {\cf18 size_t} nB){\cf17  const}\par
00426 {\cf17                             }\{ {\cf19 return} (_activeView -> values (a, nB)); \}\par
00427         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} UBytes& v, {\cf18 bool} f = {\cf17 false})\par
00428                             \{ _activeView -> set (a, v, f); \}\par
00429         std::vector <UByte> bytes ({\cf17 const} Address& a, {\cf18 size_t} nB){\cf17  const}\par
00430 {\cf17                             }\{ {\cf19 return} (_activeView -> bytes (a, nB)); \}\par
00431         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} std::vector <UByte>& v, {\cf18 bool} f = {\cf17 false})\par
00432                             \{ _activeView -> set (a, v, f); \}\par
00433 \par
00436         {\cf17 virtual} {\cf18 bool} initialize ()\par
00437                             \{ {\cf19 return} ((_lastError == MCHEmul::_NOERROR) ? _content.initialize () : {\cf17 false}); \}\par
00438 \par
00439         {\cf18 bool} loadInto ({\cf17 const} std::string& fN, {\cf17 const} Address& a)\par
00440                             \{ {\cf19 return} (_activeView -> loadInto (fN, a)); \}\par
00441 \par
00443         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00444 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00445         {\cf18 void} resetErrors ()\par
00446                             \{ _lastError = _NOERROR; \}\par
00447 \par
00448         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Memory& m);\par
00449 \par
00450         {\cf17 protected}:\par
00451         {\cf17 virtual} Stack* lookForStack () = 0;\par
00452         {\cf17 virtual} MemoryView* lookForCPUView () = 0;\par
00453 \par
00454         {\cf17 protected}:\par
00455         Content _content;\par
00456 \par
00457         {\cf20 // Implementation}\par
00458         MemoryView* _activeView;\par
00459         {\cf17 mutable} Stack* _stack;\par
00460         {\cf17 mutable} MemoryView* _cpuView;\par
00461         {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastError;\par
00462     \};\par
00463 \}\par
00464 \par
00465 {\cf21 #endif}\par
00466   \par
00467 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/OSIO.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/OSIO.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/OSIO.hpp}
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::InputOSSystem}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OSIO.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/OSIO.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/OSIO.hpp}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_OSIO__}\par
00015 {\cf21 #define __C64_OSIO__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00021     {\cf17 class }CIA1;\par
00022 \par
00026     {\cf17 class }InputOSSystem final : {\cf17 public} MCHEmul::InputOSSystem\par
00027     \{\par
00028         {\cf17 public}:\par
00029         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _ID = 2;\par
00030 \par
00031         InputOSSystem ({\cf17 const} MCHEmul::Attributes& attrs = \{ \})\par
00032             : MCHEmul::InputOSSystem (_ID, attrs),\par
00033               _cia1 ({\cf17 nullptr})\par
00034                             \{ \}\par
00035 \par
00036         {\cf17 virtual} {\cf18 void} linkToChips ({\cf17 const} MCHEmul::Chips& c) {\cf17 override};\par
00037 \par
00038         {\cf17 private}:\par
00039         {\cf17 virtual} {\cf18 void} whenKeyPressed (SDL_Scancode k) {\cf17 override};\par
00040         {\cf17 virtual} {\cf18 void} whenKeyReleased (SDL_Scancode k) {\cf17 override};\par
00041         {\cf17 virtual} {\cf18 void} whenJoystickMoved ({\cf17 const} MCHEmul::InputOSSystem::SDL_JoyAxisEvents& js) {\cf17 override};\par
00042         {\cf17 virtual} {\cf18 void} whenJoystickButtonPressed (SDL_JoyButtonEvent jb) {\cf17 override};\par
00043         {\cf17 virtual} {\cf18 void} whenJoystickButtonReleased (SDL_JoyButtonEvent jb) {\cf17 override};\par
00044 \par
00045         {\cf17 private}:\par
00046         CIA1* _cia1;\par
00047 \par
00063         {\cf17 using} KeyMPos = std::pair <{\cf18 unsigned} {\cf18 short} , {\cf18 unsigned} {\cf18 short} >;\par
00064         {\cf17 static} {\cf17 const} std::map <SDL_Scancode, KeyMPos> _C64KEYS;\par
00065     \};\par
00066 \}\par
00067 \par
00068 {\cf21 #endif}\par
00069   \par
00070 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/OSIO.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/OSIO.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/OSIO.hpp}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/IO.hpp>}\par
{\f2 #include <SDL_events.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::InputOSSystem}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OSIO.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/OSIO.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/OSIO.hpp}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_OSIO__}\par
00015 {\cf21 #define __MCHEMUL_OSIO__}\par
00016 \par
00017 {\cf21 #include <CORE/IO.hpp>}\par
00018 {\cf21 #include <SDL_events.h>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00023     {\cf17 class }InputOSSystem : {\cf17 public} IODevice\par
00024     \{\par
00025         {\cf17 public}:\par
00026         InputOSSystem ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& attrs = \{ \})\par
00027             : IODevice (Type::_OUTPUT, {\cf18 id}, attrs),\par
00028               _quitRequested ({\cf17 false})\par
00029                             \{ \}\par
00030 \par
00031         {\cf18 bool} quitRequested (){\cf17  const}\par
00032 {\cf17                             }\{ {\cf19 return} (_quitRequested); \}\par
00033 \par
00034         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00035 \par
00037         {\cf17 virtual} {\cf18 bool} simulate () {\cf17 override};\par
00038 \par
00039         {\cf17 protected}:\par
00040         {\cf20 // To manage events related with the keyboard...}\par
00042 {\cf20 }        {\cf17 virtual} {\cf18 void} whenKeyPressed (SDL_Scancode) = 0;\par
00044         {\cf17 virtual} {\cf18 void} whenKeyReleased (SDL_Scancode) = 0;\par
00045 \par
00046         {\cf20 // To manage events related with the joystick...}\par
00047         {\cf17 using} SDL_JoyAxisEvents = std::vector <SDL_JoyAxisEvent>;\par
00051         {\cf17 virtual} {\cf18 void} whenJoystickMoved ({\cf17 const} SDL_JoyAxisEvents&) = 0;\par
00053         {\cf17 virtual} {\cf18 void} whenJoystickButtonPressed (SDL_JoyButtonEvent) = 0;\par
00055         {\cf17 virtual} {\cf18 void} whenJoystickButtonReleased (SDL_JoyButtonEvent) = 0;\par
00056 \par
00057         {\cf17 protected}:\par
00058         {\cf18 bool} _quitRequested;\par
00059     \};\par
00060 \}\par
00061 \par
00062 {\cf21 #endif}\par
00063   \par
00064 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/Screen.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/Screen.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/Screen.hpp}
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/VICII.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::Screen}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::ScreenNTSC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::ScreenPAL}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Screen.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/Screen.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/Screen.hpp}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_SCREEN__}\par
00015 {\cf21 #define __C64_SCREEN__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <C64/VICII.hpp>}\par
00019 \par
00020 {\cf17 namespace }C64\par
00021 \{\par
00022     {\cf17 class }Screen : {\cf17 public} MCHEmul::Screen\par
00023     \{\par
00024         {\cf17 public}:\par
00025         {\cf17 static} {\cf17 const} {\cf18 int} _ID = 1;\par
00026         Screen ({\cf18 double} hz, {\cf18 int} w, {\cf18 int} h, {\cf17 const} MCHEmul::Attributes& attrs = \{ \});\par
00027     \};\par
00028 \par
00029     {\cf17 class }ScreenNTSC final : {\cf17 public} Screen\par
00030     \{\par
00031         {\cf17 public}:\par
00032         ScreenNTSC ()\par
00033             : Screen (59.940f, \par
00034                 (int) VICII_NTSC::_HRASTERDATA.visiblePositions (), (int) VICII_NTSC::_VRASTERDATA.visiblePositions ())\par
00035                             \{ \}\par
00036     \};\par
00037 \par
00038     {\cf17 class }ScreenPAL final : {\cf17 public} Screen\par
00039     \{\par
00040         {\cf17 public}:\par
00041         ScreenPAL ()\par
00042             : Screen (50.125f,\par
00043                 (int) VICII_PAL::_HRASTERDATA.visiblePositions (), (int) VICII_PAL::_VRASTERDATA.visiblePositions ())\par
00044                             \{ \}\par
00045     \};\par
00046 \}\par
00047 \par
00048 {\cf21 #endif}\par
00049   \par
00050 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Screen.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Screen.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Screen.hpp}
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/IO.hpp>}\par
{\f2 #include <CORE/GraphicalChip.hpp>}\par
{\f2 #include <SDL.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Screen}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Screen.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Screen.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Screen.hpp}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_SCREEN__}\par
00015 {\cf21 #define __MCHEMUL_SCREEN__}\par
00016 \par
00017 {\cf21 #include <CORE/IO.hpp>}\par
00018 {\cf21 #include <CORE/GraphicalChip.hpp>}\par
00019 {\cf21 #include <SDL.h>}\par
00020 \par
00021 {\cf17 namespace }MCHEmul\par
00022 \{\par
00024     {\cf17 class }Screen : {\cf17 public} IODevice\par
00025     \{\par
00026         {\cf17 public}:\par
00038         Screen ({\cf17 const} std::string& n, {\cf18 int} {\cf18 id},\par
00039             {\cf18 unsigned} {\cf18 int} sc, {\cf18 unsigned} {\cf18 int} sr, {\cf18 unsigned} {\cf18 int} vF, {\cf18 double} hz,\par
00040             {\cf17 const} Attributes& attrs = \{ \});\par
00041 \par
00042         Screen ({\cf17 const} Screen*) = {\cf17 delete};\par
00043 \par
00044         Screen& operator = ({\cf17 const} Screen&) = {\cf17 delete};\par
00045 \par
00046         {\cf17 virtual} ~Screen () {\cf17 override};\par
00047 \par
00048         {\cf17 virtual} {\cf18 void} linkToChips ({\cf17 const} Chips& c) {\cf17 override};\par
00049 \par
00051         {\cf17 const} GraphicalChip* graphicalChip (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_graphicalChip); \}\par
00053         GraphicalChip* graphicalChip ()\par
00054                             \{ {\cf19 return} (_graphicalChip); \}\par
00055 \par
00057         {\cf17 const} std::string screenName (){\cf17  const}\par
00058 {\cf17                             }\{ {\cf19 return} (_screenName); \}\par
00059         {\cf17 const} {\cf18 unsigned} {\cf18 int} screenColumns (){\cf17  const}\par
00060 {\cf17                             }\{ {\cf19 return} (_screenColumns); \}\par
00061         {\cf17 const} {\cf18 unsigned} {\cf18 int} screenRows (){\cf17  const}\par
00062 {\cf17                             }\{ {\cf19 return} (_screenRows); \}\par
00063         {\cf17 const} {\cf18 unsigned} {\cf18 int} visibilityFactor (){\cf17  const}\par
00064 {\cf17                             }\{ {\cf19 return} (_visibilityFactor); \}\par
00065         {\cf17 const} {\cf18 double} hertzs (){\cf17  const}\par
00066 {\cf17                             }\{ {\cf19 return} (_hertzs); \}\par
00067 \par
00068         {\cf17 virtual} {\cf18 bool} initialize (){\cf17  override}\par
00069 {\cf17                             }\{ {\cf19 return} ({\cf17 true}); \}\par
00070 \par
00072         {\cf17 virtual} {\cf18 bool} simulate () {\cf17 override};\par
00073 \par
00074         {\cf17 protected}:\par
00075         {\cf17 const} std::string _screenName;\par
00076         {\cf17 const} {\cf18 unsigned} {\cf18 int} _screenColumns;\par
00077         {\cf17 const} {\cf18 unsigned} {\cf18 int} _screenRows;\par
00078         {\cf17 const} {\cf18 unsigned} {\cf18 int} _visibilityFactor;\par
00079         {\cf17 const} {\cf18 double} _hertzs;\par
00080 \par
00081         {\cf17 protected}:\par
00085         GraphicalChip* _graphicalChip;\par
00086 \par
00087         {\cf20 // Implementation}\par
00088         SDL_Window* _window;\par
00089         SDL_Renderer* _renderer;\par
00090         SDL_Texture* _texture;\par
00091 \par
00093         {\cf18 double} _refreshRate;\par
00094     \};\par
00095 \}\par
00096 \par
00097 {\cf21 #endif}\par
00098   \par
00099 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/SFChip.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/SFChip.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/SFChip.hpp}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::SpecialFunctionsChip}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SFChip.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/SFChip.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/SFChip.hpp}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_SFCHIP__}\par
00015 {\cf21 #define __C64_SFCHIP__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00021     {\cf17 class }SpecialFunctionsChip final : {\cf17 public} MCHEmul::Chip\par
00022     \{\par
00023         {\cf17 public}:\par
00024         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _ID = 1;\par
00025 \par
00026         SpecialFunctionsChip ()\par
00027             : MCHEmul::Chip (_ID, \par
00028                 \{ \{ {\cf22 "Name"}, {\cf22 "SFChip"} \},\par
00029                   \{ {\cf22 "Manufacturer"}, {\cf22 "Ignacio Cea"} \},\par
00030                   \{ {\cf22 "Year"}, {\cf22 "2022"} \} \}),\par
00031               _BasicRAM ({\cf17 nullptr}), _BasicROM ({\cf17 nullptr}), _KernelROM ({\cf17 nullptr}), _KernelRAM ({\cf17 nullptr}),\par
00032               _CharROM ({\cf17 nullptr}), _VICIIRegisters ({\cf17 nullptr}), _SIDRegisters ({\cf17 nullptr}), _ColorRAM ({\cf17 nullptr}),\par
00033               _CIA1Registers ({\cf17 nullptr}), _CIA2registers ({\cf17 nullptr}), _IO1Registers ({\cf17 nullptr}), _IO2registers ({\cf17 nullptr})\par
00034                             \{ \}\par
00035 \par
00036         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00037 \par
00038         {\cf17 virtual} {\cf18 bool} simulate (MCHEmul::CPU* cpu) {\cf17 override};\par
00039 \par
00040         {\cf17 private}:\par
00041         MCHEmul::PhisicalStorageSubset* _BasicROM;\par
00042         MCHEmul::PhisicalStorageSubset* _BasicRAM;\par
00043         MCHEmul::PhisicalStorageSubset* _KernelROM;\par
00044         MCHEmul::PhisicalStorageSubset* _KernelRAM;\par
00045         MCHEmul::PhisicalStorageSubset* _CharROM;\par
00046         MCHEmul::PhisicalStorageSubset* _VICIIRegisters;\par
00047         MCHEmul::PhisicalStorageSubset* _SIDRegisters;\par
00048         MCHEmul::PhisicalStorageSubset* _ColorRAM;\par
00049         MCHEmul::PhisicalStorageSubset* _CIA1Registers;\par
00050         MCHEmul::PhisicalStorageSubset* _CIA2registers;\par
00051         MCHEmul::PhisicalStorageSubset* _IO1Registers;\par
00052         MCHEmul::PhisicalStorageSubset* _IO2registers;\par
00053     \};\par
00054 \}\par
00055 \par
00056 {\cf21 #endif}\par
00057   \par
00058 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/UserPeripherals.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/UserPeripherals.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/UserPeripherals.hpp}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::UserIOPeripheral}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::UserIONoPeripheral}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UserPeripherals.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/UserPeripherals.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/UserPeripherals.hpp}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_USERPERIPHERIALS__}\par
00015 {\cf21 #define __C64_USERPERIPHERIALS__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00022     {\cf17 class }UserIOPeripheral : {\cf17 public} MCHEmul::IOPeripheral\par
00023     \{\par
00024         {\cf17 public}:\par
00025         UserIOPeripheral ({\cf18 int} {\cf18 id})\par
00026             : MCHEmul::IOPeripheral (id, \{ \})\par
00027                             \{ \}\par
00028     \};\par
00029 \par
00032     {\cf17 class }UserIONoPeripheral final : {\cf17 public} UserIOPeripheral\par
00033     \{\par
00034         {\cf17 public}:\par
00035         {\cf17 static} {\cf17 const} {\cf18 int} _ID = -1;\par
00036 \par
00037         UserIONoPeripheral ()\par
00038             : UserIOPeripheral (_ID)\par
00039                             \{ \}\par
00040 \par
00041         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00042 \par
00043         {\cf17 virtual} {\cf18 bool} simulate () {\cf17 override};\par
00044     \};\par
00045 \}\par
00046 \par
00047 {\cf21 #endif}\par
00048   \par
00049 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/UserPort.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/UserPort.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/UserPort.hpp}
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::UserIOPort}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UserPort.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/UserPort.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/UserPort.hpp}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00016 {\cf21 #ifndef __C64_USERPORT__}\par
00017 {\cf21 #define __C64_USERPORT__}\par
00018 \par
00019 {\cf21 #include <CORE/incs.hpp>}\par
00020 \par
00021 {\cf17 namespace }C64\par
00022 \{\par
00024     {\cf17 class }UserIOPort final : {\cf17 public} MCHEmul::IODevice\par
00025     \{\par
00026         {\cf17 public}:\par
00027         {\cf17 static} {\cf17 const} {\cf18 int} _ID = 3;\par
00028 \par
00029         UserIOPort ();\par
00030 \par
00033         {\cf17 virtual} {\cf18 void} addPeripheral (MCHEmul::IOPeripheral* p) {\cf17 override};\par
00034     \};\par
00035 \}\par
00036 \par
00037 {\cf21 #endif}\par
00038   \par
00039 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/VICII.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/VICII.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/VICII.hpp}
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/VICIIRegisters.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::VICII}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::VICII::RasterData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::VICII::Raster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::VICII_NTSC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::VICII_PAL}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VICII.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/VICII.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/VICII.hpp}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00015 {\cf21 #ifndef __C64_VICII__}\par
00016 {\cf21 #define __C64_VICII__}\par
00017 \par
00018 {\cf21 #include <CORE/incs.hpp>}\par
00019 {\cf21 #include <C64/VICIIRegisters.hpp>}\par
00020 \par
00021 {\cf17 namespace }C64\par
00022 \{\par
00024     {\cf17 class }VICII : {\cf17 public} MCHEmul::GraphicalChip\par
00025     \{\par
00026         {\cf17 public}:\par
00028         {\cf17 class }RasterData\par
00029         \{\par
00030             {\cf17 public}:\par
00031             RasterData () = {\cf17 delete};\par
00032 \par
00033             RasterData (\par
00034                         {\cf18 unsigned} {\cf18 short} fp,      {\cf20 // First position}\par
00035                         {\cf18 unsigned} {\cf18 short} fvp,     {\cf20 // First Visible position}\par
00036                         {\cf18 unsigned} {\cf18 short} fdp,     {\cf20 // First Display position}\par
00037                         {\cf18 unsigned} {\cf18 short} ldp,     {\cf20 // Last Display Sync osition}\par
00038                         {\cf18 unsigned} {\cf18 short} lvp,     {\cf20 // Last Visible position}\par
00039                         {\cf18 unsigned} {\cf18 short} lp,      {\cf20 // Last position}\par
00040                         {\cf18 unsigned} {\cf18 short} mp,      {\cf20 // Maximum positions}\par
00041                         {\cf18 unsigned} {\cf18 short} pr1,     {\cf20 // Positions to reduce in the visible zone 1 & 2}\par
00042                         {\cf18 unsigned} {\cf18 short} pr2\par
00043                       );\par
00044 \par
00045             RasterData ({\cf17 const} RasterData&) = {\cf19 default};\par
00046 \par
00047             RasterData& operator = ({\cf17 const} RasterData&) = {\cf19 default};\par
00048 \par
00049             {\cf18 unsigned} {\cf18 short} currentPosition (){\cf17  const}\par
00050 {\cf17                             }\{ {\cf19 return} (_currentPosition); \}\par
00051             {\cf18 unsigned} {\cf18 short} currentPositionAtBase0 (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_currentPosition_0); \}\par
00053 \par
00054             {\cf18 bool} isInBlankZone (){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} ((_currentPosition_0 >= _firstPosition_0 && \par
00056                                             _currentPosition_0 < _firstVisiblePosition_0) ||\par
00057                                       (_currentPosition_0 > _lastVisiblePosition_0 && \par
00058                                             _currentPosition_0 <= _lastPosition_0)); \}\par
00059             {\cf18 bool} isInLastBlankZone (){\cf17  const}\par
00060 {\cf17                             }\{ {\cf19 return} (_currentPosition_0 > _lastVisiblePosition_0 && \par
00061                                       _currentPosition_0 <= _lastPosition_0); \}\par
00062 \par
00063             {\cf18 bool} isInVisibleZone (){\cf17  const }\par
00064 {\cf17                             }\{ {\cf19 return} ((_currentPosition_0 >= _firstVisiblePosition_0 && \par
00065                                        _currentPosition_0 <= _lastVisiblePosition_0)); \}\par
00066             {\cf18 unsigned} {\cf18 short} currentVisiblePosition () const {\cf20 // The }\par
00067                             \{ {\cf19 return} (_currentPosition_0 - _firstVisiblePosition_0); \}\par
00068             {\cf18 unsigned} {\cf18 short} visiblePositions (){\cf17  const}\par
00069 {\cf17                             }\{ {\cf19 return} (_lastVisiblePosition_0 - _firstVisiblePosition_0 + 1); \}\par
00070 \par
00072             {\cf18 bool} isInDisplayZone (){\cf17  const}\par
00073 {\cf17                             }\{ {\cf19 return} (_currentPosition_0 >= _originalFirstDisplayPosition_0 && \par
00074                                       _currentPosition_0 <= _originalLastDisplayPosition_0); \}\par
00075 \par
00077             {\cf18 unsigned} {\cf18 short} firstScreenPosition ({\cf18 bool} o = {\cf17 false}){\cf17  const}\par
00078 {\cf17                             }\{ {\cf19 return} ((o ? _originalFirstDisplayPosition_0 : _firstDisplayPosition_0) - _firstVisiblePosition_0); \}\par
00079             {\cf18 unsigned} {\cf18 short} lastScreenPosition ({\cf18 bool} o = {\cf17 false}){\cf17  const}\par
00080 {\cf17                             }\{ {\cf19 return} ((o ? _originalLastDisplayPosition_0 : _lastDisplayPosition_0) - _firstVisiblePosition_0); \}\par
00081             {\cf18 unsigned} {\cf18 short} currentScreenPosition (){\cf17  const}\par
00082 {\cf17                             }\{ {\cf19 return} (_currentPosition_0 - _firstVisiblePosition_0); \}\par
00083             {\cf18 unsigned} {\cf18 short} screenPositions (){\cf17  const}\par
00084 {\cf17                             }\{ {\cf19 return} (_lastDisplayPosition_0 - _firstDisplayPosition_0 + 1); \}\par
00085 \par
00088             {\cf18 bool} add ({\cf18 unsigned} {\cf18 short} i);\par
00089             {\cf18 bool} next ()\par
00090                             \{ {\cf19 return} (add (1)); \}\par
00091 \par
00093             {\cf18 void} reduceDisplayZone ({\cf18 bool} s);\par
00094             {\cf18 bool} isDisplayZoneReduced (){\cf17  const}\par
00095 {\cf17                             }\{ {\cf19 return} (_displayZoneReducted); \}\par
00096 \par
00097             {\cf18 void} initialize ()\par
00098                             \{ _currentPosition = _firstPosition; _currentPosition_0 = _firstPosition_0; \}\par
00099 \par
00100             {\cf17 protected}:\par
00102             {\cf18 unsigned} {\cf18 short} toBase0 ({\cf18 unsigned} {\cf18 short} m){\cf17  const}\par
00103 {\cf17                             }\{ {\cf18 int} t = (int) m - ({\cf18 int}) _firstPosition; \par
00104                               {\cf19 return} ((t < 0) ? ({\cf18 unsigned} short) t + _maxPositions : ({\cf18 unsigned} {\cf18 short}) t); \}\par
00105 \par
00106             {\cf17 protected}:\par
00107             {\cf17 const} {\cf18 unsigned} {\cf18 short} _firstPosition = 0; {\cf20 // Adjusted at construction time.}\par
00108             {\cf17 const} {\cf18 unsigned} {\cf18 short} _firstVisiblePosition = 0;\par
00109             {\cf18 unsigned} {\cf18 short} _firstDisplayPosition; {\cf20 // Both can be changed by the method reduceDisplayZone...}\par
00110             {\cf17 const} {\cf18 unsigned} {\cf18 short} _originalFirstDisplayPosition; {\cf20 // Before reducing or extending the area...}\par
00111             {\cf18 unsigned} {\cf18 short} _lastDisplayPosition;\par
00112             {\cf17 const} {\cf18 unsigned} {\cf18 short} _originalLastDisplayPosition; {\cf20 // Before reduucing or extending the area...}\par
00113             {\cf17 const} {\cf18 unsigned} {\cf18 short} _lastVisiblePosition = 0;\par
00114             {\cf17 const} {\cf18 unsigned} {\cf18 short} _lastPosition = 0;\par
00115             {\cf17 const} {\cf18 unsigned} {\cf18 short} _maxPositions = 0;\par
00116             {\cf17 const} {\cf18 unsigned} {\cf18 short} _positionsToReduce1 = 0;\par
00117             {\cf17 const} {\cf18 unsigned} {\cf18 short} _positionsToReduce2 = 0;\par
00118 \par
00119             {\cf20 // Implementation}\par
00120             {\cf20 // To speeed up calculus...}\par
00121             {\cf18 unsigned} {\cf18 short} _firstPosition_0; \par
00122             {\cf18 unsigned} {\cf18 short} _firstVisiblePosition_0;\par
00123             {\cf18 unsigned} {\cf18 short} _firstDisplayPosition_0; \par
00124             {\cf18 unsigned} {\cf18 short} _originalFirstDisplayPosition_0; \par
00125             {\cf18 unsigned} {\cf18 short} _lastDisplayPosition_0;\par
00126             {\cf18 unsigned} {\cf18 short} _originalLastDisplayPosition_0; \par
00127             {\cf18 unsigned} {\cf18 short} _lastVisiblePosition_0;\par
00128             {\cf18 unsigned} {\cf18 short} _lastPosition_0;\par
00129 \par
00130             {\cf20 // Implementation}\par
00131             {\cf18 unsigned} {\cf18 short} _currentPosition;\par
00132             {\cf18 unsigned} {\cf18 short} _currentPosition_0;\par
00133             {\cf18 bool} _displayZoneReducted;\par
00134         \};\par
00135 \par
00138         {\cf17 class }Raster final\par
00139         \{\par
00140             {\cf17 public}:\par
00141             {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 short} _FIRSTBADLINE   = 0x33;\par
00142             {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 short} _LASTBADLINE    = 0xfa;\par
00143 \par
00144             Raster () = {\cf17 delete};\par
00145 \par
00146             Raster ({\cf17 const} Raster&) = {\cf19 default};\par
00147 \par
00148             Raster& operator = ({\cf17 const} Raster&) = {\cf19 default};\par
00149 \par
00150             Raster ({\cf17 const} RasterData& vD, {\cf17 const} RasterData& hD)\par
00151                 : _vRasterData (vD), _hRasterData (hD)\par
00152                             \{ \}\par
00153 \par
00154             {\cf17 const} RasterData& vData (){\cf17  const}\par
00155 {\cf17                             }\{ {\cf19 return} (_vRasterData); \}\par
00156             RasterData& vData ()\par
00157                             \{ {\cf19 return} (_vRasterData); \}\par
00158             {\cf17 const} RasterData& hData (){\cf17  const}\par
00159 {\cf17                             }\{ {\cf19 return} (_hRasterData); \}\par
00160             RasterData& hData ()\par
00161                             \{ {\cf19 return} (_hRasterData); \}\par
00162 \par
00163             {\cf18 unsigned} {\cf18 short} currentLine (){\cf17  const}\par
00164 {\cf17                             }\{ {\cf19 return} (_vRasterData.currentPosition ()); \}\par
00165             {\cf18 unsigned} {\cf18 short} currentLineAtBase0 (){\cf17  const}\par
00166 {\cf17                             }\{ {\cf19 return} (_vRasterData.currentPositionAtBase0 ()); \}\par
00167             {\cf18 unsigned} {\cf18 short} currentColumn (){\cf17  const}\par
00168 {\cf17                             }\{ {\cf19 return} (_hRasterData.currentPosition ()); \}\par
00169             {\cf18 unsigned} {\cf18 short} currentColumnAtBase0 (){\cf17  const}\par
00170 {\cf17                             }\{ {\cf19 return} (_hRasterData.currentPositionAtBase0 ()); \}\par
00171 \par
00174             {\cf18 bool} isInPotentialBadLine (){\cf17  const}\par
00175 {\cf17                             }\{ {\cf19 return} (_vRasterData.currentPosition () >= _FIRSTBADLINE && \par
00176                                       _vRasterData.currentPosition () <= _LASTBADLINE); \}\par
00177 \par
00178             {\cf18 bool} isInVBlank (){\cf17  const}\par
00179 {\cf17                             }\{ {\cf19 return} (_vRasterData.isInBlankZone ()); \}\par
00180             {\cf18 bool} isInLastVBlank (){\cf17  const}\par
00181 {\cf17                             }\{ {\cf19 return} (_vRasterData.isInLastBlankZone ()); \}\par
00182 \par
00183             {\cf18 bool} isInVisibleZone (){\cf17  const}\par
00184 {\cf17                             }\{ {\cf19 return} (_vRasterData.isInVisibleZone () && _hRasterData.isInVisibleZone ()); \}\par
00185             {\cf18 void} currentVisiblePosition ({\cf18 unsigned} {\cf18 short}& x, {\cf18 unsigned} {\cf18 short}& y){\cf17  const}\par
00186 {\cf17                             }\{ x = _hRasterData.currentVisiblePosition (); y = _vRasterData.currentVisiblePosition (); \}\par
00187 \par
00188             {\cf18 bool} isInDisplayZone (){\cf17  const}\par
00189 {\cf17                             }\{ {\cf19 return} (_vRasterData.isInDisplayZone () && _hRasterData.isInDisplayZone ()); \}\par
00190 \par
00191             {\cf18 void} firstScreenPosition ({\cf18 unsigned} {\cf18 short}& x, {\cf18 unsigned} {\cf18 short}& y, {\cf18 bool} o = {\cf17 false}){\cf17  const}\par
00192 {\cf17                             }\{ x = _hRasterData.firstScreenPosition (o); y = _vRasterData.firstScreenPosition (o); \}\par
00193             {\cf18 void} currentScreenPosition ({\cf18 unsigned} {\cf18 short}& x, {\cf18 unsigned} {\cf18 short}& y){\cf17  const}\par
00194 {\cf17                             }\{ x = _hRasterData.currentScreenPosition (); y = _vRasterData.currentScreenPosition (); \}\par
00195             {\cf18 void} screenPositions ({\cf18 unsigned} {\cf18 short}& x1, {\cf18 unsigned} {\cf18 short}& y1, {\cf18 unsigned} {\cf18 short}& x2, {\cf18 unsigned} {\cf18 short}& y2)\par
00196                             \{ x1 = _hRasterData.firstScreenPosition (); y1 = _vRasterData.firstScreenPosition ();\par
00197                               x2 = _hRasterData.lastScreenPosition (); y2 = _vRasterData.lastScreenPosition (); \}\par
00198 \par
00199             {\cf18 unsigned} {\cf18 short} visibleLines (){\cf17  const}\par
00200 {\cf17                             }\{ {\cf19 return} (_vRasterData.visiblePositions ()); \}\par
00201             {\cf18 unsigned} {\cf18 short} visibleColumns (){\cf17  const}\par
00202 {\cf17                             }\{ {\cf19 return} (_hRasterData.visiblePositions ()); \}\par
00203 \par
00204             {\cf18 void} reduceDisplayZone ({\cf18 bool} v, {\cf18 bool} h)\par
00205                             \{ _vRasterData.reduceDisplayZone (v); _hRasterData.reduceDisplayZone (h); \}\par
00206             \par
00209             {\cf18 bool} moveCycles ({\cf18 unsigned} {\cf18 short} nC)\par
00210                             \{ {\cf18 bool} result = _hRasterData.add (nC * 8 );\par
00211                               {\cf19 if} (result) _vRasterData.next (); \par
00212                               {\cf19 return} (result); \}\par
00213 \par
00214             {\cf18 void} initialize ()\par
00215                             \{ _vRasterData.initialize (); _hRasterData.initialize (); \}\par
00216 \par
00217             {\cf17 private}:\par
00218             RasterData _vRasterData, _hRasterData;\par
00219         \};\par
00220 \par
00221         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _ID = 4;\par
00222 \par
00224         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 short} _GRAPHMAXCHARLINES      = 25; {\cf20 // Not taking into account reductions in the size}\par
00225         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 short} _GRAPHMAXCHARCOLUMNS    = 40;\par
00226         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 short} _GRAPHMAXBITMAPCOLUMNS  = 320; {\cf20 // Not taking into account double coulors}\par
00227         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 short} _GRAPHMAXBITMAPROWS     = 200;\par
00228 \par
00230         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _CPUCYCLESWHENREADGRAPHS  = 40;\par
00231 \par
00233         {\cf17 static} {\cf17 const} MCHEmul::Address _COLORMEMORY;\par
00234 \par
00236         VICII ({\cf17 const} RasterData& vd, {\cf17 const} RasterData& hd, {\cf17 const} MCHEmul::Attributes& attrs = \{ \});\par
00237 \par
00238         ~VICII ();\par
00239 \par
00241         {\cf18 unsigned} {\cf18 short} bank (){\cf17  const}\par
00242 {\cf17                             }\{ {\cf19 return} (_VICIIRegisters -> bank ()); \}\par
00243         {\cf18 void} setBank ({\cf18 unsigned} {\cf18 char} bk)\par
00244                             \{ _VICIIRegisters -> setBank (bk); \}\par
00245 \par
00246         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00247 \par
00248         {\cf17 virtual} {\cf18 bool} simulate (MCHEmul::CPU* cpu) {\cf17 override};\par
00249 \par
00250         {\cf17 private}:\par
00252         {\cf17 struct }DrawContext\par
00253         \{\par
00254             {\cf18 unsigned} {\cf18 short} _ICD;    {\cf20 // Initial Column of the Display (Not taken into account reductions in size).}\par
00255             {\cf18 unsigned} {\cf18 short} _ICS;    {\cf20 // Initial Column Screen (Screen = Display with reductions in the size considered).}\par
00256             {\cf18 unsigned} {\cf18 short} _LCD;    {\cf20 // Last Column of the Display }\par
00257             {\cf18 unsigned} {\cf18 short} _LCS;    {\cf20 // Last Column of the Screen}\par
00258             {\cf18 unsigned} {\cf18 short} _SC;     {\cf20 // Scroll X}\par
00259             {\cf18 unsigned} {\cf18 short} _RC;     {\cf20 // Raster X (from the beginning of the visible zone)}\par
00260             {\cf18 unsigned} {\cf18 short} _RCA;    {\cf20 // Raster X adjusted (Moves 8 by 8, so = Raster X >> 3 << 3)}\par
00261             {\cf18 unsigned} {\cf18 short} _IRD;    {\cf20 // Initial Row Display}\par
00262             {\cf18 unsigned} {\cf18 short} _IRS;    {\cf20 // Initial Row Screen}\par
00263             {\cf18 unsigned} {\cf18 short} _LRD;    {\cf20 // Last Row of the Display }\par
00264             {\cf18 unsigned} {\cf18 short} _LRS;    {\cf20 // Last Row of the Screen}\par
00265             {\cf18 unsigned} {\cf18 short} _SR;     {\cf20 // Scroll Y}\par
00266             {\cf18 unsigned} {\cf18 short} _RR;     {\cf20 // Raster Y (Moves 1 by 1. No adjusted neadd)}\par
00267         \};\par
00268 \par
00270         {\cf18 void} readGraphicsInfo ();\par
00271 \par
00273         {\cf18 void} drawGraphics ({\cf17 const} DrawContext& dC);\par
00274         {\cf18 void} drawSprites ({\cf17 const} DrawContext& dC);\par
00275 \par
00278         {\cf17 virtual} MCHEmul::ScreenMemory* createScreenMemory () {\cf17 override};\par
00279 \par
00280         {\cf20 // Read screen data}\par
00282 {\cf20 }        MCHEmul::UBytes readCharCodeDataAt ({\cf18 unsigned} {\cf18 short} l){\cf17  const}\par
00283 {\cf17                             }\{ {\cf19 return} (memoryRef () -> values (_VICIIRegisters -> screenMemory () + \par
00284                                 ({\cf18 size_t}) (l * _GRAPHMAXCHARCOLUMNS), _GRAPHMAXCHARCOLUMNS)); \}\par
00286         MCHEmul::UBytes readCharDataFor ({\cf17 const} MCHEmul::UBytes& chrs) {\cf17 const};\par
00290         MCHEmul::UBytes readBitmapDataAt ({\cf18 unsigned} {\cf18 short} l) {\cf17 const};\par
00293         MCHEmul::UBytes readColorDataAt ({\cf18 unsigned} {\cf18 short} l){\cf17  const}\par
00294 {\cf17                             }\{ {\cf19 return} (memoryRef () -> values (_COLORMEMORY + \par
00295                                 ({\cf18 size_t}) (l * _GRAPHMAXCHARCOLUMNS), _GRAPHMAXCHARCOLUMNS)); \}\par
00297         MCHEmul::UBytes readSpriteDataAt ({\cf18 unsigned} {\cf18 short} l) {\cf17 const};\par
00298 \par
00299         {\cf20 // Draw the graphics in detail...}\par
00301 {\cf20 }        {\cf18 void} drawMonoColorBytes ({\cf18 int} cb, {\cf18 size_t} r, \par
00302             {\cf17 const} MCHEmul::UBytes& bt, {\cf17 const} MCHEmul::UBytes& clr, {\cf17 const} DrawContext& dC);\par
00304         {\cf18 void} drawMultiColorBytes ({\cf18 int} cb, {\cf18 size_t} r, \par
00305             {\cf17 const} MCHEmul::UBytes& bt, {\cf17 const} MCHEmul::UBytes& clr, {\cf17 const} DrawContext& dC);\par
00306 \par
00307         {\cf17 private}:\par
00309         C64::VICIIRegisters* _VICIIRegisters;\par
00311         Raster _raster;\par
00312 \par
00313         {\cf20 // Implementation}\par
00316 {\cf20 }        {\cf18 unsigned} {\cf18 int} _lastCPUCycles;\par
00318         SDL_PixelFormat* _format;\par
00320         MCHEmul::UBytes _graphicsCharCodeData;\par
00321         MCHEmul::UBytes _graphicsCharData;\par
00322         MCHEmul::UBytes _graphicsBitmapData;\par
00323         MCHEmul::UBytes _graphicsColorData;\par
00325         {\cf18 bool} _isNewRasterLine; \par
00327         {\cf18 bool} _lastVBlankEntered;\par
00328     \};\par
00329 \par
00331     {\cf17 class }VICII_NTSC final : {\cf17 public} VICII\par
00332     \{\par
00333         {\cf17 public}:\par
00334         {\cf17 static} {\cf17 const} RasterData _VRASTERDATA;\par
00335         {\cf17 static} {\cf17 const} RasterData _HRASTERDATA;\par
00336 \par
00337         VICII_NTSC ();\par
00338     \};\par
00339 \par
00341     {\cf17 class }VICII_PAL final : {\cf17 public} VICII\par
00342     \{\par
00343         {\cf17 public}:\par
00344         {\cf17 static} {\cf17 const} RasterData _VRASTERDATA;\par
00345         {\cf17 static} {\cf17 const} RasterData _HRASTERDATA;\par
00346 \par
00347         VICII_PAL ();\par
00348     \};\par
00349 \}\par
00350 \par
00351 {\cf21 #endif}\par
00352   \par
00353 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/VICIIRegisters.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/VICIIRegisters.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/VICIIRegisters.hpp}
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::VICIIRegisters}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VICIIRegisters.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/VICIIRegisters.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/VICIIRegisters.hpp}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00015 {\cf21 #ifndef __C64_VICIIREGISTERS__}\par
00016 {\cf21 #define __C64_VICIIREGISTERS__}\par
00017 \par
00018 {\cf21 #include <CORE/incs.hpp>}\par
00019 \par
00020 {\cf17 namespace }C64\par
00021 \{\par
00025     {\cf17 class }VICIIRegisters final : {\cf17 public} MCHEmul::PhisicalStorageSubset\par
00026     \{\par
00027         {\cf17 public}:\par
00028         {\cf17 enum class} GraphicMode\par
00029         \{\par
00030             _CHARMODE = 0,\par
00031             _MULTICOLORCHARMODE,\par
00032             _BITMAPMODE,\par
00033             _MULTICOLORBITMAPMODE,\par
00034             _EXTENDEDBACKGROUNDMODE,\par
00035             _ILLEGALMODE\par
00036         \};\par
00037 \par
00038         VICIIRegisters ({\cf18 int} {\cf18 id}, MCHEmul::PhisicalStorage* ps)\par
00039             : MCHEmul::PhisicalStorageSubset (id, ps, 0xd000, MCHEmul::Address (\{ 0x00, 0xd0 \}, {\cf17 false}), 0x0400),\par
00040               _lastValueRead (MCHEmul::PhisicalStorage::_DEFAULTVALUE),\par
00041               _backgroundColor (4, 0x00),\par
00042               _spriteXCoord (8, 0x0000), _spriteYCoord (8, 0x0000),\par
00043               _spriteColor (8, 0x0000),\par
00044               _spriteSharedColor (2, 0x0000), _spriteMulticolor (8, {\cf17 false}),\par
00045               _spriteEnabled (8, {\cf17 false}), \par
00046               _spriteDoubleWidth (8, {\cf17 false}), _spriteDoubleHeight (8, {\cf17 false}),\par
00047               _spriteToForegroundPriority (8, {\cf17 false})\par
00048               {\cf20 // At this point the rest internal variables will have random values...}\par
00049               {\cf20 // The vector are initialized just to given them a default size!}\par
00050                             \{ initializeInternalValues (); \}\par
00051 \par
00052         {\cf18 unsigned} {\cf18 char} borderColor (){\cf17  const}\par
00053 {\cf17                             }\{ {\cf19 return} (_borderColor); \}\par
00054         {\cf18 unsigned} {\cf18 char} backgroundColor ({\cf18 size_t} p = 0){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} ( _backgroundColor [p]); \}\par
00056 \par
00057         {\cf18 unsigned} {\cf18 short} spriteXCoord ({\cf18 size_t} p){\cf17  const}\par
00058 {\cf17                             }\{ {\cf19 return} (_spriteXCoord [p]); \}\par
00059         {\cf18 unsigned} {\cf18 char} spriteYCoord ({\cf18 size_t} p){\cf17  const}\par
00060 {\cf17                             }\{ {\cf19 return} (_spriteYCoord [p]); \}\par
00061         {\cf18 unsigned} {\cf18 char} spriteColor ({\cf18 size_t} p){\cf17  const}\par
00062 {\cf17                             }\{ {\cf19 return} (_spriteColor [p]); \}\par
00063         {\cf18 unsigned} {\cf18 char} spriteSharedColor ({\cf18 size_t} p){\cf17  const}\par
00064 {\cf17                             }\{ {\cf19 return} (_spriteSharedColor [p]); \}\par
00065         {\cf18 bool} spriteEnable ({\cf18 size_t} p){\cf17  const}\par
00066 {\cf17                             }\{ {\cf19 return} (_spriteEnabled [p]); \}\par
00067         {\cf18 bool} spriteDoubleWidth ({\cf18 size_t} p){\cf17  const}\par
00068 {\cf17                             }\{ {\cf19 return} (_spriteDoubleWidth [p]); \}\par
00069         {\cf18 bool} spriteDoubleHeight ({\cf18 size_t} p){\cf17  const}\par
00070 {\cf17                             }\{ {\cf19 return} (_spriteDoubleHeight [p]); \}\par
00071         {\cf18 bool} spriteToForegroundPriority ({\cf18 size_t} p){\cf17  const}\par
00072 {\cf17                             }\{ {\cf19 return} (_spriteToForegroundPriority [p]); \}\par
00073         \par
00074         {\cf18 unsigned} {\cf18 char} verticalScrollPosition (){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_verticalScrollPosition); \}\par
00076         {\cf18 unsigned} {\cf18 char} horizontalScrollPosition (){\cf17  const}\par
00077 {\cf17                             }\{ {\cf19 return} (_horizontalScrollPosition); \}\par
00078 \par
00079         {\cf18 bool} textDisplay25RowsActive (){\cf17  const}\par
00080 {\cf17                             }\{ {\cf19 return} (_textDisplay25RowsActive); \}\par
00081         {\cf18 bool} textDisplay40ColumnsActive (){\cf17  const}\par
00082 {\cf17                             }\{ {\cf19 return} (_textDisplay40ColumnsActive); \}\par
00083         {\cf18 bool} screenSameColorBorderActive (){\cf17  const}\par
00084 {\cf17                             }\{ {\cf19 return} (_screenSameColorBorderActive); \}\par
00085         {\cf18 bool} videoResetActive (){\cf17  const}\par
00086 {\cf17                             }\{ {\cf19 return} (_videoResetActive); \}\par
00087 \par
00088         {\cf18 bool} graphicBitModeActive (){\cf17  const}\par
00089 {\cf17                             }\{ {\cf19 return} (_graphicBitModeActive); \}\par
00090         {\cf18 bool} graphicExtendedColorTextModeActive (){\cf17  const}\par
00091 {\cf17                             }\{ {\cf19 return} (_graphicExtendedColorTextModeActive); \}\par
00092         {\cf18 bool} graphicMulticolorTextModeActive (){\cf17  const}\par
00093 {\cf17                             }\{ {\cf19 return} (_graphicMulticolorTextModeActive); \}\par
00094         GraphicMode graphicModeActive (){\cf17  const}\par
00095 {\cf17                             }\{ {\cf19 return} (_graphicModeActive); \}\par
00096 \par
00097         {\cf18 bool} rasterIRQActive (){\cf17  const}\par
00098 {\cf17                             }\{ {\cf19 return} (_rasterIRQActive); \}\par
00099         {\cf18 bool} spriteCollisionWithDataIRQActive (){\cf17  const}\par
00100 {\cf17                             }\{ {\cf19 return} (_spriteCollisionWithDataIRQActive); \}\par
00101         {\cf18 bool} spriteCollisionsIRQActive (){\cf17  const}\par
00102 {\cf17                             }\{ {\cf19 return} (_spriteCollisionsIRQActive); \}\par
00103         {\cf18 bool} lightPenIRQActive (){\cf17  const}\par
00104 {\cf17                             }\{ {\cf19 return} (_lightPenIRQActive); \}\par
00105 \par
00106         {\cf18 unsigned} {\cf18 short} IRQRasterLineAt (){\cf17  const}\par
00107 {\cf17                             }\{ {\cf19 return} (_IRQRasterLineAt);  \}\par
00108 \par
00109         {\cf17 const} MCHEmul::Address charDataMemory (){\cf17  const}\par
00110 {\cf17                             }\{ {\cf19 return} (_charDataMemory + \par
00111                                 ({\cf18 size_t}) (0x4000 {\cf20 /* 16284 = 16k */} * _bank) ); \}\par
00112         {\cf17 const} MCHEmul::Address screenMemory (){\cf17  const }\par
00113 {\cf17                             }\{ {\cf19 return} (_screenMemory + ({\cf18 size_t}) (0x4000 * _bank)); \}\par
00114         {\cf17 const} MCHEmul::Address bitmapMemory (){\cf17  const }\par
00115 {\cf17                             }\{ {\cf19 return} (_bitmapMemory + ({\cf18 size_t}) (0x4000 * _bank)); \}\par
00116 \par
00117         {\cf20 // Managed from VICII Chip Emulator}\par
00118         {\cf20 // The VICII chip also uses this object as a temporary storage}\par
00119         {\cf18 unsigned} {\cf18 short} currentRasterLine (){\cf17  const}\par
00120 {\cf17                             }\{ {\cf19 return} (_currentRasterLine); \}\par
00121         {\cf18 void} setCurrentRasterLine ({\cf18 unsigned} {\cf18 short} rL)\par
00122                             \{ _currentRasterLine = rL; \}\par
00123 \par
00124         {\cf18 unsigned} {\cf18 short} currentLightPenHorizontalPosition (){\cf17  const}\par
00125 {\cf17                             }\{ {\cf19 return} (_currentLightPenHorizontalPosition); \}\par
00126         {\cf18 unsigned} {\cf18 short} currentLightPenVerticalPosition (){\cf17  const}\par
00127 {\cf17                             }\{ {\cf19 return} (_currentLightPenVerticalPosition); \}\par
00128         {\cf18 void} setCurrentLightPenPosition ({\cf18 unsigned} {\cf18 char} x, {\cf18 unsigned} {\cf18 char} y)\par
00129                             \{ _currentLightPenHorizontalPosition = x; _currentLightPenVerticalPosition = y; \}\par
00130 \par
00131         {\cf18 bool} rasterAtIRQLine (){\cf17  const}\par
00132 {\cf17                             }\{ {\cf19 return} (_rasterAtIRQLine); \}\par
00133         {\cf18 void} setRasterAtLine ({\cf18 bool} rL)\par
00134                             \{ _rasterAtIRQLine = rL; \}\par
00135         {\cf18 bool} spritesCollisionWithDataHappened (){\cf17  const}\par
00136 {\cf17                             }\{ {\cf19 return} (_spritesCollisionWithDataHappened); \}\par
00137         {\cf18 void} setSpritesCollisionWithData ({\cf18 bool} c)\par
00138                             \{ _spritesCollisionWithDataHappened = c; \}\par
00139         {\cf18 bool} spriteCollisionWithDataHappened ({\cf18 size_t} p){\cf17  const}\par
00140 {\cf17                             }\{ {\cf19 return} (_spriteCollisionWithDataHappened [p]); \}\par
00141         {\cf18 void} setSpriteCollisionWithDataHappened ({\cf18 size_t} p, {\cf18 bool} c)\par
00142                             \{ _spriteCollisionWithDataHappened [p] = c; \}\par
00143         {\cf18 bool} spritesCollisionHappened (){\cf17  const}\par
00144 {\cf17                             }\{ {\cf19 return} (_spritesCollisionHappened); \}\par
00145         {\cf18 void} setSpritesCollision ({\cf18 bool} c)\par
00146                             \{ _spritesCollisionHappened = c; \}\par
00147         {\cf18 bool} spriteCollisionHappened ({\cf18 size_t} p){\cf17  const}\par
00148 {\cf17                             }\{ {\cf19 return} (_spriteCollisionHappened [p]); \}\par
00149         {\cf18 void} setSpriteCollision ({\cf18 size_t} p, {\cf18 bool} c)\par
00150                             \{ _spriteCollisionHappened [p] = c; \}\par
00151         {\cf18 bool} lightPenOnScreenHappened (){\cf17  const}\par
00152 {\cf17                             }\{ {\cf19 return} (_lightPenOnScreenHappened); \}\par
00153         {\cf18 void} setLightPenOnScreen ({\cf18 bool} l)\par
00154                             \{ _lightPenOnScreenHappened = l; \}\par
00155         {\cf18 bool} vicIItoGenerateIRQ (){\cf17  const}\par
00156 {\cf17                             }\{ {\cf19 return} (_vicIItoGenerateIRQ); \}\par
00157         {\cf18 void} setVicIItoGenerateIRQ ({\cf18 bool} v)\par
00158                             \{ _vicIItoGenerateIRQ = v; \}\par
00159 \par
00160         {\cf18 unsigned} {\cf18 char} bank (){\cf17  const}\par
00161 {\cf17                             }\{ {\cf19 return} (_bank); \}\par
00162         {\cf18 void} setBank ({\cf18 unsigned} {\cf18 char} bk)\par
00163                             \{ {\cf19 if} (bk == 0 || bk == 1 || bk == 2 || bk == 3) _bank = bk; \}\par
00164         \par
00165         {\cf17 virtual} {\cf18 void} initialize () {\cf17 override};\par
00166 \par
00167         {\cf17 private}:\par
00168         {\cf17 virtual} {\cf18 void} setValue ({\cf18 size_t} p, {\cf17 const} MCHEmul::UByte& v) {\cf17 override};\par
00169         {\cf17 virtual} {\cf17 const} MCHEmul::UByte& readValue ({\cf18 size_t} p) {\cf17 const override};\par
00170 \par
00171         {\cf20 // Implementation}\par
00173 {\cf20 }        {\cf18 void} initializeInternalValues ();\par
00175         {\cf18 void} setGraphicModeActive ();\par
00176 \par
00177         {\cf17 private}:\par
00178         {\cf20 // The VICII registers}\par
00180 {\cf20 }        {\cf18 unsigned} {\cf18 char} _borderColor;\par
00181         std::vector <unsigned char> _backgroundColor;\par
00183         std::vector <unsigned short> _spriteXCoord; \par
00184         std::vector <unsigned char> _spriteYCoord;\par
00185         std::vector <unsigned char> _spriteColor;\par
00186         std::vector <unsigned char> _spriteSharedColor;\par
00187         std::vector <bool> _spriteMulticolor;\par
00188         std::vector <bool> _spriteEnabled;\par
00189         std::vector <bool> _spriteDoubleWidth, _spriteDoubleHeight;\par
00190         std::vector <bool> _spriteToForegroundPriority;\par
00192         {\cf18 unsigned} {\cf18 char} _verticalScrollPosition, _horizontalScrollPosition;\par
00194         {\cf18 bool} _textDisplay25RowsActive, _textDisplay40ColumnsActive;\par
00195         {\cf18 bool} _screenSameColorBorderActive;\par
00196         {\cf18 bool} _videoResetActive;\par
00198         {\cf18 bool} _graphicBitModeActive;\par
00199         {\cf18 bool} _graphicExtendedColorTextModeActive;\par
00200         {\cf18 bool} _graphicMulticolorTextModeActive;\par
00201         GraphicMode _graphicModeActive;\par
00203         {\cf18 bool} _rasterIRQActive;\par
00204         {\cf18 bool} _spriteCollisionWithDataIRQActive;\par
00205         {\cf18 bool} _spriteCollisionsIRQActive;\par
00206         {\cf18 bool} _lightPenIRQActive;\par
00208         {\cf18 unsigned} {\cf18 short} _IRQRasterLineAt; {\cf20 // To define where to launch the IRQ. When reading therre is other variable...}\par
00210 {\cf20 }        MCHEmul::Address _charDataMemory; {\cf20 // Info about the characters (the address with in the first 16k)}\par
00211         MCHEmul::Address _screenMemory; {\cf20 // Where the characters to draw are (The address within the first 16k)}\par
00212         MCHEmul::Address _bitmapMemory; {\cf20 // Where the bitmap to draw is (The address within the first 16k)}\par
00213 \par
00214         {\cf20 // Some of this variables are set by the emulation of the VICII}\par
00215         {\cf20 // The VICII chip also uses this object as a temporary storage}\par
00216         {\cf18 unsigned} {\cf18 short} _currentRasterLine;\par
00217         {\cf18 unsigned} {\cf18 short} _currentLightPenHorizontalPosition, _currentLightPenVerticalPosition;\par
00218         {\cf18 bool} _rasterAtIRQLine;\par
00219         {\cf18 bool} _spritesCollisionWithDataHappened; \par
00220         {\cf17 mutable} std::vector <bool> _spriteCollisionWithDataHappened; {\cf20 // Are modified when reading...}\par
00221         {\cf18 bool} _spritesCollisionHappened; \par
00222         {\cf17 mutable} std::vector <bool> _spriteCollisionHappened;\par
00223         {\cf18 bool} _lightPenOnScreenHappened;\par
00224         {\cf18 bool} _vicIItoGenerateIRQ;\par
00225 \par
00229         {\cf18 unsigned} {\cf18 char} _bank; \par
00230 \par
00231         {\cf20 // Implementation}\par
00232         {\cf17 mutable} MCHEmul::UByte _lastValueRead;\par
00233     \};\par
00234 \}\par
00235 \par
00236 {\cf21 #endif}\par
00237   \par
00238 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/Channel.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/Channel.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/Channel.hpp}
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <COMMS/IPAddress.hpp>}\par
{\f2 #include <COMMS/Message.hpp>}\par
{\f2 #include <RakPeerInterface.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::PeerCommunicationChannel}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Channel.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/Channel.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/Channel.hpp}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_COMMCHANNEL__}\par
00015 {\cf21 #define __MCHEMUL_COMMCHANNEL__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <COMMS/IPAddress.hpp>}\par
00019 {\cf21 #include <COMMS/Message.hpp>}\par
00020 {\cf21 #include <RakPeerInterface.h>}\par
00021 \par
00022 {\cf17 namespace }MCHEmul\par
00023 \{\par
00028     {\cf17 class }PeerCommunicationChannel\par
00029     \{\par
00030         {\cf17 public}:\par
00037         PeerCommunicationChannel ({\cf18 unsigned} {\cf18 short} p, {\cf18 unsigned} {\cf18 int} nC, {\cf17 const} IPAddress& a = IPAddress ());\par
00038 \par
00039         PeerCommunicationChannel ({\cf17 const} PeerCommunicationChannel&) = {\cf17 delete};\par
00040 \par
00041         PeerCommunicationChannel& operator = ({\cf17 const} PeerCommunicationChannel&) = {\cf17 delete};\par
00042 \par
00043         {\cf17 virtual} ~PeerCommunicationChannel ();\par
00044 \par
00045         {\cf20 // Channel data...}\par
00046         {\cf18 unsigned} {\cf18 short} listenAtPort (){\cf17  const}\par
00047 {\cf17                             }\{ {\cf19 return} (_listenAtPort); \}\par
00048         {\cf18 unsigned} {\cf18 short} simulatenousConnections (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_simultaneousConnections); \}\par
00050         {\cf17 const} IPAddress& connectedTo () const {\cf20 // IPAddress () when none...}\par
00051                             \{ {\cf19 return} (_connectedTo); \}\par
00052 \par
00053         {\cf20 // Mamanging the Status of the channel}\par
00054         {\cf18 bool} initialize ();\par
00055         {\cf18 bool} isChannelInitiated ()\par
00056                             \{ {\cf19 return} (_channelInitialized); \}\par
00057         {\cf18 bool} isChannelConnected ()\par
00058                             \{ {\cf19 return} (_channelConnected); \}\par
00059         {\cf18 bool} finalize ();\par
00060 \par
00061         {\cf20 // Managing the communication}\par
00065 {\cf20 }        {\cf18 bool} receive (std::string& str, IPAddress& from);\par
00069         {\cf18 bool} send ({\cf17 const} std::string& str, {\cf17 const} IPAddress& to);\par
00070         {\cf18 bool} send ({\cf17 const} CommunicationMessage& msg, {\cf17 const} IPAddress& to)\par
00071                             \{ {\cf19 return} (send (msg.toString (), to)); \}\par
00074         {\cf18 bool} send ({\cf17 const} std::string& str)\par
00075                             \{ {\cf19 return} (send (str, _connectedTo)); \}\par
00076         {\cf18 bool} send ({\cf17 const} CommunicationMessage& msg)\par
00077                             \{ {\cf19 return} (send (msg.toString ())); \}\par
00078 \par
00079         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00080 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00081 \par
00082         {\cf18 bool} operator ! (){\cf17  const}\par
00083 {\cf17                             }\{ {\cf19 return} (_lastError != MCHEmul::_NOERROR); \}\par
00084 \par
00085         {\cf17 protected}:\par
00086         {\cf17 const} {\cf18 unsigned} {\cf18 short} _listenAtPort; \par
00087         {\cf17 const} {\cf18 unsigned} {\cf18 short} _simultaneousConnections;\par
00088         {\cf17 const} IPAddress _connectedTo;\par
00089     \par
00090         {\cf20 // Implementation}\par
00091         RakNet::RakPeerInterface* _peer;\par
00092         {\cf17 mutable} {\cf18 bool} _channelInitialized;\par
00093         {\cf17 mutable} {\cf18 bool} _channelConnected;\par
00094         {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastError;\par
00095     \};\par
00096 \}\par
00097 \par
00098 {\cf21 #endif}\par
00099   \par
00100 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/IPAddress.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/IPAddress.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/IPAddress.hpp}
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::IPAddress}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IPAddress.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/IPAddress.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/IPAddress.hpp}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_IPADDRESS__}\par
00015 {\cf21 #define __MCHEMUL_IPADDRESS__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00022     {\cf17 class }IPAddress\par
00023     \{\par
00024         {\cf17 public}:\par
00025         IPAddress ()\par
00026             : _a (0), _b (0), _c (0), _d (0), _port (0), _error (true)\par
00027                         \{ \}\par
00028 \par
00029         IPAddress ({\cf18 unsigned} {\cf18 char} a, {\cf18 unsigned} {\cf18 char} b, {\cf18 unsigned} {\cf18 char} c, {\cf18 unsigned} {\cf18 char} d, {\cf18 unsigned} {\cf18 short} p)\par
00030             : _a (a), _b (b), _c (c), _d (d), _port (p), _error (false)\par
00031                         \{ assert (_a <= 0xff && _b <= 0xff && _c < 0xff && _port <= 0xfff); \}\par
00032 \par
00033         IPAddress ({\cf17 const} std::string& ip);\par
00034 \par
00035         IPAddress ({\cf17 const} IPAddress&) = {\cf19 default};\par
00036 \par
00037         IPAddress& operator = ({\cf17 const} IPAddress&) = {\cf19 default};\par
00038 \par
00040         {\cf18 unsigned} {\cf18 char} byte1 (){\cf17  const}\par
00041 {\cf17                         }\{ {\cf19 return} (_a); \}\par
00042         {\cf18 unsigned} {\cf18 char} byte2 (){\cf17  const}\par
00043 {\cf17                         }\{ {\cf19 return} (_b); \}\par
00044         {\cf18 unsigned} {\cf18 char} byte3 (){\cf17  const}\par
00045 {\cf17                         }\{ {\cf19 return} (_c); \}\par
00046         {\cf18 unsigned} {\cf18 char} byte4 (){\cf17  const}\par
00047 {\cf17                         }\{ {\cf19 return} (_d); \}\par
00048         {\cf18 unsigned} {\cf18 short} port (){\cf17  const}\par
00049 {\cf17                         }\{ {\cf19 return} (_port); \}\par
00050 \par
00051         std::string ipAsString (){\cf17  const}\par
00052 {\cf17                         }\{ {\cf19 return} (std::to_string (_a) + {\cf22 "."} + std::to_string (_b) + {\cf22 "."} + std::to_string (_c)); \}\par
00053         std::string asString (){\cf17  const}\par
00054 {\cf17                         }\{ {\cf19 return} (ipAsString () + {\cf22 ":"} + std::to_string (_port)); \}\par
00055 \par
00056         {\cf18 bool} error (){\cf17  const}\par
00057 {\cf17                         }\{ {\cf19 return} (_error); \}\par
00058 \par
00060         {\cf18 bool} operator ! (){\cf17  const}\par
00061 {\cf17                         }\{ {\cf19 return} (_error); \}\par
00062 \par
00063         {\cf18 bool} operator == ({\cf17 const} IPAddress& a){\cf17  const}\par
00064 {\cf17                         }\{ {\cf19 return} (_a == a._a && _b == a._b && _c == a._c && _d == a._d && _port == a._port); \}\par
00065         {\cf18 bool} operator != ({\cf17 const} IPAddress& a){\cf17  const}\par
00066 {\cf17                         }\{ {\cf19 return} (_a != a._a || _b != a._b || _c != a._c || _d != a._d || _port != a._port); \}\par
00067 \par
00068         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} IPAddress& a)\par
00069                         \{ {\cf19 return} (o << ((a._error) ? {\cf22 "Error"} : a.asString ())); \}\par
00070 \par
00071         {\cf17 private}:\par
00072         {\cf18 unsigned} {\cf18 char} _a, _b, _c, _d;\par
00073         {\cf18 unsigned} {\cf18 short} _port;\par
00074         {\cf17 mutable} {\cf18 bool} _error;\par
00075     \};\par
00076 \}\par
00077 \par
00078 {\cf21 #endif}\par
00079   \par
00080 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/Message.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/Message.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/Message.hpp}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <COMMS/IPAddress.hpp>}\par
{\f2 #include <MessageIdentifiers.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::CommunicationMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::MessageBuilder}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Message.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/Message.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/Message.hpp}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_COMMMESSAGE__}\par
00015 {\cf21 #define __MCHEMUL_COMMMESSAGE__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <COMMS/IPAddress.hpp>}\par
00019 {\cf21 #include <MessageIdentifiers.h>}\par
00020 \par
00021 {\cf17 namespace }MCHEmul\par
00022 \{\par
00023     {\cf17 class }Computer;\par
00024 \par
00027     {\cf17 class }CommunicationMessage\par
00028     \{\par
00029         {\cf17 public}:\par
00031         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _MESSAGEID = \par
00032             DefaultMessageIDTypes::ID_USER_PACKET_ENUM + 1;\par
00033 \par
00034         CommunicationMessage ({\cf18 unsigned} {\cf18 char} t, {\cf17 const} Attributes& a)\par
00035             : _type (t), _attributes (a),\par
00036               _error (false)\par
00037                             \{ \}\par
00038 \par
00040         CommunicationMessage ({\cf17 const} CommunicationMessage&) = {\cf17 delete};\par
00041 \par
00042         CommunicationMessage& operator = ({\cf17 const} CommunicationMessage&) = {\cf17 delete};\par
00043 \par
00044         {\cf17 virtual} ~CommunicationMessage ()\par
00045                             \{ \}\par
00046 \par
00047         {\cf18 unsigned} {\cf18 char} type (){\cf17  const}\par
00048 {\cf17                             }\{ {\cf19 return} (_type); \}\par
00049 \par
00050         {\cf17 const} Attributes attributes (){\cf17  const}\par
00051 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00052 \par
00053         std::string toString () {\cf17 const};\par
00054 \par
00061         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} executeOn (Computer*, CommunicationMessage*&) = 0;\par
00062 \par
00063         {\cf17 protected}:\par
00065         {\cf18 unsigned} {\cf18 int} _type;\par
00067         Attributes _attributes;\par
00068 \par
00069         {\cf20 // Implementation}\par
00070         {\cf18 bool} _error;\par
00071     \};\par
00072 \par
00085     {\cf17 class }MessageBuilder\par
00086     \{\par
00087         {\cf17 public}:\par
00088         MessageBuilder ()\par
00089                             \{ \}\par
00090 \par
00092         MessageBuilder ({\cf17 const} MessageBuilder&) = {\cf17 delete};\par
00093 \par
00094         MessageBuilder& operator = ({\cf17 const} MessageBuilder&) = {\cf17 delete};\par
00095 \par
00096         {\cf17 virtual} ~MessageBuilder ()\par
00097                             \{ \}\par
00098 \par
00099         {\cf17 virtual} CommunicationMessage* createMessage ({\cf17 const} std::string&) = 0;\par
00100 \par
00101         {\cf17 protected}:\par
00102         {\cf20 // Implementation}\par
00104 {\cf20 }        {\cf18 bool} verifyStructure ({\cf17 const} std::string& str);\par
00106         Attributes attributesFromStr ({\cf17 const} std::string& str) {\cf17 const};\par
00107     \};\par
00108 \}\par
00109 \par
00110 {\cf21 #endif}\par
00111   \par
00112 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/StdMessages.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/StdMessages.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/StdMessages.hpp}
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <COMMS/Message.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::StandardMessageBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::GetRegisterStatusMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::GetMemoryDataMessage}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StdMessages.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/StdMessages.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/StdMessages.hpp}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_STDMESSAGES__}\par
00015 {\cf21 #define __MCHEMUL_STDMESSAGES__}\par
00016 \par
00017 {\cf21 #include <COMMS/Message.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00023     {\cf17 class }StandardMessageBuilder : {\cf17 public} MessageBuilder\par
00024     \{\par
00025         {\cf17 public}:\par
00026         StandardMessageBuilder ()\par
00027             : MessageBuilder ()\par
00028                             \{ \}\par
00029 \par
00030         {\cf17 virtual} CommunicationMessage* createMessage ({\cf17 const} std::string& str) {\cf17 override};\par
00031     \};\par
00032 \par
00034     {\cf17 class }GetRegisterStatusMessage : {\cf17 public} CommunicationMessage\par
00035     \{\par
00036         {\cf17 public}:\par
00037         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _ID = {\cf23 'A'};\par
00038 \par
00039         GetRegisterStatusMessage ({\cf17 const} Attributes& a)\par
00040             : CommunicationMessage (_ID, a)\par
00041                             \{ \}\par
00042 \par
00043         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} executeOn (Computer* c, CommunicationMessage*& ans) {\cf17 override};\par
00044     \};\par
00045 \par
00047     {\cf17 class }GetMemoryDataMessage : {\cf17 public} CommunicationMessage\par
00048     \{\par
00049         {\cf17 public}:\par
00050         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _ID = {\cf23 'B'};\par
00051 \par
00052         GetMemoryDataMessage ({\cf17 const} Attributes& a)\par
00053             : CommunicationMessage (_ID, a)\par
00054                             \{ \}\par
00055 \par
00056         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} executeOn (Computer* c, CommunicationMessage*& ans) {\cf17 override};\par
00057     \};\par
00058 \}\par
00059 \par
00060 {\cf21 #endif}\par
00061   \par
00062 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/System.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/System.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/System.hpp}
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <COMMS/Channel.hpp>}\par
{\f2 #include <COMMS/Message.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::CommunicationSystem}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
System.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/System.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/System.hpp}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_COMMSSYS__}\par
00015 {\cf21 #define __MCHEMUL_COMMSSYS__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <COMMS/Channel.hpp>}\par
00019 {\cf21 #include <COMMS/Message.hpp>}\par
00020 \par
00021 {\cf17 namespace }MCHEmul\par
00022 \{\par
00023     {\cf17 class }Computer;\par
00024 \par
00025     {\cf17 class }CommunicationSystem\par
00026     \{\par
00027         {\cf17 public}:\par
00028         CommunicationSystem (PeerCommunicationChannel* cC, MessageBuilder* mB)\par
00029             : _communicationChannel (cC), _messageBuilder (mB),\par
00030               _error (false), _lastError (MCHEmul::_NOERROR)\par
00031                             \{ assert (_communicationChannel != {\cf17 nullptr} && _messageBuilder != {\cf17 nullptr}); \}\par
00032 \par
00033         CommunicationSystem ({\cf17 const} CommunicationSystem&) = {\cf17 delete};\par
00034 \par
00035         CommunicationSystem& operator = ({\cf17 const} CommunicationSystem&) = {\cf17 delete};\par
00036 \par
00037         {\cf17 virtual} ~CommunicationSystem ()\par
00038                             \{ {\cf17 delete} (_communicationChannel); {\cf17 delete} (_messageBuilder); \}\par
00039 \par
00040         {\cf20 // Managing the system...}\par
00041         {\cf17 virtual} {\cf18 bool} initialize ()\par
00042                             \{ {\cf19 return} (_communicationChannel -> initialize ()); \}\par
00044         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} processMessagesOn (Computer* c);\par
00045         {\cf17 virtual} {\cf18 bool} finalize ()\par
00046                             \{ {\cf19 return} (_communicationChannel -> finalize ()); \}\par
00047 \par
00048         {\cf18 bool} error (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_communicationChannel -> lastError ()); \}\par
00050 \par
00051         {\cf18 bool} operator ! (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (!_communicationChannel); \}\par
00053 \par
00054         {\cf17 protected}:\par
00055         MessageBuilder* _messageBuilder;\par
00056         PeerCommunicationChannel* _communicationChannel;\par
00057 \par
00058         {\cf20 // Implementation}\par
00059         {\cf18 bool} _error;\par
00060         {\cf18 unsigned} {\cf18 int} _lastError;\par
00061     \};\par
00062 \}\par
00063 \par
00064 {\cf21 #endif}\par
00065   \par
00066 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CONSOLE/Console.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CONSOLE/Console.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CONSOLE/Console.hpp}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <EMULATORS/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Console::Console}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Console}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Console.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CONSOLE/Console.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CONSOLE/Console.hpp}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __CONSOLE_CONSOLE__}\par
00015 {\cf21 #define __CONSOLE_CONSOLE__}\par
00016 \par
00017 {\cf21 #include <EMULATORS/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }Console\par
00020 \{\par
00021     {\cf17 class }Console \par
00022     \{\par
00023         {\cf17 public}:\par
00024         Console () = {\cf17 delete};\par
00025 \par
00026         Console (Emuls::Emulator* e, MCHEmul::CommandBuilder* cB);\par
00027 \par
00028         Console ({\cf17 const} Console&) = {\cf17 delete};\par
00029 \par
00030         Console& operator = ({\cf17 const} Console&) = {\cf17 delete};\par
00031 \par
00032         {\cf17 virtual} ~Console ()\par
00033                             \{ {\cf17 delete} (_commandBuilder); \}\par
00034 \par
00035         {\cf18 void} run ();\par
00036 \par
00037         {\cf17 protected}:\par
00039         {\cf18 bool} readCommand ();\par
00040 \par
00044         {\cf17 virtual} {\cf18 bool} readChar ({\cf18 char}& chr) {\cf17 const} = 0;\par
00045 \par
00046         {\cf17 protected}:\par
00047         Emuls::Emulator* _emulator;\par
00048         MCHEmul::CommandBuilder* _commandBuilder;\par
00049 \par
00050         {\cf20 // Implementation}\par
00051         std::string _command;\par
00052     \};\par
00053 \par
00054 {\cf21 #ifdef _WIN32}\par
00056     {\cf17 class }Win32Console final : {\cf17 public} Console\par
00057     \{\par
00058         {\cf17 public}:\par
00059         Win32Console (Emuls::Emulator* e, MCHEmul::CommandBuilder* cB)\par
00060             : Console (e, cB)\par
00061                             \{ \}\par
00062 \par
00063         {\cf17 protected}:\par
00064         {\cf17 virtual} {\cf18 bool} readChar ({\cf18 char}& chr) {\cf17 const override};\par
00065     \};\par
00066 {\cf21 #endif}\par
00067 \}\par
00068 \par
00069 {\cf21 #endif}\par
00070   \par
00071 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Address.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Address.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Address.hpp}
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/UInt.hpp>}\par
{\f2 #include <CORE/UBytes.hpp>}\par
{\f2 #include <CORE/UByte.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Address}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Address.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Address.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Address.hpp}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_ADDRESS__}\par
00015 {\cf21 #define __MCHEMUL_ADDRESS__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/UInt.hpp>}\par
00019 {\cf21 #include <CORE/UBytes.hpp>}\par
00020 {\cf21 #include <CORE/UByte.hpp>}\par
00021 \par
00022 {\cf17 namespace }MCHEmul\par
00023 \{\par
00027     {\cf17 class }Address final\par
00028     \{\par
00029         {\cf17 public}:\par
00030         Address ()\par
00031             : _value (UInt ())\par
00032                             \{ \}\par
00033 \par
00035         Address ({\cf17 const} UInt& a)\par
00036             : _value (a)\par
00037                             \{ \}\par
00038 \par
00039         Address ({\cf17 const} MCHEmul::UBytes& a, {\cf18 bool} bE = {\cf17 true})\par
00040             : _value (a, bE)\par
00041                             \{ \}\par
00042 \par
00043         Address ({\cf17 const} std::vector <UByte>& a, {\cf18 bool} bE = {\cf17 true})\par
00044             : _value (a, bE)\par
00045                             \{ \}\par
00046 \par
00047         Address ({\cf17 const} Address&) = {\cf19 default};\par
00048         Address& operator = ({\cf17 const} Address&) = {\cf19 default};\par
00049 \par
00050         {\cf18 size_t} size (){\cf17  const}\par
00051 {\cf17                             }\{ {\cf19 return} (_value.size ()); \}\par
00052 \par
00053         {\cf17 const} UInt& value (){\cf17  const}\par
00054 {\cf17                             }\{ {\cf19 return} (_value);\}\par
00055         {\cf17 const} UBytes& values (){\cf17  const}\par
00056 {\cf17                             }\{ {\cf19 return} (_value.values ()); \}\par
00057         {\cf17 const} std::vector <UByte>& bytes (){\cf17  const}\par
00058 {\cf17                             }\{ {\cf19 return} (_value.bytes ()); \}\par
00059 \par
00061         {\cf18 int} distanceWith ({\cf17 const} Address& a){\cf17  const}\par
00062 {\cf17                             }\{ {\cf19 return} (({\cf18 int}) a.value ().asUnsignedInt () - ({\cf18 int}) value ().asUnsignedInt ()); \}\par
00063 \par
00065         Address next ({\cf18 size_t} n){\cf17  const}\par
00066 {\cf17                             }\{ {\cf19 return} (Address (_value + UInt::fromUnsignedInt (({\cf18 unsigned} {\cf18 int}) n))); \}       \par
00067         Address previous ({\cf18 size_t} n){\cf17  const}\par
00068 {\cf17                             }\{ {\cf19 return} (Address (_value - UInt::fromUnsignedInt (({\cf18 unsigned} {\cf18 int}) n))); \}\par
00069 \par
00070         {\cf18 bool} operator == ({\cf17 const} Address& a){\cf17  const}\par
00071 {\cf17                             }\{ {\cf19 return} (_value == a._value); \}\par
00072         {\cf18 bool} operator != ({\cf17 const} Address& a){\cf17  const}\par
00073 {\cf17                             }\{ {\cf19 return} (_value != a._value); \}\par
00074         {\cf18 bool} operator < ({\cf17 const} Address& a){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_value < a._value); \}\par
00076         {\cf18 bool} operator <= ({\cf17 const} Address& a){\cf17  const}\par
00077 {\cf17                             }\{ {\cf19 return} (_value <= a._value); \}\par
00078         {\cf18 bool} operator > ({\cf17 const} Address& a){\cf17  const}\par
00079 {\cf17                             }\{ {\cf19 return} (_value > a._value); \}\par
00080         {\cf18 bool} operator >= ({\cf17 const} Address& a){\cf17  const}\par
00081 {\cf17                             }\{ {\cf19 return} (_value >= a._value); \}\par
00082 \par
00083         Address operator + ({\cf18 size_t} n){\cf17  const}\par
00084 {\cf17                             }\{ {\cf19 return} (Address (*this).next (n)); \}\par
00085         {\cf17 friend} Address operator + ({\cf18 size_t} n, {\cf17 const} Address& a)\par
00086                             \{ {\cf19 return} (a + n); \}\par
00087         Address& operator += ({\cf18 size_t} n)\par
00088                             \{ *{\cf17 this} = *{\cf17 this} + n; {\cf19 return} (*{\cf17 this}); \}\par
00089         {\cf18 size_t} operator - ({\cf17 const} Address& a){\cf17  const}\par
00090 {\cf17                             }\{ {\cf19 return} ({\cf17 this} -> distanceWith (a)); \}\par
00091         Address operator - ({\cf18 size_t} n){\cf17  const}\par
00092 {\cf17                             }\{ {\cf19 return} (Address (*this).previous (n)); \}\par
00093         {\cf17 friend} Address operator - ({\cf18 size_t} n, {\cf17 const} Address& a)\par
00094                             \{ {\cf19 return} (a - n); \}\par
00095         Address& operator -= ({\cf18 size_t} n)\par
00096                             \{ *{\cf17 this} = *{\cf17 this} - n; {\cf19 return} (*{\cf17 this}); \}\par
00097         Address& operator -- ()\par
00098                             \{ {\cf19 return} (*{\cf17 this} -= 1); \}\par
00099 \par
00100         UByte operator [] ({\cf18 size_t} p){\cf17  const}\par
00101 {\cf17                             }\{ {\cf19 return} (_value [p]); \}\par
00102 \par
00103         std::string asString (UByte::OutputFormat oF){\cf17  const}\par
00104 {\cf17                             }\{ {\cf19 return} (_value.asString (oF, {\cf23 ' '}, 2)); \}\par
00105 \par
00106         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Address& a);\par
00107 \par
00112         {\cf17 static} Address fromStr ({\cf17 const} std::string& str);\par
00113 \par
00114         {\cf17 private}:\par
00115         UInt _value;\par
00116     \};\par
00117 \}\par
00118 \par
00119 {\cf21 #endif}\par
00120   \par
00121 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Chip.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Chip.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Chip.hpp}
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/Memory.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Chip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::NoChip}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Chips} = std::map< int, Chip * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Chip.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Chip.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Chip.hpp}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_CHIP__}\par
00015 {\cf21 #define __MCHEMUL_CHIP__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/Memory.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00022     {\cf17 class }CPU;\par
00023 \par
00027     {\cf17 class }Chip\par
00028     \{\par
00029         {\cf17 public}:\par
00030         Chip () = {\cf17 delete};\par
00031 \par
00032         Chip ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& attrs = \{ \})\par
00033             : _id ({\cf18 id}), _memory ({\cf17 nullptr}), _attributes (attrs), \par
00034               _lastError (_NOERROR) {\cf20 // Memory accessed can be null, take care...}\par
00035                             \{ \}\par
00036 \par
00037         Chip ({\cf17 const} Chip&) = {\cf17 delete};\par
00038 \par
00039         Chip& operator = ({\cf17 const} Chip&) = {\cf17 delete};\par
00040 \par
00042         {\cf17 virtual} ~Chip ()\par
00043                             \{ \} \par
00044 \par
00045         {\cf18 int} id (){\cf17  const}\par
00046 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00047 \par
00049         {\cf18 void} setMemoryRef (Memory* m)\par
00050                             \{ _memory = m; \}\par
00051         {\cf17 const} Memory* memoryRef (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_memory); \}\par
00053         Memory* memoryRef ()\par
00054                             \{ {\cf19 return} (_memory); \}\par
00055 \par
00056         {\cf17 const} Attributes& attributes (){\cf17  const}\par
00057 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00058         {\cf17 const} std::string& attribute ({\cf17 const} std::string& aN){\cf17  const}\par
00059 {\cf17                             }\{ Attributes::const_iterator i = _attributes.find (aN); \par
00060                               {\cf19 return} ((i == _attributes.end ()) ? AttributedNotDefined : (*i).second); \}\par
00061 \par
00065         {\cf17 virtual} {\cf18 bool} initialize () = 0;\par
00066 \par
00071         {\cf17 virtual} {\cf18 bool} simulate (CPU*) = 0;\par
00072 \par
00074         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00076         {\cf18 void} resetErrors ()\par
00077                             \{ _lastError = _NOERROR; \}\par
00078 \par
00079         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Chip& c);\par
00080 \par
00081         {\cf17 protected}:\par
00082         {\cf17 const} {\cf18 int} _id = -1; {\cf20 // Modified at construction level}\par
00083         Memory* _memory;\par
00084         {\cf17 const} Attributes _attributes = \{ \}; {\cf20 // Maybe modified at construction level}\par
00085 \par
00086         {\cf20 // Implementation}\par
00087         {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastError;\par
00088     \};\par
00089 \par
00090     {\cf17 using} Chips = std::map <int, Chip*>;\par
00091 \par
00093     {\cf17 class }NoChip final : {\cf17 public} Chip\par
00094     \{\par
00095         {\cf17 public}:\par
00096         NoChip ()\par
00097             : Chip (0)\par
00098                             \{ \}\par
00099 \par
00100         {\cf17 virtual} {\cf18 bool} initialize (){\cf17  override}\par
00101 {\cf17                             }\{ {\cf19 return} ({\cf17 true}); \}\par
00102 \par
00103         {\cf17 virtual} {\cf18 bool} simulate (CPU*){\cf17  override}\par
00104 {\cf17                             }\{ {\cf19 return} ({\cf17 true}); \}\par
00105     \};\par
00106 \par
00108     {\cf17 static} {\cf17 const} Chip* ChipNotValid = {\cf17 new} NoChip;\par
00109     {\cf17 static} Chip* TrashChip = {\cf17 new} NoChip;\par
00110 \}\par
00111 \par
00112 {\cf21 #endif}\par
00113   \par
00114 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Command.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Command.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Command.hpp}
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Command}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Command.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Command.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Command.hpp}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __CONSOLE_COMMANDCONSOLE__}\par
00015 {\cf21 #define __CONSOLE_COMMANDCONSOLE__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00021     {\cf17 class }Command \par
00022     \{\par
00023         {\cf17 public}:\par
00024         Command () = {\cf17 delete};\par
00025 \par
00026         Command ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& prms = \{ \})\par
00027             : _id ({\cf18 id}), _parameters (prms)\par
00028                             \{ \}\par
00029 \par
00030         Command ({\cf17 const} Command&) = {\cf19 default};\par
00031 \par
00032         Command& operator = ({\cf17 const} Command&) = {\cf19 default};\par
00033 \par
00034         {\cf17 virtual} ~Command ()\par
00035                             \{ \}\par
00036 \par
00037         {\cf18 int} id (){\cf17  const}\par
00038 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00039         {\cf17 const} Attributes& parameters (){\cf17  const}\par
00040 {\cf17                             }\{ {\cf19 return} (_parameters); \}\par
00041         {\cf18 void} setParameters ({\cf17 const} Attributes& prms)\par
00042                             \{ _parameters = prms; \}\par
00043 \par
00044         {\cf17 virtual} {\cf18 bool} canBeExecuted () {\cf17 const} = 0;\par
00045 \par
00046         {\cf17 virtual} {\cf18 bool} execute (Computer* c, {\cf17 const} Attributes& rst) = 0;\par
00047 \par
00048         {\cf17 protected}:\par
00049         {\cf18 int} _id;\par
00050         Attributes _parameters;\par
00051     \};\par
00052 \}\par
00053 \par
00054 {\cf21 #endif}\par
00055   \par
00056 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/CommandBuilder.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CommandBuilder.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CommandBuilder.hpp}
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Command.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::CommandBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::StandardCommandBuilder}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CommandBuilder.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CommandBuilder.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CommandBuilder.hpp}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __CONSOLE_COMMANDBUILDER__}\par
00015 {\cf21 #define __CONSOLE_COMMANDBUILDER__}\par
00016 \par
00017 {\cf21 #include <CORE/Command.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00022     {\cf17 class }CommandBuilder\par
00023     \{\par
00024         {\cf17 public}:\par
00025         {\cf17 virtual} ~CommandBuilder ()\par
00026                             \{ \}\par
00027 \par
00028         Command* createCommand ({\cf17 const} std::string& cmd) {\cf17 const};\par
00029 \par
00030         {\cf17 protected}:\par
00031         {\cf17 virtual} Command* createEmptyCommand ({\cf17 const} std::string& cmdName) {\cf17 const} = 0;\par
00032 \par
00033         {\cf20 // Implementation}\par
00034         std::string readCommandName ({\cf17 const} std::string& cmd) {\cf17 const};\par
00035         Attributes readCommandParameters ({\cf17 const} std::string& cmd) {\cf17 const};\par
00036     \};\par
00037 \par
00039     {\cf17 class }StandardCommandBuilder : {\cf17 public} CommandBuilder\par
00040     \{\par
00041         {\cf17 protected}:\par
00042         {\cf17 virtual} Command* createEmptyCommand ({\cf17 const} std::string& cmdName) {\cf17 const override};\par
00043     \};\par
00044 \}\par
00045 \par
00046 {\cf21 #endif}\par
00047   \par
00048 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Computer.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Computer.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Computer.hpp}
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/CPU.hpp>}\par
{\f2 #include <CORE/Chip.hpp>}\par
{\f2 #include <CORE/GraphicalChip.hpp>}\par
{\f2 #include <CORE/Memory.hpp>}\par
{\f2 #include <CORE/Register.hpp>}\par
{\f2 #include <CORE/Instruction.hpp>}\par
{\f2 #include <CORE/IO.hpp>}\par
{\f2 #include <CORE/Screen.hpp>}\par
{\f2 #include <CORE/OSIO.hpp>}\par
{\f2 #include <chrono>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Computer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Computer::Clock}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Computer.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Computer.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Computer.hpp}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHMUL_COMPUTER__}\par
00015 {\cf21 #define __MCHMUL_COMPUTER__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/CPU.hpp>}\par
00019 {\cf21 #include <CORE/Chip.hpp>}\par
00020 {\cf21 #include <CORE/GraphicalChip.hpp>}\par
00021 {\cf21 #include <CORE/Memory.hpp>}\par
00022 {\cf21 #include <CORE/Register.hpp>}\par
00023 {\cf21 #include <CORE/Instruction.hpp>}\par
00024 {\cf21 #include <CORE/IO.hpp>}\par
00025 {\cf21 #include <CORE/Screen.hpp>}\par
00026 {\cf21 #include <CORE/OSIO.hpp>}\par
00027 {\cf21 #include <chrono>}\par
00028 \par
00029 {\cf17 namespace }MCHEmul\par
00030 \{\par
00033     {\cf17 class }Computer\par
00034     \{\par
00035         {\cf17 public}:\par
00036         Computer () = {\cf17 delete};\par
00037 \par
00042         Computer (CPU* cpu, {\cf17 const} Chips& c, Memory* m, {\cf17 const} IODevices& d, {\cf18 unsigned} {\cf18 int} cs, {\cf17 const} Attributes& attrs = \{ \});\par
00043 \par
00044         Computer ({\cf17 const} Computer&) = {\cf17 delete};\par
00045 \par
00046         {\cf17 virtual} ~Computer (); \par
00047 \par
00048         Computer& operator = ({\cf17 const} Computer&) = {\cf17 delete};\par
00049 \par
00050         {\cf17 const} CPU* cpu (){\cf17  const}\par
00051 {\cf17                             }\{ {\cf19 return} (_cpu); \}\par
00052         CPU* cpu ()\par
00053                             \{ {\cf19 return} (_cpu); \}\par
00054 \par
00055         {\cf17 const} Chips& chips (){\cf17  const}\par
00056 {\cf17                             }\{ {\cf19 return} (_chips); \}\par
00057         {\cf18 bool} existsChip ({\cf18 int} {\cf18 id}){\cf17  const}\par
00058 {\cf17                             }\{ {\cf19 return} (_chips.find ({\cf18 id}) != _chips.end ()); \}\par
00059         {\cf17 const} Chip* chip ({\cf18 int} {\cf18 id}){\cf17  const}\par
00060 {\cf17                             }\{ {\cf19 return} (existsChip ({\cf18 id}) ? (*_chips.find ({\cf18 id})).second : ChipNotValid); \}\par
00061         Chip* chip ({\cf18 int} {\cf18 id})\par
00062                             \{ {\cf19 return} (existsChip ({\cf18 id}) ? (*_chips.find ({\cf18 id})).second : TrashChip); \}\par
00064         {\cf17 const} GraphicalChip* graphicalChip (){\cf17  const}\par
00065 {\cf17                             }\{ {\cf19 return} (_graphicalChip); \}\par
00066         GraphicalChip* graphicalChip ()\par
00067                             \{ {\cf19 return} (_graphicalChip); \}\par
00068 \par
00069         {\cf17 const} Memory* memory (){\cf17  const}\par
00070 {\cf17                             }\{ {\cf19 return} (_memory); \}\par
00071         Memory* memory ()\par
00072                             \{ {\cf19 return} (_memory); \}\par
00073 \par
00074         {\cf17 const} IODevices& devices (){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_devices); \}\par
00076         {\cf18 bool} existsDevice ({\cf18 int} {\cf18 id}){\cf17  const}\par
00077 {\cf17                             }\{ {\cf19 return} (_devices.find ({\cf18 id}) != _devices.end ()); \}\par
00078         {\cf17 const} IODevice* device ({\cf18 int} {\cf18 id}){\cf17  const}\par
00079 {\cf17                             }\{ {\cf19 return} (existsDevice ({\cf18 id}) ? (*_devices.find ({\cf18 id})).second : {\cf17 nullptr}); \}\par
00080         IODevice* device ({\cf18 int} {\cf18 id})\par
00081                             \{ {\cf19 return} (existsDevice ({\cf18 id}) ? (*_devices.find ({\cf18 id})).second : {\cf17 nullptr}); \}\par
00082 \par
00086         {\cf17 virtual} {\cf18 bool} connect (IOPeripheral* p, IODevice* d) = 0;\par
00087 \par
00088         {\cf17 const} Screen* screen (){\cf17  const}\par
00089 {\cf17                             }\{ {\cf19 return} (_screen); \}\par
00090         Screen* screen ()\par
00091                             \{ {\cf19 return} (_screen); \}\par
00092         {\cf17 const} InputOSSystem* inputOSSystem (){\cf17  const}\par
00093 {\cf17                             }\{ {\cf19 return} (_inputOSSystem); \}\par
00094         InputOSSystem* inputOSSytem ()\par
00095                             \{ {\cf19 return} (_inputOSSystem); \}\par
00096 \par
00097         {\cf18 unsigned} {\cf18 int} cyclesPerSecond (){\cf17  const}\par
00098 {\cf17                             }\{ {\cf19 return} (_clock.cyclesPerSecond ()); \}\par
00099 \par
00100         {\cf17 const} Attributes& attributes (){\cf17  const}\par
00101 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00102         {\cf17 const} std::string& attribute ({\cf17 const} std::string& aN){\cf17  const}\par
00103 {\cf17                             }\{ Attributes::const_iterator i = _attributes.find (aN); \par
00104                               {\cf19 return} ((i == _attributes.end ()) ? AttributedNotDefined : (*i).second); \}\par
00105 \par
00106         {\cf20 // To load data files...}\par
00107         {\cf18 bool} loadInto ({\cf17 const} std::string& fN, {\cf17 const} Address& a)\par
00108                             \{ {\cf19 return} (memory () -> loadInto (fN, a)); \}\par
00109 \par
00114         {\cf17 virtual} {\cf18 bool} initialize ();\par
00115 \par
00120         {\cf18 bool} run ();\par
00121         \par
00123         {\cf18 void} startsCycle ()\par
00124                             \{ _clock.start (_cpu -> clockCycles ()); \}\par
00126         {\cf18 bool} runComputerCycle ();\par
00129         {\cf18 bool} runIOCycle ();\par
00131         {\cf18 void} finishCycle ()\par
00132                             \{ _clock.waitFor (_cpu -> clockCycles ()); \}\par
00133 \par
00134         {\cf18 bool} exit (){\cf17  const}\par
00135 {\cf17                             }\{ {\cf19 return} (_exit); \}\par
00136         {\cf18 void} setExit ({\cf18 bool} e)\par
00137                             \{ _exit = e; \}\par
00138 \par
00139         {\cf18 unsigned} {\cf18 int} debugLevel (){\cf17  const}\par
00140 {\cf17                             }\{ {\cf19 return} (_debugLevel); \}\par
00141         {\cf18 void} setDebugLevel ({\cf18 unsigned} {\cf18 int} dL)\par
00142                             \{ _debugLevel = dL; \}\par
00143 \par
00145         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00146 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00147         {\cf18 void} resetErrors ()\par
00148                             \{ _lastError = _NOERROR; \}\par
00149 \par
00150         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Computer& c);\par
00151 \par
00152         {\cf17 protected}:\par
00155         {\cf17 class }Clock final\par
00156         \{\par
00157             {\cf17 public}:\par
00158             Clock () = {\cf17 delete};\par
00159 \par
00160             Clock ({\cf18 unsigned} {\cf18 int} cS)\par
00161                 : _cyclesPerSecond (cS),\par
00162                   _initialClockCycles (0), _iClock ()\par
00163                             \{ assert (_cyclesPerSecond > 0); \}\par
00164 \par
00165             Clock ({\cf17 const} Clock&) = {\cf19 default};\par
00166 \par
00167             Clock& operator = ({\cf17 const} Clock&) = {\cf19 default};\par
00168 \par
00169             {\cf18 unsigned} {\cf18 int} cyclesPerSecond (){\cf17  const}\par
00170 {\cf17                             }\{ {\cf19 return} (_cyclesPerSecond); \}\par
00171 \par
00172             {\cf18 void} start ({\cf18 unsigned} {\cf18 int} cC);\par
00173             {\cf18 void} waitFor ({\cf18 unsigned} {\cf18 int} cC);\par
00174 \par
00175             {\cf17 private}:\par
00176             {\cf18 unsigned} {\cf18 int} _cyclesPerSecond;\par
00177 \par
00178             {\cf20 // Implementation}\par
00179             {\cf18 unsigned} {\cf18 int} _initialClockCycles;\par
00180             std::chrono::time_point <std::chrono::steady_clock> _iClock;\par
00181         \};\par
00182             \par
00183         CPU* _cpu;\par
00184         Chips _chips; \par
00185         Memory* _memory;\par
00186         IODevices _devices;\par
00187         {\cf17 const} Attributes _attributes = \{ \}; {\cf20 // Maybe modified at construction level}\par
00188 \par
00191         {\cf18 bool} _exit;\par
00192 \par
00194         {\cf18 unsigned} {\cf18 int} _debugLevel;\par
00195 \par
00196         {\cf20 // Implementation}\par
00197         {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastError;\par
00198         Screen* _screen;\par
00199         InputOSSystem* _inputOSSystem;\par
00200         GraphicalChip* _graphicalChip;\par
00201         Clock _clock; {\cf20 // To maintain the sped of the compute...}\par
00202     \};\par
00203 \}\par
00204 \par
00205 {\cf21 #endif}\par
00206   \par
00207 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/CPU.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CPU.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CPU.hpp}
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/CPUArchitecture.hpp>}\par
{\f2 #include <CORE/Chip.hpp>}\par
{\f2 #include <CORE/Memory.hpp>}\par
{\f2 #include <CORE/Register.hpp>}\par
{\f2 #include <CORE/CPUInterrupt.hpp>}\par
{\f2 #include <CORE/ProgramCounter.hpp>}\par
{\f2 #include <CORE/StatusRegister.hpp>}\par
{\f2 #include <CORE/Instruction.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::CPU}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPU.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CPU.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CPU.hpp}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_CPU__}\par
00015 {\cf21 #define __MCHEMUL_CPU__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/CPUArchitecture.hpp>}\par
00019 {\cf21 #include <CORE/Chip.hpp>}\par
00020 {\cf21 #include <CORE/Memory.hpp>}\par
00021 {\cf21 #include <CORE/Register.hpp>}\par
00022 {\cf21 #include <CORE/CPUInterrupt.hpp>}\par
00023 {\cf21 #include <CORE/ProgramCounter.hpp>}\par
00024 {\cf21 #include <CORE/StatusRegister.hpp>}\par
00025 {\cf21 #include <CORE/Instruction.hpp>}\par
00026 \par
00027 {\cf17 namespace }MCHEmul\par
00028 \{\par
00030     {\cf17 class }CPU\par
00031     \{\par
00032         {\cf17 public}:\par
00033         CPU () = {\cf17 delete};\par
00034 \par
00035         CPU ({\cf17 const} CPUArchitecture& a, {\cf17 const} Registers& r, {\cf17 const} StatusRegister& sR, {\cf17 const} Instructions& ins)\par
00036             : _architecture (a), _registers (r), _statusRegister (sR), _instructions (ins),\par
00037               _programCounter (a.numberBytes ()), _memory (nullptr), _interrupts (),\par
00038               _lastInstruction (nullptr),\par
00039               _lastError (_NOERROR), _clockCycles (0)\par
00040                             \{ assert (_registers.size () > 0 && _instructions.size () > 0); \}\par
00041 \par
00042         CPU ({\cf17 const} CPU&) = {\cf17 delete};\par
00043 \par
00044         CPU& operator = ({\cf17 const} CPU&) = {\cf17 delete}; \par
00045 \par
00046         {\cf17 virtual} ~CPU ();\par
00047 \par
00048         {\cf17 const} CPUArchitecture& architecture (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_architecture); \}\par
00050 \par
00051         {\cf17 const} Registers& internalRegisters (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_registers); \}\par
00053         {\cf18 bool} existsInternalRegister ({\cf18 size_t} nR){\cf17  const}\par
00054 {\cf17                             }\{ {\cf19 return} (nR < _registers.size ()); \}\par
00055         {\cf17 const} Register& internalRegister ({\cf18 size_t} nR){\cf17  const}\par
00056 {\cf17                             }\{ {\cf19 return} (existsInternalRegister (nR) ? _registers [nR] : NoRegister); \}\par
00057         Register& internalRegister ({\cf18 size_t} nR)\par
00058                             \{ {\cf19 return} (existsInternalRegister (nR) ? _registers [nR] : TrashRegister); \}\par
00059         {\cf18 void} setInternalRegister ({\cf18 size_t} nR, UBytes v)\par
00060                             \{ {\cf19 if} (existsInternalRegister (nR) && internalRegister (nR).accept (v)) internalRegister (nR).set (v); \}\par
00061 \par
00062         {\cf17 const} ProgramCounter& programCounter (){\cf17  const}\par
00063 {\cf17                             }\{ {\cf19 return} (_programCounter); \}\par
00064         ProgramCounter& programCounter ()\par
00065                             \{ {\cf19 return} (_programCounter); \}\par
00066 \par
00067         {\cf17 const} StatusRegister& statusRegister (){\cf17  const}\par
00068 {\cf17                             }\{ {\cf19 return} (_statusRegister); \}\par
00069         StatusRegister& statusRegister ()\par
00070                             \{ {\cf19 return} (_statusRegister); \}\par
00071 \par
00072         {\cf18 bool} existsInstruction ({\cf18 unsigned} {\cf18 int} i){\cf17  const}\par
00073 {\cf17                             }\{ {\cf19 return} (_instructions.find (i) != _instructions.end ()); \}\par
00074         {\cf17 const} Instructions& instructions (){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_instructions); \}\par
00076         {\cf17 const} Instruction* instruction ({\cf18 unsigned} {\cf18 int} i){\cf17  const}\par
00077 {\cf17                             }\{ {\cf19 return} ((*_instructions.find (i)).second); \}\par
00078         Instruction* instruction ({\cf18 unsigned} {\cf18 int} i)\par
00079                             \{ {\cf19 return} ((*_instructions.find (i)).second); \}\par
00080 \par
00081         {\cf17 const} Instruction* lastInstruction (){\cf17  const}\par
00082 {\cf17                             }\{ {\cf19 return} (_lastInstruction); \}\par
00083 \par
00086         {\cf18 void} setMemoryRef (Memory* m)\par
00087                             \{ _memory = m; \}\par
00088         {\cf17 const} Memory* memoryRef (){\cf17  const}\par
00089 {\cf17                             }\{ {\cf19 return} (_memory); \}\par
00090         Memory* memoryRef () \par
00091                             \{ {\cf19 return} (_memory); \}\par
00092 \par
00093         {\cf18 unsigned} {\cf18 int} clockCycles (){\cf17  const}\par
00094 {\cf17                             }\{ {\cf19 return} (_clockCycles); \}\par
00095         {\cf18 void} addClockCycles ({\cf18 unsigned} {\cf18 int} cC)\par
00096                             \{ _clockCycles += cC; \}\par
00097 \par
00101         {\cf17 virtual} {\cf18 bool} initialize ();\par
00102 \par
00104         {\cf18 bool} existsInterrupt ({\cf18 int} {\cf18 id}){\cf17  const}\par
00105 {\cf17                             }\{ {\cf19 return} (_interrupts.find ({\cf18 id}) != _interrupts.end ()); \}\par
00106         {\cf17 const} CPUInterrupt* interrupt ({\cf18 int} {\cf18 id}){\cf17  const}\par
00107 {\cf17                             }\{ {\cf19 return} ((*_interrupts.find ({\cf18 id})).second); \}\par
00108         CPUInterrupt* interrupt ({\cf18 int} {\cf18 id})\par
00109                             \{ {\cf19 return} ((*_interrupts.find ({\cf18 id})).second); \}\par
00110         {\cf18 void} addInterrupt (CPUInterrupt* in);\par
00111         {\cf18 void} removeInterrrupt ({\cf18 int} {\cf18 id});\par
00112 \par
00114         {\cf18 bool} executeNextInstruction ();\par
00115 \par
00117         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00118 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00119         {\cf18 void} resetErrors ()\par
00120                             \{ _lastError = _NOERROR; \}\par
00121 \par
00122         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} CPU& c);\par
00123 \par
00124         {\cf17 protected}:\par
00125         {\cf17 const} CPUArchitecture _architecture = \par
00126             CPUArchitecture (2 , 1 ); {\cf20 // Adjusted at construction level}\par
00127         Registers _registers;\par
00128         {\cf17 const} Instructions _instructions = \{ \}; {\cf20 // Adjusted at construction level}\par
00129         ProgramCounter _programCounter;\par
00130         StatusRegister _statusRegister;\par
00131         Memory* _memory; {\cf20 // A reference...}\par
00132         CPUInterrups _interrupts;\par
00133 \par
00134         Instruction* _lastInstruction;\par
00135 \par
00136         {\cf20 // Implementation}\par
00137         {\cf18 unsigned} {\cf18 int} _lastError;\par
00138         {\cf18 unsigned} {\cf18 int} _clockCycles;\par
00139     \};\par
00140 \}\par
00141 \par
00142 {\cf21 #endif}\par
00143   \par
00144 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/CPUArchitecture.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CPUArchitecture.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CPUArchitecture.hpp}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/Register.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::CPUArchitecture}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPUArchitecture.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CPUArchitecture.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CPUArchitecture.hpp}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_CPUARCHITECTURE__}\par
00015 {\cf21 #define __MCHEMUL_CPUARCHITECTURE__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/Register.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00023     {\cf17 class }CPUArchitecture final\par
00024     \{\par
00025         {\cf17 public}:\par
00026         CPUArchitecture () = {\cf17 delete};\par
00027 \par
00028         CPUArchitecture ({\cf18 size_t} nb , {\cf18 size_t} iL, {\cf18 bool} bE = {\cf17 true}, {\cf17 const} Attributes& attrs = \{ \});\par
00029 \par
00030         CPUArchitecture ({\cf17 const} CPUArchitecture&) = {\cf19 default};\par
00031 \par
00032         CPUArchitecture& operator = ({\cf17 const} CPUArchitecture&) = {\cf19 default};\par
00033 \par
00034         {\cf18 size_t} numberBytes (){\cf17  const}\par
00035 {\cf17                             }\{ {\cf19 return} (_numberBytes); \}\par
00036         {\cf18 size_t} numberBits (){\cf17  const}\par
00037 {\cf17                             }\{ {\cf19 return} (_numberBits); \}\par
00038         {\cf18 size_t} instructionLength (){\cf17  const}\par
00039 {\cf17                             }\{ {\cf19 return} (_instructionLength); \}\par
00040         {\cf18 bool} bigEndian (){\cf17  const}\par
00041 {\cf17                             }\{ {\cf19 return} (_bigEndian); \}\par
00042 \par
00044         Register registerLength ({\cf18 int} {\cf18 id}, {\cf17 const} std::string& n, {\cf18 size_t} nb ){\cf17  const}\par
00045 {\cf17                             }\{ {\cf19 return} ((nb > 0 && nb <= _numberBytes) \par
00046                                 ? Register ({\cf18 id}, n, UBytes (std::vector <UByte> (nb, UByte::_0))) : NoRegister); \}\par
00048         {\cf17 const} Register& longestRegisterPossible (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_longestRegisterPossible); \}\par
00050 \par
00051         {\cf17 const} Attributes& attributes (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00053         {\cf17 const} std::string& attribute ({\cf17 const} std::string& aN){\cf17  const}\par
00054 {\cf17                             }\{ Attributes::const_iterator i = _attributes.find (aN); \par
00055                               {\cf19 return} ((i == _attributes.end ()) ? AttributedNotDefined : (*i).second); \}\par
00056 \par
00057         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} CPUArchitecture& a);\par
00058 \par
00059         {\cf17 private}:\par
00060         {\cf17 const} {\cf18 size_t} _numberBytes = 0; {\cf20 // Adjusted at construction level}\par
00061         {\cf17 const} {\cf18 size_t} _numberBits = 0; {\cf20 // Calculated at construction level}\par
00062         {\cf17 const} {\cf18 size_t} _instructionLength = 0; {\cf20 // Adjusted at construction level}\par
00063         {\cf17 const} {\cf18 bool} _bigEndian = {\cf17 true}; {\cf20 // Are the most significant Ubyte (in an address) the first or the last in values?}\par
00064         {\cf17 const} Attributes _attributes = \{ \}; {\cf20 // Optionaly adjusted at construction level}\par
00065         {\cf17 const} Register _longestRegisterPossible = NoRegister; {\cf20 // Calculated at construction level}\par
00066     \};\par
00067 \}\par
00068 \par
00069 {\cf21 #endif}\par
00070   \par
00071 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/CPUInterrupt.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CPUInterrupt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CPUInterrupt.hpp}
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::CPUInterrupt}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::CPUInterrups} = std::map< int, CPUInterrupt * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPUInterrupt.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CPUInterrupt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CPUInterrupt.hpp}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_CPUINTERRUPT__}\par
00015 {\cf21 #define __MCHEMUL_CPUINTERRUPT__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00021     {\cf17 class }CPU;\par
00022 \par
00024     {\cf17 class }CPUInterrupt\par
00025     \{\par
00026         {\cf17 public}:\par
00027         CPUInterrupt () = {\cf17 delete};\par
00028 \par
00029         CPUInterrupt ({\cf18 int} {\cf18 id})\par
00030             : _id (id), _active (false ),\par
00031               _lastClockCyclesExecuted (0)\par
00032                             \{ \}\par
00033 \par
00034         CPUInterrupt ({\cf17 const} CPUInterrupt&) = {\cf17 delete};\par
00035 \par
00036         {\cf17 virtual} ~CPUInterrupt ()\par
00037                             \{ \}\par
00038 \par
00039         CPUInterrupt& operator = ({\cf17 const} CPUInterrupt&) = {\cf17 delete};\par
00040 \par
00041         {\cf18 int} id (){\cf17  const}\par
00042 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00043 \par
00044         {\cf18 bool} active (){\cf17  const}\par
00045 {\cf17                             }\{ {\cf19 return} (_active); \}\par
00046         {\cf18 void} setActive ({\cf18 bool} a)\par
00047                             \{ _active = a; \}\par
00048 \par
00053         {\cf18 bool} executeOver (CPU* c, {\cf18 unsigned} {\cf18 int}& nC);\par
00054 \par
00055         {\cf17 protected}:\par
00056         {\cf20 // These methods are invoked by executeOver (defined above);}\par
00058 {\cf20 }        {\cf17 virtual} {\cf18 bool} isTime (CPU* c) {\cf17 const} = 0;\par
00061         {\cf17 virtual} {\cf18 void} executeOverImpl (CPU* c, {\cf18 unsigned} {\cf18 int}& nC) = 0;\par
00062 \par
00063         {\cf17 protected}:\par
00064         {\cf18 int} _id;\par
00065         {\cf18 bool} _active;\par
00066 \par
00067         {\cf20 // Implementation}\par
00068         {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastClockCyclesExecuted;\par
00069     \};\par
00070 \par
00072     {\cf17 using} CPUInterrups = std::map <int, CPUInterrupt*>;\par
00073 \}\par
00074 \par
00075 {\cf21 #endif}\par
00076   \par
00077 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/GraphicalChip.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/GraphicalChip.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/GraphicalChip.hpp}
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Chip.hpp>}\par
{\f2 #include <CORE/ScreenMemory.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::GraphicalChip}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GraphicalChip.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/GraphicalChip.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/GraphicalChip.hpp}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_GRAPHICALCHIP__}\par
00015 {\cf21 #define __MCHEMUL_GRAPHICALCHIP__}\par
00016 \par
00017 {\cf21 #include <CORE/Chip.hpp>}\par
00018 {\cf21 #include <CORE/ScreenMemory.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00030     {\cf17 class }GraphicalChip : {\cf17 public} Chip\par
00031     \{\par
00032         {\cf17 public}:\par
00033         GraphicalChip ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& attrs = \{ \})\par
00034             : Chip ({\cf18 id}, attrs), \par
00035               _screenMemory ({\cf17 nullptr}), \par
00036               _graphicsReady ({\cf17 false})\par
00037                             \{ \}\par
00038 \par
00039         ~GraphicalChip ()\par
00040                             \{ {\cf17 delete} (_screenMemory); \}\par
00041 \par
00042         {\cf17 const} ScreenMemory* screenMemory (){\cf17  const}\par
00043 {\cf17                             }\{ {\cf19 return} (_screenMemory); \}\par
00044         ScreenMemory* screenMemory ()\par
00045                             \{ {\cf19 return} (_screenMemory); \}\par
00046 \par
00047         {\cf18 bool} graphicsReady (){\cf17  const}\par
00048 {\cf17                             }\{ {\cf19 return} (_graphicsReady); \}\par
00049         {\cf18 void} setGraphicsReady ({\cf18 bool} gR) \par
00050                             \{ _graphicsReady = gR; \}\par
00051 \par
00052         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00053 \par
00054         {\cf17 protected}:\par
00056         {\cf17 virtual} ScreenMemory* createScreenMemory () = 0;\par
00057 \par
00058         {\cf17 protected}:\par
00059         ScreenMemory* _screenMemory;\par
00060 \par
00061         {\cf20 // Implementation}\par
00062         {\cf18 bool} _graphicsReady;\par
00063     \};\par
00064 \}\par
00065 \par
00066 {\cf21 #endif}\par
00067   \par
00068 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Instruction.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Instruction.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Instruction.hpp}
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/UBytes.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Instruction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Instruction::Structure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Instruction::Structure::Parameter}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _INST_FROM}(_C,  _M,  _CC,  _T,  _I,  _J)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _INST}(_C,  _M,  _CC,  _T,  _I)\~ 	{\b _INST_FROM}(_C, _M, _CC, _T, _I, {\b MCHEmul::Instruction});\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _INST_IMPL}(_I)\~ bool _I::executeImpl ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Instructions} = std::map< unsigned int, Instruction * >\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v _INST\:Instruction.hpp}
{\xe \v Instruction.hpp\:_INST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _INST( _C,  _M,  _CC,  _T,  _I)\~ 	{\b _INST_FROM}(_C, _M, _CC, _T, _I, {\b MCHEmul::Instruction});}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Idem but inheriting from basic instruction. \par
}{
Definition at line {\b 199} of file {\b Instruction.hpp}.}\par
}
{\xe \v _INST_FROM\:Instruction.hpp}
{\xe \v Instruction.hpp\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _INST_FROM( _C,  _M,  _CC,  _T,  _I,  _J)}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 class }_I final : {\cf17 public} _J \\\par
\{ \\\par
    public: \\\par
    _I () : _J (_C, _M, _CC, _T) \{ \} \\\par
    protected: \\\par
    virtual {\cf18 bool} executeImpl () {\cf17 override}; \\\par
\};\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the way a new instruction is defined. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _C} \cell }{: Code. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _M} \cell }{: MemoryPositions occupied. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _CC} \cell }{: Clock cycles used. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _T} \cell }{: The templat to print the instruction. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _I} \cell }{: Name of the intruction. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _J} \cell }{: Name of the parent class. \cell }
{\row }
}
}{
Definition at line {\b 189} of file {\b Instruction.hpp}.}\par
}
{\xe \v _INST_IMPL\:Instruction.hpp}
{\xe \v Instruction.hpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _INST_IMPL( _I)\~ bool _I::executeImpl ()}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b Instruction.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Instruction.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Instruction.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Instruction.hpp}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_INSTRUCTION__}\par
00015 {\cf21 #define __MCHEMUL_INSTRUCTION__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/UBytes.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00022     {\cf17 class }CPU;\par
00023     {\cf17 class }Memory;\par
00024     {\cf17 class }Stack;\par
00025 \par
00027     {\cf17 class }Instruction\par
00028     \{\par
00029         {\cf17 public}:\par
00032         {\cf17 struct }Structure\par
00033         \{\par
00034             {\cf17 struct }Parameter\par
00035             \{\par
00036                 {\cf17 enum class} Type \{ _DATA = 0, _DIR, _RELJUMP, _ABSJUMP \};\par
00037 \par
00040                 {\cf17 static} std::map <unsigned char, Type> _TYPES;\par
00041 \par
00042                 Parameter () \par
00043                     : _type (Type::_DATA), _numberBytes (1)\par
00044                             \{ \}\par
00045 \par
00046                 Parameter (Type tp, {\cf18 size_t} nB)\par
00047                     : _type (tp), _numberBytes (nB)\par
00048                             \{ assert (_numberBytes > 0); \}\par
00049 \par
00050                 Parameter ({\cf17 const} Parameter&) = {\cf19 default};\par
00051 \par
00052                 Parameter& operator = ({\cf17 const} Parameter&) = {\cf19 default};\par
00053 \par
00054                 Type _type;\par
00055                 {\cf18 size_t} _numberBytes;\par
00056             \};\par
00057 \par
00058             Structure ()\par
00059                 : _error (false), _templateWithNoParameters ({\cf22 ""}), _waterMark ({\cf22 ""}), _waterMarkPlus ({\cf22 ""}), _parameters ()\par
00060                             \{ \}\par
00061 \par
00062             Structure ({\cf17 const} std::string& t, {\cf17 const} std::string& wM, {\cf17 const} std::vector <Parameter>& prms)\par
00063                 : _error (false), _templateWithNoParameters (t), _waterMark (wM), _parameters (prms)\par
00064                             \{ \}\par
00065 \par
00066             Structure ({\cf17 const} Structure&) = {\cf19 default};\par
00067 \par
00068             Structure& operator = ({\cf17 const} Structure&) = {\cf19 default};\par
00069 \par
00074             {\cf18 bool} _error; \par
00075             std::string _templateWithNoParameters;\par
00076             std::string _waterMark;\par
00077             std::string _waterMarkPlus;\par
00078             std::vector <Parameter> _parameters;\par
00079         \};\par
00080 \par
00081         Instruction () = {\cf17 delete};\par
00082 \par
00096         Instruction ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t);\par
00097 \par
00098         Instruction ({\cf17 const} Instruction&) = {\cf19 default};\par
00099 \par
00100         Instruction& operator = ({\cf17 const} Instruction&) = {\cf19 default};\par
00101 \par
00102         {\cf18 unsigned} {\cf18 int} code (){\cf17  const}\par
00103 {\cf17                             }\{ {\cf19 return} (_code); \}\par
00104         {\cf18 unsigned} {\cf18 int} memoryPositions (){\cf17  const}\par
00105 {\cf17                             }\{ {\cf19 return} (_memoryPositions); \}\par
00106         {\cf18 unsigned} {\cf18 int} clockCycles (){\cf17  const}\par
00107 {\cf17                             }\{ {\cf19 return} (_clockCycles); \}\par
00108         {\cf18 unsigned} {\cf18 int} additionalClockCycles (){\cf17  const}\par
00109 {\cf17                             }\{ {\cf19 return} (_additionalCycles); \}\par
00110         {\cf17 const} std::string iTemplate (){\cf17  const}\par
00111 {\cf17                             }\{ {\cf19 return} (_iTemplate); \}\par
00112         {\cf17 const} Structure& internalStructure (){\cf17  const}\par
00113 {\cf17                             }\{ {\cf19 return} (_iStructure); \}\par
00114 \par
00119         {\cf18 bool} matchesWith ({\cf17 const} std::string& i, std::vector <std::string>& prms);\par
00120 \par
00121         {\cf17 const} UBytes& parameters (){\cf17  const}\par
00122 {\cf17                             }\{ {\cf19 return} (_lastParameters); \}\par
00123         {\cf17 const} UBytes parameters ({\cf18 size_t} p, {\cf18 size_t} nP = 1, {\cf18 bool} bE = {\cf17 true}) {\cf17 const};\par
00124         std::string parametersAsString ({\cf18 size_t} p, {\cf18 size_t} nP = 1, {\cf18 bool} bE = {\cf17 true}) {\cf17 const}; {\cf20 // The UBytes could grouped to get a parameter...}\par
00125         std::string asString () {\cf17 const};\par
00126 \par
00129         {\cf18 bool} execute ({\cf17 const} UBytes& p, CPU* c, Memory* m, Stack* stk);\par
00130 \par
00131         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Instruction& i)\par
00132                             \{ {\cf19 return} (o << i.asString ()); \}\par
00133 \par
00134         {\cf17 protected}:\par
00136         Structure analyzeInstruction () {\cf17 const};\par
00137 \par
00140         {\cf17 virtual} {\cf18 bool} executeImpl () = 0;\par
00141 \par
00142         {\cf20 // Implementation}\par
00143         {\cf17 const} CPU* cpu (){\cf17  const}\par
00144 {\cf17                             }\{ {\cf19 return} (_cpu); \}\par
00145         CPU* cpu ()\par
00146                             \{ {\cf19 return} (_cpu); \}\par
00147         {\cf17 const} Memory* memory (){\cf17  const}\par
00148 {\cf17                             }\{ {\cf19 return} (_memory); \}\par
00149         Memory* memory () \par
00150                             \{ {\cf19 return} (_memory); \}\par
00151         {\cf17 const} Stack* stack (){\cf17  const}\par
00152 {\cf17                             }\{ {\cf19 return} (_stack); \}\par
00153         Stack* stack ()\par
00154                             \{ {\cf19 return} (_stack); \}\par
00155 \par
00156         {\cf17 protected}:\par
00157         {\cf20 // Once they assigned at construction level they couldn't be modified...}\par
00158         {\cf17 const} {\cf18 unsigned} {\cf18 int} _code = 0; \par
00159         {\cf17 const} {\cf18 unsigned} {\cf18 int} _memoryPositions = 0; \par
00160         {\cf17 const} {\cf18 unsigned} {\cf18 int} _clockCycles = 0; \par
00161         std::string _iTemplate; {\cf20 // It is modified during the construction...}\par
00162 \par
00163         {\cf20 // Implementation}\par
00164         {\cf20 // The internal structure helps us later to deal better with the instruction...}\par
00165         Structure _iStructure; \par
00166 \par
00167         {\cf18 unsigned} {\cf18 int} _additionalCycles; {\cf20 // Sometimes, when executed, }\par
00168                                         {\cf20 // an instruction could take more than expected... (@see additionalClockCylces method)}\par
00169 \par
00170         {\cf17 private}:\par
00171         MCHEmul::UBytes _lastParameters;\par
00172         MCHEmul::CPU* _cpu;\par
00173         MCHEmul::Memory* _memory;\par
00174         MCHEmul::Stack* _stack;\par
00175     \};\par
00176 \par
00177     {\cf17 using} Instructions = std::map <unsigned int, Instruction*>;\par
00178 \}\par
00179 \par
00189 {\cf21 #define _INST_FROM(_C, _M, _CC, _T, _I, _J) \\}\par
00190 {\cf21 class _I final : public _J \\}\par
00191 {\cf21 \{ \\}\par
00192 {\cf21     public: \\}\par
00193 {\cf21     _I () : _J (_C, _M, _CC, _T) \{ \} \\}\par
00194 {\cf21     protected: \\}\par
00195 {\cf21     virtual bool executeImpl () override; \\}\par
00196 {\cf21 \};}\par
00197 \par
00199 {\cf21 #define _INST(_C, _M, _CC, _T, _I) \\}\par
00200 {\cf21     _INST_FROM(_C, _M, _CC, _T, _I, MCHEmul::Instruction);}\par
00201 \par
00202 {\cf21 #define _INST_IMPL(_I) \\}\par
00203 {\cf21 bool _I::executeImpl ()}\par
00204 \par
00205 {\cf21 #endif}\par
00206   \par
00207 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/IO.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/IO.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/IO.hpp}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Chip.hpp>}\par
{\f2 #include <CORE/IOPeripheral.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::IODevice}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::IODevices} = std::map< int, IODevice * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IO.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/IO.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/IO.hpp}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_IO__}\par
00015 {\cf21 #define __MCHEMUL_IO__}\par
00016 \par
00017 {\cf21 #include <CORE/Chip.hpp>}\par
00018 {\cf21 #include <CORE/IOPeripheral.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00030     {\cf17 class }IODevice\par
00031     \{\par
00032         {\cf17 public}:\par
00033         {\cf17 enum class} Type \{ _INPUT = 0, _OUTPUT, _INPUTOUTPUT \};\par
00034 \par
00035         IODevice () = {\cf17 delete};\par
00036 \par
00037         IODevice (Type t, {\cf18 int} {\cf18 id}, {\cf17 const} Attributes& attrs = \{ \});\par
00038 \par
00039         IODevice ({\cf17 const} IODevice&) = {\cf17 delete};\par
00040 \par
00041         IODevice& operator = ({\cf17 const} IODevice&) = {\cf17 delete};\par
00042 \par
00045         {\cf17 virtual} ~IODevice () \par
00046                             \{ \}\par
00047 \par
00048         Type type (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_type); \}\par
00050 \par
00051         {\cf18 int} id (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00053 \par
00054         {\cf17 const} Attributes& attributes (){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00056         {\cf17 const} std::string& attribute ({\cf17 const} std::string& aN){\cf17  const}\par
00057 {\cf17                             }\{ Attributes::const_iterator i = _attributes.find (aN); \par
00058                               {\cf19 return} ((i == _attributes.end ()) ? AttributedNotDefined : (*i).second); \}\par
00059 \par
00063         {\cf17 virtual} {\cf18 void} linkToChips ({\cf17 const} Chips& c)\par
00064                             \{ _chips = c; \}\par
00065         {\cf17 const} Chips& chips (){\cf17  const}\par
00066 {\cf17                             }\{ {\cf19 return} (_chips); \}\par
00067 \par
00068         {\cf20 // To manage the peripherals connected...}\par
00069         {\cf17 const} IOPeripherals& peripherals (){\cf17  const}\par
00070 {\cf17                             }\{ {\cf19 return} (_peripherals); \}\par
00071         {\cf18 bool} existsPeripheral ({\cf18 int} {\cf18 id}){\cf17  const}\par
00072 {\cf17                             }\{ {\cf19 return} (_peripherals.find ({\cf18 id}) != _peripherals.end ()); \}\par
00077         {\cf17 virtual} {\cf18 void} addPeripheral (IOPeripheral* p);\par
00079         {\cf18 void} removePeripheral ({\cf18 int} {\cf18 id});\par
00080 \par
00082         {\cf17 virtual} {\cf18 bool} initialize ();\par
00083 \par
00086         {\cf17 virtual} {\cf18 bool} simulate ();\par
00087 \par
00089         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00090 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00091 \par
00092         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} IODevice& d);\par
00093 \par
00094         {\cf17 protected}:\par
00095         {\cf17 const} Type _type; {\cf20 // Modified at constrution level}\par
00096         {\cf17 const} {\cf18 int} _id; {\cf20 // Idem}\par
00097         Chips _chips; {\cf20 // linked when computer instance is built!}\par
00098         {\cf17 const} Attributes _attributes = \{ \}; {\cf20 // Maybe modified at construction level}\par
00099         IOPeripherals _peripherals;\par
00100 \par
00101         {\cf20 // Implementation}\par
00102         {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastError;\par
00103     \};\par
00104 \par
00106     {\cf17 using} IODevices = std::map <int, IODevice*>;\par
00107 \}\par
00108 \par
00109 {\cf21 #endif}\par
00110   \par
00111 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/IOPeripheral.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/IOPeripheral.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/IOPeripheral.hpp}
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::IOPeripheral}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::IOPeripherals} = std::map< int, IOPeripheral * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IOPeripheral.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/IOPeripheral.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/IOPeripheral.hpp}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_IOPERIPHERAL__}\par
00015 {\cf21 #define __MCHEMUL_IOPERIPHERAL__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00021     {\cf17 class }IODevice;\par
00022 \par
00027     {\cf17 class }IOPeripheral\par
00028     \{\par
00029         {\cf17 public}:\par
00030         {\cf17 friend} IODevice;\par
00031 \par
00032         IOPeripheral () = {\cf17 delete};\par
00033 \par
00034         IOPeripheral ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& attrs = \{ \})\par
00035             : _id ({\cf18 id}), _attributes (), _device ({\cf17 nullptr}) \par
00036                             \{ \}\par
00037 \par
00038         IOPeripheral ({\cf17 const} IOPeripheral&) = {\cf17 delete};\par
00039 \par
00040         IOPeripheral& operator = ({\cf17 const} IOPeripheral&) = {\cf17 delete};\par
00041 \par
00042         {\cf17 virtual} ~IOPeripheral () \par
00043                             \{ \}\par
00044 \par
00045         {\cf18 int} id (){\cf17  const}\par
00046 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00047 \par
00048         {\cf17 const} Attributes& attributes (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00050         {\cf17 const} std::string& attribute ({\cf17 const} std::string& aN){\cf17  const}\par
00051 {\cf17                             }\{ Attributes::const_iterator i = _attributes.find (aN); \par
00052                               {\cf19 return} ((i == _attributes.end ()) ? AttributedNotDefined : (*i).second); \}\par
00053 \par
00054         {\cf17 const} IODevice* device (){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} (_device); \}\par
00056         IODevice* device ()\par
00057                             \{ {\cf19 return} (_device); \}\par
00058 \par
00061         {\cf17 virtual} {\cf18 bool} initialize () = 0;\par
00062 \par
00065         {\cf17 virtual} {\cf18 bool} simulate () = 0;\par
00066 \par
00067         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} IOPeripheral& d);\par
00068 \par
00069         {\cf17 protected}:\par
00070         {\cf17 const} {\cf18 int} _id; {\cf20 // Adjusted at construction level}\par
00071         {\cf17 const} Attributes _attributes = \{ \}; {\cf20 // Maybe modified at construction level}\par
00073 {\cf20 }        IODevice* _device;\par
00074     \};\par
00075 \par
00077     {\cf17 using} IOPeripherals = std::map <int, IOPeripheral*>;\par
00078 \}\par
00079 \par
00080 {\cf21 #endif}\par
00081   \par
00082 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/ProgramCounter.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/ProgramCounter.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/ProgramCounter.hpp}
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Register.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::ProgramCounter}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ProgramCounter.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/ProgramCounter.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/ProgramCounter.hpp}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_PROGRAMCOUNTER__}\par
00015 {\cf21 #define __MCHEMUL_PROGRAMCOUNTER__}\par
00016 \par
00017 {\cf21 #include <CORE/Register.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00023     {\cf17 class }ProgramCounter final : {\cf17 protected} Register\par
00024     \{\par
00025         {\cf17 public}:\par
00026         ProgramCounter ({\cf18 size_t} sz)\par
00027             : Register (-1 , {\cf22 "PC"}, UBytes (std::vector <UByte> (sz, UByte::_0))) \par
00028                             \{ \}\par
00029 \par
00030         ProgramCounter ({\cf17 const} ProgramCounter&) = {\cf19 default};\par
00031         ProgramCounter& operator = ({\cf17 const} ProgramCounter&) = {\cf19 default};\par
00032 \par
00033         {\cf18 void} initialize ()\par
00034                             \{ Register::initialize (); \}\par
00035 \par
00036         Address asAddress (){\cf17  const}\par
00037 {\cf17                             }\{ {\cf19 return} (Register::asAddress ({\cf17 true})); \}\par
00038         {\cf18 void} setAddress ({\cf17 const} Address& a)\par
00039                             \{ set (a.bytes ()); \}\par
00040 \par
00041         {\cf18 void} increment ({\cf18 size_t} n = 1)\par
00042                             \{ setAddress (asAddress ().next (n)); \}\par
00043         {\cf18 void} decrement ({\cf18 size_t} n = 1)\par
00044                             \{ setAddress (asAddress ().previous (n)); \}\par
00045 \par
00046         {\cf18 bool} operator == ({\cf17 const} Address& a){\cf17  const}\par
00047 {\cf17                             }\{ {\cf19 return} (asAddress () == a); \}\par
00048         {\cf18 bool} operator != ({\cf17 const} Address& a){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (asAddress () != a); \}\par
00050         {\cf18 bool} operator > ({\cf17 const} Address& a){\cf17  const}\par
00051 {\cf17                             }\{ {\cf19 return} (asAddress () > a); \}\par
00052         {\cf18 bool} operator >= ({\cf17 const} Address& a){\cf17  const}\par
00053 {\cf17                             }\{ {\cf19 return} (asAddress () >= a); \}\par
00054         {\cf18 bool} operator < ({\cf17 const} Address& a){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} (asAddress () < a); \}\par
00056         {\cf18 bool} operator <= ({\cf17 const} Address& a){\cf17  const}\par
00057 {\cf17                             }\{ {\cf19 return} (asAddress () != a); \}\par
00058 \par
00059         ProgramCounter operator + ({\cf18 size_t} n){\cf17  const}\par
00060 {\cf17                             }\{ ProgramCounter r = *{\cf17 this}; r.increment (n); {\cf19 return} (r); \}\par
00061         ProgramCounter& operator += ({\cf18 size_t} n)\par
00062                             \{ increment (n); {\cf19 return} (*{\cf17 this}); \}\par
00063         ProgramCounter operator - ({\cf18 size_t} n){\cf17  const}\par
00064 {\cf17                             }\{ ProgramCounter r = *{\cf17 this}; r.decrement (n); {\cf19 return} (r); \}\par
00065         ProgramCounter& operator -= ({\cf18 size_t} n)\par
00066                             \{ decrement (n); {\cf19 return} (*{\cf17 this}); \}\par
00067 \par
00068         std::string asString (UByte::OutputFormat oF){\cf17  const}\par
00069 {\cf17                             }\{ {\cf19 return} (asAddress ().asString (oF)); \}\par
00070 \par
00071         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} ProgramCounter& pc);\par
00072     \};\par
00073 \}\par
00074 \par
00075 {\cf21 #endif}\par
00076   \par
00077 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Register.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Register.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Register.hpp}
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/Address.hpp>}\par
{\f2 #include <CORE/UBytes.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Register}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Registers} = std::vector< Register >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Register.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Register.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Register.hpp}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_REGISTER__}\par
00015 {\cf21 #define __MCHEMUL_REGISTER__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/Address.hpp>}\par
00019 {\cf21 #include <CORE/UBytes.hpp>}\par
00020 \par
00021 {\cf17 namespace }MCHEmul\par
00022 \{\par
00025     {\cf17 class }Register\par
00026     \{\par
00027         {\cf17 public}:\par
00028         Register () = {\cf17 delete};\par
00029 \par
00030         Register ({\cf18 int} {\cf18 id}, {\cf17 const} std::string& n, {\cf17 const} UBytes& v )\par
00031             : _id (id), _name (n), _values (v) \par
00032                             \{ \}\par
00033 \par
00034         Register ({\cf18 int} {\cf18 id}, {\cf17 const} std::string& n, {\cf17 const} std::vector <UByte>&v )\par
00035             : _id (id), _name (n), _values (v) \par
00036                             \{ \}\par
00037 \par
00038         Register ({\cf17 const} Register&) = {\cf19 default};\par
00039 \par
00040         Register& operator = ({\cf17 const} Register&) = {\cf19 default};\par
00041 \par
00043         {\cf18 void} initialize ()\par
00044                             \{ _values.to0 (); \}\par
00045 \par
00046         {\cf18 int} id (){\cf17  const}\par
00047 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00048         {\cf17 const} std::string& name (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_name); \}\par
00050         {\cf18 size_t} size (){\cf17  const}\par
00051 {\cf17                             }\{ {\cf19 return} (_values.size ()); \}\par
00052 \par
00053         {\cf17 const} UBytes& values (){\cf17  const}\par
00054 {\cf17                             }\{ {\cf19 return} (_values); \}\par
00055         {\cf17 const} std::vector <UByte>& bytes (){\cf17  const}\par
00056 {\cf17                             }\{ {\cf19 return} (_values.bytes ()); \}\par
00057 \par
00058         UInt asUInt ({\cf18 bool} bE){\cf17  const}\par
00059 {\cf17                             }\{ {\cf19 return} (UInt (_values, bE)); \}\par
00060         Address asAddress ({\cf18 bool} bE){\cf17  const}\par
00061 {\cf17                             }\{ {\cf19 return} (Address (UInt (_values, bE))); \}\par
00062 \par
00064         {\cf18 bool} accept ({\cf17 const} UBytes& v){\cf17  const}\par
00065 {\cf17                             }\{ {\cf19 return} (size () == v.size ()); \}\par
00066 \par
00068         {\cf18 void} set ({\cf17 const} std::vector <UByte>& v)\par
00069                             \{ {\cf19 if} (accept (v)) _values = v; \}\par
00070         {\cf18 void} set ({\cf17 const} UBytes& v)\par
00071                             \{ {\cf19 if} (accept (v)) _values = v; \}\par
00073         {\cf18 void} set ({\cf17 const} Register& r)\par
00074                             \{ set (r.values ()); \}\par
00075 \par
00076         {\cf18 bool} operator == ({\cf17 const} Register& r){\cf17  const}\par
00077 {\cf17                             }\{ {\cf19 return} (_values == r._values); \}\par
00078         {\cf18 bool} operator != ({\cf17 const} Register& r){\cf17  const}\par
00079 {\cf17                             }\{ {\cf19 return} (_values != r._values); \}\par
00080 \par
00081         UByte operator [] ({\cf18 size_t} p){\cf17  const}\par
00082 {\cf17                             }\{ {\cf19 return} (_values [p]); \}\par
00083 \par
00084         std::string asString (UByte::OutputFormat oF, {\cf18 char} s , {\cf18 size_t} l = 0 ){\cf17  const}\par
00085 {\cf17                             }\{ {\cf19 return} (_values.asString (oF, s, l)); \}\par
00086             \par
00087         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Register& r);\par
00088 \par
00089         {\cf17 protected}:\par
00090         {\cf17 const} {\cf18 int} _id;\par
00091         {\cf17 const} std::string _name;\par
00092         UBytes _values;\par
00093     \};\par
00094 \par
00095     {\cf17 using} Registers = std::vector <Register>;\par
00096 \par
00098     {\cf17 static} {\cf17 const} Register NoRegister = Register (0, {\cf22 "-"}, UBytes ());\par
00099 \par
00100     {\cf20 // Implementation}\par
00102 {\cf20 }    {\cf17 static} Register TrashRegister = Register (0, {\cf22 "-"}, UBytes ());\par
00103 \}\par
00104 \par
00105 {\cf21 #endif}\par
00106   \par
00107 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/ScreenMemory.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/ScreenMemory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/ScreenMemory.hpp}
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::ScreenMemory}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ScreenMemory.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/ScreenMemory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/ScreenMemory.hpp}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_SCREENMEMORY__}\par
00015 {\cf21 #define __MCHEMUL_SCREENMEMORY__}\par
00016 \par
00017 {\cf17 namespace }MCHEmul\par
00018 \{\par
00022     {\cf17 class }ScreenMemory\par
00023     \{\par
00024         {\cf17 public}:\par
00025         ScreenMemory () = {\cf17 delete};\par
00026 \par
00027         ScreenMemory ({\cf18 size_t} c, {\cf18 size_t} r, {\cf18 unsigned} {\cf18 int}* p);\par
00028 \par
00029         ScreenMemory ({\cf17 const} ScreenMemory&) = {\cf17 delete};\par
00030 \par
00031         ScreenMemory& operator = ({\cf17 const} ScreenMemory&) = {\cf17 delete};\par
00032 \par
00033         ~ScreenMemory ()\par
00034                             \{ {\cf17 delete} (_frameData); {\cf17 delete} (_colorPalette);\}\par
00035 \par
00036         {\cf20 // Size...}\par
00037         {\cf18 size_t} columns (){\cf17  const}\par
00038 {\cf17                             }\{ {\cf19 return} (_columns); \}\par
00039         {\cf18 size_t} rows (){\cf17  const}\par
00040 {\cf17                             }\{ {\cf19 return} (_rows); \}\par
00041         {\cf17 const} {\cf18 unsigned} {\cf18 int}* frameData (){\cf17  const}\par
00042 {\cf17                             }\{ {\cf19 return} (_frameData); \}\par
00043 \par
00044         {\cf20 // Managing basically the pixels of the frame...}\par
00045         {\cf18 void} setPixel ({\cf18 size_t} x, {\cf18 size_t} y, {\cf18 unsigned} {\cf18 int} color)\par
00046                             \{ _frameData [y * _columns + x] = _colorPalette [color]; \}\par
00047         {\cf18 void} setHorizontalLine ({\cf18 size_t} x, {\cf18 size_t} y, {\cf18 size_t} nP, {\cf18 unsigned} {\cf18 int} color)\par
00048                             \{ {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < nP; setPixel (x + i++, y, color)); \}\par
00049         {\cf18 void} setVerticalLine ({\cf18 size_t} x, {\cf18 size_t} y, {\cf18 size_t} nP, {\cf18 unsigned} {\cf18 int} color)\par
00050                             \{ {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < nP; setPixel (x, y + i++, color)); \}\par
00051 \par
00052         {\cf17 private}:\par
00053         {\cf18 unsigned} {\cf18 int}* _frameData;\par
00054         {\cf18 size_t} _columns, _rows;\par
00055         {\cf18 unsigned} {\cf18 int}* _colorPalette;\par
00056     \};\par
00057 \}\par
00058 \par
00059 {\cf21 #endif}\par
00060   \par
00061 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Stack.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Stack.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Stack.hpp}
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Memory.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Stack}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Stack.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Stack.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Stack.hpp}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_STACK__}\par
00015 {\cf21 #define __MCHEMUL_STACK__}\par
00016 \par
00017 {\cf21 #include <CORE/Memory.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00021     {\cf17 class }Stack : {\cf17 public} PhisicalStorageSubset\par
00022     \{\par
00023         {\cf17 public}:\par
00029         Stack ({\cf18 int} {\cf18 id}, PhisicalStorage* ps, {\cf18 size_t} pp, {\cf17 const} Address& iA, {\cf18 size_t} s, {\cf18 bool} b = {\cf17 true}, {\cf18 bool} e = {\cf17 true})\par
00030             : PhisicalStorageSubset (id, ps, pp, iA, s), \par
00031               _position (0), _fromBack (b), _pointToEmpty (e),\par
00032               _stackOverflow (false),\par
00033               _empty (true)\par
00034                             \{ \}\par
00035 \par
00036         {\cf18 size_t} position (){\cf17  const}\par
00037 {\cf17                             }\{ {\cf19 return} (_position); \}\par
00040         {\cf18 void} setPosition ({\cf18 int} p)\par
00041                             \{ _position = p; \}\par
00042 \par
00043         {\cf17 virtual} {\cf18 void} initialize () {\cf17 override};\par
00044 \par
00045         {\cf18 void} push ({\cf17 const} UBytes& v);\par
00046         UBytes pull ({\cf18 size_t} nV);\par
00047 \par
00049         {\cf18 bool} stackOverflow (){\cf17  const}\par
00050 {\cf17                             }\{ {\cf19 return} (_stackOverflow); \}\par
00051 \par
00052         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Stack& s);\par
00053 \par
00054         {\cf17 private}:\par
00055         {\cf18 int} _position;\par
00056         {\cf17 const} {\cf18 bool} _fromBack = {\cf17 true}; {\cf20 // Adapted at construction time}\par
00057         {\cf17 const} {\cf18 bool} _pointToEmpty = {\cf17 true}; {\cf20 // Ad\'E0ted at construction time}\par
00058 \par
00059         {\cf20 // Implementation}\par
00060         {\cf18 bool} _stackOverflow;\par
00061         {\cf18 bool} _empty;\par
00062     \};\par
00063 \}\par
00064 \par
00065 {\cf21 #endif}\par
00066   \par
00067 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/StatusRegister.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/StatusRegister.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/StatusRegister.hpp}
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Register.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::StatusRegister}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StatusRegister.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/StatusRegister.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/StatusRegister.hpp}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_STATUSREGISTER__}\par
00015 {\cf21 #define __MCHEMUL_STATUSREGISTER__}\par
00016 \par
00017 {\cf21 #include <CORE/Register.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00022     {\cf17 class }StatusRegister : {\cf17 protected} Register\par
00023     \{\par
00024         {\cf17 public}:\par
00025         {\cf17 using} BitNames = std::map <std::string, int>;\par
00026 \par
00027         StatusRegister ({\cf18 size_t} nB, {\cf17 const} BitNames& bN)\par
00028             : Register (-2 , {\cf22 "ST"}, UBytes (std::vector <UByte> (nB, UByte::_0))), \par
00029               _bitNames (bN)\par
00030                             \{\}\par
00031 \par
00032         StatusRegister ({\cf17 const} StatusRegister&) = {\cf19 default};\par
00033 \par
00034         StatusRegister& operator = ({\cf17 const} StatusRegister&) = {\cf19 default};\par
00035 \par
00036         {\cf18 void} initialize ()\par
00037                             \{ Register::initialize (); \}\par
00038 \par
00039         {\cf17 const} BitNames& bitNames (){\cf17  const}\par
00040 {\cf17                             }\{ {\cf19 return} (_bitNames); \}\par
00041         {\cf18 bool} existsBitStatus ({\cf17 const} std::string& bN){\cf17  const}\par
00042 {\cf17                             }\{ {\cf19 return} (_bitNames.find (bN) != _bitNames.end ()); \}\par
00044         {\cf18 bool} bitStatus ({\cf17 const} std::string& bN){\cf17  const}\par
00045 {\cf17                             }\{ {\cf19 return} (_values.bit ((*_bitNames.find (bN)).second)); \}\par
00046         {\cf18 void} setBitStatus ({\cf17 const} std::string& bN, {\cf18 bool} s)\par
00047                             \{ _values.setBit ((*_bitNames.find (bN)).second, s); \}\par
00048 \par
00049         {\cf17 const} UBytes& values (){\cf17  const}\par
00050 {\cf17                             }\{ {\cf19 return} (Register::values ()); \}\par
00051         {\cf17 const} std::vector <UByte>& bytes (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (Register::bytes ()); \}\par
00053 \par
00054         UBytes valuesWithout ({\cf17 const} std::vector <std::string>& bN);\par
00055         {\cf18 void} set ({\cf17 const} std::vector <UByte>& v)\par
00056                             \{ Register::set (v); \}\par
00057         {\cf18 void} set ({\cf17 const} UBytes& v)\par
00058                             \{ Register::set (v); \}\par
00059 \par
00060         std::string asString () {\cf17 const};\par
00061 \par
00062         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} StatusRegister& r)\par
00063                             \{ {\cf19 return} (o << r.asString ()); \}\par
00064 \par
00065         {\cf17 private}:\par
00066         {\cf17 const} BitNames _bitNames; \par
00067     \};\par
00068 \}\par
00069 \par
00070 {\cf21 #endif}\par
00071   \par
00072 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/UByte.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/UByte.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/UByte.hpp}
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UByte}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UByte.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/UByte.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/UByte.hpp}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_UBYTE__}\par
00015 {\cf21 #define __MCHEMUL_UBYTE__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00024     {\cf17 class }UByte final\par
00025     \{\par
00026         {\cf17 public}:\par
00027         {\cf17 enum class} OutputFormat\par
00028         \{\par
00029             _DECIMAL,\par
00030             _BINARY,\par
00031             _OCTAL,\par
00032             _HEXA\par
00033         \};\par
00034 \par
00035         {\cf20 // Most common values}\par
00036         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _0       = 0x00;\par
00037         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _1       = 0x01;             {\cf20 // Used e.g in adding to get complement_2!}\par
00038         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _FF      = 0xff;\par
00039         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _0F      = 0x0f;             {\cf20 // Used to extract the LS Nibble}\par
00040         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _F0      = 0xf0;             {\cf20 // Used to extract the MS Nibble}\par
00041         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _80      = 0x80;             {\cf20 // Used to test the sign...}\par
00042         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _09      = 0x09;             {\cf20 // Used in BCD limits...}\par
00043         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _90      = 0x90;             {\cf20 // Used in BCD limits...}\par
00044         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _09N     = ~_09 + 1;         {\cf20 // Used in BCD limits...}\par
00045         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _90N     = ~_90 + 1;         {\cf20 // Used in BCD limits...}\par
00046         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _06      = 0x06;             {\cf20 // Used in BCD operations...}\par
00047         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _60      = 0x60;             {\cf20 // Used in BCD operations...}\par
00048         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _06N     = ~_06 + _1;        {\cf20 // Used in BCD operations...}\par
00049         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _60N     = ~_60 + _1;        {\cf20 // Used in BCD operations...}\par
00050 \par
00051         UByte ()\par
00052             : _value (_0)\par
00053                             \{ \}\par
00054 \par
00055         UByte ({\cf18 unsigned} {\cf18 char} v)\par
00056             : _value (v)\par
00057                             \{ \}\par
00058 \par
00059         UByte ({\cf17 const} UByte&) = {\cf19 default};\par
00060         UByte& operator = ({\cf17 const} UByte&) = {\cf19 default};\par
00061 \par
00063         {\cf17 static} {\cf18 size_t} size () {\cf20 // (static) Alol the same...}\par
00064                             \{ {\cf19 return} ({\cf17 sizeof} ({\cf18 unsigned} {\cf18 char})); \}\par
00065         {\cf17 static} {\cf18 size_t} sizeBits () {\cf20 // (static) All the same...}\par
00066                             \{ {\cf19 return} ({\cf17 sizeof} ({\cf18 unsigned} {\cf18 char}) << 3); \}\par
00067 \par
00068         {\cf18 unsigned} {\cf18 char} value (){\cf17  const}\par
00069 {\cf17                             }\{ {\cf19 return} (_value); \}\par
00070 \par
00073         {\cf18 bool} bit ({\cf18 size_t} p){\cf17  const}\par
00074 {\cf17                             }\{ {\cf19 return} ((_value & (_1 << p)) != _0); \}\par
00075         {\cf18 void} setBit ({\cf18 size_t} p, {\cf18 bool} s)\par
00076                             \{ {\cf18 unsigned} {\cf18 char} v = _1 << p; _value = _value & (~v) | (s ? v : _0); \}\par
00077 \par
00078         UByte LSNibble (){\cf17  const}\par
00079 {\cf17                             }\{ {\cf19 return} (UByte (_value & _0F)); \}\par
00080         UByte MSNibble (){\cf17  const}\par
00081 {\cf17                             }\{ {\cf19 return} (UByte (_value & _F0)); \}\par
00082 \par
00084         UByte complement (){\cf17  const}\par
00085 {\cf17                             }\{ {\cf19 return} (~_value); \}\par
00086 \par
00087         {\cf18 bool} shiftLeftC ({\cf18 bool} c = {\cf17 false} , {\cf18 size_t} p = 1);\par
00088         UByte& shiftLeft ({\cf18 size_t} p = 1)\par
00089                         \{ shiftLeftC ({\cf17 false}, p); {\cf19 return} (*{\cf17 this}); \}\par
00090         {\cf18 bool} shiftRightC ({\cf18 bool} c = {\cf17 false}, {\cf18 size_t} p = 1);\par
00091         UByte& shiftRight ({\cf18 size_t} p = 1)\par
00092                         \{ shiftRightC ({\cf17 false}, p); {\cf19 return} (*{\cf17 this}); \}\par
00093 \par
00094         {\cf18 bool} rotateLeftC ({\cf18 bool} c = {\cf17 false} , {\cf18 size_t} p = 1);\par
00095         UByte& rotateLeft ({\cf18 size_t} p = 1 );\par
00096         {\cf18 bool} rotateRightC ({\cf18 bool} c = {\cf17 false}, {\cf18 size_t} p = 1);\par
00097         UByte& rotateRight ({\cf18 size_t} p = 1);\par
00098 \par
00108         {\cf17 inline} UByte bitAdding ({\cf17 const} UByte& u, {\cf18 bool} cin, {\cf18 bool}& cout, {\cf18 bool}& o) {\cf17 const};\par
00109 \par
00110         {\cf18 bool} operator == ({\cf17 const} UByte& u){\cf17  const}\par
00111 {\cf17                             }\{ {\cf19 return} (_value == u._value); \}\par
00112         {\cf18 bool} operator != ({\cf17 const} UByte& u){\cf17  const}\par
00113 {\cf17                             }\{ {\cf19 return} (_value != u._value); \}\par
00114         {\cf18 bool} operator > ({\cf17 const} UByte& u){\cf17  const}\par
00115 {\cf17                             }\{ {\cf19 return} (_value > u._value); \}\par
00116         {\cf18 bool} operator >= ({\cf17 const} UByte& u){\cf17  const}\par
00117 {\cf17                             }\{ {\cf19 return} (_value >= u._value); \}\par
00118         {\cf18 bool} operator < ({\cf17 const} UByte& u){\cf17  const}\par
00119 {\cf17                             }\{ {\cf19 return} (_value == u._value); \}\par
00120         {\cf18 bool} operator <= ({\cf17 const} UByte& u){\cf17  const}\par
00121 {\cf17                             }\{ {\cf19 return} (_value <= u._value); \}\par
00122 \par
00123         UByte operator & ({\cf17 const} UByte& u){\cf17  const}\par
00124 {\cf17                             }\{ {\cf19 return} (_value & u._value); \}\par
00125         UByte& operator &= ({\cf17 const} UByte& u)\par
00126                             \{ *{\cf17 this} = *{\cf17 this} & u; {\cf19 return} (*{\cf17 this}); \}\par
00127         UByte operator | ({\cf17 const} UByte& u){\cf17  const}\par
00128 {\cf17                             }\{ {\cf19 return} (_value | u._value); \}\par
00129         UByte& operator |= ({\cf17 const} UByte& u)\par
00130                             \{ *{\cf17 this} = *{\cf17 this} | u; {\cf19 return} (*{\cf17 this}); \}\par
00131         UByte operator ^ ({\cf17 const} UByte& u){\cf17  const}\par
00132 {\cf17                             }\{ {\cf19 return} (_value ^ u._value); \}\par
00133         UByte& operator ^= ({\cf17 const} UByte& u)\par
00134                             \{ *{\cf17 this} = *{\cf17 this} ^ u; {\cf19 return} (*{\cf17 this}); \}\par
00135         UByte operator ~ (){\cf17  const}\par
00136 {\cf17                             }\{ {\cf19 return} (complement ()); \}\par
00137 \par
00138         {\cf18 bool} operator [] ({\cf18 size_t} p){\cf17  const}\par
00139 {\cf17                             }\{ {\cf19 return} (bit (p)); \}\par
00140         UByte& operator << ({\cf18 size_t} p)\par
00141                             \{ {\cf19 return} (shiftLeft (p)); \}\par
00142         UByte& operator >> ({\cf18 size_t} p)\par
00143                             \{ {\cf19 return} (shiftRight (p)); \}\par
00144 \par
00145         std::string asString (OutputFormat oF, {\cf18 size_t} l = 0 ) {\cf17 const};\par
00146 \par
00147         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} UByte& u)\par
00148                             \{ {\cf19 return} (o << u.asString (UByte::OutputFormat::_HEXA, 2)); \}\par
00149 \par
00150         {\cf17 private}:\par
00151         {\cf18 unsigned} {\cf18 char} _value; {\cf20 // 8 bits - length (@see static method size)}\par
00152     \};\par
00153 \par
00154     {\cf20 // This piece of the code should be inline ever!}\par
00155     {\cf20 // This is the very basic adder!}\par
00156     {\cf17 inline} UByte UByte::bitAdding ({\cf17 const} UByte& u, {\cf18 bool} cin, {\cf18 bool}& cout, {\cf18 bool}& o){\cf17  const}\par
00157 {\cf17     }\{\par
00158         {\cf18 unsigned} {\cf18 short} r = \par
00159             ({\cf18 unsigned} short) (_value + u._value + \par
00160                 (cin ? 0x01  : 0x00));\par
00161 \par
00162         {\cf20 // The carry is generated if the result is bigger than a unsigned char long!}\par
00163         cout = (r & 0xff00 ) != 0x000; \par
00164         {\cf20 // The overflow is generated when both are negative and the outcome positive...or the other way around!}\par
00165         o = (bit (7) && u.bit (7) && ((r & 0x0080) == 0x0000)) |  \par
00166                 (!bit (7) && !u.bit (7) && ((r & 0x0080) != 0x0000)); \par
00167 \par
00168         {\cf19 return} (MCHEmul::UByte (({\cf18 unsigned} {\cf18 char})  r));\par
00169     \}\par
00170 \}\par
00171 \par
00172 {\cf21 #endif}\par
00173   \par
00174 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/UBytes.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/UBytes.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/UBytes.hpp}
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/UByte.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UBytes}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UBytes.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/UBytes.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/UBytes.hpp}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00015 {\cf21 #ifndef __MCHEMUL_UBYTES__}\par
00016 {\cf21 #define __MCHEMUL_UBYTES__}\par
00017 \par
00018 {\cf21 #include <CORE/UByte.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00023     {\cf17 class }UBytes final\par
00024     \{\par
00025         {\cf17 public}:\par
00026         {\cf17 static} {\cf17 const} UBytes _E;\par
00027 \par
00028         UBytes ()\par
00029             : _values ()\par
00030                             \{ \}\par
00031 \par
00032         UBytes ({\cf17 const} std::vector <UByte>& v, {\cf18 bool} bE = {\cf17 true})\par
00033             : _values (v)\par
00034                             \{ {\cf19 if} (size () > 1 && !bE) _values = reverse ().bytes (); \}\par
00035 \par
00036         UBytes ({\cf17 const} UBytes&) = {\cf19 default};\par
00037         UBytes& operator = ({\cf17 const} UBytes&) = {\cf19 default};\par
00038 \par
00039         {\cf18 size_t} size (){\cf17  const}\par
00040 {\cf17                             }\{ {\cf19 return} (_values.size ()); \}\par
00041         {\cf18 size_t} sizeBits (){\cf17  const}\par
00042 {\cf17                             }\{ {\cf19 return} (size () * UByte::sizeBits ()); \}\par
00043 \par
00044         {\cf18 void} setMinLength ({\cf18 size_t} l, {\cf18 bool} r = {\cf17 true} );\par
00045 \par
00046         {\cf17 const} UByte& value ({\cf18 size_t} p){\cf17  const}\par
00047 {\cf17                             }\{ {\cf19 return} (_values [p]); \}\par
00048         UByte& value ({\cf18 size_t} p)\par
00049                             \{ {\cf19 return} (_values [p]); \}\par
00050 \par
00051         {\cf17 const} std::vector <UByte>& bytes (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_values); \}\par
00053 \par
00054         UBytes LSUBytes ({\cf18 size_t} p){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} (UBytes ((p >= size ()) ? bytes ()\par
00056                                 : std::vector <UByte> (bytes ().begin () + (bytes ().size () - p), bytes ().end ()))); \}\par
00057         UBytes MSUBytes ({\cf18 size_t} p){\cf17  const}\par
00058 {\cf17                             }\{ {\cf19 return} (UBytes (((p >= size ()) ? bytes () \par
00059                                 : std::vector <UByte> (bytes ().begin (), bytes ().begin () + p - 1)))); \}\par
00060 \par
00063         {\cf18 bool} bit ({\cf18 size_t} p){\cf17  const }\par
00064 {\cf17                             }\{ {\cf19 return} (_values [size () - (p / UByte::sizeBits ()) - 1][p % UByte::sizeBits ()]); \}\par
00065         {\cf18 void} setBit ({\cf18 size_t} p, {\cf18 bool} s)\par
00066                             \{ _values [size () - (p / UByte::sizeBits ()) - 1].setBit (p % UByte::sizeBits (), s); \}\par
00067         \par
00068         {\cf18 void} to0 ()\par
00069                             \{ {\cf19 for} ({\cf17 auto} i : _values) i = UByte::_0; \}\par
00070         {\cf18 void} toFF ()\par
00071                             \{ {\cf19 for} ({\cf17 auto} i : _values) i = UByte::_FF; \}\par
00072 \par
00073         UBytes complement () {\cf17 const};\par
00074 \par
00075         {\cf18 bool} shiftLeftC ({\cf18 bool} c = {\cf17 false} , {\cf18 size_t} p = 1);\par
00076         UBytes& shiftLeft ({\cf18 size_t} p = 1)\par
00077                             \{ shiftLeftC ({\cf17 false}, p); {\cf19 return} (*{\cf17 this}); \}\par
00078         {\cf18 bool} shiftRightC ({\cf18 bool} c = {\cf17 false}, {\cf18 size_t} p = 1);\par
00079         UBytes& shiftRight ({\cf18 size_t} p = 1)\par
00080                             \{ shiftRightC ({\cf17 false}, p); {\cf19 return} (*{\cf17 this}); \}\par
00081         {\cf18 bool} rotateLeftC ({\cf18 bool} c = {\cf17 false}, {\cf18 size_t} p = 1);\par
00082         UBytes& rotateLeft ({\cf18 size_t} p = 1);\par
00083         {\cf18 bool} rotateRightC ({\cf18 bool} c = {\cf17 false}, {\cf18 size_t} p = 1);\par
00084         UBytes& rotateRight ({\cf18 size_t} p = 1);\par
00085 \par
00095         UBytes bitAdding ({\cf17 const} UBytes& u, {\cf18 bool} cin, {\cf18 bool}& cout, {\cf18 bool}& o) {\cf17 const};\par
00096 \par
00097         UBytes reverse () {\cf17 const};\par
00098 \par
00099         {\cf18 bool} operator == ({\cf17 const} UBytes& u) {\cf17 const};\par
00100         {\cf18 bool} operator != ({\cf17 const} UBytes& u){\cf17  const}\par
00101 {\cf17                             }\{ {\cf19 return} (!(*{\cf17 this} == u)); \}\par
00102 \par
00103         UByte operator [] ({\cf18 size_t} p){\cf17  const}\par
00104 {\cf17                             }\{ {\cf19 return} (value (p)); \}\par
00105         UByte& operator [] ({\cf18 size_t} p) \par
00106                             \{ {\cf19 return} (value (p)); \}\par
00107         UBytes& operator << ({\cf18 size_t} p)\par
00108                             \{ {\cf19 return} (shiftLeft (p)); \}\par
00109         UBytes& operator >> ({\cf18 size_t} p)\par
00110                             \{ {\cf19 return} (shiftRight (p)); \}\par
00111 \par
00112         std::string asString (UByte::OutputFormat oF, {\cf18 char} s , {\cf18 size_t} l = 0 ) {\cf17 const};\par
00113 \par
00114         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} UBytes& u)\par
00115                             \{ {\cf19 return} (o << u.asString (UByte::OutputFormat::_HEXA, {\cf23 ' '}, 2)); \}\par
00116 \par
00117         {\cf17 private}:\par
00119         std::vector <UByte> _values;\par
00120     \};\par
00121 \}\par
00122 \par
00123 {\cf21 #endif}\par
00124   \par
00125 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/UInt.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/UInt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/UInt.hpp}
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/UBytes.hpp>}\par
{\f2 #include <map>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UInt::FormatManager}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UInt::BinaryFormatManager}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UInt::PackagedBCDFormatManager}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UInt::FormatManagers}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UInt.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/UInt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/UInt.hpp}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_UINT__}\par
00015 {\cf21 #define __MCHEMUL_UINT__}\par
00016 \par
00017 {\cf21 #include <CORE/UBytes.hpp>}\par
00018 {\cf21 #include <map>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00033     {\cf17 class }UInt final\par
00034     \{\par
00035         {\cf17 public}:\par
00038         {\cf17 class }FormatManager\par
00039         \{\par
00040             {\cf17 public}:\par
00041             FormatManager () = {\cf19 default};\par
00042 \par
00044             {\cf17 virtual} UInt add ({\cf17 const} UInt&, {\cf17 const} UInt&, {\cf18 bool}) {\cf17 const} = 0;\par
00046             {\cf17 virtual} UInt substract ({\cf17 const} UInt&, {\cf17 const} UInt&, {\cf18 bool}) {\cf17 const} = 0;\par
00047 \par
00048             {\cf17 virtual} {\cf18 unsigned} {\cf18 int} asUnsignedInt ({\cf17 const} UInt&) {\cf17 const} = 0;\par
00049 \par
00050             {\cf17 virtual} UInt fromUnsignedInt ({\cf18 unsigned} {\cf18 int} n) = 0;\par
00051             {\cf17 virtual} UInt fromInt ({\cf18 int} n) = 0;\par
00052         \};\par
00053 \par
00055         {\cf17 class }BinaryFormatManager final : {\cf17 public} FormatManager\par
00056         \{\par
00057             {\cf17 public}:\par
00059             {\cf17 virtual} UInt add ({\cf17 const} UInt& u1, {\cf17 const} UInt& u2, {\cf18 bool} cIn) {\cf17 const};\par
00060             {\cf17 virtual} UInt substract ({\cf17 const} UInt& u1, {\cf17 const} UInt& u2, {\cf18 bool} cIn) {\cf17 const};\par
00061 \par
00062             {\cf17 virtual} {\cf18 unsigned} {\cf18 int} asUnsignedInt ({\cf17 const} UInt& u) {\cf17 const override};\par
00063             \par
00064             {\cf17 virtual} UInt fromUnsignedInt ({\cf18 unsigned} {\cf18 int} n);\par
00065             {\cf17 virtual} UInt fromInt ({\cf18 int} n);\par
00066         \};\par
00067 \par
00069         {\cf17 class }PackagedBCDFormatManager final : {\cf17 public} FormatManager\par
00070         \{\par
00071             {\cf17 public}:\par
00072             {\cf17 virtual} UInt add ({\cf17 const} UInt& u1, {\cf17 const} UInt& u2, {\cf18 bool} cIn) {\cf17 const};\par
00073             {\cf17 virtual} UInt substract ({\cf17 const} UInt& u1, {\cf17 const} UInt& u2, {\cf18 bool} cIn) {\cf17 const};\par
00074 \par
00075             {\cf17 virtual} {\cf18 unsigned} {\cf18 int} asUnsignedInt ({\cf17 const} UInt& u) {\cf17 const override};\par
00076 \par
00077             {\cf17 virtual} UInt fromUnsignedInt ({\cf18 unsigned} {\cf18 int} n);\par
00078             {\cf17 virtual} UInt fromInt ({\cf18 int} n);\par
00079         \};\par
00080 \par
00081         {\cf20 // The different types of formats...}\par
00083 {\cf20 }        {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _BINARY = 0x00;\par
00085         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _PACKAGEDBCD = 0x01;\par
00086 \par
00089         {\cf17 class }FormatManagers final\par
00090         \{\par
00091             {\cf17 public}:\par
00093             FormatManagers ({\cf17 const} std::map <unsigned char, FormatManager*>& fM)\par
00094                 : _formatManagers (fM)\par
00095                             \{ {\cf19 if} (_instance != {\cf17 nullptr}) exit (0); \}\par
00096 \par
00097             ~FormatManagers ()\par
00098                             \{ _instance = {\cf17 nullptr}; {\cf19 for} ({\cf17 auto} i : _formatManagers) {\cf17 delete} (i.second);\}\par
00099 \par
00100             {\cf17 public}:\par
00103             std::map <unsigned char, FormatManager*> _formatManagers;\par
00104 \par
00105             {\cf17 private}:\par
00106             {\cf20 // Implementation}\par
00107             {\cf17 static} FormatManagers* _instance;           \par
00108         \};\par
00109 \par
00112         {\cf17 static} std::map <unsigned char, FormatManager*> _formatManagers;\par
00113 \par
00115         {\cf17 static} {\cf17 const} UInt _0;\par
00116         {\cf17 static} {\cf17 const} UInt _1;\par
00117 \par
00118         UInt ()\par
00119             : _values (),\par
00120               _carry (false), _overflow (false),\par
00121               _format (_BINARY)\par
00122                             \{ \}\par
00123 \par
00126         UInt ({\cf17 const} UBytes& u, {\cf18 bool} bE = {\cf17 true}, {\cf18 unsigned} {\cf18 char} f = _BINARY)\par
00127             : _values ((u.size () > 1 && !bE) ? u.reverse () : u),\par
00128               _carry (false), _overflow (false),\par
00129               _format (f)\par
00130                             \{ \}\par
00131 \par
00132         UInt ({\cf17 const} std::vector <UByte>& u, {\cf18 bool} bE = {\cf17 true}, {\cf18 unsigned} {\cf18 char} f = _BINARY)\par
00133             : _values (u, bE),\par
00134               _carry (false), _overflow (false),\par
00135               _format (f)\par
00136                             \{ \}\par
00137 \par
00138         UInt ({\cf17 const} UInt&) = {\cf19 default};\par
00139         UInt& operator = ({\cf17 const} UInt&) = {\cf19 default};\par
00140 \par
00141         {\cf18 unsigned} {\cf18 char} format (){\cf17  const}\par
00142 {\cf17                             }\{ {\cf19 return} (_format); \}\par
00143 \par
00144         {\cf18 size_t} size (){\cf17  const}\par
00145 {\cf17                             }\{ {\cf19 return} (_values.size ()); \}\par
00146         {\cf18 size_t} sizeBits (){\cf17  const}\par
00147 {\cf17                             }\{ {\cf19 return} (_values.sizeBits ()); \}\par
00148 \par
00149         {\cf18 bool} negative (){\cf17  const}\par
00150 {\cf17                             }\{ {\cf19 return} (_values [0][UByte::sizeBits () - 1]); \}\par
00151         {\cf18 bool} positive (){\cf17  const}\par
00152 {\cf17                             }\{ {\cf19 return} (!_values [0][UByte::sizeBits () - 1]); \}\par
00153 \par
00155         {\cf18 bool} carry (){\cf17  const}\par
00156 {\cf17                             }\{ {\cf19 return} (_carry); \}\par
00157         {\cf18 void} resetCarry ()\par
00158                             \{ _carry = {\cf17 false}; \}\par
00159         {\cf18 bool} overflow (){\cf17  const}\par
00160 {\cf17                             }\{ {\cf19 return} (_overflow); \}\par
00161         {\cf18 void} resetOverflow ()\par
00162                             \{ _overflow = {\cf17 false}; \}\par
00163 \par
00164         {\cf18 void} setMinLength ({\cf18 size_t} l)\par
00165                             \{ {\cf19 return} (_values.setMinLength (l, {\cf17 false} )); \}\par
00166 \par
00167         {\cf17 const} UBytes& values (){\cf17  const}\par
00168 {\cf17                             }\{ {\cf19 return} (_values); \}\par
00169         {\cf17 const} std::vector <UByte>& bytes (){\cf17  const}\par
00170 {\cf17                             }\{ {\cf19 return} (_values.bytes ()); \}\par
00171 \par
00172         UInt LSUInt ({\cf18 size_t} p){\cf17  const}\par
00173 {\cf17                             }\{ {\cf19 return} (UInt (_values.LSUBytes (p))); \}\par
00174         UInt MSUInt ({\cf18 size_t} p){\cf17  const}\par
00175 {\cf17                             }\{ {\cf19 return} (UInt (_values.MSUBytes (p))); \}\par
00176 \par
00177         UInt add ({\cf17 const} UInt& u, {\cf18 bool} iC = {\cf17 false}) {\cf17 const};\par
00178         UInt complement (){\cf17  const}\par
00179 {\cf17                             }\{ {\cf19 return} (MCHEmul::UInt (_values.complement (), {\cf17 true}, _format)); \}\par
00180         UInt complement_2 (){\cf17  const}\par
00181 {\cf17                             }\{ {\cf18 unsigned} {\cf18 char} f = _format; \par
00182                               UInt r = complement (); r._format = _BINARY; r += _1; r._format = f; {\cf19 return} (r); \}\par
00183         UInt substract ({\cf17 const} UInt& u, {\cf18 bool} iC = {\cf17 true}) {\cf17 const};\par
00184         UInt multiply ({\cf17 const} UInt& u) {\cf17 const};\par
00185 \par
00186         {\cf18 bool} operator == ({\cf17 const} UInt& u){\cf17  const}\par
00187 {\cf17                             }\{ {\cf19 return} (_values == u._values); \}\par
00188         {\cf18 bool} operator != ({\cf17 const} UInt& u){\cf17  const}\par
00189 {\cf17                             }\{ {\cf19 return} (_values != u._values); \}\par
00190 \par
00193         {\cf18 bool} operator > ({\cf17 const} UInt& u){\cf17  const}\par
00194 {\cf17                             }\{ {\cf19 return} ((*{\cf17 this} >= u) && (*{\cf17 this} != u)); \}\par
00195         {\cf18 bool} operator >= ({\cf17 const} UInt& u){\cf17  const}\par
00196 {\cf17                             }\{ {\cf19 return} ((*{\cf17 this} - u)._carry); \}\par
00197         {\cf18 bool} operator < ({\cf17 const} UInt& u){\cf17  const}\par
00198 {\cf17                             }\{ {\cf19 return} ((*{\cf17 this} <= u) && (*{\cf17 this} != u)); \}\par
00199         {\cf18 bool} operator <= ({\cf17 const} UInt& u){\cf17  const}\par
00200 {\cf17                             }\{ {\cf19 return} ((u - *{\cf17 this})._carry); \}\par
00201 \par
00202         UInt operator + ({\cf17 const} UInt& u){\cf17  const}\par
00203 {\cf17                             }\{ {\cf19 return} (add (u)); \}\par
00204         UInt& operator += ({\cf17 const} UInt& u)\par
00205                             \{ *{\cf17 this} = *{\cf17 this} + u; {\cf19 return} (*{\cf17 this}); \}\par
00206         UInt operator - (){\cf17  const}\par
00207 {\cf17                             }\{ {\cf19 return} (complement_2 ()); \}\par
00208         UInt operator - ({\cf17 const} UInt& u){\cf17  const}\par
00209 {\cf17                             }\{ {\cf19 return} (substract (u)); \}\par
00210         UInt& operator -= ({\cf17 const} UInt& u)\par
00211                             \{ *{\cf17 this} = *{\cf17 this} - u; {\cf19 return} (*{\cf17 this}); \}\par
00212         UInt operator * ({\cf17 const} UInt& u){\cf17  const}\par
00213 {\cf17                             }\{ {\cf19 return} (multiply (u)); \}\par
00214         UInt& operator *= ({\cf17 const} UInt& u)\par
00215                             \{ *{\cf17 this} = *{\cf17 this} * u; {\cf19 return} (*{\cf17 this}); \}\par
00216 \par
00217         UByte operator [] ({\cf18 size_t} p){\cf17  const}\par
00218 {\cf17                             }\{ {\cf19 return} (_values [p]); \}\par
00219         UByte& operator [] ({\cf18 size_t} p)\par
00220                             \{ {\cf19 return} (_values [p]); \}\par
00221         \par
00222         std::string asString (UByte::OutputFormat oF, {\cf18 char} s , {\cf18 size_t} l = 0 ){\cf17  const}\par
00223 {\cf17                             }\{ {\cf19 return} (_values.asString (oF, s, l)); \}\par
00224 \par
00225         {\cf18 unsigned} {\cf18 int} asUnsignedInt (){\cf17  const}\par
00226 {\cf17                             }\{ {\cf19 return} (_formaters._formatManagers [_format] -> asUnsignedInt (*{\cf17 this})); \}\par
00227         {\cf18 int} asInt (){\cf17  const}\par
00228 {\cf17                             }\{ {\cf19 return} (negative () ? -(({\cf18 int}) complement_2 ().asUnsignedInt ()) : ({\cf18 int}) asUnsignedInt ()); \}\par
00229 \par
00230         {\cf17 static} UInt fromUnsignedInt ({\cf18 unsigned} {\cf18 int} n, {\cf18 unsigned} {\cf18 char} f = _BINARY)\par
00231                             \{ {\cf19 return} (_formaters._formatManagers [f] -> fromUnsignedInt (n)); \}\par
00232         {\cf17 static} UInt fromInt ({\cf18 int} n, {\cf18 unsigned} {\cf18 char} f = _BINARY)\par
00233                             \{ {\cf19 return} (_formaters._formatManagers [f] -> fromInt (n)); \}\par
00234         {\cf17 static} UInt fromStr ({\cf17 const} std::string& s, {\cf18 unsigned} {\cf18 char} f = _BINARY);\par
00235 \par
00236         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} UInt& u)\par
00237                             \{ {\cf19 return} (o << u.asString (UByte::OutputFormat::_HEXA, {\cf23 ' '}, 2)); \}\par
00238 \par
00239         {\cf17 private}:\par
00240         UBytes _values;\par
00242         {\cf18 unsigned} {\cf18 char} _format;\par
00243 \par
00244         {\cf20 // Implementation}\par
00245         {\cf17 mutable} {\cf18 bool} _carry;\par
00246         {\cf17 mutable} {\cf18 bool} _overflow;\par
00247         {\cf17 static} FormatManagers _formaters;\par
00248     \};\par
00249 \par
00250 \}\par
00251 \par
00252 {\cf21 #endif}\par
00253   \par
00254 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/doxy.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/doxy.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/doxy.hpp}
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
doxy.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/doxy.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/doxy.hpp}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Only for doxygen needs.}\par
00002 {\cf20 // Nobody includes it.}\par
00003 \par
00004 {\cf20 // MCHEmul Library}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/EMULATORS/C64Emulator.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/EMULATORS/C64Emulator.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/EMULATORS/C64Emulator.hpp}
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <EMULATORS/Emulator.hpp>}\par
{\f2 #include <C64/global.hpp>}\par
{\f2 #include <C64/C64.hpp>}\par
{\f2 #include <C64/IOPBuilder.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Emuls::C64Emulator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Emuls}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64Emulator.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/EMULATORS/C64Emulator.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/EMULATORS/C64Emulator.hpp}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_C64EMULATOR__}\par
00015 {\cf21 #define __MCHEMUL_C64EMULATOR__}\par
00016 \par
00017 {\cf21 #include <EMULATORS/Emulator.hpp>}\par
00018 {\cf21 #include <C64/global.hpp>}\par
00019 {\cf21 #include <C64/C64.hpp>}\par
00020 {\cf21 #include <C64/IOPBuilder.hpp>}\par
00021 \par
00022 {\cf17 namespace }Emuls\par
00023 \{\par
00024     {\cf17 class }C64Emulator : {\cf17 public} Emulator\par
00025     \{\par
00026         {\cf17 public}:\par
00028         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _PARAMNTSC;\par
00029         {\cf17 static} {\cf17 const} std::string _NTSC;\par
00030 \par
00038         C64Emulator ({\cf17 const} std::vector <std::string>& argv);\par
00039 \par
00041         {\cf18 bool} NTSCSystem (){\cf17  const}\par
00042 {\cf17                             }\{ {\cf19 return} ((_attributes.find (_NTSC) != _attributes.end ()) ? {\cf17 true} : {\cf17 false}); \}\par
00043 \par
00045         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00046 \par
00047         {\cf17 protected}:\par
00048         {\cf17 virtual} MCHEmul::Computer* createComputer (){\cf17  const override}\par
00049 {\cf17                             }\{ {\cf19 return} ({\cf17 new} C64::Commodore64 (NTSCSystem () \par
00050                                 ? C64::Commodore64::VisualSystem::_NTSC : C64::Commodore64::VisualSystem::_PAL)); \}\par
00051 \par
00052         {\cf17 virtual} MCHEmul::IOPeripheralBuilder* createPeripheralBuilder (){\cf17  const override}\par
00053 {\cf17                             }\{ {\cf19 return} ({\cf17 new} C64::IOPeripheralBuilder); \}\par
00054 \par
00056         {\cf17 virtual} {\cf18 bool} additionalRunCycle (){\cf17  override}\par
00057 {\cf17                 }\{ C64::actualizeGlobalTime ();  {\cf19 return} ({\cf17 true}); \}\par
00058     \};\par
00059 \}\par
00060 \par
00061 {\cf21 #endif}\par
00062   \par
00063 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/EMULATORS/Emulator.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/EMULATORS/Emulator.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/EMULATORS/Emulator.hpp}
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <ASSEMBLER/incs.hpp>}\par
{\f2 #include <COMMS/System.hpp>}\par
{\f2 #include <COMMS/StdMessages.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Emuls::Emulator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Emuls}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Emulator.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/EMULATORS/Emulator.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/EMULATORS/Emulator.hpp}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_EMULATOR__}\par
00015 {\cf21 #define __MCHEMUL_EMULATOR__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <ASSEMBLER/incs.hpp>}\par
00019 {\cf21 #include <COMMS/System.hpp>}\par
00020 {\cf21 #include <COMMS/StdMessages.hpp>}\par
00021 \par
00022 {\cf17 namespace }Emuls\par
00023 \{\par
00024     {\cf17 class }Emulator \par
00025     \{\par
00026         {\cf17 public}:\par
00028         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _PARAMBYTEFILE;\par
00029         {\cf17 static} {\cf17 const} std::string _BYTEFILE;\par
00030         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _PARAMASMFILE;\par
00031         {\cf17 static} {\cf17 const} std::string _ASMFILE;\par
00032         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _PARAMLOGLEVEL;\par
00033         {\cf17 static} {\cf17 const} std::string _LOGLEVEL;\par
00034         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _PARAMADDRESS;\par
00035         {\cf17 static} {\cf17 const} std::string _ADDRESS;\par
00036 \par
00037         {\cf17 using} MapOfActions = std::map <MCHEmul::Address, unsigned int>;\par
00038 \par
00049         Emulator ({\cf17 const} std::vector <std::string>& argv);\par
00050 \par
00051         {\cf17 virtual} ~Emulator ();\par
00052 \par
00053         {\cf17 const} MCHEmul::Attributes& attributes (){\cf17  const}\par
00054 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00055 \par
00056         {\cf17 const} MCHEmul::Computer* computer (){\cf17  const}\par
00057 {\cf17                             }\{ {\cf19 return} (_computer == {\cf17 nullptr}) ? (_computer = createComputer ()) : _computer; \}\par
00058         MCHEmul::Computer* computer ()\par
00059                             \{ {\cf19 return} ((MCHEmul::Computer*) ((({\cf17 const} Emulator*) {\cf17 this}) -> computer ())); \}\par
00060 \par
00062         {\cf18 void} setCommunicationSystem (MCHEmul::CommunicationSystem* cS);\par
00063 \par
00066         std::string byteFileName (){\cf17  const}\par
00067 {\cf17                             }\{ MCHEmul::Attributes::const_iterator i; \par
00068                                 {\cf19 return} (((i = _attributes.find (_BYTEFILE)) != _attributes.end ()) ? (*i).second : {\cf22 ""}); \}\par
00069 \par
00072         std::string asmFileName (){\cf17  const}\par
00073 {\cf17                             }\{ MCHEmul::Attributes::const_iterator i; \par
00074                                 {\cf19 return} (((i = _attributes.find (_ASMFILE)) != _attributes.end ()) ? (*i).second : {\cf22 ""}); \}\par
00075 \par
00078         {\cf18 unsigned} {\cf18 int} logLevel (){\cf17  const}\par
00079 {\cf17                             }\{ MCHEmul::Attributes::const_iterator i; \par
00080                                 {\cf19 return} (({\cf18 unsigned} {\cf18 int}) std::stoi (((i = _attributes.find (_LOGLEVEL)) != _attributes.end ()) \par
00081                                     ? (*i).second : {\cf22 ""})); \}\par
00082 \par
00085         MCHEmul::Address startingAddress (){\cf17  const}\par
00086 {\cf17                             }\{ MCHEmul::Attributes::const_iterator i; \par
00087                                 {\cf19 return} (MCHEmul::Address::fromStr (((i = _attributes.find (_ADDRESS)) != _attributes.end ()) \par
00088                                     ? (*i).second : {\cf22 ""})); \}\par
00089 \par
00090         {\cf18 unsigned} {\cf18 int} debugLevel (){\cf17  const}\par
00091 {\cf17                             }\{ {\cf19 return} (_debugLevel); \}\par
00092         {\cf18 void} setDebugLevel ({\cf18 unsigned} {\cf18 int} dL)\par
00093                             \{ _debugLevel = dL; computer () -> setDebugLevel (dL); \}\par
00094 \par
00095         {\cf20 // To manage actions at address level...}\par
00097 {\cf20 }        {\cf18 void} setActions ({\cf17 const} MapOfActions& at)\par
00098                             \{ _actionsAt = at; \}\par
00100         {\cf18 void} addAction ({\cf17 const} MCHEmul::Address& at, {\cf18 unsigned} {\cf18 int} a);\par
00101         {\cf18 void} removeAction ({\cf17 const} MCHEmul::Address& at);\par
00102 \par
00103         {\cf18 bool} connectPeripheral ({\cf18 int} {\cf18 id}, {\cf17 const} MCHEmul::Attributes& prms, MCHEmul::IODevice* d)\par
00104                             \{ {\cf19 return} (computer () -> connect (peripherialBuilder () -> peripheral ({\cf18 id}, prms), d)); \}\par
00105 \par
00107         {\cf17 virtual} {\cf18 bool} initialize ();\par
00108 \par
00110         {\cf18 bool} run ();\par
00111 \par
00114         {\cf18 bool} runCycle ({\cf18 unsigned} {\cf18 int} a = 0);\par
00115 \par
00116         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00117 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00118         {\cf18 bool} operator ! (){\cf17  const}\par
00119 {\cf17                             }\{ {\cf19 return} (_lastError != MCHEmul::_NOERROR); \}\par
00120 \par
00121         {\cf17 protected}:\par
00122         {\cf17 const} MCHEmul::IOPeripheralBuilder* peripherialBuilder (){\cf17  const}\par
00123 {\cf17                             }\{ {\cf19 return} (_peripheralBuilder == {\cf17 nullptr}) ? \par
00124                                 (_peripheralBuilder = createPeripheralBuilder ()) : _peripheralBuilder; \}\par
00125         MCHEmul::IOPeripheralBuilder* peripherialBuilder ()\par
00126                             \{ {\cf19 return} ((MCHEmul::IOPeripheralBuilder*) ((({\cf17 const} Emulator*) {\cf17 this}) -> peripherialBuilder ())); \}\par
00127 \par
00128         {\cf20 // To be used when e.g debugging...}\par
00139 {\cf20 }        {\cf17 virtual} {\cf18 bool} executeAction ({\cf18 unsigned} {\cf18 int}& lA, {\cf18 unsigned} {\cf18 int} at, {\cf18 unsigned} {\cf18 int} a);\par
00140 \par
00143         {\cf17 virtual} {\cf18 bool} additionalRunCycle ()\par
00144                             \{ {\cf19 return} ({\cf17 true}); \}\par
00145 \par
00146         {\cf20 // Implementation}\par
00149 {\cf20 }        {\cf17 virtual} MCHEmul::Computer* createComputer () {\cf17 const} = 0;\par
00150 \par
00152         {\cf17 virtual} MCHEmul::IOPeripheralBuilder* createPeripheralBuilder () {\cf17 const} = 0;\par
00153 \par
00154         {\cf17 protected}:\par
00156         MCHEmul::Attributes _attributes;\par
00157         MCHEmul::CommunicationSystem* _communicationSystem;\par
00158         {\cf18 unsigned} {\cf18 int} _debugLevel;\par
00159         std::map <MCHEmul::Address, unsigned int> _actionsAt;\par
00160 \par
00161         {\cf20 // Implementation}\par
00162         {\cf17 mutable} MCHEmul::Computer* _computer;\par
00163         {\cf17 mutable} MCHEmul::IOPeripheralBuilder* _peripheralBuilder;\par
00164         {\cf17 mutable} {\cf18 bool} _running;\par
00165         {\cf18 unsigned} {\cf18 int} _lastError;\par
00166         {\cf18 unsigned} {\cf18 int} _lastAction;\par
00167     \};\par
00168 \}\par
00169 \par
00170 {\cf21 #endif}\par
00171   \par
00172 {\cf20 // End of the file}\par
00174 {\cf20 }{\cf21 #pragma once}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/C6500.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/C6500.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/C6500.hpp}
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::C6500}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b F6500}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C6500.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/C6500.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/C6500.hpp}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __F6500_C6500__}\par
00015 {\cf21 #define __F6500_C6500__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }F6500\par
00020 \{\par
00022     {\cf17 class }C6500 : {\cf17 public} MCHEmul::CPU\par
00023     \{\par
00024         {\cf17 public}:\par
00026         {\cf17 enum class} AddressMode\par
00027         \{\par
00028             _IMPLICIT,      {\cf20 // The instruction has no parameter at all.}\par
00029             _INMEDIATE,     {\cf20 // The parameter is a value}\par
00030             _ABSOLUTE,      {\cf20 // The parameter is an address}\par
00031             _ZEROPAGE,      {\cf20 // The parameter is an addresss to but in th first page of the memory}\par
00032             _ABSOLUTE_X,    {\cf20 // The paremeter is got from an address and the value of the register X}\par
00033             _ABSOLUTE_Y,    {\cf20 // The paremeter is got from an address and the value of the register Y}\par
00034             _RELATIVE,      {\cf20 // The parameter is a number of steps foward or backward}\par
00035             _INDIRECT,      {\cf20 // The parameter is an address where to find other}\par
00036             _ZEROPAGE_X,    {\cf20 // The paremeter is got from an address (in page 0) and the value of the register X }\par
00037             _ZEROPAGE_Y,    {\cf20 // The paremeter is got from an address (in page 0) and the value of the register Y}\par
00038             _INDIRECT_X,    {\cf20 // The parameter is got from an address that is in other, plus the register X}\par
00039             _INDIRECT_Y,    {\cf20 // The parameter is got from an address that is in other plus the register Y}\par
00040         \};\par
00041 \par
00042         C6500 ({\cf17 const} MCHEmul::CPUArchitecture& a);\par
00043 \par
00044         {\cf17 virtual} MCHEmul::Address IRQVectorAddress () {\cf17 const} = 0;\par
00045         {\cf17 virtual} MCHEmul::Address NMIVectorAddress () {\cf17 const} = 0;\par
00046         {\cf17 virtual} MCHEmul::Address ResetVectorAddress () {\cf17 const} = 0;\par
00047 \par
00048         MCHEmul::Register& accumulator ()\par
00049                             \{ {\cf19 return} (internalRegister (_ACCUMULATOR)); \}\par
00050         MCHEmul::Register& xRegister ()\par
00051                             \{ {\cf19 return} (internalRegister (_XREGISTER)); \}\par
00052         MCHEmul::Register& yRegister ()\par
00053                             \{ {\cf19 return} (internalRegister (_YREGISTER)); \}\par
00054 \par
00055         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00056 \par
00058         {\cf17 static} {\cf17 const} {\cf18 size_t} _ACCUMULATOR = 0;\par
00059         {\cf17 static} {\cf17 const} {\cf18 size_t} _XREGISTER = 1;\par
00060         {\cf17 static} {\cf17 const} {\cf18 size_t} _YREGISTER = 2;\par
00061 \par
00062         {\cf17 private}:\par
00063         {\cf20 // Implementation}\par
00064         {\cf17 static} MCHEmul::Registers createInternalRegisters ();\par
00065         {\cf17 static} MCHEmul::StatusRegister createStatusRegister ();\par
00066         {\cf17 static} MCHEmul::Instructions createInstructions ();\par
00067     \};\par
00068 \}\par
00069 \par
00070 {\cf21 #endif}\par
00071   \par
00072 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/C6510.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/C6510.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/C6510.hpp}
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/C6500.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::C6510}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b F6500}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C6510.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/C6510.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/C6510.hpp}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __F6500_C6510__}\par
00015 {\cf21 #define __F6500_C6510__}\par
00016 \par
00017 {\cf21 #include <F6500/C6500.hpp>}\par
00018 \par
00019 {\cf17 namespace }F6500\par
00020 \{\par
00022     {\cf17 class }C6510 : {\cf17 public} C6500\par
00023     \{\par
00024         {\cf17 public}:\par
00025         C6510 ()\par
00026             : C6500 (createArchitecture ())\par
00027                             \{ \}\par
00028 \par
00029         {\cf17 virtual} MCHEmul::Address IRQVectorAddress (){\cf17  const override}\par
00030 {\cf17                             }\{ {\cf19 return} (MCHEmul::Address (\{ 0xfe, 0xff \}, {\cf17 false} )); \}\par
00031         {\cf17 virtual} MCHEmul::Address NMIVectorAddress (){\cf17  const override}\par
00032 {\cf17                             }\{ {\cf19 return} (MCHEmul::Address (\{ 0xfa, 0xff \}, {\cf17 false} )); \}\par
00033         {\cf17 virtual} MCHEmul::Address ResetVectorAddress (){\cf17  const override}\par
00034 {\cf17                             }\{ {\cf19 return} (MCHEmul::Address (\{ 0xfc, 0xff \}, {\cf17 false} )); \}\par
00035 \par
00036         {\cf17 private}:\par
00037         {\cf20 // Implementation}\par
00038         {\cf17 static} MCHEmul::CPUArchitecture createArchitecture ();\par
00039     \};\par
00040 \}\par
00041 \par
00042 {\cf21 #endif}\par
00043   \par
00044 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/Instructions.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/Instructions.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/Instructions.hpp}
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::Instruction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::ADC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::AND_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::ASL_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::BXX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::CMP_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::CPX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::CPY_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::DEC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::EOR_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::INC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::LDA_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::LDX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::LDY_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::LSR_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::ORA_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::ROL_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::ROR_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::SBC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::STA_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::STX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::STY_General}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b F6500}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x69, 2, 2, "ADC#[#1]", ADC_Inmediate, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x6d, 3, 4, "ADC[$2]", ADC_Absolute, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x65, 2, 3, "ADC[$1]", ADC_ZeroPage, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x61, 2, 6, "ADC([$1],X)", ADC_ZeroPageIndirectX, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x71, 2, 5, "ADC([$1]),Y", ADC_ZeroPageIndirectY, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x75, 2, 4, "ADC[$1],X", ADC_ZeroPageX, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x7d, 3, 4, "ADC[$2],X", ADC_AbsoluteX, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x79, 3, 4, "ADC[$2],Y", ADC_AbsoluteY, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x29, 2, 2, "AND#[#1]", AND_Inmediate, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x2d, 3, 4, "AND[$2]", AND_Absolute, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x25, 2, 3, "AND[$1]", AND_ZeroPage, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x21, 2, 6, "AND([$1],X)", AND_ZeroPageIndirectX, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x31, 2, 5, "AND([$1]),Y", AND_ZeroPageIndirectY, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x35, 2, 4, "AND[$1],X", AND_ZeroPageX, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x3d, 3, 4, "AND[$2],X", AND_AbsoluteX, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x39, 3, 4, "AND[$2],Y", AND_AbsoluteY, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x0e, 3, 6, "ASL[$2]", ASL_Absolute, ASL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x06, 2, 5, "ASL[$1]", ASL_ZeroPage, ASL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x0a, 1, 2, "ASL", ASL_Accumulator, ASL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x16, 2, 6, "ASL[$1],X", ASL_ZeroPageX, ASL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x1e, 3, 7, "ASL[$2],X", ASL_AbsoluteX, ASL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x90, 2, 2, "BCC[&1]", BCC, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb0, 2, 2, "BCS[&1]", BCS, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xf0, 2, 2, "BEQ[&1]", BEQ, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x2c, 3, 4, "BIT[$2]", BIT_Absolute, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x24, 2, 3, "BIT[$1]", BIT_ZeroPage, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x30, 2, 2, "BMI[&1]", BMI, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xd0, 2, 2, "BNE[&1]", BNE, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x10, 2, 2, "BPL[&1]", BPL, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x00, 1, 7, "BRK", BRK, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x50, 2, 2, "BVC[&1]", BVC, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x70, 2, 2, "BVS[&1]", BVS, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x18, 1, 2, "CLC", CLC, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xd8, 1, 2, "CLD", CLD, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x58, 1, 2, "CLI", CLI, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb8, 1, 2, "CLV", CLV, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc9, 2, 2, "CMP#[#1]", CMP_Inmediate, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xcd, 3, 4, "CMP[$2]", CMP_Absolute, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc5, 2, 3, "CMP[$1]", CMP_ZeroPage, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc1, 2, 6, "CMP([$1],X)", CMP_ZeroPageIndirectX, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xd1, 2, 5, "CMP([$1]),Y", CMP_ZeroPageIndirectY, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xd5, 2, 4, "CMP[$1],X", CMP_ZeroPageX, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xdd, 3, 4, "CMP[$2],X", CMP_AbsoluteX, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xd9, 3, 4, "CMP[$2],Y", CMP_AbsoluteY, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe0, 2, 2, "CPX#[#1]", CPX_Inmediate, CPX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xec, 3, 4, "CPX[$2]", CPX_Absolute, CPX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe4, 2, 3, "CPX[$1]", CPX_ZeroPage, CPX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc0, 2, 2, "CPY#[#1]", CPY_Inmediate, CPY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xcc, 3, 4, "CPY[$2]", CPY_Absolute, CPY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc4, 2, 3, "CPY[$1]", CPY_ZeroPage, CPY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xce, 3, 6, "DEC[$2]", DEC_Absolute, DEC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc6, 2, 5, "DEC[$1]", DEC_ZeroPage, DEC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xd6, 2, 6, "DEC[$1],X", DEC_ZeroPageX, DEC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xde, 3, 7, "DEC[$2],X", DEC_AbsoluteX, DEC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xca, 1, 2, "DEX", DEX, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x88, 1, 2, "DEY", DEY, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x49, 2, 2, "EOR#[#1]", EOR_Inmediate, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x4d, 3, 4, "EOR[$2]", EOR_Absolute, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x45, 2, 3, "EOR[$1]", EOR_ZeroPage, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x41, 2, 6, "EOR([$1],X)", EOR_ZeroPageIndirectX, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x51, 2, 5, "EOR([$1]),Y", EOR_ZeroPageIndirectY, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x55, 2, 4, "EOR[$1],X", EOR_ZeroPageX, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x5d, 3, 4, "EOR[$2],X", EOR_AbsoluteX, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x59, 3, 4, "EOR[$2],Y", EOR_AbsoluteY, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xee, 3, 6, "INC[$2]", INC_Absolute, INC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe6, 2, 5, "INC[$1]", INC_ZeroPage, INC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xf6, 2, 6, "INC[$1],X", INC_ZeroPageX, INC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xfe, 3, 7, "INC[$2],X", INC_AbsoluteX, INC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe8, 1, 2, "INX", INX, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc8, 1, 2, "INY", INY, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x4c, 3, 3, "JMP[%2]", JMP_Absolute, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x6c, 3, 5, "JMP([%2])", JMP_Indirect, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x20, 3, 6, "JSR[%2]", JSR_Absolute, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa9, 2, 2, "LDA#[#1]", LDA_Inmediate, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xad, 3, 4, "LDA[$2]", LDA_Absolute, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa5, 2, 3, "LDA[$1]", LDA_ZeroPage, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa1, 2, 6, "LDA([$1],X)", LDA_ZeroPageIndirectX, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb1, 2, 5, "LDA([$1]),Y", LDA_ZeroPageIndirectY, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb5, 2, 4, "LDA[$1],X", LDA_ZeroPageX, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xbd, 3, 4, "LDA[$2],X", LDA_AbsoluteX, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb9, 3, 4, "LDA[$2],Y", LDA_AbsoluteY, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa2, 2, 2, "LDX#[#1]", LDX_Inmediate, LDX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xae, 3, 4, "LDX[$2]", LDX_Absolute, LDX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa6, 2, 3, "LDX[$1]", LDX_ZeroPage, LDX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xbe, 3, 4, "LDX[$2],Y", LDX_AbsoluteY, LDX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb6, 2, 4, "LDX[$1],Y", LDX_ZeroPageY, LDX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa0, 2, 2, "LDY#[#1]", LDY_Inmediate, LDY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xac, 3, 4, "LDY[$2]", LDY_Absolute, LDY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa4, 2, 3, "LDY[$1]", LDY_ZeroPage, LDY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb4, 2, 4, "LDY[$1],X", LDY_ZeroPageX, LDY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xbc, 3, 4, "LDY[$2],X", LDY_AbsoluteX, LDY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x4e, 3, 6, "LSR[$2]", LSR_Absolute, LSR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x46, 2, 5, "LSR[$1]", LSR_ZeroPage, LSR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x4a, 1, 2, "LSR", LSR_Accumulator, LSR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x56, 2, 6, "LSR[$1],X", LSR_ZeroPageX, LSR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x5e, 3, 7, "LSR[$2],X", LSR_AbsoluteX, LSR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xea, 1, 2, "NOP", NOP, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x09, 2, 2, "ORA#[#1]", ORA_Inmediate, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x0d, 3, 4, "ORA[$2]", ORA_Absolute, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x05, 2, 3, "ORA[$1]", ORA_ZeroPage, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x01, 2, 6, "ORA([$1],X)", ORA_ZeroPageIndirectX, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x11, 2, 5, "ORA([$1]),Y", ORA_ZeroPageIndirectY, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x15, 2, 4, "ORA[$1],X", ORA_ZeroPageX, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x1d, 3, 4, "ORA[$2],X", ORA_AbsoluteX, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x19, 3, 4, "ORA[$2],Y", ORA_AbsoluteY, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x48, 1, 3, "PHA", PHA, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x08, 1, 3, "PHP", PHP, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x68, 1, 4, "PLA", PLA, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x28, 1, 4, "PLP", PLP, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x2e, 3, 6, "ROL[$2]", ROL_Absolute, ROL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x26, 2, 5, "ROL[$1]", ROL_ZeroPage, ROL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x2a, 1, 2, "ROL", ROL_Accumulator, ROL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x36, 2, 6, "ROL[$1],X", ROL_ZeroPageX, ROL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x3e, 3, 7, "ROL[$2],X", ROL_AbsoluteX, ROL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x6e, 3, 6, "ROR[$2]", ROR_Absolute, ROR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x66, 2, 5, "ROR[$1]", ROR_ZeroPage, ROR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x6a, 1, 2, "ROR", ROR_Accumulator, ROR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x76, 2, 6, "ROR[$1],X", ROR_ZeroPageX, ROR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x7e, 3, 7, "ROR[$2],X", ROR_AbsoluteX, ROR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x40, 1, 6, "RTI", RTI, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x60, 1, 6, "RTS", RTS, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe9, 2, 2, "SBC#[#1]", SBC_Inmediate, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xed, 3, 4, "SBC[$2]", SBC_Absolute, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe5, 2, 3, "SBC[$1]", SBC_ZeroPage, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe1, 2, 6, "SBC([$1],X)", SBC_ZeroPageIndirectX, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xf1, 2, 5, "SBC([$1]),Y", SBC_ZeroPageIndirectY, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xf5, 2, 4, "SBC[$1],X", SBC_ZeroPageX, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xfd, 3, 4, "SBC[$2],X", SBC_AbsoluteX, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xf9, 3, 4, "SBC[$2],Y", SBC_AbsoluteY, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x38, 1, 2, "SEC", SEC, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xf8, 1, 2, "SED", SED, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x78, 1, 2, "SEI", SEI, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x8d, 3, 4, "STA[$2]", STA_Absolute, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x85, 2, 3, "STA[$1]", STA_ZeroPage, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x81, 2, 6, "STA([$1],X)", STA_ZeroPageIndirectX, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x91, 2, 6, "STA([$1]),Y", STA_ZeroPageIndirectY, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x95, 2, 4, "STA[$1],X", STA_ZeroPageX, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x9d, 3, 5, "STA[$2],X", STA_AbsoluteX, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x99, 3, 5, "STA[$2],Y", STA_AbsoluteY, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x8e, 3, 4, "STX[$2]", STX_Absolute, STX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x86, 2, 3, "STX[$1]", STX_ZeroPage, STX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x96, 2, 4, "STX[$1],Y", STX_ZeroPageY, STX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x8c, 3, 4, "STY[$2]", STY_Absolute, STY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x84, 2, 3, "STY[$1]", STY_ZeroPage, STY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x94, 2, 4, "STY[$1],X", STY_ZeroPageX, STY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xaa, 1, 2, "TAX", TAX, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa8, 1, 2, "TAY", TAY, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xba, 1, 2, "TSX", TSX, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x8a, 1, 2, "TXA", TXA, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x9a, 1, 2, "TXS", TXS, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x98, 1, 2, "TYA", TYA, Instruction)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Instructions.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/Instructions.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/Instructions.hpp}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __F6500_INSTRUCTIONS__}\par
00015 {\cf21 #define __F6500_INSTRUCTIONS__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }F6500\par
00020 \{\par
00024     {\cf17 class }Instruction : {\cf17 public} MCHEmul::Instruction\par
00025     \{\par
00026         {\cf17 public}:\par
00027         Instruction ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00028             : MCHEmul::Instruction (c, mp, cc, t)\par
00029                             \{ \}\par
00030     \par
00031         {\cf17 protected}:\par
00032         {\cf20 // To interpret the parameters of the instruction as an address }\par
00034 {\cf20 }        MCHEmul::Address address_absolute ();\par
00036         MCHEmul::Address address_zeroPage ();\par
00039         MCHEmul::Address address_absoluteX ();\par
00042         MCHEmul::Address address_absoluteY ();\par
00045         MCHEmul::Address address_zeroPageX ();\par
00048         MCHEmul::Address address_zeroPageY ();\par
00051         MCHEmul::Address address_indirectZeroPageX ();\par
00054         MCHEmul::Address address_indirectZeroPageY ();\par
00057         MCHEmul::Address address_indirect ();\par
00058 \par
00059         {\cf20 // To interpret the parameters of the instruction as a a value}\par
00061 {\cf20 }        MCHEmul::UByte value_inmediate ();\par
00062         MCHEmul::UByte value_absolute ()\par
00063                             \{ {\cf19 return} (memory () -> value (address_absolute ())); \}\par
00064         MCHEmul::UByte value_zeroPage ()\par
00065                             \{ {\cf19 return} (memory () -> value (address_zeroPage ())); \}\par
00066         MCHEmul::UByte value_absoluteX ()\par
00067                             \{ {\cf19 return} (memory () -> value (address_absoluteX ())); \}\par
00068         MCHEmul::UByte value_absoluteY ()\par
00069                             \{ {\cf19 return} (memory () -> value (address_absoluteY ())); \}\par
00071         MCHEmul::UByte value_relative ();\par
00072         MCHEmul::UByte value_zeroPageX ()\par
00073                             \{ {\cf19 return} (memory () -> value (address_zeroPageX ())); \}\par
00074         MCHEmul::UByte value_zeroPageY ()\par
00075                             \{ {\cf19 return} (memory () -> value (address_zeroPageY ())); \}\par
00076         MCHEmul::UByte value_indirectZeroPageX ()\par
00077                             \{ {\cf19 return} (memory () -> value (address_indirectZeroPageX ())); \}\par
00078         MCHEmul::UByte value_indirectZeroPageY ()\par
00079                             \{ {\cf19 return} (memory () -> value (address_indirectZeroPageY ())); \}\par
00080     \};\par
00081 \par
00082     {\cf20 // ADC}\par
00084 {\cf20 }    {\cf17 class }ADC_General : {\cf17 public} Instruction\par
00085     \{\par
00086         {\cf17 public}:\par
00087         ADC_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00088             : Instruction (c, mp, cc, t)\par
00089                             \{ \}\par
00090 \par
00091         {\cf17 protected}:\par
00092         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00093     \};\par
00094 \par
00095     _INST_FROM (0x69, 2, 2, {\cf22 "ADC#[#1]"},     ADC_Inmediate, ADC_General);\par
00096     _INST_FROM (0x6d, 3, 4, {\cf22 "ADC[$2]"},      ADC_Absolute, ADC_General);\par
00097     _INST_FROM (0x65, 2, 3, {\cf22 "ADC[$1]"},      ADC_ZeroPage, ADC_General);\par
00098     _INST_FROM (0x61, 2, 6, {\cf22 "ADC([$1],X)"},  ADC_ZeroPageIndirectX, ADC_General);\par
00099     _INST_FROM (0x71, 2, 5, {\cf22 "ADC([$1]),Y"},  ADC_ZeroPageIndirectY, ADC_General);\par
00100     _INST_FROM (0x75, 2, 4, {\cf22 "ADC[$1],X"},    ADC_ZeroPageX, ADC_General);\par
00101     _INST_FROM (0x7d, 3, 4, {\cf22 "ADC[$2],X"},    ADC_AbsoluteX, ADC_General);\par
00102     _INST_FROM (0x79, 3, 4, {\cf22 "ADC[$2],Y"},    ADC_AbsoluteY, ADC_General);\par
00103 \par
00104     {\cf20 // AND}\par
00106 {\cf20 }    {\cf17 class }AND_General : {\cf17 public} Instruction\par
00107     \{\par
00108         {\cf17 public}:\par
00109         AND_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00110             : Instruction (c, mp, cc, t)\par
00111                             \{ \}\par
00112 \par
00113         {\cf17 protected}:\par
00114         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00115     \};\par
00116 \par
00117     _INST_FROM (0x29, 2, 2, {\cf22 "AND#[#1]"},     AND_Inmediate, AND_General);\par
00118     _INST_FROM (0x2d, 3, 4, {\cf22 "AND[$2]"},      AND_Absolute, AND_General);\par
00119     _INST_FROM (0x25, 2, 3, {\cf22 "AND[$1]"},      AND_ZeroPage, AND_General);\par
00120     _INST_FROM (0x21, 2, 6, {\cf22 "AND([$1],X)"},  AND_ZeroPageIndirectX, AND_General);\par
00121     _INST_FROM (0x31, 2, 5, {\cf22 "AND([$1]),Y"},  AND_ZeroPageIndirectY, AND_General);\par
00122     _INST_FROM (0x35, 2, 4, {\cf22 "AND[$1],X"},    AND_ZeroPageX, AND_General);\par
00123     _INST_FROM (0x3d, 3, 4, {\cf22 "AND[$2],X"},    AND_AbsoluteX, AND_General);\par
00124     _INST_FROM (0x39, 3, 4, {\cf22 "AND[$2],Y"},    AND_AbsoluteY, AND_General);\par
00125 \par
00126     {\cf20 // ASL}\par
00128 {\cf20 }    {\cf17 class }ASL_General : {\cf17 public} Instruction\par
00129     \{\par
00130         {\cf17 public}:\par
00131         ASL_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00132             : Instruction (c, mp, cc, t)\par
00133                             \{ \}\par
00134 \par
00135         {\cf17 protected}:\par
00136         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00137     \};\par
00138 \par
00139     _INST_FROM (0x0e, 3, 6, {\cf22 "ASL[$2]"},  ASL_Absolute, ASL_General);\par
00140     _INST_FROM (0x06, 2, 5, {\cf22 "ASL[$1]"},      ASL_ZeroPage, ASL_General);\par
00141     _INST_FROM (0x0a, 1, 2, {\cf22 "ASL"},          ASL_Accumulator, ASL_General);\par
00142     _INST_FROM (0x16, 2, 6, {\cf22 "ASL[$1],X"},    ASL_ZeroPageX, ASL_General);\par
00143     _INST_FROM (0x1e, 3, 7, {\cf22 "ASL[$2],X"},    ASL_AbsoluteX, ASL_General);\par
00144 \par
00146     {\cf17 class }BXX_General : {\cf17 public} Instruction\par
00147     \{\par
00148         {\cf17 public}:\par
00149         BXX_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00150             : Instruction (c, mp, cc, t)\par
00151                             \{ \}\par
00152 \par
00153         {\cf17 protected}:\par
00154         {\cf18 void} executeBranch ();\par
00155     \};\par
00156 \par
00157     {\cf20 // BCC }\par
00158     _INST_FROM (0x90, 2, 2, {\cf22 "BCC[&1]"},      BCC, BXX_General);\par
00159 \par
00160     {\cf20 // BCS }\par
00161     _INST_FROM (0xb0, 2, 2, {\cf22 "BCS[&1]"},      BCS, BXX_General);\par
00162 \par
00163     {\cf20 // BEQ}\par
00164     _INST_FROM (0xf0, 2, 2, {\cf22 "BEQ[&1]"},      BEQ, BXX_General);\par
00165 \par
00166     {\cf20 // BIT}\par
00167     _INST_FROM (0x2c, 3, 4, {\cf22 "BIT[$2]"},      BIT_Absolute, Instruction);\par
00168     _INST_FROM (0x24, 2, 3, {\cf22 "BIT[$1]"},      BIT_ZeroPage, Instruction);\par
00169 \par
00170     {\cf20 // BMI}\par
00171     _INST_FROM (0x30, 2, 2, {\cf22 "BMI[&1]"},      BMI, BXX_General);\par
00172 \par
00173     {\cf20 // BNE}\par
00174     _INST_FROM (0xd0, 2, 2, {\cf22 "BNE[&1]"},      BNE, BXX_General);\par
00175 \par
00176     {\cf20 // BPL}\par
00177     _INST_FROM (0x10, 2, 2, {\cf22 "BPL[&1]"},      BPL, BXX_General);\par
00178 \par
00179     {\cf20 // BRK}\par
00180     _INST_FROM (0x00, 1, 7, {\cf22 "BRK"},          BRK, Instruction);\par
00181 \par
00182     {\cf20 // BVC}\par
00183     _INST_FROM (0x50, 2, 2, {\cf22 "BVC[&1]"},      BVC, BXX_General);\par
00184 \par
00185     {\cf20 // BVS}\par
00186     _INST_FROM (0x70, 2, 2, {\cf22 "BVS[&1]"},      BVS, BXX_General);\par
00187 \par
00188     {\cf20 // CLC}\par
00189     _INST_FROM (0x18, 1, 2, {\cf22 "CLC"},          CLC, Instruction);\par
00190 \par
00191     {\cf20 // CLD}\par
00192     _INST_FROM (0xd8, 1, 2, {\cf22 "CLD"},          CLD, Instruction);\par
00193 \par
00194     {\cf20 // CLI}\par
00195     _INST_FROM (0x58, 1, 2, {\cf22 "CLI"},          CLI, Instruction);\par
00196 \par
00197     {\cf20 // CLV}\par
00198     _INST_FROM (0xb8, 1, 2, {\cf22 "CLV"},          CLV, Instruction);\par
00199 \par
00200     {\cf20 // CMP}\par
00202 {\cf20 }    {\cf17 class }CMP_General : {\cf17 public} Instruction\par
00203     \{\par
00204         {\cf17 public}:\par
00205         CMP_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00206             : Instruction (c, mp, cc, t)\par
00207                             \{ \}\par
00208 \par
00209         {\cf17 protected}:\par
00210         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00211     \};\par
00212 \par
00213     _INST_FROM (0xc9, 2, 2, {\cf22 "CMP#[#1]"},     CMP_Inmediate, CMP_General);\par
00214     _INST_FROM (0xcd, 3, 4, {\cf22 "CMP[$2]"},  CMP_Absolute, CMP_General);\par
00215     _INST_FROM (0xc5, 2, 3, {\cf22 "CMP[$1]"},      CMP_ZeroPage, CMP_General);\par
00216     _INST_FROM (0xc1, 2, 6, {\cf22 "CMP([$1],X)"},  CMP_ZeroPageIndirectX, CMP_General);\par
00217     _INST_FROM (0xd1, 2, 5, {\cf22 "CMP([$1]),Y"},  CMP_ZeroPageIndirectY, CMP_General);\par
00218     _INST_FROM (0xd5, 2, 4, {\cf22 "CMP[$1],X"},    CMP_ZeroPageX, CMP_General);\par
00219     _INST_FROM (0xdd, 3, 4, {\cf22 "CMP[$2],X"},    CMP_AbsoluteX, CMP_General);\par
00220     _INST_FROM (0xd9, 3, 4, {\cf22 "CMP[$2],Y"},    CMP_AbsoluteY, CMP_General);\par
00221 \par
00222     {\cf20 // CPX}\par
00224 {\cf20 }    {\cf17 class }CPX_General : {\cf17 public} Instruction\par
00225     \{\par
00226         {\cf17 public}:\par
00227         CPX_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00228             : Instruction (c, mp, cc, t)\par
00229                             \{ \}\par
00230 \par
00231         {\cf17 protected}:\par
00232         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00233     \};\par
00234 \par
00235     _INST_FROM (0xe0, 2, 2, {\cf22 "CPX#[#1]"},     CPX_Inmediate, CPX_General);\par
00236     _INST_FROM (0xec, 3, 4, {\cf22 "CPX[$2]"},  CPX_Absolute, CPX_General);\par
00237     _INST_FROM (0xe4, 2, 3, {\cf22 "CPX[$1]"},      CPX_ZeroPage, CPX_General);\par
00238 \par
00239     {\cf20 // CPY}\par
00241 {\cf20 }    {\cf17 class }CPY_General : {\cf17 public} Instruction\par
00242     \{\par
00243         {\cf17 public}:\par
00244         CPY_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00245             : Instruction (c, mp, cc, t)\par
00246                             \{ \}\par
00247 \par
00248         {\cf17 protected}:\par
00249         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00250     \};\par
00251 \par
00252     _INST_FROM (0xc0, 2, 2, {\cf22 "CPY#[#1]"},     CPY_Inmediate, CPY_General);\par
00253     _INST_FROM (0xcc, 3, 4, {\cf22 "CPY[$2]"},  CPY_Absolute, CPY_General);\par
00254     _INST_FROM (0xc4, 2, 3, {\cf22 "CPY[$1]"},      CPY_ZeroPage, CPY_General);\par
00255 \par
00256     {\cf20 // DEC}\par
00258 {\cf20 }    {\cf17 class }DEC_General : {\cf17 public} Instruction\par
00259     \{\par
00260         {\cf17 public}:\par
00261         DEC_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00262             : Instruction (c, mp, cc, t)\par
00263                             \{ \}\par
00264 \par
00265         {\cf17 protected}:\par
00266         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00267     \};\par
00268 \par
00269     _INST_FROM (0xce, 3, 6, {\cf22 "DEC[$2]"},  DEC_Absolute, DEC_General);\par
00270     _INST_FROM (0xc6, 2, 5, {\cf22 "DEC[$1]"},      DEC_ZeroPage, DEC_General);\par
00271     _INST_FROM (0xd6, 2, 6, {\cf22 "DEC[$1],X"},    DEC_ZeroPageX, DEC_General);\par
00272     _INST_FROM (0xde, 3, 7, {\cf22 "DEC[$2],X"},    DEC_AbsoluteX, DEC_General);\par
00273 \par
00274     {\cf20 // DEX}\par
00275     _INST_FROM (0xca, 1, 2, {\cf22 "DEX"},          DEX, Instruction);\par
00276 \par
00277     {\cf20 // DEY}\par
00278     _INST_FROM (0x88, 1, 2, {\cf22 "DEY"},          DEY, Instruction);\par
00279 \par
00280     {\cf20 // EOR}\par
00282 {\cf20 }    {\cf17 class }EOR_General : {\cf17 public} Instruction\par
00283     \{\par
00284         {\cf17 public}:\par
00285         EOR_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00286             : Instruction (c, mp, cc, t)\par
00287                             \{ \}\par
00288 \par
00289         {\cf17 protected}:\par
00290         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00291     \};\par
00292 \par
00293     _INST_FROM (0x49, 2, 2, {\cf22 "EOR#[#1]"},     EOR_Inmediate, EOR_General);\par
00294     _INST_FROM (0x4d, 3, 4, {\cf22 "EOR[$2]"},      EOR_Absolute, EOR_General);\par
00295     _INST_FROM (0x45, 2, 3, {\cf22 "EOR[$1]"},      EOR_ZeroPage, EOR_General);\par
00296     _INST_FROM (0x41, 2, 6, {\cf22 "EOR([$1],X)"},  EOR_ZeroPageIndirectX, EOR_General);\par
00297     _INST_FROM (0x51, 2, 5, {\cf22 "EOR([$1]),Y"},  EOR_ZeroPageIndirectY, EOR_General);\par
00298     _INST_FROM (0x55, 2, 4, {\cf22 "EOR[$1],X"},    EOR_ZeroPageX, EOR_General);\par
00299     _INST_FROM (0x5d, 3, 4, {\cf22 "EOR[$2],X"},    EOR_AbsoluteX, EOR_General);\par
00300     _INST_FROM (0x59, 3, 4, {\cf22 "EOR[$2],Y"},    EOR_AbsoluteY, EOR_General);\par
00301 \par
00302     {\cf20 // INC}\par
00304 {\cf20 }    {\cf17 class }INC_General : {\cf17 public} Instruction\par
00305     \{\par
00306         {\cf17 public}:\par
00307         INC_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00308             : Instruction (c, mp, cc, t)\par
00309                             \{ \}\par
00310 \par
00311         {\cf17 protected}:\par
00312         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00313     \};\par
00314 \par
00315     _INST_FROM (0xee, 3, 6, {\cf22 "INC[$2]"},      INC_Absolute, INC_General);\par
00316     _INST_FROM (0xe6, 2, 5, {\cf22 "INC[$1]"},      INC_ZeroPage, INC_General);\par
00317     _INST_FROM (0xf6, 2, 6, {\cf22 "INC[$1],X"},    INC_ZeroPageX, INC_General);\par
00318     _INST_FROM (0xfe, 3, 7, {\cf22 "INC[$2],X"},    INC_AbsoluteX, INC_General);\par
00319 \par
00320     {\cf20 // INX}\par
00321     _INST_FROM (0xe8, 1, 2, {\cf22 "INX"},          INX, Instruction);\par
00322 \par
00323     {\cf20 // INY}\par
00324     _INST_FROM (0xc8, 1, 2, {\cf22 "INY"},          INY, Instruction);\par
00325 \par
00326     {\cf20 // JMP}\par
00327     _INST_FROM (0x4c, 3, 3, {\cf22 "JMP[%2]"},      JMP_Absolute, Instruction);\par
00328     _INST_FROM (0x6c, 3, 5, {\cf22 "JMP([%2])"},    JMP_Indirect, Instruction);\par
00329 \par
00330     {\cf20 // JSR}\par
00331     _INST_FROM (0x20, 3, 6, {\cf22 "JSR[%2]"},      JSR_Absolute, Instruction);\par
00332 \par
00333     {\cf20 // LDA}\par
00335 {\cf20 }    {\cf17 class }LDA_General : {\cf17 public} Instruction\par
00336     \{\par
00337         {\cf17 public}:\par
00338         LDA_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00339             : Instruction (c, mp, cc, t)\par
00340                             \{ \}\par
00341 \par
00342         {\cf17 protected}:\par
00343         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00344     \};\par
00345 \par
00346     _INST_FROM (0xa9, 2, 2, {\cf22 "LDA#[#1]"},     LDA_Inmediate, LDA_General);\par
00347     _INST_FROM (0xad, 3, 4, {\cf22 "LDA[$2]"},      LDA_Absolute, LDA_General);\par
00348     _INST_FROM (0xa5, 2, 3, {\cf22 "LDA[$1]"},      LDA_ZeroPage, LDA_General);\par
00349     _INST_FROM (0xa1, 2, 6, {\cf22 "LDA([$1],X)"},  LDA_ZeroPageIndirectX, LDA_General);\par
00350     _INST_FROM (0xb1, 2, 5, {\cf22 "LDA([$1]),Y"},  LDA_ZeroPageIndirectY, LDA_General);\par
00351     _INST_FROM (0xb5, 2, 4, {\cf22 "LDA[$1],X"},    LDA_ZeroPageX, LDA_General);\par
00352     _INST_FROM (0xbd, 3, 4, {\cf22 "LDA[$2],X"},    LDA_AbsoluteX, LDA_General);\par
00353     _INST_FROM (0xb9, 3, 4, {\cf22 "LDA[$2],Y"},    LDA_AbsoluteY, LDA_General);\par
00354 \par
00355     {\cf20 // LDX}\par
00357 {\cf20 }    {\cf17 class }LDX_General : {\cf17 public} Instruction\par
00358     \{\par
00359         {\cf17 public}:\par
00360         LDX_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00361             : Instruction (c, mp, cc, t)\par
00362                             \{ \}\par
00363 \par
00364         {\cf17 protected}:\par
00365         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00366     \};\par
00367 \par
00368     _INST_FROM (0xa2, 2, 2, {\cf22 "LDX#[#1]"},     LDX_Inmediate, LDX_General);\par
00369     _INST_FROM (0xae, 3, 4, {\cf22 "LDX[$2]"},      LDX_Absolute, LDX_General);\par
00370     _INST_FROM (0xa6, 2, 3, {\cf22 "LDX[$1]"},      LDX_ZeroPage, LDX_General);\par
00371     _INST_FROM (0xbe, 3, 4, {\cf22 "LDX[$2],Y"},    LDX_AbsoluteY, LDX_General);\par
00372     _INST_FROM (0xb6, 2, 4, {\cf22 "LDX[$1],Y"},    LDX_ZeroPageY, LDX_General);\par
00373 \par
00374     {\cf20 // LDY}\par
00376 {\cf20 }    {\cf17 class }LDY_General : {\cf17 public} Instruction\par
00377     \{\par
00378         {\cf17 public}:\par
00379         LDY_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00380             : Instruction (c, mp, cc, t)\par
00381                             \{ \}\par
00382 \par
00383         {\cf17 protected}:\par
00384         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00385     \};\par
00386 \par
00387     _INST_FROM (0xa0, 2, 2, {\cf22 "LDY#[#1]"},     LDY_Inmediate, LDY_General);\par
00388     _INST_FROM (0xac, 3, 4, {\cf22 "LDY[$2]"},      LDY_Absolute, LDY_General);\par
00389     _INST_FROM (0xa4, 2, 3, {\cf22 "LDY[$1]"},      LDY_ZeroPage, LDY_General);\par
00390     _INST_FROM (0xb4, 2, 4, {\cf22 "LDY[$1],X"},    LDY_ZeroPageX, LDY_General);\par
00391     _INST_FROM (0xbc, 3, 4, {\cf22 "LDY[$2],X"},    LDY_AbsoluteX, LDY_General);\par
00392 \par
00393     {\cf20 // LSR}\par
00395 {\cf20 }    {\cf17 class }LSR_General : {\cf17 public} Instruction\par
00396     \{\par
00397         {\cf17 public}:\par
00398         LSR_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00399             : Instruction (c, mp, cc, t)\par
00400                             \{ \}\par
00401 \par
00402         {\cf17 protected}:\par
00403         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00404     \};\par
00405 \par
00406     _INST_FROM (0x4e, 3, 6, {\cf22 "LSR[$2]"},      LSR_Absolute, LSR_General);\par
00407     _INST_FROM (0x46, 2, 5, {\cf22 "LSR[$1]"},      LSR_ZeroPage, LSR_General);\par
00408     _INST_FROM (0x4a, 1, 2, {\cf22 "LSR"},          LSR_Accumulator, LSR_General);\par
00409     _INST_FROM (0x56, 2, 6, {\cf22 "LSR[$1],X"},    LSR_ZeroPageX, LSR_General);\par
00410     _INST_FROM (0x5e, 3, 7, {\cf22 "LSR[$2],X"},    LSR_AbsoluteX, LSR_General);\par
00411 \par
00412     {\cf20 // NOP}\par
00413     _INST_FROM (0xea, 1, 2, {\cf22 "NOP"},          NOP, Instruction);\par
00414 \par
00415     {\cf20 // ORA}\par
00417 {\cf20 }    {\cf17 class }ORA_General : {\cf17 public} Instruction\par
00418     \{\par
00419         {\cf17 public}:\par
00420         ORA_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00421             : Instruction (c, mp, cc, t)\par
00422                             \{ \}\par
00423 \par
00424         {\cf17 protected}:\par
00425         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00426     \};\par
00427 \par
00428     _INST_FROM (0x09, 2, 2, {\cf22 "ORA#[#1]"},     ORA_Inmediate, ORA_General);\par
00429     _INST_FROM (0x0d, 3, 4, {\cf22 "ORA[$2]"},      ORA_Absolute, ORA_General);\par
00430     _INST_FROM (0x05, 2, 3, {\cf22 "ORA[$1]"},      ORA_ZeroPage, ORA_General);\par
00431     _INST_FROM (0x01, 2, 6, {\cf22 "ORA([$1],X)"},  ORA_ZeroPageIndirectX, ORA_General);\par
00432     _INST_FROM (0x11, 2, 5, {\cf22 "ORA([$1]),Y"},  ORA_ZeroPageIndirectY, ORA_General);\par
00433     _INST_FROM (0x15, 2, 4, {\cf22 "ORA[$1],X"},    ORA_ZeroPageX, ORA_General);\par
00434     _INST_FROM (0x1d, 3, 4, {\cf22 "ORA[$2],X"},    ORA_AbsoluteX, ORA_General);\par
00435     _INST_FROM (0x19, 3, 4, {\cf22 "ORA[$2],Y"},    ORA_AbsoluteY, ORA_General);\par
00436 \par
00437     {\cf20 // PHA}\par
00438     _INST_FROM (0x48, 1, 3, {\cf22 "PHA"},          PHA, Instruction);\par
00439 \par
00440     {\cf20 // PHP}\par
00441     _INST_FROM (0x08, 1, 3, {\cf22 "PHP"},          PHP, Instruction);\par
00442 \par
00443     {\cf20 // PLA}\par
00444     _INST_FROM (0x68, 1, 4, {\cf22 "PLA"},          PLA, Instruction);\par
00445 \par
00446     {\cf20 // PLP}\par
00447     _INST_FROM (0x28, 1, 4, {\cf22 "PLP"},          PLP, Instruction);\par
00448 \par
00449     {\cf20 // ROL}\par
00451 {\cf20 }    {\cf17 class }ROL_General : {\cf17 public} Instruction\par
00452     \{\par
00453         {\cf17 public}:\par
00454         ROL_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00455             : Instruction (c, mp, cc, t)\par
00456                             \{ \}\par
00457 \par
00458         {\cf17 protected}:\par
00459         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00460     \};\par
00461 \par
00462     _INST_FROM (0x2e, 3, 6, {\cf22 "ROL[$2]"},      ROL_Absolute, ROL_General);\par
00463     _INST_FROM (0x26, 2, 5, {\cf22 "ROL[$1]"},      ROL_ZeroPage, ROL_General);\par
00464     _INST_FROM (0x2a, 1, 2, {\cf22 "ROL"},          ROL_Accumulator, ROL_General);\par
00465     _INST_FROM (0x36, 2, 6, {\cf22 "ROL[$1],X"},    ROL_ZeroPageX, ROL_General);\par
00466     _INST_FROM (0x3e, 3, 7, {\cf22 "ROL[$2],X"},    ROL_AbsoluteX, ROL_General);\par
00467 \par
00468     {\cf20 // ROR}\par
00470 {\cf20 }    {\cf17 class }ROR_General : {\cf17 public} Instruction\par
00471     \{\par
00472         {\cf17 public}:\par
00473         ROR_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00474             : Instruction (c, mp, cc, t)\par
00475                             \{ \}\par
00476 \par
00477         {\cf17 protected}:\par
00478         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00479     \};\par
00480 \par
00481     _INST_FROM (0x6e, 3, 6, {\cf22 "ROR[$2]"},      ROR_Absolute, ROR_General);\par
00482     _INST_FROM (0x66, 2, 5, {\cf22 "ROR[$1]"},      ROR_ZeroPage, ROR_General);\par
00483     _INST_FROM (0x6a, 1, 2, {\cf22 "ROR"},          ROR_Accumulator, ROR_General);\par
00484     _INST_FROM (0x76, 2, 6, {\cf22 "ROR[$1],X"},    ROR_ZeroPageX, ROR_General);\par
00485     _INST_FROM (0x7e, 3, 7, {\cf22 "ROR[$2],X"},    ROR_AbsoluteX, ROR_General);\par
00486 \par
00487     {\cf20 // RTI}\par
00488     _INST_FROM (0x40, 1, 6, {\cf22 "RTI"},          RTI, Instruction);\par
00489 \par
00490     {\cf20 // RTS}\par
00491     _INST_FROM (0x60, 1, 6, {\cf22 "RTS"},          RTS, Instruction);\par
00492 \par
00493     {\cf20 // SBC}\par
00495 {\cf20 }    {\cf17 class }SBC_General : {\cf17 public} Instruction\par
00496     \{\par
00497         {\cf17 public}:\par
00498         SBC_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00499             : Instruction (c, mp, cc, t)\par
00500                             \{ \}\par
00501 \par
00502         {\cf17 protected}:\par
00503         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00504     \};\par
00505 \par
00506     _INST_FROM (0xe9, 2, 2, {\cf22 "SBC#[#1]"},     SBC_Inmediate, SBC_General);\par
00507     _INST_FROM (0xed, 3, 4, {\cf22 "SBC[$2]"},      SBC_Absolute, SBC_General);\par
00508     _INST_FROM (0xe5, 2, 3, {\cf22 "SBC[$1]"},      SBC_ZeroPage, SBC_General);\par
00509     _INST_FROM (0xe1, 2, 6, {\cf22 "SBC([$1],X)"},  SBC_ZeroPageIndirectX, SBC_General);\par
00510     _INST_FROM (0xf1, 2, 5, {\cf22 "SBC([$1]),Y"},  SBC_ZeroPageIndirectY, SBC_General);\par
00511     _INST_FROM (0xf5, 2, 4, {\cf22 "SBC[$1],X"},    SBC_ZeroPageX, SBC_General);\par
00512     _INST_FROM (0xfd, 3, 4, {\cf22 "SBC[$2],X"},    SBC_AbsoluteX, SBC_General);\par
00513     _INST_FROM (0xf9, 3, 4, {\cf22 "SBC[$2],Y"},    SBC_AbsoluteY, SBC_General);\par
00514 \par
00515     {\cf20 // SEC}\par
00516     _INST_FROM (0x38, 1, 2, {\cf22 "SEC"},          SEC, Instruction);\par
00517 \par
00518     {\cf20 // SED}\par
00519     _INST_FROM (0xf8, 1, 2, {\cf22 "SED"},          SED, Instruction);\par
00520 \par
00521     {\cf20 // SEI}\par
00522     _INST_FROM (0x78, 1, 2, {\cf22 "SEI"},          SEI, Instruction);\par
00523 \par
00524     {\cf20 // STA}\par
00526 {\cf20 }    {\cf17 class }STA_General : {\cf17 public} Instruction\par
00527     \{\par
00528         {\cf17 public}:\par
00529         STA_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00530             : Instruction (c, mp, cc, t)\par
00531                             \{ \}\par
00532 \par
00533         {\cf17 protected}:\par
00534         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00535     \};\par
00536 \par
00537     _INST_FROM (0x8d, 3, 4, {\cf22 "STA[$2]"},      STA_Absolute, STA_General);\par
00538     _INST_FROM (0x85, 2, 3, {\cf22 "STA[$1]"},      STA_ZeroPage, STA_General);\par
00539     _INST_FROM (0x81, 2, 6, {\cf22 "STA([$1],X)"},  STA_ZeroPageIndirectX, STA_General);\par
00540     _INST_FROM (0x91, 2, 6, {\cf22 "STA([$1]),Y"},  STA_ZeroPageIndirectY, STA_General);\par
00541     _INST_FROM (0x95, 2, 4, {\cf22 "STA[$1],X"},    STA_ZeroPageX, STA_General);\par
00542     _INST_FROM (0x9d, 3, 5, {\cf22 "STA[$2],X"},    STA_AbsoluteX, STA_General);\par
00543     _INST_FROM (0x99, 3, 5, {\cf22 "STA[$2],Y"},    STA_AbsoluteY, STA_General);\par
00544 \par
00545     {\cf20 // STX}\par
00547 {\cf20 }    {\cf17 class }STX_General : {\cf17 public} Instruction\par
00548     \{\par
00549         {\cf17 public}:\par
00550         STX_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00551             : Instruction (c, mp, cc, t)\par
00552                             \{ \}\par
00553 \par
00554         {\cf17 protected}:\par
00555         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00556     \};\par
00557 \par
00558     _INST_FROM (0x8e, 3, 4, {\cf22 "STX[$2]"},      STX_Absolute, STX_General);\par
00559     _INST_FROM (0x86, 2, 3, {\cf22 "STX[$1]"},      STX_ZeroPage, STX_General);\par
00560     _INST_FROM (0x96, 2, 4, {\cf22 "STX[$1],Y"},    STX_ZeroPageY, STX_General);\par
00561 \par
00562     {\cf20 // STY}\par
00564 {\cf20 }    {\cf17 class }STY_General : {\cf17 public} Instruction\par
00565     \{\par
00566         {\cf17 public}:\par
00567         STY_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00568             : Instruction (c, mp, cc, t)\par
00569                             \{ \}\par
00570 \par
00571         {\cf17 protected}:\par
00572         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00573     \};\par
00574 \par
00575     _INST_FROM (0x8c, 3, 4, {\cf22 "STY[$2]"},      STY_Absolute, STY_General);\par
00576     _INST_FROM (0x84, 2, 3, {\cf22 "STY[$1]"},      STY_ZeroPage, STY_General);\par
00577     _INST_FROM (0x94, 2, 4, {\cf22 "STY[$1],X"},    STY_ZeroPageX, STY_General);\par
00578 \par
00579     {\cf20 // TAX}\par
00580     _INST_FROM (0xaa, 1, 2, {\cf22 "TAX"},          TAX, Instruction);\par
00581 \par
00582     {\cf20 // TAY}\par
00583     _INST_FROM (0xa8, 1, 2, {\cf22 "TAY"},          TAY, Instruction);\par
00584 \par
00585     {\cf20 // TSX}\par
00586     _INST_FROM (0xba, 1, 2, {\cf22 "TSX"},          TSX, Instruction);\par
00587 \par
00588     {\cf20 // TXA}\par
00589     _INST_FROM (0x8a, 1, 2, {\cf22 "TXA"},          TXA, Instruction);\par
00590 \par
00591     {\cf20 // TXS}\par
00592     _INST_FROM (0x9a, 1, 2, {\cf22 "TXS"},          TXS, Instruction);\par
00593 \par
00594     {\cf20 // TYA}\par
00595     _INST_FROM (0x98, 1, 2, {\cf22 "TYA"},          TYA, Instruction);\par
00596 \}\par
00597 \par
00598 {\cf21 #endif}\par
00599   \par
00600 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/IRQInterrupt.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/IRQInterrupt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/IRQInterrupt.hpp}
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::IRQInterrupt}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b F6500}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IRQInterrupt.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/IRQInterrupt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/IRQInterrupt.hpp}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __F6500_IRQINTERRUPT__}\par
00015 {\cf21 #define __F6500_IRQINTERRUPT__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }F6500\par
00020 \{\par
00022     {\cf17 class }IRQInterrupt : {\cf17 public} MCHEmul::CPUInterrupt\par
00023     \{\par
00024         {\cf17 public}:\par
00025         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _ID = 0;\par
00026 \par
00027         IRQInterrupt ()\par
00028             : MCHEmul::CPUInterrupt (_ID)\par
00029                             \{ \}\par
00030 \par
00031         {\cf17 protected}:\par
00033         {\cf17 virtual} {\cf18 bool} isTime (MCHEmul::CPU* c) {\cf17 const override}; \par
00034         {\cf17 virtual} {\cf18 void} executeOverImpl (MCHEmul::CPU* c, {\cf18 unsigned} {\cf18 int}& nC) {\cf17 override};\par
00035     \};\par
00036 \}\par
00037 \par
00038 {\cf21 #endif}\par
00039   \par
00040 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/NMIInterrupt.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/NMIInterrupt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/NMIInterrupt.hpp}
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::NMIInterrupt}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b F6500}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NMIInterrupt.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/NMIInterrupt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/NMIInterrupt.hpp}
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __F6500_NMIINTERRUPT__}\par
00015 {\cf21 #define __F6500_NMIINTERRUPT__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }F6500\par
00020 \{\par
00022     {\cf17 class }NMIInterrupt : {\cf17 public} MCHEmul::CPUInterrupt\par
00023     \{\par
00024         {\cf17 public}:\par
00025         {\cf17 static} {\cf17 const} {\cf18 int} _ID = 1;\par
00026 \par
00027         NMIInterrupt ()\par
00028             : MCHEmul::CPUInterrupt (_ID)\par
00029                             \{ \}\par
00030 \par
00031         {\cf17 protected}:\par
00033         {\cf17 virtual} {\cf18 bool} isTime (MCHEmul::CPU* c){\cf17  const override }\par
00034 {\cf17                             }\{{\cf19 return} ({\cf17 true}); \} \par
00035         {\cf17 virtual} {\cf18 void} executeOverImpl (MCHEmul::CPU* c, {\cf18 unsigned} {\cf18 int}& nC) {\cf17 override};\par
00036     \};\par
00037 \}\par
00038 \par
00039 {\cf21 #endif}\par
00040   \par
00041 {\cf20 // End of the file}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
