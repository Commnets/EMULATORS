{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment EMULATORS }EMULATORS}
{\comment Generated by doxygen1.9.3.}
{\creatim \yr2022\mo9\dy24\hr19\min47\sec4}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt EMULATORS}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Sat Sep 24 2022 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Module Index\par \pard\plain 
{\tc \v Module Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Modules\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all modules:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Classes representing any CPU\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Classes representing a Parseer/Compiler emulator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Classes representing the communications between server and client.\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Classes needed to excute an emultor from a console.\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Classes defining the 6500 chip family\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
All classes defining the C64 Computer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
All classes defining a template for any emulator.\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all namespaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b C64} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Console} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Emuls} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::Address\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::ByteCode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::ByteCodeLine\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Chip\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::CIA1\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::CIA2\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::SpecialFunctionsChip\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::GraphicalChip\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::VICII\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::VICII_NTSC\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::VICII_PAL\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
MCHEmul::NoChip\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
C64::CIAClock\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::CIATimer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Computer::Clock\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Command\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::CommandBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::StandardCommandBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::Assembler::CommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBY \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::Assembler::BytesCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::CommentCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADCX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::IncludeCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::InstructionCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADET \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::LabelCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::MacroCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::StartingPointCommandParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADHD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::CommunicationMessage\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVP \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::GetMemoryDataMessage\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::GetRegisterStatusMessage\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::CommunicationSystem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::Compiler\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Computer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWS \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::Commodore64\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Console::Console\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Memory::Content\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::CPU\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
F6500::C6500\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
F6500::C6510\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
MCHEmul::CPUArchitecture\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::CPUInterrupt\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
F6500::IRQInterrupt\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::NMIInterrupt\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Emuls::Emulator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Emuls::C64Emulator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::Assembler::Error\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::UInt::FormatManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZK \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::UInt::BinaryFormatManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::UInt::PackagedBCDFormatManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::UInt::FormatManagers\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::GrammaticalElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::Assembler::BytesInMemoryElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::InstructionElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::LabelElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::StartingPointElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADHF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::Instruction\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCY \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
F6500::Instruction\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPE \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
F6500::ADC_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::AND_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::ASL_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::BXX_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::CMP_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::CPX_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::CPY_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::DEC_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::EOR_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::INC_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::LDA_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::LDX_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::LDY_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::LSR_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::ORA_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::ROL_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::ROR_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::SBC_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::STA_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::STX_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
F6500::STY_General\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
MCHEmul::IODevice\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::UserIOPort\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::InputOSSystem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCK \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::InputOSSystem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::Screen\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQX \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::Screen\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::ScreenNTSC\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::ScreenPAL\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
}\par
MCHEmul::IOPeripheral\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGE \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::UserIOPeripheral\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::UserIONoPeripheral\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
MCHEmul::IOPeripheralBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGU \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::IOPeripheralBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::IPAddress\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::Macro\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Memory\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHT \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::Memory\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::MemoryView\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::MessageBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLE \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::StandardMessageBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::Instruction::Structure::Parameter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::Parser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::PeerCommunicationChannel\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::PhisicalStorage\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::PhisicalStorageSubset\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
C64::CIA1Registers\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::CIA2Registers\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::ColorRAMMemory\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::VICIIRegisters\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Stack\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
C64::VICII::Raster\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
C64::VICII::RasterData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Register\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPX \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MCHEmul::ProgramCounter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::StatusRegister\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MCHEmul::ScreenMemory\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACRT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Assembler::Semantic\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADGJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::Instruction::Structure\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::UByte\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::UBytes\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACVO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MCHEmul::UInt\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b F6500::ADC_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Address} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::AND_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::ASL_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UInt::BinaryFormatManager} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::BXX_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::ByteCode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::ByteCodeLine} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::BytesCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::BytesInMemoryElement} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Emuls::C64Emulator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::C6500} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::C6510} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Chip} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::CIA1} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::CIA1Registers} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::CIA2} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::CIA2Registers} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::CIAClock} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::CIATimer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Computer::Clock} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::CMP_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::ColorRAMMemory} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Command} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::CommandBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::CommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::CommentCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADCX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::Commodore64} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::CommunicationMessage} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::CommunicationSystem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::Compiler} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Computer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Console::Console} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Memory::Content} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::CPU} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::CPUArchitecture} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::CPUInterrupt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::CPX_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::CPY_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::DEC_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Emuls::Emulator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::EOR_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::Error} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UInt::FormatManager} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UInt::FormatManagers} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::GetMemoryDataMessage} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::GetRegisterStatusMessage} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::GrammaticalElement} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::GraphicalChip} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::INC_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::IncludeCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::InputOSSystem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::InputOSSystem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::Instruction} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Instruction} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::InstructionCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADET \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::InstructionElement} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::IODevice} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::IOPeripheral} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::IOPeripheralBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::IOPeripheralBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::IPAddress} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::IRQInterrupt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::LabelCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::LabelElement} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::LDA_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::LDX_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::LDY_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::LSR_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::Macro} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::MacroCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::Memory} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Memory} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::MemoryView} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::MessageBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::NMIInterrupt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::NoChip} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::ORA_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UInt::PackagedBCDFormatManager} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Instruction::Structure::Parameter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::Parser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::PeerCommunicationChannel} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::PhisicalStorage} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::PhisicalStorageSubset} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::ProgramCounter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::VICII::Raster} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::VICII::RasterData} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Register} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::ROL_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::ROR_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::SBC_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::Screen} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Screen} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::ScreenMemory} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACRT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::ScreenNTSC} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::ScreenPAL} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::Semantic} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADGJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::SpecialFunctionsChip} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::STA_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Stack} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::StandardCommandBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::StandardMessageBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::StartingPointCommandParser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADHD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Assembler::StartingPointElement} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADHF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::StatusRegister} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::Instruction::Structure} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::STX_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F6500::STY_General} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UByte} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UBytes} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACVO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MCHEmul::UInt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::UserIONoPeripheral} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::UserIOPeripheral} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::UserIOPort} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::VICII} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::VICII_NTSC} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::VICII_PAL} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b C64::VICIIRegisters} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b C:/WorkspacesII/EMULATORS/include/{\b doxy.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Compiler.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Error.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b C64.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b CIA1.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b CIA1Registers.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b CIA2.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b CIA2Registers.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b CIAClock.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b CIATimer.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b ColorMemory.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b global.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b IOPBuilder.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b Memory.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b OSIO.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b Screen.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b SFChip.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b UserPeripherals.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b UserPort.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b VICII.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/C64/{\b VICIIRegisters.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/COMMS/{\b Channel.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/COMMS/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/COMMS/{\b IPAddress.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/COMMS/{\b Message.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/COMMS/{\b StdMessages.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/COMMS/{\b System.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CONSOLE/{\b Console.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CONSOLE/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Address.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Chip.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Command.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b CommandBuilder.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Computer.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b CPU.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b CPUArchitecture.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b CPUInterrupt.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b global.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b GraphicalChip.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Instruction.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b IO.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b IOPBuilder.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b IOPeripheral.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Memory.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b OSIO.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b ProgramCounter.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Register.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Screen.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b ScreenMemory.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b Stack.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b StatusRegister.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b UByte.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b UBytes.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/CORE/{\b UInt.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAII \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/EMULATORS/{\b C64Emulator.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/EMULATORS/{\b Emulator.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/EMULATORS/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/F6500/{\b C6500.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/F6500/{\b C6510.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/F6500/{\b incs.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/F6500/{\b IRQInterrupt.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/include/F6500/{\b NMIInterrupt.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Compiler.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Error.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Grammar.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Parser.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b C64.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b CIA1.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b CIA1Registers.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b CIA2.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b CIA2Registers.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b CIAClock.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b CIATimer.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b ColorMemory.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b global.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b IOPBuilder.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b Memory.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b OSIO.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b Screen.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b SFChip.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b UserPeripherals.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b UserPort.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b VICII.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/C64/{\b VICIIRegisters.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/COMMS/{\b Channel.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/COMMS/{\b IPAddress.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/COMMS/{\b Message.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/COMMS/{\b StdMessages.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/COMMS/{\b System.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CONSOLE/{\b Console.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b Address.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b Chip.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b CommandBuilder.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b Computer.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b CPU.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b CPUArchitecture.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b CPUInterrupt.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b global.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b GraphicalChip.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b Instruction.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b IO.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b IOPBuilder.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b IOPeripheral.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b Memory.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b OSIO.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b ProgramCounter.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b Register.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b Screen.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b ScreenMemory.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b Stack.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b StatusRegister.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b UByte.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b UBytes.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/CORE/{\b UInt.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/EMULATORS/{\b C64Emulator.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/EMULATORS/{\b Emulator.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b ADC.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b AND.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b ASL.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b BRANCHES.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b C6500.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b C6510.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b CMP.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b CPX.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b CPY.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b DEC.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b EOR.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b INC.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b INCDECXY.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b Instructions.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b IRQInterrupt.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b JUMPS.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b LDA.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b LDX.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b LDY.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b LSR.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b NMIInterrupt.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b ORA.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b ROL.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b ROR.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b SBC.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b SEX.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b STA.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b STACK.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b STATUS.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b STX.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b STY.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/WorkspacesII/EMULATORS/src/F6500/{\b TRANSFERS.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAART \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Module Documentation{\tc \v Module Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Classes representing any CPU\par \pard\plain 
{\tc\tcl2 \v Classes representing any CPU}
{\xe \v Classes representing any CPU}
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the core of any CPU emulator. \par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Classes representing a Parseer/Compiler emulator\par \pard\plain 
{\tc\tcl2 \v Classes representing a Parseer/Compiler emulator}
{\xe \v Classes representing a Parseer/Compiler emulator}
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the Parser and Compiling processes for any type assambler. \par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Classes representing the communications between server and client.\par \pard\plain 
{\tc\tcl2 \v Classes representing the communications between server and client.}
{\xe \v Classes representing the communications between server and client.}
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the way an emulator can communication with other external tools. \par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Classes needed to excute an emultor from a console.\par \pard\plain 
{\tc\tcl2 \v Classes needed to excute an emultor from a console.}
{\xe \v Classes needed to excute an emultor from a console.}
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the way an emulator can be similated from a console. \par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Classes defining the 6500 chip family\par \pard\plain 
{\tc\tcl2 \v Classes defining the 6500 chip family}
{\xe \v Classes defining the 6500 chip family}
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the characteristics of the Motorola 6500 chip family. \par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
All classes defining the C64 Computer\par \pard\plain 
{\tc\tcl2 \v All classes defining the C64 Computer}
{\xe \v All classes defining the C64 Computer}
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the characteristics of any Commodore64 Computer. \par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
All classes defining a template for any emulator.\par \pard\plain 
{\tc\tcl2 \v All classes defining a template for any emulator.}
{\xe \v All classes defining a template for any emulator.}
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classes and macros defining the common characteristics to any Emulator. \par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64 Namespace Reference\par \pard\plain 
{\tc\tcl2 \v C64}
{\xe \v C64}
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CIA1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CIA1Registers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CIA2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CIA2Registers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CIAClock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CIATimer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ColorRAMMemory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Commodore64}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InputOSSystem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IOPeripheralBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Memory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Screen}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ScreenNTSC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ScreenPAL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SpecialFunctionsChip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UserIONoPeripheral}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UserIOPeripheral}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UserIOPort}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VICII}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VICII_NTSC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VICII_PAL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VICIIRegisters}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Duration} = std::chrono::duration< unsigned long, std::deci >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Time} = std::chrono::time_point< std::chrono::steady_clock, {\b Duration} >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b actualizeGlobalTime} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Duration\:C64}
{\xe \v C64\:Duration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b C64::Duration} = typedef std::chrono::duration <unsigned long, std::deci>}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b C64} counts using tenth of seconds only. \par
}{
Definition at line {\b 22} of file {\b global.hpp}.}\par
}
{\xe \v Time\:C64}
{\xe \v C64\:Time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b C64::Time} = typedef std::chrono::time_point <std::chrono::steady_clock, {\b Duration}>}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b global.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v actualizeGlobalTime\:C64}
{\xe \v C64\:actualizeGlobalTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::actualizeGlobalTime ()}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To actualize the time. \par
}{
Definition at line {\b 4} of file {\b global.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_c64_af90d49657dd593c30399c041da0e7259_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Console Namespace Reference\par \pard\plain 
{\tc\tcl2 \v Console}
{\xe \v Console}
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Console}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Emuls Namespace Reference\par \pard\plain 
{\tc\tcl2 \v Emuls}
{\xe \v Emuls}
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64Emulator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Emulator}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500 Namespace Reference\par \pard\plain 
{\tc\tcl2 \v F6500}
{\xe \v F6500}
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ADC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AND_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ASL_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BXX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C6500}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C6510}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CMP_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPY_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DEC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EOR_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b INC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Instruction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IRQInterrupt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LDA_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LDX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LDY_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LSR_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NMIInterrupt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ORA_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ROL_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ROR_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SBC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b STA_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b STX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b STY_General}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x69, 2, 2, "ADC#[#1]", ADC_Inmediate, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x6d, 3, 4, "ADC[$2]", ADC_Absolute, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x65, 2, 3, "ADC[$1]", ADC_ZeroPage, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x61, 2, 6, "ADC([$1],X)", ADC_ZeroPageIndirectX, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x71, 2, 5, "ADC([$1]),Y", ADC_ZeroPageIndirectY, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x75, 2, 4, "ADC[$1],X", ADC_ZeroPageX, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x7d, 3, 4, "ADC[$2],X", ADC_AbsoluteX, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x79, 3, 4, "ADC[$2],Y", ADC_AbsoluteY, {\b ADC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x29, 2, 2, "AND#[#1]", AND_Inmediate, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x2d, 3, 4, "AND[$2]", AND_Absolute, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x25, 2, 3, "AND[$1]", AND_ZeroPage, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x21, 2, 6, "AND([$1],X)", AND_ZeroPageIndirectX, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x31, 2, 5, "AND([$1]),Y", AND_ZeroPageIndirectY, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x35, 2, 4, "AND[$1],X", AND_ZeroPageX, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x3d, 3, 4, "AND[$2],X", AND_AbsoluteX, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x39, 3, 4, "AND[$2],Y", AND_AbsoluteY, {\b AND_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x0e, 3, 6, "ASL[$2]", ASL_Absolute, {\b ASL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x06, 2, 5, "ASL[$1]", ASL_ZeroPage, {\b ASL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x0a, 1, 2, "ASL", ASL_Accumulator, {\b ASL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x16, 2, 6, "ASL[$1],X", ASL_ZeroPageX, {\b ASL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x1e, 3, 7, "ASL[$2],X", ASL_AbsoluteX, {\b ASL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x90, 2, 2, "BCC[&1]", BCC, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb0, 2, 2, "BCS[&1]", BCS, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xf0, 2, 2, "BEQ[&1]", BEQ, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x2c, 3, 4, "BIT[$2]", BIT_Absolute, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x24, 2, 3, "BIT[$1]", BIT_ZeroPage, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x30, 2, 2, "BMI[&1]", BMI, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xd0, 2, 2, "BNE[&1]", BNE, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x10, 2, 2, "BPL[&1]", BPL, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x00, 1, 7, "BRK", BRK, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x50, 2, 2, "BVC[&1]", BVC, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x70, 2, 2, "BVS[&1]", BVS, {\b BXX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x18, 1, 2, "CLC", CLC, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xd8, 1, 2, "CLD", CLD, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x58, 1, 2, "CLI", CLI, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb8, 1, 2, "CLV", CLV, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc9, 2, 2, "CMP#[#1]", CMP_Inmediate, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xcd, 3, 4, "CMP[$2]", CMP_Absolute, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc5, 2, 3, "CMP[$1]", CMP_ZeroPage, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc1, 2, 6, "CMP([$1],X)", CMP_ZeroPageIndirectX, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xd1, 2, 5, "CMP([$1]),Y", CMP_ZeroPageIndirectY, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xd5, 2, 4, "CMP[$1],X", CMP_ZeroPageX, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xdd, 3, 4, "CMP[$2],X", CMP_AbsoluteX, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xd9, 3, 4, "CMP[$2],Y", CMP_AbsoluteY, {\b CMP_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe0, 2, 2, "CPX#[#1]", CPX_Inmediate, {\b CPX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xec, 3, 4, "CPX[$2]", CPX_Absolute, {\b CPX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe4, 2, 3, "CPX[$1]", CPX_ZeroPage, {\b CPX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc0, 2, 2, "CPY#[#1]", CPY_Inmediate, {\b CPY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xcc, 3, 4, "CPY[$2]", CPY_Absolute, {\b CPY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc4, 2, 3, "CPY[$1]", CPY_ZeroPage, {\b CPY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xce, 3, 6, "DEC[$2]", DEC_Absolute, {\b DEC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc6, 2, 5, "DEC[$1]", DEC_ZeroPage, {\b DEC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xd6, 2, 6, "DEC[$1],X", DEC_ZeroPageX, {\b DEC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xde, 3, 7, "DEC[$2],X", DEC_AbsoluteX, {\b DEC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xca, 1, 2, "DEX", DEX, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x88, 1, 2, "DEY", DEY, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x49, 2, 2, "EOR#[#1]", EOR_Inmediate, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x4d, 3, 4, "EOR[$2]", EOR_Absolute, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x45, 2, 3, "EOR[$1]", EOR_ZeroPage, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x41, 2, 6, "EOR([$1],X)", EOR_ZeroPageIndirectX, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x51, 2, 5, "EOR([$1]),Y", EOR_ZeroPageIndirectY, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x55, 2, 4, "EOR[$1],X", EOR_ZeroPageX, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x5d, 3, 4, "EOR[$2],X", EOR_AbsoluteX, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x59, 3, 4, "EOR[$2],Y", EOR_AbsoluteY, {\b EOR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xee, 3, 6, "INC[$2]", INC_Absolute, {\b INC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe6, 2, 5, "INC[$1]", INC_ZeroPage, {\b INC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xf6, 2, 6, "INC[$1],X", INC_ZeroPageX, {\b INC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xfe, 3, 7, "INC[$2],X", INC_AbsoluteX, {\b INC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe8, 1, 2, "INX", INX, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xc8, 1, 2, "INY", INY, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x4c, 3, 3, "JMP[%2]", JMP_Absolute, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x6c, 3, 5, "JMP([%2])", JMP_Indirect, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x20, 3, 6, "JSR[%2]", JSR_Absolute, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa9, 2, 2, "LDA#[#1]", LDA_Inmediate, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xad, 3, 4, "LDA[$2]", LDA_Absolute, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa5, 2, 3, "LDA[$1]", LDA_ZeroPage, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa1, 2, 6, "LDA([$1],X)", LDA_ZeroPageIndirectX, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb1, 2, 5, "LDA([$1]),Y", LDA_ZeroPageIndirectY, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb5, 2, 4, "LDA[$1],X", LDA_ZeroPageX, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xbd, 3, 4, "LDA[$2],X", LDA_AbsoluteX, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb9, 3, 4, "LDA[$2],Y", LDA_AbsoluteY, {\b LDA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa2, 2, 2, "LDX#[#1]", LDX_Inmediate, {\b LDX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xae, 3, 4, "LDX[$2]", LDX_Absolute, {\b LDX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa6, 2, 3, "LDX[$1]", LDX_ZeroPage, {\b LDX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xbe, 3, 4, "LDX[$2],Y", LDX_AbsoluteY, {\b LDX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb6, 2, 4, "LDX[$1],Y", LDX_ZeroPageY, {\b LDX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa0, 2, 2, "LDY#[#1]", LDY_Inmediate, {\b LDY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xac, 3, 4, "LDY[$2]", LDY_Absolute, {\b LDY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa4, 2, 3, "LDY[$1]", LDY_ZeroPage, {\b LDY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xb4, 2, 4, "LDY[$1],X", LDY_ZeroPageX, {\b LDY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xbc, 3, 4, "LDY[$2],X", LDY_AbsoluteX, {\b LDY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x4e, 3, 6, "LSR[$2]", LSR_Absolute, {\b LSR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x46, 2, 5, "LSR[$1]", LSR_ZeroPage, {\b LSR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x4a, 1, 2, "LSR", LSR_Accumulator, {\b LSR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x56, 2, 6, "LSR[$1],X", LSR_ZeroPageX, {\b LSR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x5e, 3, 7, "LSR[$2],X", LSR_AbsoluteX, {\b LSR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xea, 1, 2, "NOP", NOP, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x09, 2, 2, "ORA#[#1]", ORA_Inmediate, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x0d, 3, 4, "ORA[$2]", ORA_Absolute, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x05, 2, 3, "ORA[$1]", ORA_ZeroPage, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x01, 2, 6, "ORA([$1],X)", ORA_ZeroPageIndirectX, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x11, 2, 5, "ORA([$1]),Y", ORA_ZeroPageIndirectY, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x15, 2, 4, "ORA[$1],X", ORA_ZeroPageX, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x1d, 3, 4, "ORA[$2],X", ORA_AbsoluteX, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x19, 3, 4, "ORA[$2],Y", ORA_AbsoluteY, {\b ORA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x48, 1, 3, "PHA", PHA, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x08, 1, 3, "PHP", PHP, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x68, 1, 4, "PLA", PLA, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x28, 1, 4, "PLP", PLP, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x2e, 3, 6, "ROL[$2]", ROL_Absolute, {\b ROL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x26, 2, 5, "ROL[$1]", ROL_ZeroPage, {\b ROL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x2a, 1, 2, "ROL", ROL_Accumulator, {\b ROL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x36, 2, 6, "ROL[$1],X", ROL_ZeroPageX, {\b ROL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x3e, 3, 7, "ROL[$2],X", ROL_AbsoluteX, {\b ROL_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x6e, 3, 6, "ROR[$2]", ROR_Absolute, {\b ROR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x66, 2, 5, "ROR[$1]", ROR_ZeroPage, {\b ROR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x6a, 1, 2, "ROR", ROR_Accumulator, {\b ROR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x76, 2, 6, "ROR[$1],X", ROR_ZeroPageX, {\b ROR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x7e, 3, 7, "ROR[$2],X", ROR_AbsoluteX, {\b ROR_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x40, 1, 6, "RTI", RTI, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x60, 1, 6, "RTS", RTS, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe9, 2, 2, "SBC#[#1]", SBC_Inmediate, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xed, 3, 4, "SBC[$2]", SBC_Absolute, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe5, 2, 3, "SBC[$1]", SBC_ZeroPage, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xe1, 2, 6, "SBC([$1],X)", SBC_ZeroPageIndirectX, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xf1, 2, 5, "SBC([$1]),Y", SBC_ZeroPageIndirectY, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xf5, 2, 4, "SBC[$1],X", SBC_ZeroPageX, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xfd, 3, 4, "SBC[$2],X", SBC_AbsoluteX, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xf9, 3, 4, "SBC[$2],Y", SBC_AbsoluteY, {\b SBC_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x38, 1, 2, "SEC", SEC, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xf8, 1, 2, "SED", SED, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x78, 1, 2, "SEI", SEI, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x8d, 3, 4, "STA[$2]", STA_Absolute, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x85, 2, 3, "STA[$1]", STA_ZeroPage, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x81, 2, 6, "STA([$1],X)", STA_ZeroPageIndirectX, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x91, 2, 6, "STA([$1]),Y", STA_ZeroPageIndirectY, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x95, 2, 4, "STA[$1],X", STA_ZeroPageX, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x9d, 3, 5, "STA[$2],X", STA_AbsoluteX, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x99, 3, 5, "STA[$2],Y", STA_AbsoluteY, {\b STA_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x8e, 3, 4, "STX[$2]", STX_Absolute, {\b STX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x86, 2, 3, "STX[$1]", STX_ZeroPage, {\b STX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x96, 2, 4, "STX[$1],Y", STX_ZeroPageY, {\b STX_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x8c, 3, 4, "STY[$2]", STY_Absolute, {\b STY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x84, 2, 3, "STY[$1]", STY_ZeroPage, {\b STY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x94, 2, 4, "STY[$1],X", STY_ZeroPageX, {\b STY_General})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xaa, 1, 2, "TAX", TAX, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xa8, 1, 2, "TAY", TAY, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0xba, 1, 2, "TSX", TSX, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x8a, 1, 2, "TXA", TXA, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x9a, 1, 2, "TXS", TXS, {\b Instruction})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_FROM} (0x98, 1, 2, "TYA", TYA, {\b Instruction})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x00 , 1 , 7 , "BRK" , BRK , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x01 , 2 , 6 , "ORA([$1],X)" , ORA_ZeroPageIndirectX , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x05 , 2 , 3 , "ORA" [ $1], ORA_ZeroPage , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x06 , 2 , 5 , "ASL" [ $1], ASL_ZeroPage , {\b ASL_General} )}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x08 , 1 , 3 , "PHP" , PHP , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x09 , 2 , 2 , "ORA#" [#1], ORA_Inmediate , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x0a , 1 , 2 , "ASL" , ASL_Accumulator , {\b ASL_General} )}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x0d , 3 , 4 , "ORA" [ $2], ORA_Absolute , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x0e , 3 , 6 , "ASL" [ $2], ASL_Absolute , {\b ASL_General} )}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x10 , 2 , 2 , "BPL" [&1], BPL , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x11 , 2 , 5 , "  {\i ORA}[$1], Y" , ORA_ZeroPageIndirectY , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x15 , 2 , 4 , "  {\i ORA}[ $1], X" , ORA_ZeroPageX , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x16 , 2 , 6 , "  {\i ASL}[ $1], X" , ASL_ZeroPageX , {\b ASL_General} )}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x18 , 1 , 2 , "CLC" , CLC , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x19 , 3 , 4 , "  {\i ORA}[ $2], Y" , ORA_AbsoluteY , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x1d , 3 , 4 , "  {\i ORA}[ $2], X" , ORA_AbsoluteX , {\b ORA_General} )}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x1e , 3 , 7 , "  {\i ASL}[ $2], X" , ASL_AbsoluteX , {\b ASL_General} )}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x20 , 3 , 6 , "JSR" [%2], JSR_Absolute , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x21 , 2 , 6 , "AND([$1],X)" , AND_ZeroPageIndirectX , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x24 , 2 , 3 , "BIT" [ $1], BIT_ZeroPage , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x25 , 2 , 3 , "AND" [ $1], AND_ZeroPage , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x26 , 2 , 5 , "ROL" [ $1], ROL_ZeroPage , {\b ROL_General} )}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x28 , 1 , 4 , "PLP" , PLP , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x29 , 2 , 2 , "AND#" [#1], AND_Inmediate , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x2a , 1 , 2 , "ROL" , ROL_Accumulator , {\b ROL_General} )}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x2c , 3 , 4 , "BIT" [ $2], BIT_Absolute , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x2d , 3 , 4 , "AND" [ $2], AND_Absolute , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x2e , 3 , 6 , "ROL" [ $2], ROL_Absolute , {\b ROL_General} )}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x30 , 2 , 2 , "BMI" [&1], BMI , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x31 , 2 , 5 , "  {\i AND}[$1], Y" , AND_ZeroPageIndirectY , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x35 , 2 , 4 , "  {\i AND}[ $1], X" , AND_ZeroPageX , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x36 , 2 , 6 , "  {\i ROL}[ $1], X" , ROL_ZeroPageX , {\b ROL_General} )}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x38 , 1 , 2 , "SEC" , SEC , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x39 , 3 , 4 , "  {\i AND}[ $2], Y" , AND_AbsoluteY , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x3d , 3 , 4 , "  {\i AND}[ $2], X" , AND_AbsoluteX , {\b AND_General} )}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x3e , 3 , 7 , "  {\i ROL}[ $2], X" , ROL_AbsoluteX , {\b ROL_General} )}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x40 , 1 , 6 , "RTI" , RTI , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x41 , 2 , 6 , "EOR([$1],X)" , EOR_ZeroPageIndirectX , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x45 , 2 , 3 , "EOR" [ $1], EOR_ZeroPage , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x46 , 2 , 5 , "LSR" [ $1], LSR_ZeroPage , {\b LSR_General} )}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x48 , 1 , 3 , "PHA" , PHA , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x49 , 2 , 2 , "EOR#" [#1], EOR_Inmediate , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x4a , 1 , 2 , "LSR" , LSR_Accumulator , {\b LSR_General} )}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x4c , 3 , 3 , "JMP" [%2], JMP_Absolute , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x4d , 3 , 4 , "EOR" [ $2], EOR_Absolute , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x4e , 3 , 6 , "LSR" [ $2], LSR_Absolute , {\b LSR_General} )}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x50 , 2 , 2 , "BVC" [&1], BVC , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x51 , 2 , 5 , "  {\i EOR}[$1], Y" , EOR_ZeroPageIndirectY , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x55 , 2 , 4 , "  {\i EOR}[ $1], X" , EOR_ZeroPageX , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x56 , 2 , 6 , "  {\i LSR}[ $1], X" , LSR_ZeroPageX , {\b LSR_General} )}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x58 , 1 , 2 , "CLI" , CLI , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x59 , 3 , 4 , "  {\i EOR}[ $2], Y" , EOR_AbsoluteY , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x5d , 3 , 4 , "  {\i EOR}[ $2], X" , EOR_AbsoluteX , {\b EOR_General} )}}
\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x5e , 3 , 7 , "  {\i LSR}[ $2], X" , LSR_AbsoluteX , {\b LSR_General} )}}
\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x60 , 1 , 6 , "RTS" , RTS , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x61 , 2 , 6 , "ADC([$1],X)" , ADC_ZeroPageIndirectX , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x65 , 2 , 3 , "ADC" [ $1], ADC_ZeroPage , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x66 , 2 , 5 , "ROR" [ $1], ROR_ZeroPage , {\b ROR_General} )}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x68 , 1 , 4 , "PLA" , PLA , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x69 , 2 , 2 , "ADC#" [#1], ADC_Inmediate , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x6a , 1 , 2 , "ROR" , ROR_Accumulator , {\b ROR_General} )}}
\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x6c , 3 , 5 , "JMP([%2])" , JMP_Indirect , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x6d , 3 , 4 , "ADC" [ $2], ADC_Absolute , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x6e , 3 , 6 , "ROR" [ $2], ROR_Absolute , {\b ROR_General} )}}
\par
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x70 , 2 , 2 , "BVS" [&1], BVS , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x71 , 2 , 5 , "  {\i ADC}[$1], Y" , ADC_ZeroPageIndirectY , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x75 , 2 , 4 , "  {\i ADC}[ $1], X" , ADC_ZeroPageX , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x76 , 2 , 6 , "  {\i ROR}[ $1], X" , ROR_ZeroPageX , {\b ROR_General} )}}
\par
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x78 , 1 , 2 , "SEI" , SEI , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x79 , 3 , 4 , "  {\i ADC}[ $2], Y" , ADC_AbsoluteY , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x7d , 3 , 4 , "  {\i ADC}[ $2], X" , ADC_AbsoluteX , {\b ADC_General} )}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x7e , 3 , 7 , "  {\i ROR}[ $2], X" , ROR_AbsoluteX , {\b ROR_General} )}}
\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x81 , 2 , 6 , "STA([$1],X)" , STA_ZeroPageIndirectX , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x84 , 2 , 3 , "STY" [ $1], STY_ZeroPage , {\b STY_General} )}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x85 , 2 , 3 , "STA" [ $1], STA_ZeroPage , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x86 , 2 , 3 , "STX" [ $1], STX_ZeroPage , {\b STX_General} )}}
\par
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x88 , 1 , 2 , "DEY" , DEY , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x8a , 1 , 2 , "TXA" , TXA , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x8c , 3 , 4 , "STY" [ $2], STY_Absolute , {\b STY_General} )}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x8d , 3 , 4 , "STA" [ $2], STA_Absolute , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x8e , 3 , 4 , "STX" [ $2], STX_Absolute , {\b STX_General} )}}
\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x90 , 2 , 2 , "BCC" [&1], BCC , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x91 , 2 , 6 , "  {\i STA}[$1], Y" , STA_ZeroPageIndirectY , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x94 , 2 , 4 , "  {\i STY}[ $1], X" , STY_ZeroPageX , {\b STY_General} )}}
\par
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x95 , 2 , 4 , "  {\i STA}[ $1], X" , STA_ZeroPageX , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x96 , 2 , 4 , "  {\i STX}[ $1], Y" , STX_ZeroPageY , {\b STX_General} )}}
\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x98 , 1 , 2 , "TYA" , TYA , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x99 , 3 , 5 , "  {\i STA}[ $2], Y" , STA_AbsoluteY , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x9a , 1 , 2 , "TXS" , TXS , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0x9d , 3 , 5 , "  {\i STA}[ $2], X" , STA_AbsoluteX , {\b STA_General} )}}
\par
{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa0 , 2 , 2 , "LDY#" [#1], LDY_Inmediate , {\b LDY_General} )}}
\par
{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa1 , 2 , 6 , "LDA([$1],X)" , LDA_ZeroPageIndirectX , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa2 , 2 , 2 , "LDX#" [#1], LDX_Inmediate , {\b LDX_General} )}}
\par
{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa4 , 2 , 3 , "LDY" [ $1], LDY_ZeroPage , {\b LDY_General} )}}
\par
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa5 , 2 , 3 , "LDA" [ $1], LDA_ZeroPage , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa6 , 2 , 3 , "LDX" [ $1], LDX_ZeroPage , {\b LDX_General} )}}
\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa8 , 1 , 2 , "TAY" , TAY , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xa9 , 2 , 2 , "LDA#" [#1], LDA_Inmediate , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xaa , 1 , 2 , "TAX" , TAX , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xac , 3 , 4 , "LDY" [ $2], LDY_Absolute , {\b LDY_General} )}}
\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xad , 3 , 4 , "LDA" [ $2], LDA_Absolute , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xae , 3 , 4 , "LDX" [ $2], LDX_Absolute , {\b LDX_General} )}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb0 , 2 , 2 , "BCS" [&1], BCS , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb1 , 2 , 5 , "  {\i LDA}[$1], Y" , LDA_ZeroPageIndirectY , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb4 , 2 , 4 , "  {\i LDY}[ $1], X" , LDY_ZeroPageX , {\b LDY_General} )}}
\par
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb5 , 2 , 4 , "  {\i LDA}[ $1], X" , LDA_ZeroPageX , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb6 , 2 , 4 , "  {\i LDX}[ $1], Y" , LDX_ZeroPageY , {\b LDX_General} )}}
\par
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb8 , 1 , 2 , "CLV" , CLV , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xb9 , 3 , 4 , "  {\i LDA}[ $2], Y" , LDA_AbsoluteY , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xba , 1 , 2 , "TSX" , TSX , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xbc , 3 , 4 , "  {\i LDY}[ $2], X" , LDY_AbsoluteX , {\b LDY_General} )}}
\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xbd , 3 , 4 , "  {\i LDA}[ $2], X" , LDA_AbsoluteX , {\b LDA_General} )}}
\par
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xbe , 3 , 4 , "  {\i LDX}[ $2], Y" , LDX_AbsoluteY , {\b LDX_General} )}}
\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc0 , 2 , 2 , "CPY#" [#1], CPY_Inmediate , {\b CPY_General} )}}
\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc1 , 2 , 6 , "CMP([$1],X)" , CMP_ZeroPageIndirectX , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc4 , 2 , 3 , "CPY" [ $1], CPY_ZeroPage , {\b CPY_General} )}}
\par
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc5 , 2 , 3 , "CMP" [ $1], CMP_ZeroPage , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc6 , 2 , 5 , "DEC" [ $1], DEC_ZeroPage , {\b DEC_General} )}}
\par
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc8 , 1 , 2 , "INY" , INY , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xc9 , 2 , 2 , "CMP#" [#1], CMP_Inmediate , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xca , 1 , 2 , "DEX" , DEX , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xcc , 3 , 4 , "CPY" [ $2], CPY_Absolute , {\b CPY_General} )}}
\par
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xcd , 3 , 4 , "CMP" [ $2], CMP_Absolute , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xce , 3 , 6 , "DEC" [ $2], DEC_Absolute , {\b DEC_General} )}}
\par
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xd0 , 2 , 2 , "BNE" [&1], BNE , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xd1 , 2 , 5 , "  {\i CMP}[$1], Y" , CMP_ZeroPageIndirectY , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xd5 , 2 , 4 , "  {\i CMP}[ $1], X" , CMP_ZeroPageX , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xd6 , 2 , 6 , "  {\i DEC}[ $1], X" , DEC_ZeroPageX , {\b DEC_General} )}}
\par
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xd8 , 1 , 2 , "CLD" , CLD , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xd9 , 3 , 4 , "  {\i CMP}[ $2], Y" , CMP_AbsoluteY , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xdd , 3 , 4 , "  {\i CMP}[ $2], X" , CMP_AbsoluteX , {\b CMP_General} )}}
\par
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xde , 3 , 7 , "  {\i DEC}[ $2], X" , DEC_AbsoluteX , {\b DEC_General} )}}
\par
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe0 , 2 , 2 , "CPX#" [#1], CPX_Inmediate , {\b CPX_General} )}}
\par
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe1 , 2 , 6 , "SBC([$1],X)" , SBC_ZeroPageIndirectX , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe4 , 2 , 3 , "CPX" [ $1], CPX_ZeroPage , {\b CPX_General} )}}
\par
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe5 , 2 , 3 , "SBC" [ $1], SBC_ZeroPage , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe6 , 2 , 5 , "INC" [ $1], INC_ZeroPage , {\b INC_General} )}}
\par
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe8 , 1 , 2 , "INX" , INX , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xe9 , 2 , 2 , "SBC#" [#1], SBC_Inmediate , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xea , 1 , 2 , "NOP" , NOP , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xec , 3 , 4 , "CPX" [ $2], CPX_Absolute , {\b CPX_General} )}}
\par
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xed , 3 , 4 , "SBC" [ $2], SBC_Absolute , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xee , 3 , 6 , "INC" [ $2], INC_Absolute , {\b INC_General} )}}
\par
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xf0 , 2 , 2 , "BEQ" [&1], BEQ , {\b BXX_General} )}}
\par
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xf1 , 2 , 5 , "  {\i SBC}[$1], Y" , SBC_ZeroPageIndirectY , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xf5 , 2 , 4 , "  {\i SBC}[ $1], X" , SBC_ZeroPageX , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xf6 , 2 , 6 , "  {\i INC}[ $1], X" , INC_ZeroPageX , {\b INC_General} )}}
\par
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xf8 , 1 , 2 , "SED" , SED , {\b Instruction} )}}
\par
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xf9 , 3 , 4 , "  {\i SBC}[ $2], Y" , SBC_AbsoluteY , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xfd , 3 , 4 , "  {\i SBC}[ $2], X" , SBC_AbsoluteX , {\b SBC_General} )}}
\par
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _INST_FROM\:F6500}
{\xe \v F6500\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::_INST_FROM (0xfe , 3 , 7 , "  {\i INC}[ $2], X" , INC_AbsoluteX , {\b INC_General} )}}
\par
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul Namespace Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul}
{\xe \v MCHEmul}
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Assembler}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Address}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Chip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Command}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CommandBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CommunicationMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CommunicationSystem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Computer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPU}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPUArchitecture}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPUInterrupt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GetMemoryDataMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GetRegisterStatusMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GraphicalChip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InputOSSystem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Instruction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IODevice}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IOPeripheral}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IOPeripheralBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IPAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Memory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MemoryView}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MessageBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NoChip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PeerCommunicationChannel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PhisicalStorage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PhisicalStorageSubset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ProgramCounter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Register}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Screen}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ScreenMemory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Stack}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StandardCommandBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StandardMessageBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StatusRegister}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UByte}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UBytes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UInt}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Chips} = std::map< int, {\b Chip} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b CPUInterrups} = std::map< int, {\b CPUInterrupt} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Attributes} = std::map< std::string, std::string >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Instructions} = std::map< unsigned int, {\b Instruction} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b IODevices} = std::map< int, {\b IODevice} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b IOPeripherals} = std::map< int, {\b IOPeripheral} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b PhisicalStorages} = std::map< int, {\b PhisicalStorage} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b PhisicalStorageSubsets} = std::map< int, {\b PhisicalStorageSubset} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b PhisicalStorageSubsetsList} = std::vector< {\b PhisicalStorageSubset} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MemoryViews} = std::map< int, {\b MemoryView} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Registers} = std::vector< {\b Register} >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Attributes} &attrs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b ltrim} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b rtrim} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b trim} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b upper} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b lower} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b noSpaces} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b onlyAlphanumeric} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b noneOf} (const std::string &s, const std::string &chrs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b removeAllFrom} (const std::string &s, std::vector< std::string > &strs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b getElementsFrom} (const std::string &txt, unsigned char ch, size_t nE=std::numeric_limits< size_t >::max())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b validLabel} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b validBytesOctal} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b validBytesHexadecimal} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b validBytesDecimal} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b validBytes} (const std::string &s)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Attributes\:MCHEmul}
{\xe \v MCHEmul\:Attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Attributes} = typedef std::map <std::string, std::string>}}
\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attributes ar used in many places. \par
}{
Definition at line {\b 27} of file {\b global.hpp}.}\par
}
{\xe \v Chips\:MCHEmul}
{\xe \v MCHEmul\:Chips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Chips} = typedef std::map <int, {\b Chip}*>}}
\par
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Chip.hpp}.}\par
}
{\xe \v CPUInterrups\:MCHEmul}
{\xe \v MCHEmul\:CPUInterrups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::CPUInterrups} = typedef std::map <int, {\b CPUInterrupt}*>}}
\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A map of interrupts. \par
}{
Definition at line {\b 72} of file {\b CPUInterrupt.hpp}.}\par
}
{\xe \v Instructions\:MCHEmul}
{\xe \v MCHEmul\:Instructions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Instructions} = typedef std::map <unsigned int, {\b Instruction}*>}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 177} of file {\b Instruction.hpp}.}\par
}
{\xe \v IODevices\:MCHEmul}
{\xe \v MCHEmul\:IODevices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::IODevices} = typedef std::map <int, {\b IODevice}*>}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the management of a map of devices. \par
}{
Definition at line {\b 106} of file {\b IO.hpp}.}\par
}
{\xe \v IOPeripherals\:MCHEmul}
{\xe \v MCHEmul\:IOPeripherals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::IOPeripherals} = typedef std::map <int, {\b IOPeripheral}*>}}
\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the management of a set of peripherals. \par
}{
Definition at line {\b 77} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v MemoryViews\:MCHEmul}
{\xe \v MCHEmul\:MemoryViews}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::MemoryViews} = typedef std::map <int, {\b MemoryView}*>}}
\par
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the way a map of elements is managed. \par
}{
Definition at line {\b 284} of file {\b Memory.hpp}.}\par
}
{\xe \v PhisicalStorages\:MCHEmul}
{\xe \v MCHEmul\:PhisicalStorages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::PhisicalStorages} = typedef std::map <int, {\b PhisicalStorage}*>}}
\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the way a map of elements is managed. \par
}{
Definition at line {\b 96} of file {\b Memory.hpp}.}\par
}
{\xe \v PhisicalStorageSubsets\:MCHEmul}
{\xe \v MCHEmul\:PhisicalStorageSubsets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::PhisicalStorageSubsets} = typedef std::map <int, {\b PhisicalStorageSubset}*>}}
\par
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the way a map of elements is managed. \par
}{
Definition at line {\b 217} of file {\b Memory.hpp}.}\par
}
{\xe \v PhisicalStorageSubsetsList\:MCHEmul}
{\xe \v MCHEmul\:PhisicalStorageSubsetsList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::PhisicalStorageSubsetsList} = typedef std::vector <{\b PhisicalStorageSubset}*>}}
\par
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 218} of file {\b Memory.hpp}.}\par
}
{\xe \v Registers\:MCHEmul}
{\xe \v MCHEmul\:Registers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Registers} = typedef std::vector <{\b Register}>}}
\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b Register.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v getElementsFrom\:MCHEmul}
{\xe \v MCHEmul\:getElementsFrom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > MCHEmul::getElementsFrom (const std::string &  {\i txt}, unsigned char  {\i ch}, size_t  {\i nE} = {\f2 std::numeric_limits\~ <size_t>::max\~ ()})}}
\par
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b global.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_af0c91fc127585245e8031d4c433f7909_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_af0c91fc127585245e8031d4c433f7909_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v lower\:MCHEmul}
{\xe \v MCHEmul\:lower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::lower (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b global.cpp}.}\par
}
{\xe \v ltrim\:MCHEmul}
{\xe \v MCHEmul\:ltrim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::ltrim (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
General functions to manage strings \par
}{
Definition at line {\b 22} of file {\b global.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_ad93485f66a0164e99a459971deafd47a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v noneOf\:MCHEmul}
{\xe \v MCHEmul\:noneOf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::noneOf (const std::string &  {\i s}, const std::string &  {\i chrs})}}
\par
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b global.cpp}.}\par
}
{\xe \v noSpaces\:MCHEmul}
{\xe \v MCHEmul\:noSpaces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::noSpaces (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b global.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_a2db3c37872a0f90f7d36fec72115253d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v onlyAlphanumeric\:MCHEmul}
{\xe \v MCHEmul\:onlyAlphanumeric}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::onlyAlphanumeric (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b global.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_ad777c945b32490978d242c7bfe4522a9_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<<\:MCHEmul}
{\xe \v MCHEmul\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & MCHEmul::operator<< (std::ostream &  {\i o}, const {\b Attributes} &  {\i attrs})}}
\par
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The list of attributes can be printed out. \par
}{
Definition at line {\b 6} of file {\b global.cpp}.}\par
}
{\xe \v removeAllFrom\:MCHEmul}
{\xe \v MCHEmul\:removeAllFrom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::removeAllFrom (const std::string &  {\i s}, std::vector< std::string > &  {\i strs})}}
\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b global.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_aacef1d213be45b5258d512a34bb688e3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rtrim\:MCHEmul}
{\xe \v MCHEmul\:rtrim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::rtrim (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b global.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_aae68df24dca0d15a8e429fc6e58dfd23_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v trim\:MCHEmul}
{\xe \v MCHEmul\:trim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::trim (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b global.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_a034cc9e64b4baebddc5a25929dca4998_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_a034cc9e64b4baebddc5a25929dca4998_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v upper\:MCHEmul}
{\xe \v MCHEmul\:upper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::upper (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b global.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_a2b043f08c484f8d1f84de570ce94b142_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v validBytes\:MCHEmul}
{\xe \v MCHEmul\:validBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::validBytes (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b global.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_a5b5a8ba8f82f93b7da1eb8c31893c88d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_a5b5a8ba8f82f93b7da1eb8c31893c88d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v validBytesDecimal\:MCHEmul}
{\xe \v MCHEmul\:validBytesDecimal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::validBytesDecimal (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It will be octal instead\par
}{
Definition at line {\b 167} of file {\b global.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_a15f74fb36cba9b7dcdf1d48179c4a995_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v validBytesHexadecimal\:MCHEmul}
{\xe \v MCHEmul\:validBytesHexadecimal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::validBytesHexadecimal (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 156} of file {\b global.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_a5515dc4a11943bdf2ce4823ef78de8b6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v validBytesOctal\:MCHEmul}
{\xe \v MCHEmul\:validBytesOctal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::validBytesOctal (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 145} of file {\b global.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_a7644a598a6e6b00a49ae7f36a39d2171_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v validLabel\:MCHEmul}
{\xe \v MCHEmul\:validLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::validLabel (const std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
General functions to determine whether a string is or not valid from a spcific perspective. \par
}{
Definition at line {\b 136} of file {\b global.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_m_c_h_emul_a2a2a1493f37f186d6ce1cc43eaff9c35_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler Namespace Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler}
{\bkmkstart AAAAAAACZW}
{\bkmkend AAAAAAACZW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ByteCode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ByteCodeLine}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BytesCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BytesInMemoryElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CommentCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Compiler}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Error}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GrammaticalElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IncludeCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InstructionCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b InstructionElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LabelCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LabelElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Macro}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MacroCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Parser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Semantic}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StartingPointCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StartingPointElement}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Errors} = std::vector< {\b Error} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Macros} = std::map< std::string, {\b Macro} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b StartingPointElements} = std::vector< {\b StartingPointElement} * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b CommandParsers} = std::vector< {\b CommandParser} * >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b ErrorType} \{ {\b _NOERROR} = 0
, {\b _MACROBADDEFINED}
, {\b _MACRONOTDEFINED}
, {\b _LABELNOTVALID}
, {\b _LABELNOTDEFINED}
, {\b _BYTESNOTVALID}
, {\b _INSTRUCTIONNOTVALID}
, {\b _INSTRUCTIONNOTDEFINED}
, {\b _STARTINGPOINTNOTVALID}
, {\b _GRAMARELEMENTNOTVALID}
, {\b _STARTINGPOINTNOTDEFINED}
, {\b _DUPLICATEMACRO}
, {\b _SEMANTICERROR}
, {\b _FILEEMPTY}
, {\b _PARSERNOTFOUND}
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v CommandParsers\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:CommandParsers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Assembler::CommandParsers} = typedef std::vector <{\b CommandParser}*>}}
\par
{\bkmkstart AAAAAAACZX}
{\bkmkend AAAAAAACZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To facilitate the use of a list of commands. \par
}{
Definition at line {\b 68} of file {\b Parser.hpp}.}\par
}
{\xe \v Errors\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:Errors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Assembler::Errors} = typedef std::vector <{\b Error}>}}
\par
{\bkmkstart AAAAAAACZY}
{\bkmkend AAAAAAACZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b Error.hpp}.}\par
}
{\xe \v Macros\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:Macros}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Assembler::Macros} = typedef std::map <std::string, {\b Macro}>}}
\par
{\bkmkstart AAAAAAACZZ}
{\bkmkend AAAAAAACZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Grammar.hpp}.}\par
}
{\xe \v StartingPointElements\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:StartingPointElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::Assembler::StartingPointElements} = typedef std::vector <{\b StartingPointElement}*>}}
\par
{\bkmkstart AAAAAAADAA}
{\bkmkend AAAAAAADAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Notice that it is a set of pointers. \par
}{
Definition at line {\b 253} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v ErrorType\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:ErrorType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b MCHEmul::Assembler::ErrorType}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAADAB}
{\bkmkend AAAAAAADAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The type of errors admitted by the system. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _NOERROR\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_NOERROR}
{\qr _NOERROR{\bkmkstart AAAAAAADAC}
{\bkmkend AAAAAAADAC}
\cell }{\cell }{\row }
{\xe \v _MACROBADDEFINED\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_MACROBADDEFINED}
{\qr _MACROBADDEFINED{\bkmkstart AAAAAAADAD}
{\bkmkend AAAAAAADAD}
\cell }{\cell }{\row }
{\xe \v _MACRONOTDEFINED\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_MACRONOTDEFINED}
{\qr _MACRONOTDEFINED{\bkmkstart AAAAAAADAE}
{\bkmkend AAAAAAADAE}
\cell }{\cell }{\row }
{\xe \v _LABELNOTVALID\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_LABELNOTVALID}
{\qr _LABELNOTVALID{\bkmkstart AAAAAAADAF}
{\bkmkend AAAAAAADAF}
\cell }{\cell }{\row }
{\xe \v _LABELNOTDEFINED\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_LABELNOTDEFINED}
{\qr _LABELNOTDEFINED{\bkmkstart AAAAAAADAG}
{\bkmkend AAAAAAADAG}
\cell }{\cell }{\row }
{\xe \v _BYTESNOTVALID\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_BYTESNOTVALID}
{\qr _BYTESNOTVALID{\bkmkstart AAAAAAADAH}
{\bkmkend AAAAAAADAH}
\cell }{\cell }{\row }
{\xe \v _INSTRUCTIONNOTVALID\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_INSTRUCTIONNOTVALID}
{\qr _INSTRUCTIONNOTVALID{\bkmkstart AAAAAAADAI}
{\bkmkend AAAAAAADAI}
\cell }{\cell }{\row }
{\xe \v _INSTRUCTIONNOTDEFINED\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_INSTRUCTIONNOTDEFINED}
{\qr _INSTRUCTIONNOTDEFINED{\bkmkstart AAAAAAADAJ}
{\bkmkend AAAAAAADAJ}
\cell }{\cell }{\row }
{\xe \v _STARTINGPOINTNOTVALID\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_STARTINGPOINTNOTVALID}
{\qr _STARTINGPOINTNOTVALID{\bkmkstart AAAAAAADAK}
{\bkmkend AAAAAAADAK}
\cell }{\cell }{\row }
{\xe \v _GRAMARELEMENTNOTVALID\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_GRAMARELEMENTNOTVALID}
{\qr _GRAMARELEMENTNOTVALID{\bkmkstart AAAAAAADAL}
{\bkmkend AAAAAAADAL}
\cell }{\cell }{\row }
{\xe \v _STARTINGPOINTNOTDEFINED\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_STARTINGPOINTNOTDEFINED}
{\qr _STARTINGPOINTNOTDEFINED{\bkmkstart AAAAAAADAM}
{\bkmkend AAAAAAADAM}
\cell }{\cell }{\row }
{\xe \v _DUPLICATEMACRO\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_DUPLICATEMACRO}
{\qr _DUPLICATEMACRO{\bkmkstart AAAAAAADAN}
{\bkmkend AAAAAAADAN}
\cell }{\cell }{\row }
{\xe \v _SEMANTICERROR\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_SEMANTICERROR}
{\qr _SEMANTICERROR{\bkmkstart AAAAAAADAO}
{\bkmkend AAAAAAADAO}
\cell }{\cell }{\row }
{\xe \v _FILEEMPTY\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_FILEEMPTY}
{\qr _FILEEMPTY{\bkmkstart AAAAAAADAP}
{\bkmkend AAAAAAADAP}
\cell }{\cell }{\row }
{\xe \v _PARSERNOTFOUND\:MCHEmul::Assembler}
{\xe \v MCHEmul::Assembler\:_PARSERNOTFOUND}
{\qr _PARSERNOTFOUND{\bkmkstart AAAAAAADAQ}
{\bkmkend AAAAAAADAQ}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 24} of file {\b Error.hpp}.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::ADC_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::ADC_General}
{\xe \v F6500::ADC_General}
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::ADC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_d_c___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::ADC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_d_c___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ADC_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ADC_General}: To aggregate common steps in every ADC instruction. \par
}{
Definition at line {\b 84} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ADC_General\:F6500::ADC_General}
{\xe \v F6500::ADC_General\:ADC_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::ADC_General::ADC_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::ADC_General}
{\xe \v F6500::ADC_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::ADC_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 byte long.\par
}{
Definition at line {\b 5} of file {\b ADC.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_d_c___general_a244bd0da24899dc9ee634866e4162797_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b ADC.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Address Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Address}
{\xe \v MCHEmul::Address}
{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
\par
{
{\f2 #include <Address.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} (const {\b UInt} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} (const {\b MCHEmul::UBytes} &a, bool bE=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} (const std::vector< {\b UByte} > &a, bool bE=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} (const {\b Address} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} & {\b operator=} (const {\b Address} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UInt} & {\b value} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UBytes} & {\b values} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< {\b UByte} > & {\b bytes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b distanceWith} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b next} (size_t n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b previous} (size_t n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b operator+} (size_t n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} & {\b operator+=} (size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b operator-} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b operator-} (size_t n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} & {\b operator-=} (size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} & {\b operator--} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator[]} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} ({\b UByte::OutputFormat} oF) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Address} {\b fromStr} (const std::string &str)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b operator+} (size_t n, const {\b Address} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b operator-} (size_t n, const {\b Address} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Address} &a)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing and address that can vary from 0 to a limit. An initial value and the limit is given at construction time. If no limit is given the maximum possible in the framework is taken. \par
}{
Definition at line {\b 27} of file {\b Address.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Address\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Address::Address (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b Address.hpp}.}\par
}
{\xe \v Address\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Address::Address (const {\b UInt} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set at the length of the limit. \par
}{
Definition at line {\b 35} of file {\b Address.hpp}.}\par
}
{\xe \v Address\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Address::Address (const {\b MCHEmul::UBytes} &  {\i a}, bool  {\i bE} = {\f2 true}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b Address.hpp}.}\par
}
{\xe \v Address\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Address::Address (const std::vector< {\b UByte} > &  {\i a}, bool  {\i bE} = {\f2 true}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b Address.hpp}.}\par
}
{\xe \v Address\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Address::Address (const {\b Address} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asString\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Address::asString ({\b UByte::OutputFormat}  {\i oF}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_ad430a2b6338964f32de2067547d4d39e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bytes\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< {\b UByte} > & MCHEmul::Address::bytes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_ad67872c7f0572e693a090ac876528f7a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_ad67872c7f0572e693a090ac876528f7a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v distanceWith\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:distanceWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::Address::distanceWith (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Could be negative. \par
}{
Definition at line {\b 61} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a62b90165f365b170279f28e1193cbb2f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a62b90165f365b170279f28e1193cbb2f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fromStr\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:fromStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} MCHEmul::Address::fromStr (const std::string &  {\i str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create an {\b Address} from an string.\par
The string should start with $ if written in hexadecimal, with 0 if it is in octal and with no 0 number in decimal: \par
e.g $D400 (hexa), 07600 (octal), 53248 (decimal). \par
If the str is not valid, then an empty address will be given. \par
}{
Definition at line {\b 10} of file {\b Address.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_ab6fa87badf2e8d3b374995800131f1d3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_ab6fa87badf2e8d3b374995800131f1d3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v next\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::Address::next (size_t  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When reach the limit start back in th other side. \par
}{
Definition at line {\b 65} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a0323eecc3f036752cdd155b78d38d61f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a0323eecc3f036752cdd155b78d38d61f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!=\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Address::operator!= (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b Address.hpp}.}\par
}
{\xe \v operator+\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::Address::operator+ (size_t  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a8ed281710b6e7bacc5a74892193b162a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} & MCHEmul::Address::operator+= (size_t  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b Address.hpp}.}\par
}
{\xe \v operator-\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::Address::operator- (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_ab2f5b4d71707e4c053240243b34cad7b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::Address::operator- (size_t  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a0e37cda7d3a3ed82a141e7b67f22c980_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator--\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} & MCHEmul::Address::operator-- (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b Address.hpp}.}\par
}
{\xe \v operator-=\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} & MCHEmul::Address::operator-= (size_t  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b Address.hpp}.}\par
}
{\xe \v operator<\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Address::operator< (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b Address.hpp}.}\par
}
{\xe \v operator<=\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Address::operator<= (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Address.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} & MCHEmul::Address::operator= (const {\b Address} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Address::operator== (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b Address.hpp}.}\par
}
{\xe \v operator>\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Address::operator> (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Address.hpp}.}\par
}
{\xe \v operator>=\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Address::operator>= (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b Address.hpp}.}\par
}
{\xe \v operator[]\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::Address::operator[] (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b Address.hpp}.}\par
}
{\xe \v previous\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:previous}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::Address::previous (size_t  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a83511885ae269ba97fd3c9bc04cdf6b7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a83511885ae269ba97fd3c9bc04cdf6b7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::Address::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a1202d7aa588b99ab03c788bd931b947c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a1202d7aa588b99ab03c788bd931b947c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt} & MCHEmul::Address::value () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b Address.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_aa55936e1140c35634e3c3a5a83fca288_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v values\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UBytes} & MCHEmul::Address::values () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Address.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a0853a0eeb8ccc3d4ea72f89ab682dce6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_address_a0853a0eeb8ccc3d4ea72f89ab682dce6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator+\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} operator+ (size_t  {\i n}, const {\b Address} &  {\i a}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b Address.hpp}.}\par
}
{\xe \v operator-\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} operator- (size_t  {\i n}, const {\b Address} &  {\i a}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b Address.hpp}.}\par
}
{\xe \v operator<<\:MCHEmul::Address}
{\xe \v MCHEmul::Address\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Address} &  {\i a}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Address.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b Address.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::AND_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::AND_General}
{\xe \v F6500::AND_General}
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::AND_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_n_d___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::AND_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_n_d___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AND_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AND_General}: To aggregate common steps in every AND instruction. \par
}{
Definition at line {\b 106} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AND_General\:F6500::AND_General}
{\xe \v F6500::AND_General\:AND_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::AND_General::AND_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::AND_General}
{\xe \v F6500::AND_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::AND_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b AND.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_n_d___general_a133077685b538d78075eae70d3a45899_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b AND.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::ASL_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::ASL_General}
{\xe \v F6500::ASL_General}
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::ASL_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_s_l___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::ASL_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_s_l___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ASL_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ASL_General}: To aggregate common steps in every ASL instruction. \par
}{
Definition at line {\b 128} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ASL_General\:F6500::ASL_General}
{\xe \v F6500::ASL_General\:ASL_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::ASL_General::ASL_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::ASL_General}
{\xe \v F6500::ASL_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::ASL_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0 is put into\par
}{
Definition at line {\b 5} of file {\b ASL.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_a_s_l___general_aa10c449082e21a94cb134375fa2e17d3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b ASL.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UInt::BinaryFormatManager Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UInt::BinaryFormatManager}
{\xe \v MCHEmul::UInt::BinaryFormatManager}
{\bkmkstart AAAAAAACYZ}
{\bkmkend AAAAAAACYZ}
\par
{
{\f2 #include <UInt.hpp>}}\par
Inheritance diagram for MCHEmul::UInt::BinaryFormatManager:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_binary_format_manager__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::UInt::BinaryFormatManager:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_binary_format_manager__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b add} (const {\b UInt} &u1, const {\b UInt} &u2, bool cIn) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b substract} (const {\b UInt} &u1, const {\b UInt} &u2, bool cIn) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b asUnsignedInt} (const {\b UInt} &u) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b fromUnsignedInt} (unsigned int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b fromInt} (int n)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For _BINARY format. \par
}{
Definition at line {\b 55} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add\:MCHEmul::UInt::BinaryFormatManager}
{\xe \v MCHEmul::UInt::BinaryFormatManager\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UInt} MCHEmul::UInt::BinaryFormatManager::add (const {\b UInt} &  {\i u1}, const {\b UInt} &  {\i u2}, bool  {\i cIn}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACZA}
{\bkmkend AAAAAAACZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For _BINARY numbers no adjustment is needed at all after adding operation. \par
}{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 14} of file {\b UInt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_binary_format_manager_a5d67db8f92ef1e2e27fa110b3ff99967_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asUnsignedInt\:MCHEmul::UInt::BinaryFormatManager}
{\xe \v MCHEmul::UInt::BinaryFormatManager\:asUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::UInt::BinaryFormatManager::asUnsignedInt (const {\b UInt} &  {\i u}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACZC}
{\bkmkend AAAAAAACZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 34} of file {\b UInt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_binary_format_manager_a9d118545d80c9633ec480f6509be90fa_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fromInt\:MCHEmul::UInt::BinaryFormatManager}
{\xe \v MCHEmul::UInt::BinaryFormatManager\:fromInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UInt} MCHEmul::UInt::BinaryFormatManager::fromInt (int  {\i n}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACZE}
{\bkmkend AAAAAAACZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 67} of file {\b UInt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_binary_format_manager_a83617bdd1f8191b9efaf5b937c26585f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fromUnsignedInt\:MCHEmul::UInt::BinaryFormatManager}
{\xe \v MCHEmul::UInt::BinaryFormatManager\:fromUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UInt} MCHEmul::UInt::BinaryFormatManager::fromUnsignedInt (unsigned int  {\i n}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACZG}
{\bkmkend AAAAAAACZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 46} of file {\b UInt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_binary_format_manager_afc1cb13be22457f3c886cee90ba65423_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v substract\:MCHEmul::UInt::BinaryFormatManager}
{\xe \v MCHEmul::UInt::BinaryFormatManager\:substract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UInt} MCHEmul::UInt::BinaryFormatManager::substract (const {\b UInt} & , const {\b UInt} & , bool ) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACZI}
{\bkmkend AAAAAAACZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The same for substracting. \par
}{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 24} of file {\b UInt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_binary_format_manager_a672c6514913d729e18cfb2f629b235e3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UInt.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b UInt.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::BXX_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::BXX_General}
{\xe \v F6500::BXX_General}
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::BXX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_b_x_x___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::BXX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_b_x_x___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BXX_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b executeBranch} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b BXX_General}: To aggregate common steps in every Branch instruction. \par
}{
Definition at line {\b 146} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BXX_General\:F6500::BXX_General}
{\xe \v F6500::BXX_General\:BXX_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::BXX_General::BXX_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeBranch\:F6500::BXX_General}
{\xe \v F6500::BXX_General\:executeBranch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void F6500::BXX_General::executeBranch (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b BRANCHES.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_b_x_x___general_ad53597e70feb7e84f7822f2051bdf5c2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b BRANCHES.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::ByteCode Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode}
{\bkmkstart AAAAAAADAR}
{\bkmkend AAAAAAADAR}
\par
{
{\f2 #include <Compiler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCode} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCode} (const {\b ByteCode} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCode} & {\b operator=} (const {\b ByteCode} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b asSetOfBytes} ({\b Address} &iA) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< {\b Address}, unsigned int > {\b listOfActions} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b loadIntoMemory} ({\b Memory} *m)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b ByteCode} {\b createFromMemory} (const {\b Address} &a, unsigned int b, {\b Memory} *m, {\b CPU} *cpu)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b ByteCodeLine} > {\b _lines}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To manage the set of bytecode lines. \par
}{
Definition at line {\b 51} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ByteCode\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:ByteCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::ByteCode::ByteCode (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADAS}
{\bkmkend AAAAAAADAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ByteCode\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:ByteCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::ByteCode::ByteCode (const {\b ByteCode} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADAT}
{\bkmkend AAAAAAADAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asSetOfBytes\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:asSetOfBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b MCHEmul::UByte} > MCHEmul::Assembler::ByteCode::asSetOfBytes ({\b MCHEmul::Address} &  {\i iA}) const}}
\par
{\bkmkstart AAAAAAADAU}
{\bkmkend AAAAAAADAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the initial address in the iA variable. The addresses with no info are filled with 0x00. \par
}{
Definition at line {\b 23} of file {\b Compiler.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_byte_code_a3a01248dc8f4f37ac0477219b5353838_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_byte_code_a3a01248dc8f4f37ac0477219b5353838_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v createFromMemory\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:createFromMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Assembler::ByteCode} MCHEmul::Assembler::ByteCode::createFromMemory (const {\b Address} &  {\i a}, unsigned int  {\i b}, {\b MCHEmul::Memory} *  {\i m}, {\b MCHEmul::CPU} *  {\i cpu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAADAV}
{\bkmkend AAAAAAADAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
no label ever.\par
no action.\par
}{
Definition at line {\b 79} of file {\b Compiler.cpp}.}\par
}
{\xe \v listOfActions\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:listOfActions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map< {\b MCHEmul::Address}, unsigned int > MCHEmul::Assembler::ByteCode::listOfActions () const}}
\par
{\bkmkstart AAAAAAADAW}
{\bkmkend AAAAAAADAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the list of actions per address. Action == 0 are not actions! \par
}{
Definition at line {\b 58} of file {\b Compiler.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_byte_code_a27fe270a7d5f31a31508ac0e5c055429_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v loadIntoMemory\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:loadIntoMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::ByteCode::loadIntoMemory ({\b MCHEmul::Memory} *  {\i m})}}
\par
{\bkmkstart AAAAAAADAX}
{\bkmkend AAAAAAADAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To load the info into the memory. \par
}{
Definition at line {\b 70} of file {\b Compiler.cpp}.}\par
}
{\xe \v operator=\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ByteCode} & MCHEmul::Assembler::ByteCode::operator= (const {\b ByteCode} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADAY}
{\bkmkend AAAAAAADAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _lines\:MCHEmul::Assembler::ByteCode}
{\xe \v MCHEmul::Assembler::ByteCode\:_lines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b ByteCodeLine}> MCHEmul::Assembler::ByteCode::_lines}}
\par
{\bkmkstart AAAAAAADAZ}
{\bkmkend AAAAAAADAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Compiler.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Compiler.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::ByteCodeLine Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine}
{\bkmkstart AAAAAAADBA}
{\bkmkend AAAAAAADBA}
\par
{
{\f2 #include <Compiler.hpp>}}\par
Collaboration diagram for MCHEmul::Assembler::ByteCodeLine:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_byte_code_line__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCodeLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCodeLine} (const {\b Address} &a, const std::vector< {\b UByte} > &b, const std::string &n, const {\b Instruction} *i, unsigned int act)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCodeLine} (const {\b ByteCodeLine} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCodeLine} & {\b operator=} (const {\b ByteCodeLine} &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b _address}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b _bytes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _label}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Instruction} * {\b _instruction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _actionOn}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b ByteCodeLine} &c)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The compiler reads the semantic and transform it into lines of bytes. \par
}{
Definition at line {\b 26} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ByteCodeLine\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:ByteCodeLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::ByteCodeLine::ByteCodeLine (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADBB}
{\bkmkend AAAAAAADBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b Compiler.hpp}.}\par
}
{\xe \v ByteCodeLine\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:ByteCodeLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::ByteCodeLine::ByteCodeLine (const {\b Address} &  {\i a}, const std::vector< {\b UByte} > &  {\i b}, const std::string &  {\i n}, const {\b Instruction} *  {\i i}, unsigned int  {\i act}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADBC}
{\bkmkend AAAAAAADBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Compiler.hpp}.}\par
}
{\xe \v ByteCodeLine\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:ByteCodeLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::ByteCodeLine::ByteCodeLine (const {\b ByteCodeLine} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADBD}
{\bkmkend AAAAAAADBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ByteCodeLine} & MCHEmul::Assembler::ByteCodeLine::operator= (const {\b ByteCodeLine} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADBE}
{\bkmkend AAAAAAADBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b ByteCodeLine} &  {\i c}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADBF}
{\bkmkend AAAAAAADBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _actionOn\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:_actionOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Assembler::ByteCodeLine::_actionOn}}
\par
{\bkmkstart AAAAAAADBG}
{\bkmkend AAAAAAADBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b Compiler.hpp}.}\par
}
{\xe \v _address\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:_address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::Assembler::ByteCodeLine::_address}}
\par
{\bkmkstart AAAAAAADBH}
{\bkmkend AAAAAAADBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b Compiler.hpp}.}\par
}
{\xe \v _bytes\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:_bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b UByte}> MCHEmul::Assembler::ByteCodeLine::_bytes}}
\par
{\bkmkstart AAAAAAADBI}
{\bkmkend AAAAAAADBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b Compiler.hpp}.}\par
}
{\xe \v _instruction\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:_instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Instruction}* MCHEmul::Assembler::ByteCodeLine::_instruction}}
\par
{\bkmkstart AAAAAAADBJ}
{\bkmkend AAAAAAADBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Compiler.hpp}.}\par
}
{\xe \v _label\:MCHEmul::Assembler::ByteCodeLine}
{\xe \v MCHEmul::Assembler::ByteCodeLine\:_label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Assembler::ByteCodeLine::_label}}
\par
{\bkmkstart AAAAAAADBK}
{\bkmkend AAAAAAADBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Compiler.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::BytesCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::BytesCommandParser}
{\xe \v MCHEmul::Assembler::BytesCommandParser}
{\bkmkstart AAAAAAADBL}
{\bkmkend AAAAAAADBL}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::BytesCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_bytes_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::BytesCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_bytes_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BytesCommandParser} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *s) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser a set of bytes. \par
}{
Definition at line {\b 182} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BytesCommandParser\:MCHEmul::Assembler::BytesCommandParser}
{\xe \v MCHEmul::Assembler::BytesCommandParser\:BytesCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::BytesCommandParser::BytesCommandParser (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADBM}
{\bkmkend AAAAAAADBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 185} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::BytesCommandParser}
{\xe \v MCHEmul::Assembler::BytesCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::BytesCommandParser::canParse (const std::string &  {\i l}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADBN}
{\bkmkend AAAAAAADBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 193} of file {\b Parser.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_bytes_command_parser_af5bb0e91f810b38eba0697631e3f16c2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::Assembler::BytesCommandParser}
{\xe \v MCHEmul::Assembler::BytesCommandParser\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::BytesCommandParser::initialize (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADBP}
{\bkmkend AAAAAAADBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maybe one of them could need it. \par
}{
Reimplemented from {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 190} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::BytesCommandParser}
{\xe \v MCHEmul::Assembler::BytesCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::BytesCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADBR}
{\bkmkend AAAAAAADBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Until a potential comment.\par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 88} of file {\b Parser.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_bytes_command_parser_aeff1c8f4e7ae796692f3f9792a3084c3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Parser.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::BytesInMemoryElement Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::BytesInMemoryElement}
{\xe \v MCHEmul::Assembler::BytesInMemoryElement}
{\bkmkstart AAAAAAADBT}
{\bkmkend AAAAAAADBT}
\par
{
{\f2 #include <Grammar.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::BytesInMemoryElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_bytes_in_memory_element__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::BytesInMemoryElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_bytes_in_memory_element__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BytesInMemoryElement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BytesInMemoryElement} (const {\b BytesInMemoryElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BytesInMemoryElement} & {\b operator=} (const {\b BytesInMemoryElement} &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b _elements}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
explanation at the beggining of the file. \par
}}}{
Definition at line {\b 179} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BytesInMemoryElement\:MCHEmul::Assembler::BytesInMemoryElement}
{\xe \v MCHEmul::Assembler::BytesInMemoryElement\:BytesInMemoryElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::BytesInMemoryElement::BytesInMemoryElement (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADBU}
{\bkmkend AAAAAAADBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 181} of file {\b Grammar.hpp}.}\par
}
{\xe \v BytesInMemoryElement\:MCHEmul::Assembler::BytesInMemoryElement}
{\xe \v MCHEmul::Assembler::BytesInMemoryElement\:BytesInMemoryElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::BytesInMemoryElement::BytesInMemoryElement (const {\b BytesInMemoryElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADBV}
{\bkmkend AAAAAAADBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:MCHEmul::Assembler::BytesInMemoryElement}
{\xe \v MCHEmul::Assembler::BytesInMemoryElement\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BytesInMemoryElement} & MCHEmul::Assembler::BytesInMemoryElement::operator= (const {\b BytesInMemoryElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADBW}
{\bkmkend AAAAAAADBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _elements\:MCHEmul::Assembler::BytesInMemoryElement}
{\xe \v MCHEmul::Assembler::BytesInMemoryElement\:_elements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<std::string> MCHEmul::Assembler::BytesInMemoryElement::_elements}}
\par
{\bkmkstart AAAAAAADBX}
{\bkmkend AAAAAAADBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 189} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Grammar.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Emuls::C64Emulator Class Reference\par \pard\plain 
{\tc\tcl2 \v Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator}
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
\par
{
{\f2 #include <C64Emulator.hpp>}}\par
Inheritance diagram for Emuls::C64Emulator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_c64_emulator__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for Emuls::C64Emulator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_c64_emulator__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C64Emulator} (const std::vector< std::string > &argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b NTSCSystem} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _PARAMNTSC} = 'n'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const std::string {\b _NTSC} = "NTSC"\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Computer} * {\b createComputer} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::IOPeripheralBuilder} * {\b createPeripheralBuilder} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b additionalRunCycle} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 24} of file {\b C64Emulator.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v C64Emulator\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:C64Emulator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Emuls::C64Emulator::C64Emulator (const std::vector< std::string > &  {\i argv})}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor: {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argc} \cell }{: N\'FAmero de par\'E1metros. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argv} \cell }{: The parameters.\par
The basic parameters for any {\b C64} emulator are (apart of the ones defined by the parent: \par
/n : To indicate if the visualization system is NTSC. PAL by default. \cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
param 0 = name of the executable\par
}{
Definition at line {\b 21} of file {\b C64Emulator.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v additionalRunCycle\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:additionalRunCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Emuls::C64Emulator::additionalRunCycle (){\f2 [inline]}, {\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Just to actualize the global time of the {\b C64}. \par
}{
Reimplemented from {\b Emuls::Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABEZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 56} of file {\b C64Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_c64_emulator_a3ecd6ddfe8870352c3be0c9f4d6a95a3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v createComputer\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:createComputer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Computer} * Emuls::C64Emulator::createComputer () const{\f2 [inline]}, {\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create the right version of the computer, attending the parameters received by the constructor. \par
}{
Implements {\b Emuls::Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABFB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 48} of file {\b C64Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_c64_emulator_a117cc6906d6cff90836c233680b37030_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v createPeripheralBuilder\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:createPeripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::IOPeripheralBuilder} * Emuls::C64Emulator::createPeripheralBuilder () const{\f2 [inline]}, {\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create the right version of the Peripheral Builder. \par
}{
Implements {\b Emuls::Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABFD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 52} of file {\b C64Emulator.hpp}.}\par
}
{\xe \v initialize\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::C64Emulator::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To add the peripherals linked to the computer, according to the parameters. \par
}{
Reimplemented from {\b Emuls::Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABFF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 9} of file {\b C64Emulator.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_c64_emulator_ad29fe7969896ac949eb2ac65704f7613_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v NTSCSystem\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:NTSCSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::C64Emulator::NTSCSystem () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know whether the visualizacion system is or not NTSC. \par
}{
Definition at line {\b 41} of file {\b C64Emulator.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_c64_emulator_ae84cf6a01e8c2d43a984fd9503d5c49a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _NTSC\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:_NTSC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string Emuls::C64Emulator::_NTSC = "NTSC"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b C64Emulator.hpp}.}\par
}
{\xe \v _PARAMNTSC\:Emuls::C64Emulator}
{\xe \v Emuls::C64Emulator\:_PARAMNTSC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char Emuls::C64Emulator::_PARAMNTSC = 'n'{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The possible additional parameters of the {\b C64} {\b Emulator}. \par
}{
Definition at line {\b 28} of file {\b C64Emulator.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/EMULATORS/{\b C64Emulator.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/EMULATORS/{\b C64Emulator.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::C6500 Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::C6500}
{\xe \v F6500::C6500}
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
\par
{
{\f2 #include <C6500.hpp>}}\par
Inheritance diagram for F6500::C6500:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6500__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::C6500:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6500__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b AddressMode} \{ {\b _IMPLICIT}
, {\b _INMEDIATE}
, {\b _ABSOLUTE}
, {\b _ZEROPAGE}
, {\b _ABSOLUTE_X}
, {\b _ABSOLUTE_Y}
, {\b _RELATIVE}
, {\b _INDIRECT}
, {\b _ZEROPAGE_X}
, {\b _ZEROPAGE_Y}
, {\b _INDIRECT_X}
, {\b _INDIRECT_Y}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C6500} (const {\b MCHEmul::CPUArchitecture} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Address} {\b IRQVectorAddress} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Address} {\b NMIVectorAddress} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Address} {\b ResetVectorAddress} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Register} & {\b accumulator} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Register} & {\b xRegister} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Register} & {\b yRegister} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b _ACCUMULATOR} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b _XREGISTER} = 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b _YREGISTER} = 2\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Chip CPU type 6500 \par
}{
Definition at line {\b 22} of file {\b C6500.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v AddressMode\:F6500::C6500}
{\xe \v F6500::C6500\:AddressMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b F6500::C6500::AddressMode}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The different possibilities a 6500 instruction set has to understand its parameters. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _IMPLICIT\:F6500::C6500}
{\xe \v F6500::C6500\:_IMPLICIT}
{\qr _IMPLICIT{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
\cell }{\cell }{\row }
{\xe \v _INMEDIATE\:F6500::C6500}
{\xe \v F6500::C6500\:_INMEDIATE}
{\qr _INMEDIATE{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
\cell }{\cell }{\row }
{\xe \v _ABSOLUTE\:F6500::C6500}
{\xe \v F6500::C6500\:_ABSOLUTE}
{\qr _ABSOLUTE{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
\cell }{\cell }{\row }
{\xe \v _ZEROPAGE\:F6500::C6500}
{\xe \v F6500::C6500\:_ZEROPAGE}
{\qr _ZEROPAGE{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
\cell }{\cell }{\row }
{\xe \v _ABSOLUTE_X\:F6500::C6500}
{\xe \v F6500::C6500\:_ABSOLUTE_X}
{\qr _ABSOLUTE_X{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
\cell }{\cell }{\row }
{\xe \v _ABSOLUTE_Y\:F6500::C6500}
{\xe \v F6500::C6500\:_ABSOLUTE_Y}
{\qr _ABSOLUTE_Y{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
\cell }{\cell }{\row }
{\xe \v _RELATIVE\:F6500::C6500}
{\xe \v F6500::C6500\:_RELATIVE}
{\qr _RELATIVE{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
\cell }{\cell }{\row }
{\xe \v _INDIRECT\:F6500::C6500}
{\xe \v F6500::C6500\:_INDIRECT}
{\qr _INDIRECT{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
\cell }{\cell }{\row }
{\xe \v _ZEROPAGE_X\:F6500::C6500}
{\xe \v F6500::C6500\:_ZEROPAGE_X}
{\qr _ZEROPAGE_X{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
\cell }{\cell }{\row }
{\xe \v _ZEROPAGE_Y\:F6500::C6500}
{\xe \v F6500::C6500\:_ZEROPAGE_Y}
{\qr _ZEROPAGE_Y{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
\cell }{\cell }{\row }
{\xe \v _INDIRECT_X\:F6500::C6500}
{\xe \v F6500::C6500\:_INDIRECT_X}
{\qr _INDIRECT_X{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
\cell }{\cell }{\row }
{\xe \v _INDIRECT_Y\:F6500::C6500}
{\xe \v F6500::C6500\:_INDIRECT_Y}
{\qr _INDIRECT_Y{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 26} of file {\b C6500.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v C6500\:F6500::C6500}
{\xe \v F6500::C6500\:C6500}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::C6500::C6500 (const {\b MCHEmul::CPUArchitecture} &  {\i a})}}
\par
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b C6500.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6500_ac3378fe6fc1813e9a109411b6e65461d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v accumulator\:F6500::C6500}
{\xe \v F6500::C6500\:accumulator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Register} & F6500::C6500::accumulator (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b C6500.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6500_a6346170632f1750f1cffdef79ccb09bc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:F6500::C6500}
{\xe \v F6500::C6500\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::C6500::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the CPU. It could be overloaded later. \par
By default it just initialize registers and program counter to 0. \par
Returns true if everything was ok and false in any other case. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Little - endian\par
}{
Reimplemented from {\b MCHEmul::CPU} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABNY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 22} of file {\b C6500.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6500_a74f7145d16ee2d53df9a15d30228059a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IRQVectorAddress\:F6500::C6500}
{\xe \v F6500::C6500\:IRQVectorAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Address} F6500::C6500::IRQVectorAddress () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b F6500::C6510} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v NMIVectorAddress\:F6500::C6500}
{\xe \v F6500::C6500\:NMIVectorAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Address} F6500::C6500::NMIVectorAddress () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b F6500::C6510} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ResetVectorAddress\:F6500::C6500}
{\xe \v F6500::C6500\:ResetVectorAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Address} F6500::C6500::ResetVectorAddress () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b F6500::C6510} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v xRegister\:F6500::C6500}
{\xe \v F6500::C6500\:xRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Register} & F6500::C6500::xRegister (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b C6500.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6500_ac9facf1bb7a0026087553330b21e3d05_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v yRegister\:F6500::C6500}
{\xe \v F6500::C6500\:yRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Register} & F6500::C6500::yRegister (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b C6500.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6500_ab6a03805d14af306c92b1d8c066d111a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ACCUMULATOR\:F6500::C6500}
{\xe \v F6500::C6500\:_ACCUMULATOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t F6500::C6500::_ACCUMULATOR = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To identify the number of the registers. \par
}{
Definition at line {\b 58} of file {\b C6500.hpp}.}\par
}
{\xe \v _XREGISTER\:F6500::C6500}
{\xe \v F6500::C6500\:_XREGISTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t F6500::C6500::_XREGISTER = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b C6500.hpp}.}\par
}
{\xe \v _YREGISTER\:F6500::C6500}
{\xe \v F6500::C6500\:_YREGISTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t F6500::C6500::_YREGISTER = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b C6500.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b C6500.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b C6500.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::C6510 Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::C6510}
{\xe \v F6500::C6510}
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
\par
{
{\f2 #include <C6510.hpp>}}\par
Inheritance diagram for F6500::C6510:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6510__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::C6510:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c6510__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b C6510} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Address} {\b IRQVectorAddress} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Address} {\b NMIVectorAddress} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Address} {\b ResetVectorAddress} () const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Chip CPU 6510 \par
}{
Definition at line {\b 22} of file {\b C6510.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v C6510\:F6500::C6510}
{\xe \v F6500::C6510\:C6510}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::C6510::C6510 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b C6510.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v IRQVectorAddress\:F6500::C6510}
{\xe \v F6500::C6510\:IRQVectorAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Address} F6500::C6510::IRQVectorAddress () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Little - endian\par
}{
Implements {\b F6500::C6500} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABNZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 29} of file {\b C6510.hpp}.}\par
}
{\xe \v NMIVectorAddress\:F6500::C6510}
{\xe \v F6500::C6510\:NMIVectorAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Address} F6500::C6510::NMIVectorAddress () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Little - endian\par
}{
Implements {\b F6500::C6500} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 31} of file {\b C6510.hpp}.}\par
}
{\xe \v ResetVectorAddress\:F6500::C6510}
{\xe \v F6500::C6510\:ResetVectorAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Address} F6500::C6510::ResetVectorAddress () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Little - endian\par
}{
Implements {\b F6500::C6500} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 33} of file {\b C6510.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b C6510.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b C6510.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Chip Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Chip}
{\xe \v MCHEmul::Chip}
{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
\par
{
{\f2 #include <Chip.hpp>}}\par
Inheritance diagram for MCHEmul::Chip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_chip__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Chip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_chip__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chip} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chip} (int {\b id}, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chip} (const {\b Chip} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chip} & {\b operator=} (const {\b Chip} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Chip} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMemoryRef} ({\b Memory} *m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Memory} * {\b memoryRef} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b memoryRef} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} & {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b attribute} (const std::string &aN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ({\b CPU} *)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetErrors} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b _id} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b _memory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} {\b _attributes} = \{ \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Chip} &c)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A chip is a specialized element within the computer (different that the {\b CPU}). \par
All chips are set with the full memory accesibl when the computer is initialized, unless something specific is said initializing the chip itself!. \par
}{
Definition at line {\b 27} of file {\b Chip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Chip\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:Chip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Chip::Chip (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Chip\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:Chip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Chip::Chip (int  {\i id}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Chip.hpp}.}\par
}
{\xe \v Chip\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:Chip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Chip::Chip (const {\b Chip} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Chip\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:~Chip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::Chip::~Chip (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The chip is not owner of the memory. \par
}{
Definition at line {\b 42} of file {\b Chip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attribute\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::Chip::attribute (const std::string &  {\i aN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b Chip.hpp}.}\par
}
{\xe \v attributes\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} & MCHEmul::Chip::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b Chip.hpp}.}\par
}
{\xe \v id\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::Chip::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b Chip.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Chip::initialize (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Implemented in {\b C64::CIA1} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::CIA2} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASY \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::SpecialFunctionsChip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXR \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::VICII} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::NoChip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABUI \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::GraphicalChip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v lastError\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Chip::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the last error happend (after initialize or simulate methods). \par
}{
Definition at line {\b 74} of file {\b Chip.hpp}.}\par
}
{\xe \v memoryRef\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:memoryRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory} * MCHEmul::Chip::memoryRef (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b Chip.hpp}.}\par
}
{\xe \v memoryRef\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:memoryRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Memory} * MCHEmul::Chip::memoryRef () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b Chip.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_chip_a55f259ed37c44ef719846393f1a49551_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Chip} & MCHEmul::Chip::operator= (const {\b Chip} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resetErrors\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:resetErrors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Chip::resetErrors (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Chip.hpp}.}\par
}
{\xe \v setMemoryRef\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:setMemoryRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Chip::setMemoryRef ({\b Memory} *  {\i m}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The memory the chip can access to. \par
}{
Definition at line {\b 49} of file {\b Chip.hpp}.}\par
}
{\xe \v simulate\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Chip::simulate ({\b CPU} * ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate th behaviour of the chip. It has to be defined per chip. \par
Returns true if everything was ok, and false in any other circunstance. \par
 The last error could be recovered from the variable _lastError in that case. \par
The clock cyclees is added. \par
}{
Implemented in {\b MCHEmul::NoChip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABUP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::CIA1} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASN \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::CIA2} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::SpecialFunctionsChip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXS \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b C64::VICII} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Chip} &  {\i c}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _attributes\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} MCHEmul::Chip::_attributes = \{ \}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b Chip.hpp}.}\par
}
{\xe \v _id\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int MCHEmul::Chip::_id = -1{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b Chip.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Chip::_lastError{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b Chip.hpp}.}\par
}
{\xe \v _memory\:MCHEmul::Chip}
{\xe \v MCHEmul::Chip\:_memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory}* MCHEmul::Chip::_memory{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b Chip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Chip.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::CIA1 Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::CIA1}
{\xe \v C64::CIA1}
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
\par
{
{\f2 #include <CIA1.hpp>}}\par
Inheritance diagram for C64::CIA1:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a1__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::CIA1:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a1__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIA1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ({\b MCHEmul::CPU} *cpu) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b InputOSSystem}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _ID} = 2\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CIA1} is mainly to communicate {\b C64} with external devices. Additionaly it is also used to read the keyboard and the joysticks. \par
}{
Definition at line {\b 28} of file {\b CIA1.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CIA1\:C64::CIA1}
{\xe \v C64::CIA1\:CIA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::CIA1::CIA1 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b CIA1.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::CIA1}
{\xe \v C64::CIA1\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIA1::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 5} of file {\b CIA1.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a1_a03de10e49771845d2fa5ff4b77d29791_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v simulate\:C64::CIA1}
{\xe \v C64::CIA1\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIA1::simulate ({\b MCHEmul::CPU} * ){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate th behaviour of the chip. It has to be defined per chip. \par
Returns true if everything was ok, and false in any other circunstance. \par
 The last error could be recovered from the variable _lastError in that case. \par
The clock cyclees is added. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 26} of file {\b CIA1.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::CIA1}
{\xe \v C64::CIA1\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int C64::CIA1::_ID = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b CIA1.hpp}.}\par
}
{\xe \v InputOSSystem\:C64::CIA1}
{\xe \v C64::CIA1\:InputOSSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend C64::CIA1::InputOSSystem}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b CIA1.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b CIA1.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b CIA1.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::CIA1Registers Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::CIA1Registers}
{\xe \v C64::CIA1Registers}
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
\par
{
{\f2 #include <CIA1Registers.hpp>}}\par
Inheritance diagram for C64::CIA1Registers:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a1_registers__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::CIA1Registers:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a1_registers__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIA1Registers} (int {\b id}, {\b MCHEmul::PhisicalStorage} *pS)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b CIA1}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In the {\b CIA1} {\b Memory}, there are a couple of records that behave different when they are read that when they are written. \par
}{
Definition at line {\b 27} of file {\b CIA1Registers.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CIA1Registers\:C64::CIA1Registers}
{\xe \v C64::CIA1Registers\:CIA1Registers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::CIA1Registers::CIA1Registers (int  {\i id}, {\b MCHEmul::PhisicalStorage} *  {\i pS})}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b CIA1Registers.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::CIA1Registers}
{\xe \v C64::CIA1Registers\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIA1Registers::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To init the memory. It might be overloaded. By default the "defaultData" value is assigned. It doesn't matter whether the subset is or not active. \par
}{
Reimplemented from {\b MCHEmul::PhisicalStorageSubset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 16} of file {\b CIA1Registers.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a1_registers_a59f078fc5087e55ef18625fdc8083651_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v CIA1\:C64::CIA1Registers}
{\xe \v C64::CIA1Registers\:CIA1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend C64::CIA1Registers::CIA1}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b CIA1Registers.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b CIA1Registers.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b CIA1Registers.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::CIA2 Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::CIA2}
{\xe \v C64::CIA2}
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
\par
{
{\f2 #include <CIA2.hpp>}}\par
Inheritance diagram for C64::CIA2:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a2__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::CIA2:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a2__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIA2} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ({\b MCHEmul::CPU} *cpu) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b Commodore64}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _ID} = 3\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The chip is to communicate the {\b C64} with the environment. \par
}{
Definition at line {\b 28} of file {\b CIA2.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CIA2\:C64::CIA2}
{\xe \v C64::CIA2\:CIA2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::CIA2::CIA2 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b CIA2.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::CIA2}
{\xe \v C64::CIA2\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIA2::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 7} of file {\b CIA2.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a2_af13e14be251a1a6916639931a2b42312_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v simulate\:C64::CIA2}
{\xe \v C64::CIA2\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIA2::simulate ({\b MCHEmul::CPU} * ){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate th behaviour of the chip. It has to be defined per chip. \par
Returns true if everything was ok, and false in any other circunstance. \par
 The last error could be recovered from the variable _lastError in that case. \par
The clock cyclees is added. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 28} of file {\b CIA2.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::CIA2}
{\xe \v C64::CIA2\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int C64::CIA2::_ID = 3{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b CIA2.hpp}.}\par
}
{\xe \v Commodore64\:C64::CIA2}
{\xe \v C64::CIA2\:Commodore64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend C64::CIA2::Commodore64}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b CIA2.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b CIA2.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b CIA2.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::CIA2Registers Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::CIA2Registers}
{\xe \v C64::CIA2Registers}
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
\par
{
{\f2 #include <CIA2Registers.hpp>}}\par
Inheritance diagram for C64::CIA2Registers:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a2_registers__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::CIA2Registers:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a2_registers__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIA2Registers} (int {\b id}, {\b MCHEmul::PhisicalStorage} *pS)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b VICIIBank} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b CIA2}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In the {\b CIA2} {\b Memory}, there are a couple of records that behave different when they are read that when they are written. \par
}{
Definition at line {\b 27} of file {\b CIA2Registers.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CIA2Registers\:C64::CIA2Registers}
{\xe \v C64::CIA2Registers\:CIA2Registers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::CIA2Registers::CIA2Registers (int  {\i id}, {\b MCHEmul::PhisicalStorage} *  {\i pS})}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b CIA2Registers.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::CIA2Registers}
{\xe \v C64::CIA2Registers\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIA2Registers::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To init the memory. It might be overloaded. By default the "defaultData" value is assigned. It doesn't matter whether the subset is or not active. \par
}{
Reimplemented from {\b MCHEmul::PhisicalStorageSubset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 16} of file {\b CIA2Registers.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a2_registers_a032a5f162776cb0673e7a350921b14d5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v VICIIBank\:C64::CIA2Registers}
{\xe \v C64::CIA2Registers\:VICIIBank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::CIA2Registers::VICIIBank () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b CIA2Registers.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v CIA2\:C64::CIA2Registers}
{\xe \v C64::CIA2Registers\:CIA2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend C64::CIA2Registers::CIA2}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b CIA2Registers.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b CIA2Registers.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b CIA2Registers.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::CIAClock Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::CIAClock}
{\xe \v C64::CIAClock}
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
\par
{
{\f2 #include <CIAClock.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIAClock} (int {\b id})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b reachesAlarm} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IRQEnabled} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setIRQEnabled} (bool e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IRQRequested} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAlarmHours} (unsigned char h)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAlarmMinutes} (unsigned char m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAlarmSeconds} (unsigned char s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAlarmTenthSeconds} (unsigned char ts)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHours} (unsigned char h)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinutes} (unsigned char m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSeconds} (unsigned char s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTenthSeconds} (unsigned char ts)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b hours} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b minutes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b seconds} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b tenthsSecond} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b simulate} ({\b MCHEmul::CPU} *cpu)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 22} of file {\b CIAClock.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CIAClock\:C64::CIAClock}
{\xe \v C64::CIAClock\:CIAClock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::CIAClock::CIAClock (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i id} \cell }{unique in the CIA chip. \cell }
{\row }
}
}{
Definition at line {\b 25} of file {\b CIAClock.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a_clock_a90a830650939b544d5478279a8c60079_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v hours\:C64::CIAClock}
{\xe \v C64::CIAClock\:hours}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::CIAClock::hours () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know the alarm, by pieces. This is the way the chips works. Anytime hours are read, no new value can be read until tenths of second are also read. \par
}{
Definition at line {\b 70} of file {\b CIAClock.hpp}.}\par
}
{\xe \v id\:C64::CIAClock}
{\xe \v C64::CIAClock\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int C64::CIAClock::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b CIAClock.hpp}.}\par
}
{\xe \v initialize\:C64::CIAClock}
{\xe \v C64::CIAClock\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the timer. By default it is not enabled. \par
}{
Definition at line {\b 5} of file {\b CIAClock.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a_clock_a5f04f7c415abf02ae9c46e3b6397d8ac_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IRQEnabled\:C64::CIAClock}
{\xe \v C64::CIAClock\:IRQEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIAClock::IRQEnabled () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b CIAClock.hpp}.}\par
}
{\xe \v IRQRequested\:C64::CIAClock}
{\xe \v C64::CIAClock\:IRQRequested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIAClock::IRQRequested () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b CIAClock.hpp}.}\par
}
{\xe \v minutes\:C64::CIAClock}
{\xe \v C64::CIAClock\:minutes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::CIAClock::minutes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b CIAClock.hpp}.}\par
}
{\xe \v reachesAlarm\:C64::CIAClock}
{\xe \v C64::CIAClock\:reachesAlarm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIAClock::reachesAlarm () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To point whether the timer reached the alarm set. This variable will be true until the clock moves to the next tenth of second. \par
}{
Definition at line {\b 37} of file {\b CIAClock.hpp}.}\par
}
{\xe \v seconds\:C64::CIAClock}
{\xe \v C64::CIAClock\:seconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::CIAClock::seconds () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setAlarmHours\:C64::CIAClock}
{\xe \v C64::CIAClock\:setAlarmHours}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setAlarmHours (unsigned char  {\i h}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To set the alarm by pieces, because this is the way the CIA chip works. \par
}{
Definition at line {\b 49} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setAlarmMinutes\:C64::CIAClock}
{\xe \v C64::CIAClock\:setAlarmMinutes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setAlarmMinutes (unsigned char  {\i m}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setAlarmSeconds\:C64::CIAClock}
{\xe \v C64::CIAClock\:setAlarmSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setAlarmSeconds (unsigned char  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setAlarmTenthSeconds\:C64::CIAClock}
{\xe \v C64::CIAClock\:setAlarmTenthSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setAlarmTenthSeconds (unsigned char  {\i ts}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setHours\:C64::CIAClock}
{\xe \v C64::CIAClock\:setHours}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setHours (unsigned char  {\i h}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setIRQEnabled\:C64::CIAClock}
{\xe \v C64::CIAClock\:setIRQEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setIRQEnabled (bool  {\i e}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setMinutes\:C64::CIAClock}
{\xe \v C64::CIAClock\:setMinutes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setMinutes (unsigned char  {\i m}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setSeconds\:C64::CIAClock}
{\xe \v C64::CIAClock\:setSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setSeconds (unsigned char  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b CIAClock.hpp}.}\par
}
{\xe \v setTenthSeconds\:C64::CIAClock}
{\xe \v C64::CIAClock\:setTenthSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::setTenthSeconds (unsigned char  {\i ts}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b CIAClock.hpp}.}\par
}
{\xe \v simulate\:C64::CIAClock}
{\xe \v C64::CIAClock\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIAClock::simulate ({\b MCHEmul::CPU} *  {\i cpu})}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate the behaviour of the timer. \par
It invokes also some private methods. When an interruption is launches the variable _IRQRequested is set. It becomes back to false when it is read. \par
}{
Definition at line {\b 24} of file {\b CIAClock.cpp}.}\par
}
{\xe \v tenthsSecond\:C64::CIAClock}
{\xe \v C64::CIAClock\:tenthsSecond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::CIAClock::tenthsSecond () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b CIAClock.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b CIAClock.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b CIAClock.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::CIATimer Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::CIATimer}
{\xe \v C64::CIATimer}
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
\par
{
{\f2 #include <CIATimer.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b RunMode} \{ {\b _RESTART} = 0
, {\b _ONETIME}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b CountMode} \{ {\b _PROCESSORCYCLES} = 0
, {\b _SIGNALSONCNTLINE} = 1
, {\b _TIMERCOUNTSDOWNTO0} = 2
, {\b _0ONCNTPULSES} = 3
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIATimer} (int {\b id})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RunMode} {\b runMode} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRunMode} ({\b RunMode} rm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CountMode} {\b countMode} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCountMode} ({\b CountMode} cm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b reaches0} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b enabled} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEnabled} (bool e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IRQEnabled} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setIRQEnabled} (bool e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IRQRequested} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b initialValue} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInitialValue} (unsigned char iV)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentValue} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b simulate} ({\b MCHEmul::CPU} *cpu, {\b CIATimer} *t=nullptr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 22} of file {\b CIATimer.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v CountMode\:C64::CIATimer}
{\xe \v C64::CIATimer\:CountMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b C64::CIATimer::CountMode}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To determine the signal that moves a timer to count down... \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _PROCESSORCYCLES\:C64::CIATimer}
{\xe \v C64::CIATimer\:_PROCESSORCYCLES}
{\qr _PROCESSORCYCLES{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
\cell }{\cell }{\row }
{\xe \v _SIGNALSONCNTLINE\:C64::CIATimer}
{\xe \v C64::CIATimer\:_SIGNALSONCNTLINE}
{\qr _SIGNALSONCNTLINE{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
\cell }{\cell }{\row }
{\xe \v _TIMERCOUNTSDOWNTO0\:C64::CIATimer}
{\xe \v C64::CIATimer\:_TIMERCOUNTSDOWNTO0}
{\qr _TIMERCOUNTSDOWNTO0{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
\cell }{\cell }{\row }
{\xe \v _0ONCNTPULSES\:C64::CIATimer}
{\xe \v C64::CIATimer\:_0ONCNTPULSES}
{\qr _0ONCNTPULSES{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 33} of file {\b CIATimer.hpp}.}\par
}
{\xe \v RunMode\:C64::CIATimer}
{\xe \v C64::CIATimer\:RunMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b C64::CIATimer::RunMode}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To determine the behaviour of the Timer onces it reaches the 0. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _RESTART\:C64::CIATimer}
{\xe \v C64::CIATimer\:_RESTART}
{\qr _RESTART{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
\cell }{\cell }{\row }
{\xe \v _ONETIME\:C64::CIATimer}
{\xe \v C64::CIATimer\:_ONETIME}
{\qr _ONETIME{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 26} of file {\b CIATimer.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CIATimer\:C64::CIATimer}
{\xe \v C64::CIATimer\:CIATimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::CIATimer::CIATimer (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the timer is created, the value of the internal variables will be as follows: RUNMODE = RESTART COUNTMODE = PROCESSORCYCLES ENABLED = FALSE IRQENABLED = FALSE INITIALVALUE = 0 TIME = 0 (in thenth of second) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i id} \cell }{unique in the CIA chip. \cell }
{\row }
}
}{
Definition at line {\b 52} of file {\b CIATimer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a_timer_a2b44b7df089f442cf0a483217343e186_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v countMode\:C64::CIATimer}
{\xe \v C64::CIATimer\:countMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CountMode} C64::CIATimer::countMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b CIATimer.hpp}.}\par
}
{\xe \v currentValue\:C64::CIATimer}
{\xe \v C64::CIATimer\:currentValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::CIATimer::currentValue () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current value of the timer. \par
}{
Definition at line {\b 97} of file {\b CIATimer.hpp}.}\par
}
{\xe \v enabled\:C64::CIATimer}
{\xe \v C64::CIATimer\:enabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIATimer::enabled () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b CIATimer.hpp}.}\par
}
{\xe \v id\:C64::CIATimer}
{\xe \v C64::CIATimer\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int C64::CIATimer::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b CIATimer.hpp}.}\par
}
{\xe \v initialize\:C64::CIATimer}
{\xe \v C64::CIATimer\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the timer. By default it is not enabled. \par
}{
Definition at line {\b 5} of file {\b CIATimer.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_c_i_a_timer_aad0ff6e7f10649b669ec1a9417c4c0cf_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialValue\:C64::CIATimer}
{\xe \v C64::CIATimer\:initialValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::CIATimer::initialValue () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The value used as the starting point for the count down. \par
}{
Definition at line {\b 92} of file {\b CIATimer.hpp}.}\par
}
{\xe \v IRQEnabled\:C64::CIATimer}
{\xe \v C64::CIATimer\:IRQEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIATimer::IRQEnabled () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b CIATimer.hpp}.}\par
}
{\xe \v IRQRequested\:C64::CIATimer}
{\xe \v C64::CIATimer\:IRQRequested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIATimer::IRQRequested () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b CIATimer.hpp}.}\par
}
{\xe \v reaches0\:C64::CIATimer}
{\xe \v C64::CIATimer\:reaches0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::CIATimer::reaches0 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To point whether the timer reached 0. This variable will be true until the timer starts back. \par
}{
Definition at line {\b 74} of file {\b CIATimer.hpp}.}\par
}
{\xe \v reset\:C64::CIATimer}
{\xe \v C64::CIATimer\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::reset (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The timer is forced to start back. \par
}{
Definition at line {\b 100} of file {\b CIATimer.hpp}.}\par
}
{\xe \v runMode\:C64::CIATimer}
{\xe \v C64::CIATimer\:runMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RunMode} C64::CIATimer::runMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b CIATimer.hpp}.}\par
}
{\xe \v setCountMode\:C64::CIATimer}
{\xe \v C64::CIATimer\:setCountMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::setCountMode ({\b CountMode}  {\i cm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b CIATimer.hpp}.}\par
}
{\xe \v setEnabled\:C64::CIATimer}
{\xe \v C64::CIATimer\:setEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::setEnabled (bool  {\i e}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b CIATimer.hpp}.}\par
}
{\xe \v setInitialValue\:C64::CIATimer}
{\xe \v C64::CIATimer\:setInitialValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::setInitialValue (unsigned char  {\i iV}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b CIATimer.hpp}.}\par
}
{\xe \v setIRQEnabled\:C64::CIATimer}
{\xe \v C64::CIATimer\:setIRQEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::setIRQEnabled (bool  {\i e}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b CIATimer.hpp}.}\par
}
{\xe \v setRunMode\:C64::CIATimer}
{\xe \v C64::CIATimer\:setRunMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::setRunMode ({\b RunMode}  {\i rm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b CIATimer.hpp}.}\par
}
{\xe \v simulate\:C64::CIATimer}
{\xe \v C64::CIATimer\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::CIATimer::simulate ({\b MCHEmul::CPU} *  {\i cpu}, {\b C64::CIATimer} *  {\i t} = {\f2 nullptr})}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate the behaviour of the timer. \par
It invokes also some private methods. \par
}{
Definition at line {\b 25} of file {\b CIATimer.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b CIATimer.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b CIATimer.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Computer::Clock Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock}
{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
\par
{
{\f2 #include <Computer.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clock} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clock} (unsigned int cS)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clock} (const {\b Clock} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clock} & {\b operator=} (const {\b Clock} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b cyclesPerSecond} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b start} (unsigned int cC)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b waitFor} (unsigned int cC)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to align the speed to the microprocessor to the speed of the code in this machine. \par
}{
Definition at line {\b 155} of file {\b Computer.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Clock\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:Clock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Computer::Clock::Clock (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Clock\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:Clock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Computer::Clock::Clock (unsigned int  {\i cS}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b Computer.hpp}.}\par
}
{\xe \v Clock\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:Clock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Computer::Clock::Clock (const {\b Clock} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v cyclesPerSecond\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:cyclesPerSecond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Computer::Clock::cyclesPerSecond () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b Computer.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_1_1_clock_ab3a8cc1f93be0fac0ce1de58528c7b37_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Clock} & MCHEmul::Computer::Clock::operator= (const {\b Clock} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v start\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::Clock::start (unsigned int  {\i cC})}}
\par
{\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 213} of file {\b Computer.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_1_1_clock_a0883f759ef8325dd545778b77f1cc501_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v waitFor\:MCHEmul::Computer::Clock}
{\xe \v MCHEmul::Computer::Clock\:waitFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::Clock::waitFor (unsigned int  {\i cC})}}
\par
{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 220} of file {\b Computer.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_1_1_clock_ad18d47837d809a73080c435815be486c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Computer.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b Computer.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::CMP_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::CMP_General}
{\xe \v F6500::CMP_General}
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::CMP_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_m_p___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::CMP_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_m_p___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMP_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CMP_General}: To aggregate common steps in every CMP instruction. \par
}{
Definition at line {\b 202} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CMP_General\:F6500::CMP_General}
{\xe \v F6500::CMP_General\:CMP_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::CMP_General::CMP_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 205} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::CMP_General}
{\xe \v F6500::CMP_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::CMP_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 byte long\par
}{
Definition at line {\b 5} of file {\b CMP.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_m_p___general_a539e7b36b67107be31ff73796ce8b216_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b CMP.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::ColorRAMMemory Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::ColorRAMMemory}
{\xe \v C64::ColorRAMMemory}
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
\par
{
{\f2 #include <ColorMemory.hpp>}}\par
Inheritance diagram for C64::ColorRAMMemory:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_color_r_a_m_memory__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::ColorRAMMemory:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_color_r_a_m_memory__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ColorRAMMemory} (int {\b id}, {\b MCHEmul::PhisicalStorage} *ps)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The color RAM type {\b Memory} manage only LSB nibbles. \par
}{
Definition at line {\b 22} of file {\b ColorMemory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ColorRAMMemory\:C64::ColorRAMMemory}
{\xe \v C64::ColorRAMMemory\:ColorRAMMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::ColorRAMMemory::ColorRAMMemory (int  {\i id}, {\b MCHEmul::PhisicalStorage} *  {\i ps}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b ColorMemory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b ColorMemory.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Command Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Command}
{\xe \v MCHEmul::Command}
{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
\par
{
{\f2 #include <Command.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Command} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Command} (int {\b id}, const {\b Attributes} &prms=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Command} (const {\b Command} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Command} & {\b operator=} (const {\b Command} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Command} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} & {\b parameters} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setParameters} (const {\b Attributes} &prms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canBeExecuted} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b execute} ({\b Computer} *c, const {\b Attributes} &rst)=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Attributes} {\b _parameters}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 21} of file {\b Command.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Command\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:Command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Command::Command (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Command\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:Command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Command::Command (int  {\i id}, const {\b Attributes} &  {\i prms} = {\f2 \{\~ \}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b Command.hpp}.}\par
}
{\xe \v Command\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:Command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Command::Command (const {\b Command} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Command\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:~Command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::Command::~Command (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b Command.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canBeExecuted\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:canBeExecuted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Command::canBeExecuted () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v execute\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:execute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Command::execute ({\b Computer} *  {\i c}, const {\b Attributes} &  {\i rst}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v id\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::Command::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b Command.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Command} & MCHEmul::Command::operator= (const {\b Command} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parameters\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} & MCHEmul::Command::parameters () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b Command.hpp}.}\par
}
{\xe \v setParameters\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:setParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Command::setParameters (const {\b Attributes} &  {\i prms}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b Command.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _id\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::Command::_id{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b Command.hpp}.}\par
}
{\xe \v _parameters\:MCHEmul::Command}
{\xe \v MCHEmul::Command\:_parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Attributes} MCHEmul::Command::_parameters{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Command.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Command.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::CommandBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::CommandBuilder}
{\xe \v MCHEmul::CommandBuilder}
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
\par
{
{\f2 #include <CommandBuilder.hpp>}}\par
Inheritance diagram for MCHEmul::CommandBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_command_builder__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CommandBuilder} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Command} * {\b createCommand} (const std::string &cmd) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Command} * {\b createEmptyCommand} (const std::string &cmdName) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b readCommandName} (const std::string &cmd) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Attributes} {\b readCommandParameters} (const std::string &cmd) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create commands from an string that represents it. \par
}{
Definition at line {\b 22} of file {\b CommandBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ~CommandBuilder\:MCHEmul::CommandBuilder}
{\xe \v MCHEmul::CommandBuilder\:~CommandBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::CommandBuilder::~CommandBuilder (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b CommandBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createCommand\:MCHEmul::CommandBuilder}
{\xe \v MCHEmul::CommandBuilder\:createCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Command} * MCHEmul::CommandBuilder::createCommand (const std::string &  {\i cmd}) const}}
\par
{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b CommandBuilder.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_command_builder_a78f92c71ce006c9c850f3fe5ef0bafa6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v createEmptyCommand\:MCHEmul::CommandBuilder}
{\xe \v MCHEmul::CommandBuilder\:createEmptyCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b Command} * MCHEmul::CommandBuilder::createEmptyCommand (const std::string &  {\i cmdName}) const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b MCHEmul::StandardCommandBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_command_builder_ae3f15fdaef5e771f78e7293f789c4d8b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readCommandName\:MCHEmul::CommandBuilder}
{\xe \v MCHEmul::CommandBuilder\:readCommandName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::CommandBuilder::readCommandName (const std::string &  {\i cmd}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b CommandBuilder.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_command_builder_ac4b13d016fbe2b0469755a15c4aea5b6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readCommandParameters\:MCHEmul::CommandBuilder}
{\xe \v MCHEmul::CommandBuilder\:readCommandParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Attributes} MCHEmul::CommandBuilder::readCommandParameters (const std::string &  {\i cmd}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b CommandBuilder.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_command_builder_af7e22f3892a576c041522cd380e96887_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_command_builder_af7e22f3892a576c041522cd380e96887_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b CommandBuilder.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b CommandBuilder.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::CommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser}
{\bkmkstart AAAAAAADBY}
{\bkmkend AAAAAAADBY}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::CommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::CommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommandParser} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CommandParser} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPU} * {\b cpu} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Parser} * {\b parser} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *s) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCPU} (const {\b CPU} *c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setParser} (const {\b Parser} *p)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b Parser}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPU} * {\b _cpu}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Parser} * {\b _parser}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 29} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CommandParser\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:CommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::CommandParser::CommandParser (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADBZ}
{\bkmkend AAAAAAADBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b Parser.hpp}.}\par
}
{\xe \v ~CommandParser\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:~CommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::Assembler::CommandParser::~CommandParser (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCA}
{\bkmkend AAAAAAADCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::CommandParser::canParse (const std::string &  {\i l}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAADBO}
{\bkmkend AAAAAAADBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implemented in {\b MCHEmul::Assembler::CommentCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCB \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::IncludeCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::MacroCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::StartingPointCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::LabelCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::BytesCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBN \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::Assembler::InstructionCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v cpu\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPU} * MCHEmul::Assembler::CommandParser::cpu () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADCH}
{\bkmkend AAAAAAADCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b Parser.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::CommandParser::initialize (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADBQ}
{\bkmkend AAAAAAADBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maybe one of them could need it. \par
}{
Reimplemented in {\b MCHEmul::Assembler::StartingPointCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::LabelCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::BytesCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBP \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::Assembler::InstructionCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 47} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::CommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAADBS}
{\bkmkend AAAAAAADBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{
Implemented in {\b MCHEmul::Assembler::IncludeCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::MacroCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::StartingPointCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCN \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::LabelCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::BytesCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBR \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b MCHEmul::Assembler::InstructionCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCP \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::Assembler::CommentCommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v parser\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Parser} * MCHEmul::Assembler::CommandParser::parser () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADCR}
{\bkmkend AAAAAAADCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b Parser.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_command_parser_a10791ec7826019653bd6cea96731531a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setCPU\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:setCPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::CommandParser::setCPU (const {\b CPU} *  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADCS}
{\bkmkend AAAAAAADCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invoked from the {\b Parser}'s constructor. \par
}{
Definition at line {\b 57} of file {\b Parser.hpp}.}\par
}
{\xe \v setParser\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:setParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::CommandParser::setParser (const {\b Parser} *  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADCT}
{\bkmkend AAAAAAADCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _cpu\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:_cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPU}* MCHEmul::Assembler::CommandParser::_cpu{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADCU}
{\bkmkend AAAAAAADCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b Parser.hpp}.}\par
}
{\xe \v _parser\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:_parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Parser}* MCHEmul::Assembler::CommandParser::_parser{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADCV}
{\bkmkend AAAAAAADCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b Parser.hpp}.}\par
}
{\xe \v Parser\:MCHEmul::Assembler::CommandParser}
{\xe \v MCHEmul::Assembler::CommandParser\:Parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend MCHEmul::Assembler::CommandParser::Parser}}
\par
{\bkmkstart AAAAAAADCW}
{\bkmkend AAAAAAADCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::CommentCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::CommentCommandParser}
{\xe \v MCHEmul::Assembler::CommentCommandParser}
{\bkmkstart AAAAAAADCX}
{\bkmkend AAAAAAADCX}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::CommentCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_comment_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::CommentCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_comment_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommentCommandParser} (unsigned char s=';')\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b symbol} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int, {\b Semantic} *) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser a comment. Th symbol defining the beginning of a comment can be redefined. \par
}{
Definition at line {\b 72} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CommentCommandParser\:MCHEmul::Assembler::CommentCommandParser}
{\xe \v MCHEmul::Assembler::CommentCommandParser\:CommentCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::CommentCommandParser::CommentCommandParser (unsigned char  {\i s} = {\f2 ';'}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADCY}
{\bkmkend AAAAAAADCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::CommentCommandParser}
{\xe \v MCHEmul::Assembler::CommentCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::CommentCommandParser::canParse (const std::string &  {\i l}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCB}
{\bkmkend AAAAAAADCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 83} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::CommentCommandParser}
{\xe \v MCHEmul::Assembler::CommentCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::CommentCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCQ}
{\bkmkend AAAAAAADCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nothing after the comment is important.\par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 85} of file {\b Parser.hpp}.}\par
}
{\xe \v symbol\:MCHEmul::Assembler::CommentCommandParser}
{\xe \v MCHEmul::Assembler::CommentCommandParser\:symbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::Assembler::CommentCommandParser::symbol () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADCZ}
{\bkmkend AAAAAAADCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::Commodore64 Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::Commodore64}
{\xe \v C64::Commodore64}
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
\par
{
{\f2 #include <C64.hpp>}}\par
Inheritance diagram for C64::Commodore64:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_commodore64__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::Commodore64:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_commodore64__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b VisualSystem} \{ {\b _NTSC}
, {\b _PAL}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Commodore64} ({\b VisualSystem} vS={\b VisualSystem::_PAL})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b connect} ({\b MCHEmul::IOPeripheral} *p, {\b MCHEmul::IODevice} *d) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VisualSystem} {\b _visualSystem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Attributes} {\b _parameters}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
There were two main lines of versions for the {\b C64}, atenfing to the standard of video system: NTSC and PAL. However the constructor receives attributes comming from the emulator class (createComputer method) and within those there might be attributes to define specific devices connected. \par
}{
Definition at line {\b 28} of file {\b C64.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v VisualSystem\:C64::Commodore64}
{\xe \v C64::Commodore64\:VisualSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b C64::Commodore64::VisualSystem}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _NTSC\:C64::Commodore64}
{\xe \v C64::Commodore64\:_NTSC}
{\qr _NTSC{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
\cell }{\cell }{\row }
{\xe \v _PAL\:C64::Commodore64}
{\xe \v C64::Commodore64\:_PAL}
{\qr _PAL{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 31} of file {\b C64.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Commodore64\:C64::Commodore64}
{\xe \v C64::Commodore64\:Commodore64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::Commodore64::Commodore64 ({\b VisualSystem}  {\i vS} = {\f2 {\b VisualSystem::_PAL}})}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vS} \cell }{Europe initially \cell }
{\row }
}
}{
Definition at line {\b 13} of file {\b C64.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v connect\:C64::Commodore64}
{\xe \v C64::Commodore64\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::Commodore64::connect ({\b MCHEmul::IOPeripheral} *  {\i p}, {\b MCHEmul::IODevice} *  {\i d}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To connect a peripheral to a device on the computer. \par
It returns true when it is ok, and false in other circunstance. The way the peripheral is connected will depend on the computer, on the device and on the peripheral itself. \par
}{
Implements {\b MCHEmul::Computer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 30} of file {\b C64.cpp}.}\par
}
{\xe \v initialize\:C64::Commodore64}
{\xe \v C64::Commodore64\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::Commodore64::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the Computer, when the "power is set up". \par
 It could be defined per computer. By default it initializes the chips. \par
Returns true, when verything was ok, and false in any other circusntance. \par
The last error happend could then be checked in _lastEerror. \par
}{
Reimplemented from {\b MCHEmul::Computer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 38} of file {\b C64.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_commodore64_adf0c2c4e19692d48d1bc479ab981390e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _parameters\:C64::Commodore64}
{\xe \v C64::Commodore64\:_parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Attributes} C64::Commodore64::_parameters{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Other parameters used when initialized. \par
}{
Definition at line {\b 48} of file {\b C64.hpp}.}\par
}
{\xe \v _visualSystem\:C64::Commodore64}
{\xe \v C64::Commodore64\:_visualSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b VisualSystem} C64::Commodore64::_visualSystem{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The video system used by the commodore 64. \par
}{
Definition at line {\b 46} of file {\b C64.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b C64.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b C64.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::CommunicationMessage Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage}
{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
\par
{
{\f2 #include <Message.hpp>}}\par
Inheritance diagram for MCHEmul::CommunicationMessage:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_message__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommunicationMessage} (unsigned char t, const {\b Attributes} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommunicationMessage} (const {\b CommunicationMessage} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommunicationMessage} & {\b operator=} (const {\b CommunicationMessage} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CommunicationMessage} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b type} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b executeOn} ({\b Computer} *, {\b CommunicationMessage} *&)=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _MESSAGEID}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Attributes} {\b _attributes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _error}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b CommunicationMessage} class referes to the different instructions a client can sent to a server or a server can answer to a client on ergard to processing an emulator. \par
}{
Definition at line {\b 27} of file {\b Message.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CommunicationMessage\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:CommunicationMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CommunicationMessage::CommunicationMessage (unsigned char  {\i t}, const {\b Attributes} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b Message.hpp}.}\par
}
{\xe \v CommunicationMessage\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:CommunicationMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CommunicationMessage::CommunicationMessage (const {\b CommunicationMessage} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To avoid uncontrolable behaviours of any one inheriting from this. \par
}}
{\xe \v ~CommunicationMessage\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:~CommunicationMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::CommunicationMessage::~CommunicationMessage (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b Message.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attributes\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} MCHEmul::CommunicationMessage::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Message.hpp}.}\par
}
{\xe \v executeOn\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual unsigned int MCHEmul::CommunicationMessage::executeOn ({\b Computer} * , {\b CommunicationMessage} *& ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very important method. \par
This method execute what was required from the computer. \par
It must be overloaded per any specific behaviour. \par
The communication message can have an answer, and it is given in the second parameter. The method returns a number than can be additional info for the invoker. NOTE that Default result should be 0 meaning "No additional info for invoker". \par
}{
Implemented in {\b MCHEmul::GetRegisterStatusMessage} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVV \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::GetMemoryDataMessage} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CommunicationMessage} & MCHEmul::CommunicationMessage::operator= (const {\b CommunicationMessage} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v toString\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:toString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::CommunicationMessage::toString () const}}
\par
{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b Message.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_message_a354593ef90a679c5fad409bc93a79a4f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v type\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::CommunicationMessage::type () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b Message.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _attributes\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Attributes} MCHEmul::CommunicationMessage::_attributes{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The attributes of the message. \par
}{
Definition at line {\b 67} of file {\b Message.hpp}.}\par
}
{\xe \v _error\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CommunicationMessage::_error{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b Message.hpp}.}\par
}
{\xe \v _MESSAGEID\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:_MESSAGEID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::CommunicationMessage::_MESSAGEID{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \par
            DefaultMessageIDTypes::ID_USER_PACKET_ENUM + 1\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The id of the package having the specific meesages to control emulator. \par
}{
Definition at line {\b 31} of file {\b Message.hpp}.}\par
}
{\xe \v _type\:MCHEmul::CommunicationMessage}
{\xe \v MCHEmul::CommunicationMessage\:_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CommunicationMessage::_type{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The type of the message. \par
}{
Definition at line {\b 65} of file {\b Message.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b Message.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/COMMS/{\b Message.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::CommunicationSystem Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem}
{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
\par
{
{\f2 #include <System.hpp>}}\par
Collaboration diagram for MCHEmul::CommunicationSystem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_system__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommunicationSystem} ({\b PeerCommunicationChannel} *cC, {\b MessageBuilder} *mB)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommunicationSystem} (const {\b CommunicationSystem} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommunicationSystem} & {\b operator=} (const {\b CommunicationSystem} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CommunicationSystem} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b processMessagesOn} ({\b Computer} *c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b finalize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b error} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageBuilder} * {\b _messageBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PeerCommunicationChannel} * {\b _communicationChannel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _error}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 25} of file {\b System.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CommunicationSystem\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:CommunicationSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CommunicationSystem::CommunicationSystem ({\b PeerCommunicationChannel} *  {\i cC}, {\b MessageBuilder} *  {\i mB}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b System.hpp}.}\par
}
{\xe \v CommunicationSystem\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:CommunicationSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CommunicationSystem::CommunicationSystem (const {\b CommunicationSystem} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~CommunicationSystem\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:~CommunicationSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::CommunicationSystem::~CommunicationSystem (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b System.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v error\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CommunicationSystem::error () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b System.hpp}.}\par
}
{\xe \v finalize\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:finalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::CommunicationSystem::finalize (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b System.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_system_a3943c54136ea1d393feb5b137ff71c5e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_system_a3943c54136ea1d393feb5b137ff71c5e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::CommunicationSystem::initialize (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b System.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_system_a640a7d08dc85d4dfbf8ce95964257ef6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_communication_system_a640a7d08dc85d4dfbf8ce95964257ef6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CommunicationSystem::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b System.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CommunicationSystem} & MCHEmul::CommunicationSystem::operator= (const {\b CommunicationSystem} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v processMessagesOn\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:processMessagesOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CommunicationSystem::processMessagesOn ({\b MCHEmul::Computer} *  {\i c}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The method returns a potential additional info to the caller. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Meaning continue.\par
}{
Definition at line {\b 6} of file {\b System.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _communicationChannel\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:_communicationChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PeerCommunicationChannel}* MCHEmul::CommunicationSystem::_communicationChannel{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b System.hpp}.}\par
}
{\xe \v _error\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CommunicationSystem::_error{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b System.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CommunicationSystem::_lastError{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b System.hpp}.}\par
}
{\xe \v _messageBuilder\:MCHEmul::CommunicationSystem}
{\xe \v MCHEmul::CommunicationSystem\:_messageBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MessageBuilder}* MCHEmul::CommunicationSystem::_messageBuilder{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b System.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b System.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/COMMS/{\b System.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::Compiler Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::Compiler}
{\xe \v MCHEmul::Assembler::Compiler}
{\bkmkstart AAAAAAADDA}
{\bkmkend AAAAAAADDA}
\par
{
{\f2 #include <Compiler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Compiler} (const {\b Parser} &p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ByteCode} {\b compile} (const std::string &fN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPU} * {\b cpu} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Errors} {\b errors} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Compiler} just to do the work. \par
The {\b Compiler} is defined for a {\b CPU} too (the same than the {\b Parser}). \par
The {\b Compiler} doesn't own the {\b Parser}. \par
}{
Definition at line {\b 78} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Compiler\:MCHEmul::Assembler::Compiler}
{\xe \v MCHEmul::Assembler::Compiler\:Compiler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Compiler::Compiler (const {\b Parser} &  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADDB}
{\bkmkend AAAAAAADDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v compile\:MCHEmul::Assembler::Compiler}
{\xe \v MCHEmul::Assembler::Compiler\:compile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Assembler::ByteCode} MCHEmul::Assembler::Compiler::compile (const std::string &  {\i fN}) const}}
\par
{\bkmkstart AAAAAAADDC}
{\bkmkend AAAAAAADDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The key method. Generic the Byte Codes to by load and executed. It receives the file with the instructions as parameter. A file with the extension ".act" from the previous one will be looked for. This file could have commands on the code like stop it (break points). \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Action affection the code bytes.\par
}{
Definition at line {\b 105} of file {\b Compiler.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_compiler_a7224e7e11eb49bf5d343df957829c4dd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_compiler_a7224e7e11eb49bf5d343df957829c4dd_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v cpu\:MCHEmul::Assembler::Compiler}
{\xe \v MCHEmul::Assembler::Compiler\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPU} * MCHEmul::Assembler::Compiler::cpu () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADDD}
{\bkmkend AAAAAAADDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b Compiler.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_compiler_a57eb6c63cacf8cea3b4a6bcd3318ae97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v errors\:MCHEmul::Assembler::Compiler}
{\xe \v MCHEmul::Assembler::Compiler\:errors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Errors} MCHEmul::Assembler::Compiler::errors () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADDE}
{\bkmkend AAAAAAADDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b Compiler.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_compiler_aa8fdecee0e6b50215f2f753ef01b61a8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!\:MCHEmul::Assembler::Compiler}
{\xe \v MCHEmul::Assembler::Compiler\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::Compiler::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADDF}
{\bkmkend AAAAAAADDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify checking whether there was or not an error compiling. \par
}{
Definition at line {\b 98} of file {\b Compiler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Compiler.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Compiler.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Computer Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Computer}
{\xe \v MCHEmul::Computer}
{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
\par
{
{\f2 #include <Computer.hpp>}}\par
Inheritance diagram for MCHEmul::Computer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Computer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Clock}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Computer} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Computer} ({\b CPU} *{\b cpu}, const {\b Chips} &c, {\b Memory} *m, const {\b IODevices} &d, unsigned int cs, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Computer} (const {\b Computer} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Computer} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Computer} & {\b operator=} (const {\b Computer} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPU} * {\b cpu} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} * {\b cpu} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Chips} & {\b chips} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsChip} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Chip} * {\b chip} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chip} * {\b chip} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b GraphicalChip} * {\b graphicalChip} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GraphicalChip} * {\b graphicalChip} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Memory} * {\b memory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b memory} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b IODevices} & {\b devices} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsDevice} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b IODevice} * {\b device} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} * {\b device} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b connect} ({\b IOPeripheral} *p, {\b IODevice} *d)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Screen} * {\b screen} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Screen} * {\b screen} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b InputOSSystem} * {\b inputOSSystem} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InputOSSystem} * {\b inputOSSytem} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b cyclesPerSecond} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} & {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b attribute} (const std::string &aN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadInto} (const std::string &fN, const {\b Address} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b run} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b startsCycle} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b runComputerCycle} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b runIOCycle} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b finishCycle} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b exit} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setExit} (bool e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b debugLevel} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDebugLevel} (unsigned int dL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetErrors} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} * {\b _cpu}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chips} {\b _chips}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b _memory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevices} {\b _devices}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} {\b _attributes} = \{ \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _exit}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _debugLevel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Screen} * {\b _screen}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InputOSSystem} * {\b _inputOSSystem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GraphicalChip} * {\b _graphicalChip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clock} {\b _clock}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Computer} &c)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The computer links many different elements. \par
 The computer owns all the elements linked. \par
}{
Definition at line {\b 33} of file {\b Computer.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Computer\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:Computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Computer::Computer (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Computer\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:Computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Computer::Computer ({\b MCHEmul::CPU} *  {\i cpu}, const {\b Chips} &  {\i c}, {\b MCHEmul::Memory} *  {\i m}, const {\b IODevices} &  {\i d}, unsigned int  {\i cs}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}})}}
\par
{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The computer owns the different elements. The devices mandatory are the screen and the InputOSDevice. This is verified at construction level. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spd} \cell }{the number of cycles per second of the clock. \cell }
{\row }
}
}{
Definition at line {\b 6} of file {\b Computer.cpp}.}\par
}
{\xe \v Computer\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:Computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Computer::Computer (const {\b Computer} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Computer\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:~Computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Computer::~Computer (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b Computer.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attribute\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::Computer::attribute (const std::string &  {\i aN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b Computer.hpp}.}\par
}
{\xe \v attributes\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} & MCHEmul::Computer::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b Computer.hpp}.}\par
}
{\xe \v chip\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:chip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Chip} * MCHEmul::Computer::chip (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_ab6841c2842b160846080ddcfb798ad9e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v chip\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:chip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Chip} * MCHEmul::Computer::chip (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_ae99e32e2ebb5bda1c1139da9102d0e1a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v chips\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:chips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Chips} & MCHEmul::Computer::chips () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Computer.hpp}.}\par
}
{\xe \v connect\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Computer::connect ({\b IOPeripheral} *  {\i p}, {\b IODevice} *  {\i d}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To connect a peripheral to a device on the computer. \par
It returns true when it is ok, and false in other circunstance. The way the peripheral is connected will depend on the computer, on the device and on the peripheral itself. \par
}{
Implemented in {\b C64::Commodore64} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v cpu\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU} * MCHEmul::Computer::cpu (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b Computer.hpp}.}\par
}
{\xe \v cpu\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPU} * MCHEmul::Computer::cpu () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Computer.hpp}.}\par
}
{\xe \v cyclesPerSecond\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:cyclesPerSecond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Computer::cyclesPerSecond () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a78b0432c9686150be15c099ba719316c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v debugLevel\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:debugLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Computer::debugLevel () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b Computer.hpp}.}\par
}
{\xe \v device\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IODevice} * MCHEmul::Computer::device (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a2af801eb58860184d2a67e608ac3a45c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v device\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b IODevice} * MCHEmul::Computer::device (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a12264630fee0a6d9a83c9f405a96a45f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v devices\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:devices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b IODevices} & MCHEmul::Computer::devices () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b Computer.hpp}.}\par
}
{\xe \v existsChip\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:existsChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::existsChip (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b Computer.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a66adc31b27b3e8eba56a4d63371baaae_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsDevice\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:existsDevice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::existsDevice (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Computer.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a523ee54dfb5187e4e2aba5a3baad909c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v exit\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::exit () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b Computer.hpp}.}\par
}
{\xe \v finishCycle\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:finishCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::finishCycle (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To indicate that the cycle finishes. \par
}{
Definition at line {\b 131} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a744410e1d92d05c59d3dfa69534d82c0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v graphicalChip\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:graphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GraphicalChip} * MCHEmul::Computer::graphicalChip (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b Computer.hpp}.}\par
}
{\xe \v graphicalChip\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:graphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b GraphicalChip} * MCHEmul::Computer::graphicalChip () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is specifically choosen at construction time. \par
}{
Definition at line {\b 64} of file {\b Computer.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the {\b Computer}, when the "power is set up". \par
 It could be defined per computer. By default it initializes the chips. \par
Returns true, when verything was ok, and false in any other circusntance. \par
The last error happend could then be checked in _lastEerror. \par
}{
Reimplemented in {\b C64::Commodore64} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 59} of file {\b Computer.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_ae2a91c90184f8cf2c5472537a3c552a4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v inputOSSystem\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:inputOSSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b InputOSSystem} * MCHEmul::Computer::inputOSSystem () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b Computer.hpp}.}\par
}
{\xe \v inputOSSytem\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:inputOSSytem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InputOSSystem} * MCHEmul::Computer::inputOSSytem (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b Computer.hpp}.}\par
}
{\xe \v lastError\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Computer::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the last error happend (after initialize or simulate methods). \par
}{
Definition at line {\b 145} of file {\b Computer.hpp}.}\par
}
{\xe \v loadInto\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:loadInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::loadInto (const std::string &  {\i fN}, const {\b Address} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_aa351aeb25e904383dd971086d440878f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_aa351aeb25e904383dd971086d440878f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v memory\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory} * MCHEmul::Computer::memory (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b Computer.hpp}.}\par
}
{\xe \v memory\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Memory} * MCHEmul::Computer::memory () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b Computer.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a8326cd7ead7fb291cfb13938c39ccd7b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Computer} & MCHEmul::Computer::operator= (const {\b Computer} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resetErrors\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:resetErrors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::resetErrors (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b Computer.hpp}.}\par
}
{\xe \v run\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::run ()}}
\par
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate how the computer works. Returns true when finalizing the run ok, and false with error. \par
The parameter is the log level. \par
This method used the other tow defined behind and it can be simulated from outside. \par
}{
Definition at line {\b 107} of file {\b Computer.cpp}.}\par
}
{\xe \v runComputerCycle\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:runComputerCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::runComputerCycle ()}}
\par
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Execute one computer cycle (cpu + chips). \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Max length to tab inst = 16\par
}{
Definition at line {\b 129} of file {\b Computer.cpp}.}\par
}
{\xe \v runIOCycle\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:runIOCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::runIOCycle ()}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Execute the IO Cycle. Returns true when ok, and false when no ok. \par
}{
Definition at line {\b 175} of file {\b Computer.cpp}.}\par
}
{\xe \v screen\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Screen} * MCHEmul::Computer::screen (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Computer.hpp}.}\par
}
{\xe \v screen\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Screen} * MCHEmul::Computer::screen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b Computer.hpp}.}\par
}
{\xe \v setDebugLevel\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:setDebugLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::setDebugLevel (unsigned int  {\i dL}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b Computer.hpp}.}\par
}
{\xe \v setExit\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:setExit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::setExit (bool  {\i e}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b Computer.hpp}.}\par
}
{\xe \v startsCycle\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:startsCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Computer::startsCycle (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To indicate that th loop starts. \par
}{
Definition at line {\b 123} of file {\b Computer.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_computer_a53d2b5b93dafc09f7322fa2bda468507_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Computer} &  {\i c}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _attributes\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} MCHEmul::Computer::_attributes = \{ \}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 187} of file {\b Computer.hpp}.}\par
}
{\xe \v _chips\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_chips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Chips} MCHEmul::Computer::_chips{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 184} of file {\b Computer.hpp}.}\par
}
{\xe \v _clock\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_clock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Clock} MCHEmul::Computer::_clock{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 201} of file {\b Computer.hpp}.}\par
}
{\xe \v _cpu\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU}* MCHEmul::Computer::_cpu{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 183} of file {\b Computer.hpp}.}\par
}
{\xe \v _debugLevel\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_debugLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Computer::_debugLevel{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The level of the debug info. \par
}{
Definition at line {\b 194} of file {\b Computer.hpp}.}\par
}
{\xe \v _devices\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_devices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IODevices} MCHEmul::Computer::_devices{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b Computer.hpp}.}\par
}
{\xe \v _exit\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Computer::_exit{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to to indicate the execution must finishes. There could have been an error or not. \par
}{
Definition at line {\b 191} of file {\b Computer.hpp}.}\par
}
{\xe \v _graphicalChip\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_graphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GraphicalChip}* MCHEmul::Computer::_graphicalChip{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b Computer.hpp}.}\par
}
{\xe \v _inputOSSystem\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_inputOSSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InputOSSystem}* MCHEmul::Computer::_inputOSSystem{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b Computer.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Computer::_lastError{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 197} of file {\b Computer.hpp}.}\par
}
{\xe \v _memory\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory}* MCHEmul::Computer::_memory{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 185} of file {\b Computer.hpp}.}\par
}
{\xe \v _screen\:MCHEmul::Computer}
{\xe \v MCHEmul::Computer\:_screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Screen}* MCHEmul::Computer::_screen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 198} of file {\b Computer.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Computer.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b Computer.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Console::Console Class Reference\par \pard\plain 
{\tc\tcl2 \v Console::Console}
{\xe \v Console::Console}
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
\par
{
{\f2 #include <Console.hpp>}}\par
Collaboration diagram for Console::Console:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_console_1_1_console__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Console} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Console} ({\b Emuls::Emulator} *e, {\b MCHEmul::CommandBuilder} *cB)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Console} (const {\b Console} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Console} & {\b operator=} (const {\b Console} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Console} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b run} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b readCommand} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b readChar} (char &chr) const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Emuls::Emulator} * {\b _emulator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::CommandBuilder} * {\b _commandBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _command}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 21} of file {\b Console.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Console\:Console::Console}
{\xe \v Console::Console\:Console}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Console::Console::Console (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Console\:Console::Console}
{\xe \v Console::Console\:Console}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Console::Console::Console ({\b Emuls::Emulator} *  {\i e}, {\b MCHEmul::CommandBuilder} *  {\i cB})}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b Console.cpp}.}\par
}
{\xe \v Console\:Console::Console}
{\xe \v Console::Console\:Console}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Console::Console::Console (const {\b Console} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Console\:Console::Console}
{\xe \v Console::Console\:~Console}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Console::Console::~Console (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Console.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:Console::Console}
{\xe \v Console::Console\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Console} & Console::Console::operator= (const {\b Console} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v readChar\:Console::Console}
{\xe \v Console::Console\:readChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Console::Console::readChar (char &  {\i chr}) const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The way a character is read from the console is different depending on the OS. \par
The method returns true when a char is read and false in other case. \par
The internal variable chr holds the char code read if any!. \par
}}
{\xe \v readCommand\:Console::Console}
{\xe \v Console::Console\:readCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Console::Console::readCommand (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true when a instruction is ready and false in other case. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
enter key code\par
}{
Definition at line {\b 57} of file {\b Console.cpp}.}\par
}
{\xe \v run\:Console::Console}
{\xe \v Console::Console\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Console::Console::run ()}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
good?\par
possible?\par
}{
Definition at line {\b 13} of file {\b Console.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_console_1_1_console_a4c547bc8af57681f772d2496fe403dd3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _command\:Console::Console}
{\xe \v Console::Console\:_command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Console::Console::_command{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b Console.hpp}.}\par
}
{\xe \v _commandBuilder\:Console::Console}
{\xe \v Console::Console\:_commandBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::CommandBuilder}* Console::Console::_commandBuilder{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b Console.hpp}.}\par
}
{\xe \v _emulator\:Console::Console}
{\xe \v Console::Console\:_emulator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Emuls::Emulator}* Console::Console::_emulator{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b Console.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CONSOLE/{\b Console.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CONSOLE/{\b Console.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Memory::Content Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content}
{\bkmkstart AAAAAAACJJ}
{\bkmkend AAAAAAACJJ}
\par
{
{\f2 #include <Memory.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Content} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Content} (const {\b Content} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Content} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Content} & {\b operator=} (const {\b Content} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b verifyCoherence} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorages} & {\b phisicalStorages} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsPhisicalStorage} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorage} * {\b phisicalStorage} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} * {\b phisicalStorage} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorageSubsets} & {\b Subsets} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsSubset} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorageSubset} * {\b subset} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} * {\b subset} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MemoryViews} & {\b views} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsView} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MemoryView} * {\b view} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} * {\b view} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} * {\b firstView} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b error} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorages} {\b _phisicalStorages}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubsets} {\b _subsets}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryViews} {\b _views}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To content all together the elements a memory is made up of. \par
}{
Definition at line {\b 297} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Content\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:Content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::Content::Content (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJK}
{\bkmkend AAAAAAACJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 300} of file {\b Memory.hpp}.}\par
}
{\xe \v Content\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:Content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::Content::Content (const {\b Content} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACJL}
{\bkmkend AAAAAAACJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Content\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:~Content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::Content::~Content (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACJM}
{\bkmkend AAAAAAACJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v error\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::Content::error () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJN}
{\bkmkend AAAAAAACJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 348} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_aa97578a55f2644664f1538c171995ec2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsPhisicalStorage\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:existsPhisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::Content::existsPhisicalStorage (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJO}
{\bkmkend AAAAAAACJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 316} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_ab0ded3bf026c17a4f9fa9f1383f5a0a5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsSubset\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:existsSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::Content::existsSubset (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJP}
{\bkmkend AAAAAAACJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 326} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a54fd8d0e84f038f5e33173f0f35626ef_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsView\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:existsView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::Content::existsView (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJQ}
{\bkmkend AAAAAAACJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 336} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a51f9541905b8bfa5d96dd335410824de_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v firstView\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:firstView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView} * MCHEmul::Memory::Content::firstView () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJR}
{\bkmkend AAAAAAACJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 343} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_af0cd26f1d85cfad4289f467a883d05b1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::Content::initialize ()}}
\par
{\bkmkstart AAAAAAACJS}
{\bkmkend AAAAAAACJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b Memory.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a1b9e9aecf19d4ac15947ef2b705d350d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Content} & MCHEmul::Memory::Content::operator= (const {\b Content} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACJT}
{\bkmkend AAAAAAACJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v phisicalStorage\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorage} * MCHEmul::Memory::Content::phisicalStorage (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJU}
{\bkmkend AAAAAAACJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 320} of file {\b Memory.hpp}.}\par
}
{\xe \v phisicalStorage\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorage} * MCHEmul::Memory::Content::phisicalStorage (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJV}
{\bkmkend AAAAAAACJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 318} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a7864c52b616a6138c973299e4553abc6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a7864c52b616a6138c973299e4553abc6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v phisicalStorages\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:phisicalStorages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorages} & MCHEmul::Memory::Content::phisicalStorages () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJW}
{\bkmkend AAAAAAACJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 314} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a9723b3d5edd36d58c80e4b2d2135f8c6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subset\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:subset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorageSubset} * MCHEmul::Memory::Content::subset (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJX}
{\bkmkend AAAAAAACJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 330} of file {\b Memory.hpp}.}\par
}
{\xe \v subset\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:subset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorageSubset} * MCHEmul::Memory::Content::subset (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJY}
{\bkmkend AAAAAAACJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 328} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_ad146d8b25735bb142bba8dd7eaf7567c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_ad146d8b25735bb142bba8dd7eaf7567c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Subsets\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:Subsets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorageSubsets} & MCHEmul::Memory::Content::Subsets () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJZ}
{\bkmkend AAAAAAACJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 324} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a076b2e004e6f1375b7fdc386183822c1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v verifyCoherence\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:verifyCoherence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::Content::verifyCoherence () const}}
\par
{\bkmkstart AAAAAAACKA}
{\bkmkend AAAAAAACKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unless this method is executed, the class is always in error (_error = true). \par
}{
Definition at line {\b 259} of file {\b Memory.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a950e6928d22e698878752872319e3009_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v view\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:view}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView} * MCHEmul::Memory::Content::view (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKB}
{\bkmkend AAAAAAACKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 340} of file {\b Memory.hpp}.}\par
}
{\xe \v view\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:view}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MemoryView} * MCHEmul::Memory::Content::view (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKC}
{\bkmkend AAAAAAACKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 338} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_ad14149e8e2342e6dbf02006374380969_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_ad14149e8e2342e6dbf02006374380969_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v views\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:views}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MemoryViews} & MCHEmul::Memory::Content::views () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKD}
{\bkmkend AAAAAAACKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 334} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_1_1_content_a752ac27288c65a515f42d00302fafc5d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _phisicalStorages\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:_phisicalStorages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorages} MCHEmul::Memory::Content::_phisicalStorages}}
\par
{\bkmkstart AAAAAAACKE}
{\bkmkend AAAAAAACKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Can be accesses directly to set them up. \par
}{
Definition at line {\b 352} of file {\b Memory.hpp}.}\par
}
{\xe \v _subsets\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:_subsets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorageSubsets} MCHEmul::Memory::Content::_subsets}}
\par
{\bkmkstart AAAAAAACKF}
{\bkmkend AAAAAAACKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 353} of file {\b Memory.hpp}.}\par
}
{\xe \v _views\:MCHEmul::Memory::Content}
{\xe \v MCHEmul::Memory::Content\:_views}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryViews} MCHEmul::Memory::Content::_views}}
\par
{\bkmkstart AAAAAAACKG}
{\bkmkend AAAAAAACKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 354} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Memory.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b Memory.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::CPU Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::CPU}
{\xe \v MCHEmul::CPU}
{\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
\par
{
{\f2 #include <CPU.hpp>}}\par
Inheritance diagram for MCHEmul::CPU:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::CPU:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} (const {\b CPUArchitecture} &a, const {\b Registers} &r, const {\b StatusRegister} &sR, const {\b Instructions} &ins)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} (const {\b CPU} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} & {\b operator=} (const {\b CPU} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CPU} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPUArchitecture} & {\b architecture} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Registers} & {\b internalRegisters} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsInternalRegister} (size_t nR) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Register} & {\b internalRegister} (size_t nR) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} & {\b internalRegister} (size_t nR)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInternalRegister} (size_t nR, {\b UBytes} v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b ProgramCounter} & {\b programCounter} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} & {\b programCounter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b StatusRegister} & {\b statusRegister} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StatusRegister} & {\b statusRegister} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsInstruction} (unsigned int i) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Instructions} & {\b instructions} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Instruction} * {\b instruction} (unsigned int i) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} * {\b instruction} (unsigned int i)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Instruction} * {\b lastInstruction} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMemoryRef} ({\b Memory} *m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Memory} * {\b memoryRef} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b memoryRef} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b clockCycles} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addClockCycles} (unsigned int cC)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsInterrupt} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPUInterrupt} * {\b interrupt} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUInterrupt} * {\b interrupt} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addInterrupt} ({\b CPUInterrupt} *in)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeInterrrupt} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeNextInstruction} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetErrors} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPUArchitecture} {\b _architecture}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Registers} {\b _registers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Instructions} {\b _instructions} = \{ \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} {\b _programCounter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StatusRegister} {\b _statusRegister}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b _memory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUInterrups} {\b _interrupts}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} * {\b _lastInstruction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _clockCycles}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b CPU} &c)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The center of any Machine. \par
}{
Definition at line {\b 30} of file {\b CPU.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CPU\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:CPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPU::CPU (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CPU\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:CPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPU::CPU (const {\b CPUArchitecture} &  {\i a}, const {\b Registers} &  {\i r}, const {\b StatusRegister} &  {\i sR}, const {\b Instructions} &  {\i ins}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b CPU.hpp}.}\par
}
{\xe \v CPU\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:CPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPU::CPU (const {\b CPU} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~CPU\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:~CPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPU::~CPU (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b CPU.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addClockCycles\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:addClockCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPU::addClockCycles (unsigned int  {\i cC}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b CPU.hpp}.}\par
}
{\xe \v addInterrupt\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:addInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPU::addInterrupt ({\b MCHEmul::CPUInterrupt} *  {\i in})}}
\par
{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b CPU.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_a4b5d8927f8d36409bcb34b07cb99df13_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v architecture\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:architecture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPUArchitecture} & MCHEmul::CPU::architecture () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b CPU.hpp}.}\par
}
{\xe \v clockCycles\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:clockCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CPU::clockCycles () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b CPU.hpp}.}\par
}
{\xe \v executeNextInstruction\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:executeNextInstruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPU::executeNextInstruction ()}}
\par
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To execute the next instruction. \par
}{
Definition at line {\b 52} of file {\b CPU.cpp}.}\par
}
{\xe \v existsInstruction\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:existsInstruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPU::existsInstruction (unsigned int  {\i i}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b CPU.hpp}.}\par
}
{\xe \v existsInternalRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:existsInternalRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPU::existsInternalRegister (size_t  {\i nR}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b CPU.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_a0f3db0544dca669c146de751ca492447_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsInterrupt\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:existsInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPU::existsInterrupt (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To add and remove interrupts. \par
}{
Definition at line {\b 104} of file {\b CPU.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPU::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the {\b CPU}. It could be overloaded later. \par
By default it just initialize registers and program counter to 0. \par
Returns true if everything was ok and false in any other case. \par
}{
Reimplemented in {\b F6500::C6500} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABNX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 14} of file {\b CPU.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_a8184f82008589be3172d94bf68f28253_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v instruction\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Instruction} * MCHEmul::CPU::instruction (unsigned int  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b CPU.hpp}.}\par
}
{\xe \v instruction\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Instruction} * MCHEmul::CPU::instruction (unsigned int  {\i i}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b CPU.hpp}.}\par
}
{\xe \v instructions\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:instructions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Instructions} & MCHEmul::CPU::instructions () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b CPU.hpp}.}\par
}
{\xe \v internalRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:internalRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Register} & MCHEmul::CPU::internalRegister (size_t  {\i nR}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b CPU.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_a47aa6ee1b5bde914c5c48df7a07da948_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v internalRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:internalRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Register} & MCHEmul::CPU::internalRegister (size_t  {\i nR}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b CPU.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_ad232a6b8d848b23bc4542f8dcbe6cd08_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_ad232a6b8d848b23bc4542f8dcbe6cd08_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v internalRegisters\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:internalRegisters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Registers} & MCHEmul::CPU::internalRegisters () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b CPU.hpp}.}\par
}
{\xe \v interrupt\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPUInterrupt} * MCHEmul::CPU::interrupt (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b CPU.hpp}.}\par
}
{\xe \v interrupt\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPUInterrupt} * MCHEmul::CPU::interrupt (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b CPU.hpp}.}\par
}
{\xe \v lastError\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CPU::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the last error happend (after initialize or simulate methods). \par
}{
Definition at line {\b 117} of file {\b CPU.hpp}.}\par
}
{\xe \v lastInstruction\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:lastInstruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Instruction} * MCHEmul::CPU::lastInstruction () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b CPU.hpp}.}\par
}
{\xe \v memoryRef\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:memoryRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory} * MCHEmul::CPU::memoryRef (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b CPU.hpp}.}\par
}
{\xe \v memoryRef\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:memoryRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Memory} * MCHEmul::CPU::memoryRef () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b CPU.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU} & MCHEmul::CPU::operator= (const {\b CPU} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v programCounter\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:programCounter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} & MCHEmul::CPU::programCounter (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b CPU.hpp}.}\par
}
{\xe \v programCounter\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:programCounter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b ProgramCounter} & MCHEmul::CPU::programCounter () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b CPU.hpp}.}\par
}
{\xe \v removeInterrrupt\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:removeInterrrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPU::removeInterrrupt (int  {\i id})}}
\par
{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b CPU.cpp}.}\par
}
{\xe \v resetErrors\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:resetErrors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPU::resetErrors (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b CPU.hpp}.}\par
}
{\xe \v setInternalRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:setInternalRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPU::setInternalRegister (size_t  {\i nR}, {\b UBytes}  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b CPU.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_ab61dbdbe572f9f75b50ce9a11648d769_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setMemoryRef\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:setMemoryRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPU::setMemoryRef ({\b Memory} *  {\i m}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b CPU} is not the owner of the memory, but the computer (just to keep all in the same place) A reference is here given to simplify the execution of transactions. \par
}{
Definition at line {\b 86} of file {\b CPU.hpp}.}\par
}
{\xe \v statusRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:statusRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StatusRegister} & MCHEmul::CPU::statusRegister (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b CPU.hpp}.}\par
}
{\xe \v statusRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:statusRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b StatusRegister} & MCHEmul::CPU::statusRegister () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b CPU.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b CPU} &  {\i c}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _architecture\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_architecture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPUArchitecture} MCHEmul::CPU::_architecture{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \par
            CPUArchitecture (2 , 1 )\par
}
{
Definition at line {\b 125} of file {\b CPU.hpp}.}\par
}
{\xe \v _clockCycles\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_clockCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CPU::_clockCycles{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b CPU.hpp}.}\par
}
{\xe \v _instructions\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_instructions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Instructions} MCHEmul::CPU::_instructions = \{ \}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b CPU.hpp}.}\par
}
{\xe \v _interrupts\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_interrupts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPUInterrups} MCHEmul::CPU::_interrupts{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b CPU.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CPU::_lastError{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b CPU.hpp}.}\par
}
{\xe \v _lastInstruction\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_lastInstruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Instruction}* MCHEmul::CPU::_lastInstruction{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b CPU.hpp}.}\par
}
{\xe \v _memory\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory}* MCHEmul::CPU::_memory{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b CPU.hpp}.}\par
}
{\xe \v _programCounter\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_programCounter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} MCHEmul::CPU::_programCounter{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b CPU.hpp}.}\par
}
{\xe \v _registers\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_registers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Registers} MCHEmul::CPU::_registers{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b CPU.hpp}.}\par
}
{\xe \v _statusRegister\:MCHEmul::CPU}
{\xe \v MCHEmul::CPU\:_statusRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StatusRegister} MCHEmul::CPU::_statusRegister{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b CPU.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b CPU.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b CPU.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::CPUArchitecture Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture}
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
\par
{
{\f2 #include <CPUArchitecture.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUArchitecture} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUArchitecture} (size_t nb, size_t iL, bool bE=true, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUArchitecture} (const {\b CPUArchitecture} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUArchitecture} & {\b operator=} (const {\b CPUArchitecture} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b numberBytes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b numberBits} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b instructionLength} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b bigEndian} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} {\b registerLength} (int id, const std::string &n, size_t nb) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Register} & {\b longestRegisterPossible} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} & {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b attribute} (const std::string &aN) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b CPUArchitecture} &a)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The architecture of {\b CPU} is related usually with the maximum size of its registers in number of bytes. \par
}{
Definition at line {\b 23} of file {\b CPUArchitecture.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CPUArchitecture\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:CPUArchitecture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPUArchitecture::CPUArchitecture (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CPUArchitecture\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:CPUArchitecture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPUArchitecture::CPUArchitecture (size_t  {\i nb}, size_t  {\i iL}, bool  {\i bE} = {\f2 true}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}})}}
\par
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nb} \cell }{Bytes \cell }
{\row }
}
}{
Definition at line {\b 4} of file {\b CPUArchitecture.cpp}.}\par
}
{\xe \v CPUArchitecture\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:CPUArchitecture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPUArchitecture::CPUArchitecture (const {\b CPUArchitecture} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attribute\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::CPUArchitecture::attribute (const std::string &  {\i aN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v attributes\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} & MCHEmul::CPUArchitecture::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAY}
{\bkmkend AAAAAAACAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v bigEndian\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:bigEndian}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPUArchitecture::bigEndian () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAZ}
{\bkmkend AAAAAAACAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v instructionLength\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:instructionLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::CPUArchitecture::instructionLength () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBA}
{\bkmkend AAAAAAACBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v longestRegisterPossible\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:longestRegisterPossible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Register} & MCHEmul::CPUArchitecture::longestRegisterPossible () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBB}
{\bkmkend AAAAAAACBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get a exampla of the longest possible register. It is constant so it would have to be copied once it is got. \par
}{
Definition at line {\b 48} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v numberBits\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:numberBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::CPUArchitecture::numberBits () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBC}
{\bkmkend AAAAAAACBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v numberBytes\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:numberBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::CPUArchitecture::numberBytes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBD}
{\bkmkend AAAAAAACBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b CPUArchitecture.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPUArchitecture} & MCHEmul::CPUArchitecture::operator= (const {\b CPUArchitecture} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v registerLength\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:registerLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Register} MCHEmul::CPUArchitecture::registerLength (int  {\i id}, const std::string &  {\i n}, size_t  {\i nb}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get a register of a specific length only if is possible. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nb} \cell }{Bytes. \cell }
{\row }
}
}{
Definition at line {\b 44} of file {\b CPUArchitecture.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::CPUArchitecture}
{\xe \v MCHEmul::CPUArchitecture\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b CPUArchitecture} &  {\i a}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACBG}
{\bkmkend AAAAAAACBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b CPUArchitecture.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b CPUArchitecture.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::CPUInterrupt Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt}
{\bkmkstart AAAAAAACBH}
{\bkmkend AAAAAAACBH}
\par
{
{\f2 #include <CPUInterrupt.hpp>}}\par
Inheritance diagram for MCHEmul::CPUInterrupt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_interrupt__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUInterrupt} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUInterrupt} (int {\b id})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUInterrupt} (const {\b CPUInterrupt} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CPUInterrupt} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPUInterrupt} & {\b operator=} (const {\b CPUInterrupt} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b active} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setActive} (bool a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOver} ({\b CPU} *c, unsigned int &nC)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isTime} ({\b CPU} *c) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b executeOverImpl} ({\b CPU} *c, unsigned int &nC)=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _active}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastClockCyclesExecuted}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A {\b CPU} Interrupt is something that is able to stop the normal progress of the {\b CPU} execution. \par
}{
Definition at line {\b 24} of file {\b CPUInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CPUInterrupt\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:CPUInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPUInterrupt::CPUInterrupt (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACBI}
{\bkmkend AAAAAAACBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CPUInterrupt\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:CPUInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPUInterrupt::CPUInterrupt (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBJ}
{\bkmkend AAAAAAACBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b CPUInterrupt.hpp}.}\par
}
{\xe \v CPUInterrupt\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:CPUInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::CPUInterrupt::CPUInterrupt (const {\b CPUInterrupt} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACBK}
{\bkmkend AAAAAAACBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~CPUInterrupt\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:~CPUInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::CPUInterrupt::~CPUInterrupt (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACBL}
{\bkmkend AAAAAAACBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b CPUInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v active\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:active}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPUInterrupt::active () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBM}
{\bkmkend AAAAAAACBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b CPUInterrupt.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_interrupt_a9c0b786704f32e5792655f2957ce2a02_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v executeOver\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:executeOver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPUInterrupt::executeOver ({\b MCHEmul::CPU} *  {\i c}, unsigned int &  {\i nC})}}
\par
{\bkmkstart AAAAAAACBN}
{\bkmkend AAAAAAACBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Receive the {\b CPU} the interrupts works for. \par
It receives also a reference to a variable where to load the number of cycles it took the execution (when the return was ok). \par
It returns true if ok and false if not. \par
}{
Definition at line {\b 5} of file {\b CPUInterrupt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_interrupt_a980546c52700b37009e63c2f06f5f811_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v executeOverImpl\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:executeOverImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::CPUInterrupt::executeOverImpl ({\b CPU} *  {\i c}, unsigned int &  {\i nC}){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To really execute the interrupt. \par
 This must be overloaded by the real interrupt. \par
}{
Implemented in {\b F6500::IRQInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQB \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b F6500::NMIInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_interrupt_afb047a77c7a1238f6265b57e2dfeb466_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v id\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::CPUInterrupt::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBO}
{\bkmkend AAAAAAACBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b CPUInterrupt.hpp}.}\par
}
{\xe \v isTime\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:isTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::CPUInterrupt::isTime ({\b CPU} *  {\i c}) const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To determine whether it is the time to execute the interruption. \par
}{
Implemented in {\b F6500::IRQInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQD \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b F6500::NMIInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_c_p_u_interrupt_aa4dcc99a3820c31daa896be875667af4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPUInterrupt} & MCHEmul::CPUInterrupt::operator= (const {\b CPUInterrupt} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACBP}
{\bkmkend AAAAAAACBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setActive\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:setActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::CPUInterrupt::setActive (bool  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBQ}
{\bkmkend AAAAAAACBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b CPUInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _active\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:_active}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::CPUInterrupt::_active{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACBR}
{\bkmkend AAAAAAACBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b CPUInterrupt.hpp}.}\par
}
{\xe \v _id\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::CPUInterrupt::_id{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACBS}
{\bkmkend AAAAAAACBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b CPUInterrupt.hpp}.}\par
}
{\xe \v _lastClockCyclesExecuted\:MCHEmul::CPUInterrupt}
{\xe \v MCHEmul::CPUInterrupt\:_lastClockCyclesExecuted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::CPUInterrupt::_lastClockCyclesExecuted{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACBT}
{\bkmkend AAAAAAACBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b CPUInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b CPUInterrupt.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b CPUInterrupt.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::CPX_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::CPX_General}
{\xe \v F6500::CPX_General}
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::CPX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_p_x___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::CPX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_p_x___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPX_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CPX_General}: To aggregate common steps in every CPX instruction. \par
}{
Definition at line {\b 224} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CPX_General\:F6500::CPX_General}
{\xe \v F6500::CPX_General\:CPX_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::CPX_General::CPX_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 227} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::CPX_General}
{\xe \v F6500::CPX_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::CPX_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 byte long\par
}{
Definition at line {\b 5} of file {\b CPX.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_p_x___general_a8415351b6b47afd66feed3883f63279f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b CPX.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::CPY_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::CPY_General}
{\xe \v F6500::CPY_General}
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::CPY_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_p_y___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::CPY_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_p_y___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPY_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CPY_General}: To aggregate common steps in every CPY instruction. \par
}{
Definition at line {\b 241} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CPY_General\:F6500::CPY_General}
{\xe \v F6500::CPY_General\:CPY_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::CPY_General::CPY_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 244} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::CPY_General}
{\xe \v F6500::CPY_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::CPY_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 byte long\par
}{
Definition at line {\b 5} of file {\b CPY.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_c_p_y___general_a450afe3aba6cc979b10379d19fcc0917_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b CPY.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::DEC_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::DEC_General}
{\xe \v F6500::DEC_General}
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::DEC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_d_e_c___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::DEC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_d_e_c___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DEC_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b DEC_General}: To aggregate common steps in every DEC instruction. \par
}{
Definition at line {\b 258} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DEC_General\:F6500::DEC_General}
{\xe \v F6500::DEC_General\:DEC_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::DEC_General::DEC_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 261} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::DEC_General}
{\xe \v F6500::DEC_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::DEC_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b DEC.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_d_e_c___general_aed69fbc608f5bdc91bd482a1e38bfcf6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b DEC.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Emuls::Emulator Class Reference\par \pard\plain 
{\tc\tcl2 \v Emuls::Emulator}
{\xe \v Emuls::Emulator}
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
\par
{
{\f2 #include <Emulator.hpp>}}\par
Inheritance diagram for Emuls::Emulator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for Emuls::Emulator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MapOfActions} = std::map< {\b MCHEmul::Address}, unsigned int >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Emulator} (const std::vector< std::string > &argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Emulator} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MCHEmul::Attributes} & {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MCHEmul::Computer} * {\b computer} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Computer} * {\b computer} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCommunicationSystem} ({\b MCHEmul::CommunicationSystem} *cS)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b byteFileName} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asmFileName} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b logLevel} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b startingAddress} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b debugLevel} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDebugLevel} (unsigned int dL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setActions} (const {\b MapOfActions} &at)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addAction} (const {\b MCHEmul::Address} &at, unsigned int a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeAction} (const {\b MCHEmul::Address} &at)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b connectPeripheral} (int id, const {\b MCHEmul::Attributes} &prms, {\b MCHEmul::IODevice} *d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b run} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b runCycle} (unsigned int a=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _PARAMBYTEFILE} = 'f'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const std::string {\b _BYTEFILE} = "BYTEFILE"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _PARAMASMFILE} = 'c'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const std::string {\b _ASMFILE} = "ASMFILE"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _PARAMLOGLEVEL} = 'l'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const std::string {\b _LOGLEVEL} = "LOGLEVEL"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _PARAMADDRESS} = 'a'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const std::string {\b _ADDRESS} = "ADDRESS"\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MCHEmul::IOPeripheralBuilder} * {\b peripherialBuilder} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::IOPeripheralBuilder} * {\b peripherialBuilder} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b executeAction} (unsigned int &lA, unsigned int at, unsigned int a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b additionalRunCycle} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::Computer} * {\b createComputer} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::IOPeripheralBuilder} * {\b createPeripheralBuilder} () const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Attributes} {\b _attributes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::CommunicationSystem} * {\b _communicationSystem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _debugLevel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< {\b MCHEmul::Address}, unsigned int > {\b _actionsAt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Computer} * {\b _computer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::IOPeripheralBuilder} * {\b _peripheralBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _running}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastAction}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 24} of file {\b Emulator.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v MapOfActions\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:MapOfActions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Emuls::Emulator::MapOfActions} =  std::map <{\b MCHEmul::Address}, unsigned int>}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b Emulator.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Emulator\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:Emulator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Emuls::Emulator::Emulator (const std::vector< std::string > &  {\i argv})}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor: {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argc} \cell }{: N\'FAmero de par\'E1metros. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argv} \cell }{: The parameters. The basic parameters for any emulator are: \par
/fFILENAME : bytes file (with path) to be loaded into the memory. /cFILENAME : ASM file (with path) to be parsed, compiled and loadd into the memory. /lLEVEL : To print out logs. /aADDRESS : The address where to start the execution of the emulator. \cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
param 0 = name of the executable\par
}{
Definition at line {\b 15} of file {\b Emulator.cpp}.}\par
}
{\xe \v ~Emulator\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:~Emulator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Emuls::Emulator::~Emulator (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b Emulator.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addAction\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:addAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Emuls::Emulator::addAction (const {\b MCHEmul::Address} &  {\i at}, unsigned int  {\i a})}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To manage them individually. \par
}{
Definition at line {\b 72} of file {\b Emulator.cpp}.}\par
}
{\xe \v additionalRunCycle\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:additionalRunCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Emuls::Emulator::additionalRunCycle (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An exit method that can hold specific code needed per cycle and per type of emulator. By default it does nothing. \par
}{
Reimplemented in {\b Emuls::C64Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABEY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 143} of file {\b Emulator.hpp}.}\par
}
{\xe \v asmFileName\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:asmFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Emuls::Emulator::asmFileName () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know whether there is an ASM file where data to be loaded. "" when there is no ASM file data. \par
}{
Definition at line {\b 72} of file {\b Emulator.hpp}.}\par
}
{\xe \v attributes\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::Attributes} & Emuls::Emulator::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b Emulator.hpp}.}\par
}
{\xe \v byteFileName\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:byteFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Emuls::Emulator::byteFileName () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know whether there is a byte file where data to be loaded. \par
"" when there is no byte file data. \par
}{
Definition at line {\b 66} of file {\b Emulator.hpp}.}\par
}
{\xe \v computer\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Computer} * Emuls::Emulator::computer (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a469c363da0b7f3bae69211a90c12371a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v computer\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::Computer} * Emuls::Emulator::computer () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_af7eae1eb535a9539d1e6b11c3f28bcd4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_af7eae1eb535a9539d1e6b11c3f28bcd4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v connectPeripheral\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:connectPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::Emulator::connectPeripheral (int  {\i id}, const {\b MCHEmul::Attributes} &  {\i prms}, {\b MCHEmul::IODevice} *  {\i d}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a716f074ddd49d290162f1220dcdd19b1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v createComputer\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:createComputer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::Computer} * Emuls::Emulator::createComputer () const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create the right version of the computer, attending the parameters received by the constructor. \par
}{
Implemented in {\b Emuls::C64Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABFA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_ac32f27fbb6f8a20b54a1bfa0098c6247_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v createPeripheralBuilder\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:createPeripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MCHEmul::IOPeripheralBuilder} * Emuls::Emulator::createPeripheralBuilder () const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create the right version of the Peripheral Builder. \par
}{
Implemented in {\b Emuls::C64Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABFC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_acd5f251736a6eafede84ab397ed46629_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v debugLevel\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:debugLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Emuls::Emulator::debugLevel () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Emulator.hpp}.}\par
}
{\xe \v executeAction\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:executeAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::Emulator::executeAction (unsigned int &  {\i lA}, unsigned int  {\i at}, unsigned int  {\i a}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In the method runCycle, before executing the cycle related to the computer (cpu + chips), this method is invoked. \par
The parameters passed through are: "lA" is the last action executed (if any), "at" is the action associated to the point where the program counter is now at, and "a" is the action parameter received by the method itself. \par
A potential "like a" parameter received through the communication system (if active and if any) is also taken into account. However the parameter "a" received by the method has priority. With these three/four variables this method should do whatever is requires and decide whether execute the cycle of the computer (true) or not (return false). \par
It can be overloaded for specific pruposes. \par
During the execution of the method the firt parameter (lastAction) can be modified. \par
}{
Definition at line {\b 213} of file {\b Emulator.cpp}.}\par
}
{\xe \v initialize\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::Emulator::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the emulator. \par
}{
Reimplemented in {\b Emuls::C64Emulator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABFE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 88} of file {\b Emulator.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_aabf769cc18ca5a5ed67f6dcfa5897fde_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_aabf769cc18ca5a5ed67f6dcfa5897fde_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v lastError\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Emuls::Emulator::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b Emulator.hpp}.}\par
}
{\xe \v logLevel\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:logLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Emuls::Emulator::logLevel () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know the level of the log. 0 means no log. \par
}{
Definition at line {\b 78} of file {\b Emulator.hpp}.}\par
}
{\xe \v operator!\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::Emulator::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b Emulator.hpp}.}\par
}
{\xe \v peripherialBuilder\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:peripherialBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::IOPeripheralBuilder} * Emuls::Emulator::peripherialBuilder (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a4d9b31c092cab6a4c88613889a7bb451_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v peripherialBuilder\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:peripherialBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::IOPeripheralBuilder} * Emuls::Emulator::peripherialBuilder () const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a9afb486d4f3cabd7d9155066bf529eac_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a9afb486d4f3cabd7d9155066bf529eac_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v removeAction\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:removeAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Emuls::Emulator::removeAction (const {\b MCHEmul::Address} &  {\i at})}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b Emulator.cpp}.}\par
}
{\xe \v run\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::Emulator::run ()}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
True when finishes ok, false when no ok. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
no action.\par
}{
Definition at line {\b 166} of file {\b Emulator.cpp}.}\par
}
{\xe \v runCycle\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:runCycle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::Emulator::runCycle (unsigned int  {\i a} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Execute just one cycle. The method can receive an action that can affect the execution of the compuer cycle. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Priority.\par
something?\par
}{
Definition at line {\b 182} of file {\b Emulator.cpp}.}\par
}
{\xe \v setActions\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:setActions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Emuls::Emulator::setActions (const {\b MapOfActions} &  {\i at}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set a couple of them. \par
}{
Definition at line {\b 97} of file {\b Emulator.hpp}.}\par
}
{\xe \v setCommunicationSystem\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:setCommunicationSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Emuls::Emulator::setCommunicationSystem ({\b MCHEmul::CommunicationSystem} *  {\i cS})}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not possible to change when running. \par
}{
Definition at line {\b 51} of file {\b Emulator.cpp}.}\par
}
{\xe \v setDebugLevel\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:setDebugLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Emuls::Emulator::setDebugLevel (unsigned int  {\i dL}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a4c73b0ae4c901030277a83413c08e855_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a4c73b0ae4c901030277a83413c08e855_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v startingAddress\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:startingAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} Emuls::Emulator::startingAddress () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know the address where to start the execution from. \par
0x00 when no address has been defined. \par
}{
Definition at line {\b 85} of file {\b Emulator.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_emuls_1_1_emulator_a59bf87811004c1b9cb5090c64b9e8e86_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _actionsAt\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_actionsAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<{\b MCHEmul::Address}, unsigned int> Emuls::Emulator::_actionsAt{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b Emulator.hpp}.}\par
}
{\xe \v _ADDRESS\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string Emuls::Emulator::_ADDRESS = "ADDRESS"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b Emulator.hpp}.}\par
}
{\xe \v _ASMFILE\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_ASMFILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string Emuls::Emulator::_ASMFILE = "ASMFILE"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b Emulator.hpp}.}\par
}
{\xe \v _attributes\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Attributes} Emuls::Emulator::_attributes{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defined in the constructor. \par
}{
Definition at line {\b 156} of file {\b Emulator.hpp}.}\par
}
{\xe \v _BYTEFILE\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_BYTEFILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string Emuls::Emulator::_BYTEFILE = "BYTEFILE"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b Emulator.hpp}.}\par
}
{\xe \v _communicationSystem\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_communicationSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::CommunicationSystem}* Emuls::Emulator::_communicationSystem{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b Emulator.hpp}.}\par
}
{\xe \v _computer\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_computer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Computer}* Emuls::Emulator::_computer{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b Emulator.hpp}.}\par
}
{\xe \v _debugLevel\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_debugLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Emuls::Emulator::_debugLevel{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b Emulator.hpp}.}\par
}
{\xe \v _lastAction\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_lastAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Emuls::Emulator::_lastAction{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b Emulator.hpp}.}\par
}
{\xe \v _lastError\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Emuls::Emulator::_lastError{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b Emulator.hpp}.}\par
}
{\xe \v _LOGLEVEL\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_LOGLEVEL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string Emuls::Emulator::_LOGLEVEL = "LOGLEVEL"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b Emulator.hpp}.}\par
}
{\xe \v _PARAMADDRESS\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_PARAMADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char Emuls::Emulator::_PARAMADDRESS = 'a'{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b Emulator.hpp}.}\par
}
{\xe \v _PARAMASMFILE\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_PARAMASMFILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char Emuls::Emulator::_PARAMASMFILE = 'c'{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b Emulator.hpp}.}\par
}
{\xe \v _PARAMBYTEFILE\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_PARAMBYTEFILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char Emuls::Emulator::_PARAMBYTEFILE = 'f'{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The possible parameters of the {\b Emulator}. \par
}{
Definition at line {\b 28} of file {\b Emulator.hpp}.}\par
}
{\xe \v _PARAMLOGLEVEL\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_PARAMLOGLEVEL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char Emuls::Emulator::_PARAMLOGLEVEL = 'l'{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Emulator.hpp}.}\par
}
{\xe \v _peripheralBuilder\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_peripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::IOPeripheralBuilder}* Emuls::Emulator::_peripheralBuilder{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 163} of file {\b Emulator.hpp}.}\par
}
{\xe \v _running\:Emuls::Emulator}
{\xe \v Emuls::Emulator\:_running}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Emuls::Emulator::_running{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b Emulator.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/EMULATORS/{\b Emulator.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/EMULATORS/{\b Emulator.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::EOR_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::EOR_General}
{\xe \v F6500::EOR_General}
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::EOR_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_e_o_r___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::EOR_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_e_o_r___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EOR_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b EOR_General}: To aggregate common steps in every EOR instruction. \par
}{
Definition at line {\b 282} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EOR_General\:F6500::EOR_General}
{\xe \v F6500::EOR_General\:EOR_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::EOR_General::EOR_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 285} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::EOR_General}
{\xe \v F6500::EOR_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::EOR_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b EOR.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_e_o_r___general_a7b91db5db3b2999707039825edc6230a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b EOR.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::Error Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error}
{\bkmkstart AAAAAAADDG}
{\bkmkend AAAAAAADDG}
\par
{
{\f2 #include <Error.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Error} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Error} ({\b ErrorType} eT, const std::string &f, unsigned int l, unsigned int c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Error} (const {\b Error} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Error} & {\b operator=} (const {\b Error} &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ErrorType} {\b _type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _file}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _line}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _column}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Error} &e)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The error class. \par
}{
Definition at line {\b 48} of file {\b Error.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Error\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:Error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Error::Error (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADDH}
{\bkmkend AAAAAAADDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Error.hpp}.}\par
}
{\xe \v Error\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:Error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Error::Error ({\b ErrorType}  {\i eT}, const std::string &  {\i f}, unsigned int  {\i l}, unsigned int  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADDI}
{\bkmkend AAAAAAADDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b Error.hpp}.}\par
}
{\xe \v Error\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:Error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Error::Error (const {\b Error} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADDJ}
{\bkmkend AAAAAAADDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Error} & MCHEmul::Assembler::Error::operator= (const {\b Error} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADDK}
{\bkmkend AAAAAAADDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Error} &  {\i e}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADDL}
{\bkmkend AAAAAAADDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _column\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:_column}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Assembler::Error::_column}}
\par
{\bkmkstart AAAAAAADDM}
{\bkmkend AAAAAAADDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b Error.hpp}.}\par
}
{\xe \v _file\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Assembler::Error::_file}}
\par
{\bkmkstart AAAAAAADDN}
{\bkmkend AAAAAAADDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b Error.hpp}.}\par
}
{\xe \v _line\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:_line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Assembler::Error::_line}}
\par
{\bkmkstart AAAAAAADDO}
{\bkmkend AAAAAAADDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b Error.hpp}.}\par
}
{\xe \v _type\:MCHEmul::Assembler::Error}
{\xe \v MCHEmul::Assembler::Error\:_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ErrorType} MCHEmul::Assembler::Error::_type}}
\par
{\bkmkstart AAAAAAADDP}
{\bkmkend AAAAAAADDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b Error.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Error.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UInt::FormatManager Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager}
{\bkmkstart AAAAAAACZK}
{\bkmkend AAAAAAACZK}
\par
{
{\f2 #include <UInt.hpp>}}\par
Inheritance diagram for MCHEmul::UInt::FormatManager:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_format_manager__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FormatManager} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b add} (const {\b UInt} &, const {\b UInt} &, bool) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b substract} (const {\b UInt} &, const {\b UInt} &, bool) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b asUnsignedInt} (const {\b UInt} &) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b fromUnsignedInt} (unsigned int n)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b fromInt} (int n)=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is accountable for managing aspects specifically related with the format of a number. \par
}{
Definition at line {\b 38} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v FormatManager\:MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager\:FormatManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::FormatManager::FormatManager (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACZL}
{\bkmkend AAAAAAACZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add\:MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::FormatManager::add (const {\b UInt} & , const {\b UInt} & , bool ) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACZB}
{\bkmkend AAAAAAACZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The way the add is executed depends on the format. \par
}{
Implemented in {\b MCHEmul::UInt::BinaryFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZA \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::UInt::PackagedBCDFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v asUnsignedInt\:MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager\:asUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual unsigned int MCHEmul::UInt::FormatManager::asUnsignedInt (const {\b UInt} & ) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACZD}
{\bkmkend AAAAAAACZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b MCHEmul::UInt::BinaryFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZC \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::UInt::PackagedBCDFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v fromInt\:MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager\:fromInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::FormatManager::fromInt (int  {\i n}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACZF}
{\bkmkend AAAAAAACZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b MCHEmul::UInt::BinaryFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZE \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::UInt::PackagedBCDFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v fromUnsignedInt\:MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager\:fromUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::FormatManager::fromUnsignedInt (unsigned int  {\i n}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACZH}
{\bkmkend AAAAAAACZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b MCHEmul::UInt::BinaryFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZG \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::UInt::PackagedBCDFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v substract\:MCHEmul::UInt::FormatManager}
{\xe \v MCHEmul::UInt::FormatManager\:substract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b UInt} MCHEmul::UInt::FormatManager::substract (const {\b UInt} & , const {\b UInt} & , bool ) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACZJ}
{\bkmkend AAAAAAACZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The same for substracting. \par
}{
Implemented in {\b MCHEmul::UInt::BinaryFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZI \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::UInt::PackagedBCDFormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UInt.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UInt::FormatManagers Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UInt::FormatManagers}
{\xe \v MCHEmul::UInt::FormatManagers}
{\bkmkstart AAAAAAACZR}
{\bkmkend AAAAAAACZR}
\par
{
{\f2 #include <UInt.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FormatManagers} (const std::map< unsigned char, {\b FormatManager} * > &fM)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~FormatManagers} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< unsigned char, {\b FormatManager} * > {\b _formatManagers}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create and destroy the format managers. There can only be onky one instance of this class!. \par
}{
Definition at line {\b 89} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v FormatManagers\:MCHEmul::UInt::FormatManagers}
{\xe \v MCHEmul::UInt::FormatManagers\:FormatManagers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::FormatManagers::FormatManagers (const std::map< unsigned char, {\b FormatManager} * > &  {\i fM}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACZS}
{\bkmkend AAAAAAACZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the formates used, Only one instance can exists. \par
}{
Definition at line {\b 93} of file {\b UInt.hpp}.}\par
}
{\xe \v ~FormatManagers\:MCHEmul::UInt::FormatManagers}
{\xe \v MCHEmul::UInt::FormatManagers\:~FormatManagers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::FormatManagers::~FormatManagers (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACZT}
{\bkmkend AAAAAAACZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _formatManagers\:MCHEmul::UInt::FormatManagers}
{\xe \v MCHEmul::UInt::FormatManagers\:_formatManagers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<unsigned char, {\b FormatManager}*> MCHEmul::UInt::FormatManagers::_formatManagers}}
\par
{\bkmkstart AAAAAAACZU}
{\bkmkend AAAAAAACZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It can be accessed from anyplace. \par
So other formaters can be added later if needed. \par
}{
Definition at line {\b 103} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UInt.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b UInt.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::GetMemoryDataMessage Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::GetMemoryDataMessage}
{\xe \v MCHEmul::GetMemoryDataMessage}
{\bkmkstart AAAAAAACBU}
{\bkmkend AAAAAAACBU}
\par
{
{\f2 #include <StdMessages.hpp>}}\par
Inheritance diagram for MCHEmul::GetMemoryDataMessage:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_get_memory_data_message__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::GetMemoryDataMessage:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_get_memory_data_message__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GetMemoryDataMessage} (const {\b Attributes} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b executeOn} ({\b Computer} *c, {\b CommunicationMessage} *&ans) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _ID} = 'B'\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A message to get the data of the memory. \par
}{
Definition at line {\b 47} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GetMemoryDataMessage\:MCHEmul::GetMemoryDataMessage}
{\xe \v MCHEmul::GetMemoryDataMessage\:GetMemoryDataMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::GetMemoryDataMessage::GetMemoryDataMessage (const {\b Attributes} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBV}
{\bkmkend AAAAAAACBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:MCHEmul::GetMemoryDataMessage}
{\xe \v MCHEmul::GetMemoryDataMessage\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::GetMemoryDataMessage::executeOn ({\b Computer} * , {\b CommunicationMessage} *& ){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very important method. \par
This method execute what was required from the computer. \par
It must be overloaded per any specific behaviour. \par
The communication message can have an answer, and it is given in the second parameter. The method returns a number than can be additional info for the invoker. NOTE that Default result should be 0 meaning "No additional info for invoker". \par
}{
Implements {\b MCHEmul::CommunicationMessage} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 38} of file {\b StdMessages.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:MCHEmul::GetMemoryDataMessage}
{\xe \v MCHEmul::GetMemoryDataMessage\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::GetMemoryDataMessage::_ID = 'B'{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBW}
{\bkmkend AAAAAAACBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b StdMessages.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/COMMS/{\b StdMessages.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::GetRegisterStatusMessage Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::GetRegisterStatusMessage}
{\xe \v MCHEmul::GetRegisterStatusMessage}
{\bkmkstart AAAAAAACBX}
{\bkmkend AAAAAAACBX}
\par
{
{\f2 #include <StdMessages.hpp>}}\par
Inheritance diagram for MCHEmul::GetRegisterStatusMessage:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_get_register_status_message__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::GetRegisterStatusMessage:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_get_register_status_message__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GetRegisterStatusMessage} (const {\b Attributes} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b executeOn} ({\b Computer} *c, {\b CommunicationMessage} *&ans) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _ID} = 'A'\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A message to get the status of the internal registers. \par
}{
Definition at line {\b 34} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GetRegisterStatusMessage\:MCHEmul::GetRegisterStatusMessage}
{\xe \v MCHEmul::GetRegisterStatusMessage\:GetRegisterStatusMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::GetRegisterStatusMessage::GetRegisterStatusMessage (const {\b Attributes} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBY}
{\bkmkend AAAAAAACBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:MCHEmul::GetRegisterStatusMessage}
{\xe \v MCHEmul::GetRegisterStatusMessage\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::GetRegisterStatusMessage::executeOn ({\b Computer} * , {\b CommunicationMessage} *& ){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very important method. \par
This method execute what was required from the computer. \par
It must be overloaded per any specific behaviour. \par
The communication message can have an answer, and it is given in the second parameter. The method returns a number than can be additional info for the invoker. NOTE that Default result should be 0 meaning "No additional info for invoker". \par
}{
Implements {\b MCHEmul::CommunicationMessage} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 30} of file {\b StdMessages.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:MCHEmul::GetRegisterStatusMessage}
{\xe \v MCHEmul::GetRegisterStatusMessage\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::GetRegisterStatusMessage::_ID = 'A'{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBZ}
{\bkmkend AAAAAAACBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b StdMessages.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/COMMS/{\b StdMessages.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::GrammaticalElement Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement}
{\bkmkstart AAAAAAADDQ}
{\bkmkend AAAAAAADDQ}
\par
{
{\f2 #include <Grammar.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::GrammaticalElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_grammatical_element__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::GrammaticalElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_grammatical_element__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Type} \{ {\b _LABEL} = 0
, {\b _BYTESINMEMORY}
, {\b _INSTRUCTION}
, {\b _STARTINGPOINT}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GrammaticalElement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GrammaticalElement} (const {\b GrammaticalElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GrammaticalElement} & {\b operator=} (const {\b GrammaticalElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GrammaticalElement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b size} (const {\b Semantic} *s) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b codeBytes} (const {\b Semantic} *s, bool bE=true) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Address} {\b address} (const {\b MCHEmul::Assembler::Semantic} *s) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ErrorType} {\b error} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Type} {\b _type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _line}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _actionOn}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GrammaticalElement} * {\b _nextElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GrammaticalElement} * {\b _previousElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ErrorType} {\b _error}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::vector< {\b UByte} > {\b calculateCodeBytes} (const {\b Semantic} *s, bool bE=true) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b bytesFromExpression} (const std::string &e, const {\b Macros} &ms, bool &er) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b _codeBytes}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 101} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Type\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MCHEmul::Assembler::GrammaticalElement::Type}}}
\par
{\bkmkstart AAAAAAADDR}
{\bkmkend AAAAAAADDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _LABEL\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_LABEL}
{\qr _LABEL{\bkmkstart AAAAAAADDS}
{\bkmkend AAAAAAADDS}
\cell }{\cell }{\row }
{\xe \v _BYTESINMEMORY\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_BYTESINMEMORY}
{\qr _BYTESINMEMORY{\bkmkstart AAAAAAADDT}
{\bkmkend AAAAAAADDT}
\cell }{\cell }{\row }
{\xe \v _INSTRUCTION\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_INSTRUCTION}
{\qr _INSTRUCTION{\bkmkstart AAAAAAADDU}
{\bkmkend AAAAAAADDU}
\cell }{\cell }{\row }
{\xe \v _STARTINGPOINT\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_STARTINGPOINT}
{\qr _STARTINGPOINT{\bkmkstart AAAAAAADDV}
{\bkmkend AAAAAAADDV}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 103} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GrammaticalElement\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:GrammaticalElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::GrammaticalElement::GrammaticalElement (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADDW}
{\bkmkend AAAAAAADDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b Grammar.hpp}.}\par
}
{\xe \v GrammaticalElement\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:GrammaticalElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::GrammaticalElement::GrammaticalElement (const {\b GrammaticalElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADDX}
{\bkmkend AAAAAAADDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~GrammaticalElement\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:~GrammaticalElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::Assembler::GrammaticalElement::~GrammaticalElement (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADDY}
{\bkmkend AAAAAAADDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Chained.\par
}{
Definition at line {\b 115} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v address\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} MCHEmul::Assembler::GrammaticalElement::address (const {\b MCHEmul::Assembler::Semantic} *  {\i s}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADDZ}
{\bkmkend AAAAAAADDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know the address of the grammatical element. \par
}{
Reimplemented in {\b MCHEmul::Assembler::StartingPointElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADEA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 64} of file {\b Grammar.cpp}.}\par
}
{\xe \v bytesFromExpression\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:bytesFromExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b MCHEmul::UByte} > MCHEmul::Assembler::GrammaticalElement::bytesFromExpression (const std::string &  {\i e}, const {\b Macros} &  {\i ms}, bool &  {\i er}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADEB}
{\bkmkend AAAAAAADEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
No name needed.\par
}{
Definition at line {\b 84} of file {\b Grammar.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_grammatical_element_a9fcde13cb4ce5ec4d890a8787b893e78_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v calculateCodeBytes\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:calculateCodeBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::vector< {\b UByte} > MCHEmul::Assembler::GrammaticalElement::calculateCodeBytes (const {\b Semantic} *  {\i s}, bool  {\i bE} = {\f2 true}) const{\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADEC}
{\bkmkend AAAAAAADEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To calculat the codeBytes first time. \par
}{
Definition at line {\b 156} of file {\b Grammar.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_grammatical_element_a3b8814ee95bdada6b97bc76f3086aa44_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v codeBytes\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:codeBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b UByte} > MCHEmul::Assembler::GrammaticalElement::codeBytes (const {\b Semantic} *  {\i s}, bool  {\i bE} = {\f2 true}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADED}
{\bkmkend AAAAAAADED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the value of the grammatical element (if makes sense) as a set of executable bytes. The value is get taking into account a semantic. \par
When using this method errors could be generated. \par
}{
Definition at line {\b 126} of file {\b Grammar.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_grammatical_element_a0b0f68836d3b7e183e9a64295d484f24_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_grammatical_element_a0b0f68836d3b7e183e9a64295d484f24_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v error\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ErrorType} MCHEmul::Assembler::GrammaticalElement::error () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADEE}
{\bkmkend AAAAAAADEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b Grammar.hpp}.}\par
}
{\xe \v operator!\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::GrammaticalElement::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADEF}
{\bkmkend AAAAAAADEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To visually simplify the way the error system is managed. \par
}{
Definition at line {\b 136} of file {\b Grammar.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GrammaticalElement} & MCHEmul::Assembler::GrammaticalElement::operator= (const {\b GrammaticalElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADEG}
{\bkmkend AAAAAAADEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual size_t MCHEmul::Assembler::GrammaticalElement::size (const {\b Semantic} *  {\i s}) const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADEH}
{\bkmkend AAAAAAADEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the size of the grammatical element in bytes. By default the bytes are calculated and then the size. \par
}{
Reimplemented in {\b MCHEmul::Assembler::InstructionElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADEI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 120} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _actionOn\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_actionOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Assembler::GrammaticalElement::_actionOn}}
\par
{\bkmkstart AAAAAAADEJ}
{\bkmkend AAAAAAADEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b Grammar.hpp}.}\par
}
{\xe \v _codeBytes\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_codeBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b UByte}> MCHEmul::Assembler::GrammaticalElement::_codeBytes{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADEK}
{\bkmkend AAAAAAADEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 152} of file {\b Grammar.hpp}.}\par
}
{\xe \v _error\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ErrorType} MCHEmul::Assembler::GrammaticalElement::_error{\f2 [mutable]}}}
\par
{\bkmkstart AAAAAAADEL}
{\bkmkend AAAAAAADEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To define whether it has or not some mistake inside, it could be modified even consulting data. \par
}{
Definition at line {\b 148} of file {\b Grammar.hpp}.}\par
}
{\xe \v _id\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Assembler::GrammaticalElement::_id}}
\par
{\bkmkstart AAAAAAADEM}
{\bkmkend AAAAAAADEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 140} of file {\b Grammar.hpp}.}\par
}
{\xe \v _line\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Assembler::GrammaticalElement::_line}}
\par
{\bkmkstart AAAAAAADEN}
{\bkmkend AAAAAAADEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b Grammar.hpp}.}\par
}
{\xe \v _nextElement\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_nextElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GrammaticalElement}* MCHEmul::Assembler::GrammaticalElement::_nextElement}}
\par
{\bkmkstart AAAAAAADEO}
{\bkmkend AAAAAAADEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The next gramatical element linked. \par
}{
Definition at line {\b 144} of file {\b Grammar.hpp}.}\par
}
{\xe \v _previousElement\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_previousElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GrammaticalElement}* MCHEmul::Assembler::GrammaticalElement::_previousElement}}
\par
{\bkmkstart AAAAAAADEP}
{\bkmkend AAAAAAADEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The previous gramatical element linked. \par
}{
Definition at line {\b 146} of file {\b Grammar.hpp}.}\par
}
{\xe \v _type\:MCHEmul::Assembler::GrammaticalElement}
{\xe \v MCHEmul::Assembler::GrammaticalElement\:_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Type} MCHEmul::Assembler::GrammaticalElement::_type}}
\par
{\bkmkstart AAAAAAADEQ}
{\bkmkend AAAAAAADEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Grammar.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::GraphicalChip Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip}
{\bkmkstart AAAAAAACCA}
{\bkmkend AAAAAAACCA}
\par
{
{\f2 #include <GraphicalChip.hpp>}}\par
Inheritance diagram for MCHEmul::GraphicalChip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_graphical_chip__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::GraphicalChip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_graphical_chip__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GraphicalChip} (int {\b id}, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~GraphicalChip} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b ScreenMemory} * {\b screenMemory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenMemory} * {\b screenMemory} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b graphicsReady} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setGraphicsReady} (bool gR)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ScreenMemory} * {\b createScreenMemory} ()=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenMemory} * {\b _screenMemory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _graphicsReady}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GraphicalChip} is very connected with a {\b Screen}. \par
The graphical chip uses the {\b ScreenMemory} to write. \par
The same object will be taken by th {\b Screen} to finaly put the graphics out to the display. \par
The instance of the {\b ScreenMemory} object used is created in the method "createScreenMemory ()" that has to be overload. \par
When a graphic is ready (complete) to be sent to the screen, the method "setGraphicsReady (true)" should be invoked. \par
The {\b Screen}, when output the raphics to the display invokes back the method "setGraphicsReady (false)". \par
}{
Definition at line {\b 30} of file {\b GraphicalChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GraphicalChip\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:GraphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::GraphicalChip::GraphicalChip (int  {\i id}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCB}
{\bkmkend AAAAAAACCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b GraphicalChip.hpp}.}\par
}
{\xe \v ~GraphicalChip\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:~GraphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::GraphicalChip::~GraphicalChip (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCC}
{\bkmkend AAAAAAACCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b GraphicalChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createScreenMemory\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:createScreenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b ScreenMemory} * MCHEmul::GraphicalChip::createScreenMemory (){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACCD}
{\bkmkend AAAAAAACCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invoked from initialize to create the right screen memory. \par
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_graphical_chip_ab37ad811ee4376ad4487569d8c0a0cae_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v graphicsReady\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:graphicsReady}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::GraphicalChip::graphicsReady () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCE}
{\bkmkend AAAAAAACCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b GraphicalChip.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::GraphicalChip::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b C64::VICII} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 4} of file {\b GraphicalChip.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_graphical_chip_af9c99b2301206774f27aa56f45062ddf_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_graphical_chip_af9c99b2301206774f27aa56f45062ddf_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v screenMemory\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:screenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScreenMemory} * MCHEmul::GraphicalChip::screenMemory (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCF}
{\bkmkend AAAAAAACCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b GraphicalChip.hpp}.}\par
}
{\xe \v screenMemory\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:screenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b ScreenMemory} * MCHEmul::GraphicalChip::screenMemory () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCG}
{\bkmkend AAAAAAACCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b GraphicalChip.hpp}.}\par
}
{\xe \v setGraphicsReady\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:setGraphicsReady}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::GraphicalChip::setGraphicsReady (bool  {\i gR}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCH}
{\bkmkend AAAAAAACCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b GraphicalChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _graphicsReady\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:_graphicsReady}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::GraphicalChip::_graphicsReady{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCI}
{\bkmkend AAAAAAACCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b GraphicalChip.hpp}.}\par
}
{\xe \v _screenMemory\:MCHEmul::GraphicalChip}
{\xe \v MCHEmul::GraphicalChip\:_screenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScreenMemory}* MCHEmul::GraphicalChip::_screenMemory{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCJ}
{\bkmkend AAAAAAACCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b GraphicalChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b GraphicalChip.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b GraphicalChip.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::INC_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::INC_General}
{\xe \v F6500::INC_General}
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::INC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_i_n_c___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::INC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_i_n_c___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b INC_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b INC_General}: To aggregate common steps in every INC instruction. \par
}{
Definition at line {\b 304} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v INC_General\:F6500::INC_General}
{\xe \v F6500::INC_General\:INC_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::INC_General::INC_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 307} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::INC_General}
{\xe \v F6500::INC_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::INC_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b INC.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_i_n_c___general_a2bdae4b6342341ddb964401c80407e44_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b INC.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::IncludeCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::IncludeCommandParser}
{\xe \v MCHEmul::Assembler::IncludeCommandParser}
{\bkmkstart AAAAAAADER}
{\bkmkend AAAAAAADER}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::IncludeCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_include_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::IncludeCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_include_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IncludeCommandParser} (unsigned char s='#')\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *c) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser a file inclusion. The symbol defining that can be changed. \par
}{
Definition at line {\b 94} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IncludeCommandParser\:MCHEmul::Assembler::IncludeCommandParser}
{\xe \v MCHEmul::Assembler::IncludeCommandParser\:IncludeCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::IncludeCommandParser::IncludeCommandParser (unsigned char  {\i s} = {\f2 '#'}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADES}
{\bkmkend AAAAAAADES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::IncludeCommandParser}
{\xe \v MCHEmul::Assembler::IncludeCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::IncludeCommandParser::canParse (const std::string &  {\i l}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCC}
{\bkmkend AAAAAAADCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 102} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::IncludeCommandParser}
{\xe \v MCHEmul::Assembler::IncludeCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::IncludeCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCL}
{\bkmkend AAAAAAADCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Until a potencial comment\par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 6} of file {\b Parser.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_include_command_parser_a5c076c3df8989152aef4fc0601fae9cd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_include_command_parser_a5c076c3df8989152aef4fc0601fae9cd_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Parser.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::InputOSSystem Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::InputOSSystem}
{\xe \v C64::InputOSSystem}
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
\par
{
{\f2 #include <OSIO.hpp>}}\par
Inheritance diagram for C64::InputOSSystem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_input_o_s_system__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::InputOSSystem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_input_o_s_system__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InputOSSystem} (const {\b MCHEmul::Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b linkToChips} (const {\b MCHEmul::Chips} &c) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _ID} = 2\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b C64::InputOSSystem} is very related with the chip {\b CIA1}. \par
The events that happen in the OS have to be transmitted to that chip for them to be accesible for the rest of the computer elements. \par
}{
Definition at line {\b 26} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InputOSSystem\:C64::InputOSSystem}
{\xe \v C64::InputOSSystem\:InputOSSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::InputOSSystem::InputOSSystem (const {\b MCHEmul::Attributes} &  {\i attrs} = {\f2 \{\~ \}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v linkToChips\:C64::InputOSSystem}
{\xe \v C64::InputOSSystem\:linkToChips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::InputOSSystem::linkToChips (const {\b MCHEmul::Chips} &  {\i c}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To link to the right chips. The IO device never owns the chips. By default all chips are linked. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 73} of file {\b OSIO.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::InputOSSystem}
{\xe \v C64::InputOSSystem\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int C64::InputOSSystem::_ID = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b OSIO.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b OSIO.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::InputOSSystem Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem}
{\bkmkstart AAAAAAACCK}
{\bkmkend AAAAAAACCK}
\par
{
{\f2 #include <OSIO.hpp>}}\par
Inheritance diagram for MCHEmul::InputOSSystem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_input_o_s_system__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::InputOSSystem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_input_o_s_system__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InputOSSystem} (int {\b id}, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b quitRequested} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b SDL_JoyAxisEvents} = std::vector< SDL_JoyAxisEvent >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b whenKeyPressed} (SDL_Scancode)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b whenKeyReleased} (SDL_Scancode)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b whenJoystickMoved} (const {\b SDL_JoyAxisEvents} &)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b whenJoystickButtonPressed} (SDL_JoyButtonEvent)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b whenJoystickButtonReleased} (SDL_JoyButtonEvent)=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _quitRequested}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the generation of inputs from the OS. \par
}{
Definition at line {\b 23} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v SDL_JoyAxisEvents\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:SDL_JoyAxisEvents}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::InputOSSystem::SDL_JoyAxisEvents} =  std::vector <SDL_JoyAxisEvent>{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCL}
{\bkmkend AAAAAAACCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InputOSSystem\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:InputOSSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::InputOSSystem::InputOSSystem (int  {\i id}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCM}
{\bkmkend AAAAAAACCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::InputOSSystem::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACCN}
{\bkmkend AAAAAAACCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the device. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACCO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 5} of file {\b OSIO.cpp}.}\par
}
{\xe \v quitRequested\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:quitRequested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::InputOSSystem::quitRequested () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCP}
{\bkmkend AAAAAAACCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b OSIO.hpp}.}\par
}
{\xe \v simulate\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::InputOSSystem::simulate (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACCQ}
{\bkmkend AAAAAAACCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Algorithm, invoking the protected methods defined. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACCR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 13} of file {\b OSIO.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_input_o_s_system_a397eacb288480dbee3c0f7806b65bdba_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v whenJoystickButtonPressed\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:whenJoystickButtonPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::InputOSSystem::whenJoystickButtonPressed (SDL_JoyButtonEvent ){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACCS}
{\bkmkend AAAAAAACCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
What to do when the joystick button is pressed. \par
}}
{\xe \v whenJoystickButtonReleased\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:whenJoystickButtonReleased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::InputOSSystem::whenJoystickButtonReleased (SDL_JoyButtonEvent ){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACCT}
{\bkmkend AAAAAAACCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
What to do when the joystick button is released. \par
}}
{\xe \v whenJoystickMoved\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:whenJoystickMoved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::InputOSSystem::whenJoystickMoved (const {\b SDL_JoyAxisEvents} & ){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACCU}
{\bkmkend AAAAAAACCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
What to do when the joystick is moved. Take care that the events in the joystick have to be managed as a hole, because may of them can happen at the same time: e.g. when the joystick is moved in two axes simultaneosly. \par
}}
{\xe \v whenKeyPressed\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:whenKeyPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::InputOSSystem::whenKeyPressed (SDL_Scancode ){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACCV}
{\bkmkend AAAAAAACCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
What to do when a key has been pressed. \par
}}
{\xe \v whenKeyReleased\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:whenKeyReleased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::InputOSSystem::whenKeyReleased (SDL_Scancode ){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACCW}
{\bkmkend AAAAAAACCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
What to do when a key has been released. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _quitRequested\:MCHEmul::InputOSSystem}
{\xe \v MCHEmul::InputOSSystem\:_quitRequested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::InputOSSystem::_quitRequested{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCX}
{\bkmkend AAAAAAACCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b OSIO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b OSIO.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b OSIO.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::Instruction Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::Instruction}
{\xe \v F6500::Instruction}
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::Instruction:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::Instruction:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_absolute} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_zeroPage} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_absoluteX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_absoluteY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_zeroPageX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_zeroPageY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_indirectZeroPageX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_indirectZeroPageY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::Address} {\b address_indirect} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_inmediate} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_absolute} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_zeroPage} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_absoluteX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_absoluteY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_relative} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_zeroPageX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_zeroPageY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_indirectZeroPageX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MCHEmul::UByte} {\b value_indirectZeroPageY} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Most of 6500 instruction inherits from this class because it includes diffrent access for any addrss mode. Always little-endian format and no more than 2 bytes for and address are values taken. \par
}{
Definition at line {\b 24} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Instruction\:F6500::Instruction}
{\xe \v F6500::Instruction\:Instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::Instruction::Instruction (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v address_absolute\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_absolute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_absolute (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2 parameters representing an address. \par
}{
Definition at line {\b 5} of file {\b Instructions.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a200c88e5a9642d29d1a05d5bdeb3cca7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a200c88e5a9642d29d1a05d5bdeb3cca7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_absoluteX\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_absoluteX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_absoluteX (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2 parameters representing a base address. The final one is got adding the X register to the base. \par
}{
Definition at line {\b 21} of file {\b Instructions.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a84564b51e93735f9168c140d65e856e3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_absoluteY\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_absoluteY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_absoluteY (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2 parameters representing a base address. The final one is got adding the Y register to the base. \par
}{
Definition at line {\b 34} of file {\b Instructions.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a1c947fc95e524984c76a5808522ae80e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_indirect\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_indirect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_indirect (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2 parameters representint a base addreess. The final one is got at the position of that first base address. \par
}{
Definition at line {\b 95} of file {\b Instructions.cpp}.}\par
}
{\xe \v address_indirectZeroPageX\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_indirectZeroPageX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_indirectZeroPageX (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter representing a base address in page 0. The final one is got from the position in page 0 result of adding the X register to the base. \par
}{
Definition at line {\b 69} of file {\b Instructions.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a06be01ccbf0c409819572d9cb6bc7b3f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_indirectZeroPageY\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_indirectZeroPageY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_indirectZeroPageY (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter representing a base address in page 0. The final one is got from the position in page 0 result of adding the X register to position found in the base. \par
}{
Definition at line {\b 81} of file {\b Instructions.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_ab46ef4cf214245aa7d3ff75bc5769264_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_zeroPage\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_zeroPage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_zeroPage (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter representing an address in the page 0. \par
}{
Definition at line {\b 13} of file {\b Instructions.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a9d5bf43bec88cc365b8527bdfce2382b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_zeroPageX\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_zeroPageX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_zeroPageX (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter representing a base address in page 0. The final one is got adding the X register to the base. \par
}{
Definition at line {\b 47} of file {\b Instructions.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_ae948b408260616fc67dfb1c4a0cc22d3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v address_zeroPageY\:F6500::Instruction}
{\xe \v F6500::Instruction\:address_zeroPageY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} F6500::Instruction::address_zeroPageY (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter representing a base address in page 0. The final one is got adding the Y register to the base. \par
}{
Definition at line {\b 58} of file {\b Instructions.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a550dcfea2e3677bc3c2884f67f1eeef9_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_absolute\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_absolute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_absolute (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a6ac1e32ee4e114a14d244aa83f391782_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_absoluteX\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_absoluteX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_absoluteX (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_aaad6c21a20539f0e8dad8791bcac23c0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_absoluteY\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_absoluteY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_absoluteY (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a567cb6bddb3dc359d02fccde15011759_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_indirectZeroPageX\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_indirectZeroPageX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_indirectZeroPageX (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_aece62f93531b34cbe8ecd99c249030e0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_indirectZeroPageY\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_indirectZeroPageY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_indirectZeroPageY (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_aaec87199ef5f8cbf52a2b0f0a132f92f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_inmediate\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_inmediate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_inmediate (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter with the value. \par
}{
Definition at line {\b 104} of file {\b Instructions.cpp}.}\par
}
{\xe \v value_relative\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_relative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_relative (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 parameter that can be negative value. It us used in jumps. \par
}{
Definition at line {\b 112} of file {\b Instructions.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a1e51e588deadacb2e78302949edb7721_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_zeroPage\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_zeroPage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_zeroPage (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a8b042f8d4645bb49419a25b201123483_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_zeroPageX\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_zeroPageX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_zeroPageX (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a3f47b44d2da8080346ce906e4390645c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value_zeroPageY\:F6500::Instruction}
{\xe \v F6500::Instruction\:value_zeroPageY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} F6500::Instruction::value_zeroPageY (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b Instructions.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_instruction_a62cbe9b05a382d52202fb46eccf97611_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b Instructions.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Instruction Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction}
{\bkmkstart AAAAAAACCY}
{\bkmkend AAAAAAACCY}
\par
{
{\f2 #include <Instruction.hpp>}}\par
Inheritance diagram for MCHEmul::Instruction:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_instruction__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Instruction:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_instruction__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Structure}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} (const {\b Instruction} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} & {\b operator=} (const {\b Instruction} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b code} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b memoryPositions} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b clockCycles} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b additionalClockCycles} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b iTemplate} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Structure} & {\b internalStructure} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b matchesWith} (const std::string &i, std::vector< std::string > &prms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UBytes} & {\b parameters} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UBytes} {\b parameters} (size_t p, size_t nP=1, bool bE=true) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b parametersAsString} (size_t p, size_t nP=1, bool bE=true) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b execute} (const {\b UBytes} &p, {\b CPU} *c, {\b Memory} *m, {\b Stack} *stk)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Structure} {\b analyzeInstruction} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b executeImpl} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPU} * {\b cpu} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} * {\b cpu} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Memory} * {\b memory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} * {\b memory} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Stack} * {\b stack} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Stack} * {\b stack} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b _code} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b _memoryPositions} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b _clockCycles} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _iTemplate}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Structure} {\b _iStructure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _additionalCycles}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Instruction} &i)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a instruction executed by a {\b CPU}. \par
}{
Definition at line {\b 27} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Instruction\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:Instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Instruction (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACCZ}
{\bkmkend AAAAAAACCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Instruction\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:Instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Instruction (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t})}}
\par
{\bkmkstart AAAAAAACDA}
{\bkmkend AAAAAAACDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{: The internal code of the instruction. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mp} \cell }{: The number of memory positions (in number of ubytes) occupied by the instruction (and params). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cc} \cell }{: The number of clock cyles the instruction uses to be executed (usually). \par
 Some ocassions, some instructions under certain circunstances can take longer than expected. \par
 \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
for so: _additionalClockCycles (method and variable). \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i t} \cell }{: The template of the instruction. \par
 The way it is defined is key for it to be read and understood by the parsers. \par
 The parameters should be within [] with two additional data: \par
 The type of the parameter, and the number of bytes that parameter occupies. \par
 Regarding the type: # means number, $ means address and & means relative jump (\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
type of parameter). \par
}}}{
Definition at line {\b 14} of file {\b Instruction.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_instruction_af5be1fcfd285651f17935d1414817243_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Instruction\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:Instruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Instruction (const {\b Instruction} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACDB}
{\bkmkend AAAAAAACDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v additionalClockCycles\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:additionalClockCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Instruction::additionalClockCycles () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDC}
{\bkmkend AAAAAAACDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b Instruction.hpp}.}\par
}
{\xe \v analyzeInstruction\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:analyzeInstruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Instruction::Structure} MCHEmul::Instruction::analyzeInstruction () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDD}
{\bkmkend AAAAAAACDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To analyze the structure of the instruction. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
minimum length including type and number of bytes\par
To identify some variable.\par
}{
Definition at line {\b 195} of file {\b Instruction.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_instruction_ae62e0eab802164eb13a2b26f1ecba9fc_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asString\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Instruction::asString () const}}
\par
{\bkmkstart AAAAAAACDE}
{\bkmkend AAAAAAACDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b Instruction.cpp}.}\par
}
{\xe \v clockCycles\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:clockCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Instruction::clockCycles () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDF}
{\bkmkend AAAAAAACDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b Instruction.hpp}.}\par
}
{\xe \v code\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Instruction::code () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDG}
{\bkmkend AAAAAAACDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b Instruction.hpp}.}\par
}
{\xe \v cpu\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU} * MCHEmul::Instruction::cpu (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDH}
{\bkmkend AAAAAAACDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 145} of file {\b Instruction.hpp}.}\par
}
{\xe \v cpu\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPU} * MCHEmul::Instruction::cpu () const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDI}
{\bkmkend AAAAAAACDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b Instruction.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_instruction_a616982c1b43cf2f740e109fb0512a312_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v execute\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:execute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Instruction::execute (const {\b UBytes} &  {\i p}, {\b MCHEmul::CPU} *  {\i c}, {\b MCHEmul::Memory} *  {\i m}, {\b MCHEmul::Stack} *  {\i stk})}}
\par
{\bkmkstart AAAAAAACDJ}
{\bkmkend AAAAAAACDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To execute the instruction. It has to be redefined. \par
It returns true if everything is ok, \par
}{
Definition at line {\b 179} of file {\b Instruction.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_instruction_a136fb2f90690a29702bd465b382937f4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v executeImpl\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:executeImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Instruction::executeImpl (){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACDK}
{\bkmkend AAAAAAACDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The implementation of the execution. It has to be redefined. \par
}}
{\xe \v internalStructure\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:internalStructure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Structure} & MCHEmul::Instruction::internalStructure () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDL}
{\bkmkend AAAAAAACDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b Instruction.hpp}.}\par
}
{\xe \v iTemplate\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:iTemplate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string MCHEmul::Instruction::iTemplate () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDM}
{\bkmkend AAAAAAACDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b Instruction.hpp}.}\par
}
{\xe \v matchesWith\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:matchesWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Instruction::matchesWith (const std::string &  {\i i}, std::vector< std::string > &  {\i prms})}}
\par
{\bkmkstart AAAAAAACDN}
{\bkmkend AAAAAAACDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know whether the instruction template matches of not with the example received. \par
Returns true when matches, and false when it doesn't. \par
When matches the parameter prms received is also filled. \par
When doesn't the parameter prms will have trash!. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic structure.\par
But also the extended version.\par
and for sure the paramete4rs.\par
}{
Definition at line {\b 31} of file {\b Instruction.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_instruction_ac6bf7a22a799bd5ecd104a092da4c007_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v memory\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory} * MCHEmul::Instruction::memory (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDO}
{\bkmkend AAAAAAACDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b Instruction.hpp}.}\par
}
{\xe \v memory\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Memory} * MCHEmul::Instruction::memory () const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDP}
{\bkmkend AAAAAAACDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b Instruction.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_instruction_a32706ddfc9c7729c5fa5e826d2cc230f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v memoryPositions\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:memoryPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Instruction::memoryPositions () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDQ}
{\bkmkend AAAAAAACDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b Instruction.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Instruction} & MCHEmul::Instruction::operator= (const {\b Instruction} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACDR}
{\bkmkend AAAAAAACDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parameters\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UBytes} & MCHEmul::Instruction::parameters () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b Instruction.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_instruction_ad3533e9dfc7b07656e4b5f4440fe67d2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v parameters\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::UBytes} MCHEmul::Instruction::parameters (size_t  {\i p}, size_t  {\i nP} = {\f2 1}, bool  {\i bE} = {\f2 true}) const}}
\par
{\bkmkstart AAAAAAACDT}
{\bkmkend AAAAAAACDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b Instruction.cpp}.}\par
}
{\xe \v parametersAsString\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:parametersAsString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Instruction::parametersAsString (size_t  {\i p}, size_t  {\i nP} = {\f2 1}, bool  {\i bE} = {\f2 true}) const}}
\par
{\bkmkstart AAAAAAACDU}
{\bkmkend AAAAAAACDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b Instruction.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_instruction_ab137f5b93b80dcaf5dda5fccce227859_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v stack\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Stack} * MCHEmul::Instruction::stack (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDV}
{\bkmkend AAAAAAACDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b Instruction.hpp}.}\par
}
{\xe \v stack\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Stack} * MCHEmul::Instruction::stack () const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDW}
{\bkmkend AAAAAAACDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Instruction} &  {\i i}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACDX}
{\bkmkend AAAAAAACDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _additionalCycles\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:_additionalCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Instruction::_additionalCycles{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDY}
{\bkmkend AAAAAAACDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b Instruction.hpp}.}\par
}
{\xe \v _clockCycles\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:_clockCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Instruction::_clockCycles = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDZ}
{\bkmkend AAAAAAACDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b Instruction.hpp}.}\par
}
{\xe \v _code\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Instruction::_code = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEA}
{\bkmkend AAAAAAACEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b Instruction.hpp}.}\par
}
{\xe \v _iStructure\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:_iStructure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Structure} MCHEmul::Instruction::_iStructure{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEB}
{\bkmkend AAAAAAACEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b Instruction.hpp}.}\par
}
{\xe \v _iTemplate\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:_iTemplate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Instruction::_iTemplate{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEC}
{\bkmkend AAAAAAACEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 161} of file {\b Instruction.hpp}.}\par
}
{\xe \v _memoryPositions\:MCHEmul::Instruction}
{\xe \v MCHEmul::Instruction\:_memoryPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Instruction::_memoryPositions = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACED}
{\bkmkend AAAAAAACED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Instruction.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b Instruction.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::InstructionCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::InstructionCommandParser}
{\xe \v MCHEmul::Assembler::InstructionCommandParser}
{\bkmkstart AAAAAAADET}
{\bkmkend AAAAAAADET}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::InstructionCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_instruction_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::InstructionCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_instruction_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InstructionCommandParser} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *s) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser an instruction. \par
}{
Definition at line {\b 204} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InstructionCommandParser\:MCHEmul::Assembler::InstructionCommandParser}
{\xe \v MCHEmul::Assembler::InstructionCommandParser\:InstructionCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::InstructionCommandParser::InstructionCommandParser (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADEU}
{\bkmkend AAAAAAADEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 207} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::InstructionCommandParser}
{\xe \v MCHEmul::Assembler::InstructionCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::InstructionCommandParser::canParse (const std::string &  {\i l}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCG}
{\bkmkend AAAAAAADCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Until a potential comment.\par
not used here.\par
At least 1 matching.\par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 115} of file {\b Parser.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_instruction_command_parser_ad937f66e7327bb790e34da32254cc407_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::Assembler::InstructionCommandParser}
{\xe \v MCHEmul::Assembler::InstructionCommandParser\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::InstructionCommandParser::initialize (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCK}
{\bkmkend AAAAAAADCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maybe one of them could need it. \par
}{
Reimplemented from {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 212} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::InstructionCommandParser}
{\xe \v MCHEmul::Assembler::InstructionCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::InstructionCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCP}
{\bkmkend AAAAAAADCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Until a potential comment.\par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 129} of file {\b Parser.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_instruction_command_parser_aca974fbdc783bc3f3e3deba9a07ce3e0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Parser.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::InstructionElement Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement}
{\bkmkstart AAAAAAADEV}
{\bkmkend AAAAAAADEV}
\par
{
{\f2 #include <Grammar.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::InstructionElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_instruction_element__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::InstructionElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_instruction_element__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InstructionElement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InstructionElement} (const {\b InstructionElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InstructionElement} & {\b operator=} (const {\b InstructionElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b size} (const {\b Semantic} *s) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasAnyLabelAsParameter} (const {\b Semantic} *s) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< size_t > {\b labelParameters} (const {\b Semantic} *s) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Instruction} * > {\b _possibleInstructions}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b _parameters}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Instruction} * {\b _selectedInstruction}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
explanation at the beggining of the file. An instruction is just also a set of bytes in memory. \par
}}}{
Definition at line {\b 197} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InstructionElement\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:InstructionElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::InstructionElement::InstructionElement (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADEW}
{\bkmkend AAAAAAADEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b Grammar.hpp}.}\par
}
{\xe \v InstructionElement\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:InstructionElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::InstructionElement::InstructionElement (const {\b InstructionElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADEX}
{\bkmkend AAAAAAADEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v hasAnyLabelAsParameter\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:hasAnyLabelAsParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::InstructionElement::hasAnyLabelAsParameter (const {\b Semantic} *  {\i s}) const}}
\par
{\bkmkstart AAAAAAADEY}
{\bkmkend AAAAAAADEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know whether any of the parameters could be or not a label. \par
}{
Definition at line {\b 216} of file {\b Grammar.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_instruction_element_a27875fd164c52769335b0bed1536a112_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v labelParameters\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:labelParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< size_t > MCHEmul::Assembler::InstructionElement::labelParameters (const {\b Semantic} *  {\i s}) const}}
\par
{\bkmkstart AAAAAAADEZ}
{\bkmkend AAAAAAADEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know the list of the the parameters that could be a label. \par
}{
Definition at line {\b 229} of file {\b Grammar.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_instruction_element_a36801963182de3b1643c14ec9744ad43_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InstructionElement} & MCHEmul::Assembler::InstructionElement::operator= (const {\b InstructionElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADFA}
{\bkmkend AAAAAAADFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::Assembler::InstructionElement::size (const {\b Semantic} *  {\i s}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADEI}
{\bkmkend AAAAAAADEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the size of the grammatical element in bytes. By default the bytes are calculated and then the size. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
true or false is the same at this point.\par
}{
Reimplemented from {\b MCHEmul::Assembler::GrammaticalElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADEH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 141} of file {\b Grammar.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _parameters\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:_parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<std::string> MCHEmul::Assembler::InstructionElement::_parameters}}
\par
{\bkmkstart AAAAAAADFB}
{\bkmkend AAAAAAADFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 218} of file {\b Grammar.hpp}.}\par
}
{\xe \v _possibleInstructions\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:_possibleInstructions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b Instruction}*> MCHEmul::Assembler::InstructionElement::_possibleInstructions}}
\par
{\bkmkstart AAAAAAADFC}
{\bkmkend AAAAAAADFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 217} of file {\b Grammar.hpp}.}\par
}
{\xe \v _selectedInstruction\:MCHEmul::Assembler::InstructionElement}
{\xe \v MCHEmul::Assembler::InstructionElement\:_selectedInstruction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Instruction}* MCHEmul::Assembler::InstructionElement::_selectedInstruction{\f2 [mutable]}}}
\par
{\bkmkstart AAAAAAADFD}
{\bkmkend AAAAAAADFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 219} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Grammar.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::IODevice Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice}
{\bkmkstart AAAAAAACFB}
{\bkmkend AAAAAAACFB}
\par
{
{\f2 #include <IO.hpp>}}\par
Inheritance diagram for MCHEmul::IODevice:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_o_device__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Type} \{ {\b _INPUT} = 0
, {\b _OUTPUT}
, {\b _INPUTOUTPUT}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} ({\b Type} t, int {\b id}, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} (const {\b IODevice} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} & {\b operator=} (const {\b IODevice} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IODevice} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Type} {\b type} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} & {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b attribute} (const std::string &aN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b linkToChips} (const {\b Chips} &c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Chips} & {\b chips} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b IOPeripherals} & {\b peripherals} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsPeripheral} (int {\b id}) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b addPeripheral} ({\b IOPeripheral} *p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removePeripheral} (int {\b id})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Type} {\b _type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chips} {\b _chips}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} {\b _attributes} = \{ \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripherals} {\b _peripherals}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b IODevice} &d)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class {\b IODevice} represents anything connected to any {\b Chip} of the motherboard. \par
The ports (RS232, Serial, IEEE, etc...) are typically elements comnnected to communication chips but also the screen or the keyboard. \par
Connected to a device there might be different peripherials. \par
For some specific devices (like screen or keyboard) the peripheral connected is "implicit" and there is no other way to add other different, but it has to be opened to other possibilities! \par
}{
Definition at line {\b 30} of file {\b IO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Type\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b MCHEmul::IODevice::Type}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAACFC}
{\bkmkend AAAAAAACFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _INPUT\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_INPUT}
{\qr _INPUT{\bkmkstart AAAAAAACFD}
{\bkmkend AAAAAAACFD}
\cell }{\cell }{\row }
{\xe \v _OUTPUT\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_OUTPUT}
{\qr _OUTPUT{\bkmkstart AAAAAAACFE}
{\bkmkend AAAAAAACFE}
\cell }{\cell }{\row }
{\xe \v _INPUTOUTPUT\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_INPUTOUTPUT}
{\qr _INPUTOUTPUT{\bkmkstart AAAAAAACFF}
{\bkmkend AAAAAAACFF}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 33} of file {\b IO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IODevice\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:IODevice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IODevice::IODevice (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACFG}
{\bkmkend AAAAAAACFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IODevice\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:IODevice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IODevice::IODevice ({\b Type}  {\i t}, int  {\i id}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}})}}
\par
{\bkmkstart AAAAAAACFH}
{\bkmkend AAAAAAACFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b IO.cpp}.}\par
}
{\xe \v IODevice\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:IODevice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IODevice::IODevice (const {\b IODevice} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACFI}
{\bkmkend AAAAAAACFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~IODevice\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:~IODevice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::IODevice::~IODevice (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFJ}
{\bkmkend AAAAAAACFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The device doesn't own the chips, only work with them. The device doesn't own the peripherals either. \par
}{
Definition at line {\b 45} of file {\b IO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addPeripheral\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:addPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::IODevice::addPeripheral ({\b MCHEmul::IOPeripheral} *  {\i p}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To connect a peripheral. If either there had been a peripheral with the same id already connected or the peripheral were not valid, nothing would happen. \par
The method can be overloaded to check (e.g) compability before adding it. \par
}{
Reimplemented in {\b C64::UserIOPort} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 17} of file {\b IO.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_o_device_a85bc1f5593b3a2615de5a70e9c6e04ca_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v attribute\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::IODevice::attribute (const std::string &  {\i aN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFK}
{\bkmkend AAAAAAACFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b IO.hpp}.}\par
}
{\xe \v attributes\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} & MCHEmul::IODevice::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFL}
{\bkmkend AAAAAAACFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b IO.hpp}.}\par
}
{\xe \v chips\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:chips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Chips} & MCHEmul::IODevice::chips () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFM}
{\bkmkend AAAAAAACFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b IO.hpp}.}\par
}
{\xe \v existsPeripheral\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:existsPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::IODevice::existsPeripheral (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFN}
{\bkmkend AAAAAAACFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b IO.hpp}.}\par
}
{\xe \v id\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::IODevice::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFO}
{\bkmkend AAAAAAACFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b IO.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::IODevice::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACCO}
{\bkmkend AAAAAAACCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the device. \par
}{
Reimplemented in {\b MCHEmul::InputOSSystem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACCN \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::Screen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 44} of file {\b IO.cpp}.}\par
}
{\xe \v lastError\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::IODevice::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFQ}
{\bkmkend AAAAAAACFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the last error happend (after initialize or simulate methods). \par
}{
Definition at line {\b 89} of file {\b IO.hpp}.}\par
}
{\xe \v linkToChips\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:linkToChips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::IODevice::linkToChips (const {\b Chips} &  {\i c}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To link to the right chips. The IO device never owns the chips. By default all chips are linked. \par
}{
Reimplemented in {\b MCHEmul::Screen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFR \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b C64::InputOSSystem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 63} of file {\b IO.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IODevice} & MCHEmul::IODevice::operator= (const {\b IODevice} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACFS}
{\bkmkend AAAAAAACFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v peripherals\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:peripherals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b IOPeripherals} & MCHEmul::IODevice::peripherals () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFT}
{\bkmkend AAAAAAACFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b IO.hpp}.}\par
}
{\xe \v removePeripheral\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:removePeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::IODevice::removePeripheral (int  {\i id})}}
\par
{\bkmkstart AAAAAAACFU}
{\bkmkend AAAAAAACFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To remove a Peripheral. if the peripheral doesn't exist nothing happens. \par
}{
Definition at line {\b 32} of file {\b IO.cpp}.}\par
}
{\xe \v simulate\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::IODevice::simulate (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACCR}
{\bkmkend AAAAAAACCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To emulate the way it works. \par
Return true, if everything was ok. \par
}{
Reimplemented in {\b MCHEmul::InputOSSystem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACCQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::Screen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 57} of file {\b IO.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_o_device_adfe2e29dcfe9d51d90cc854f9de6b8ef_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v type\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Type} MCHEmul::IODevice::type () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFW}
{\bkmkend AAAAAAACFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b IO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b IODevice} &  {\i d}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACFX}
{\bkmkend AAAAAAACFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _attributes\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} MCHEmul::IODevice::_attributes = \{ \}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFY}
{\bkmkend AAAAAAACFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b IO.hpp}.}\par
}
{\xe \v _chips\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_chips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Chips} MCHEmul::IODevice::_chips{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFZ}
{\bkmkend AAAAAAACFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b IO.hpp}.}\par
}
{\xe \v _id\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int MCHEmul::IODevice::_id{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGA}
{\bkmkend AAAAAAACGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b IO.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::IODevice::_lastError{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGB}
{\bkmkend AAAAAAACGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b IO.hpp}.}\par
}
{\xe \v _peripherals\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_peripherals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IOPeripherals} MCHEmul::IODevice::_peripherals{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGC}
{\bkmkend AAAAAAACGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b IO.hpp}.}\par
}
{\xe \v _type\:MCHEmul::IODevice}
{\xe \v MCHEmul::IODevice\:_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Type} MCHEmul::IODevice::_type{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGD}
{\bkmkend AAAAAAACGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b IO.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b IO.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b IO.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::IOPeripheral Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral}
{\bkmkstart AAAAAAACGE}
{\bkmkend AAAAAAACGE}
\par
{
{\f2 #include <IOPeripheral.hpp>}}\par
Inheritance diagram for MCHEmul::IOPeripheral:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_o_peripheral__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::IOPeripheral:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_o_peripheral__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheral} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheral} (int {\b id}, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheral} (const {\b IOPeripheral} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheral} & {\b operator=} (const {\b IOPeripheral} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IOPeripheral} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} & {\b attributes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b attribute} (const std::string &aN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b IODevice} * {\b device} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} * {\b device} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ()=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b IODevice}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Attributes} {\b _attributes} = \{ \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IODevice} * {\b _device}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b IOPeripheral} &d)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b IOPeripheral} represents an element connected to a {\b IODevice}. \par
For some IODevices the number and type (and manufacturers) of elements that can be connected might be wide and different. \par
And the simulation of each can even be very different. \par
This is the reason to represent them in a separate class. \par
}{
Definition at line {\b 27} of file {\b IOPeripheral.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IOPeripheral\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:IOPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IOPeripheral::IOPeripheral (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACGF}
{\bkmkend AAAAAAACGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IOPeripheral\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:IOPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IOPeripheral::IOPeripheral (int  {\i id}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGG}
{\bkmkend AAAAAAACGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set when attached. \par
}{
Definition at line {\b 34} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v IOPeripheral\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:IOPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IOPeripheral::IOPeripheral (const {\b IOPeripheral} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACGH}
{\bkmkend AAAAAAACGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~IOPeripheral\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:~IOPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::IOPeripheral::~IOPeripheral (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACGI}
{\bkmkend AAAAAAACGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b IOPeripheral.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attribute\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::IOPeripheral::attribute (const std::string &  {\i aN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGJ}
{\bkmkend AAAAAAACGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v attributes\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} & MCHEmul::IOPeripheral::attributes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGK}
{\bkmkend AAAAAAACGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v device\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IODevice} * MCHEmul::IOPeripheral::device (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGL}
{\bkmkend AAAAAAACGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v device\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b IODevice} * MCHEmul::IOPeripheral::device () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGM}
{\bkmkend AAAAAAACGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v id\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::IOPeripheral::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGN}
{\bkmkend AAAAAAACGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::IOPeripheral::initialize (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the peripheral. The initialization should return true when everything is ok, and false in other case. \par
}{
Implemented in {\b C64::UserIONoPeripheral} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IOPeripheral} & MCHEmul::IOPeripheral::operator= (const {\b IOPeripheral} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACGO}
{\bkmkend AAAAAAACGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v simulate\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::IOPeripheral::simulate (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To emulate the way it works. \par
Should return true if everything was ok. \par
}{
Implemented in {\b C64::UserIONoPeripheral} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b IOPeripheral} &  {\i d}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACGP}
{\bkmkend AAAAAAACGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _attributes\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Attributes} MCHEmul::IOPeripheral::_attributes = \{ \}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGQ}
{\bkmkend AAAAAAACGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v _device\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IODevice}* MCHEmul::IOPeripheral::_device{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGR}
{\bkmkend AAAAAAACGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Accesed from {\b IODevice} when a peripherial is added! \par
}{
Definition at line {\b 73} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v _id\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int MCHEmul::IOPeripheral::_id{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGS}
{\bkmkend AAAAAAACGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b IOPeripheral.hpp}.}\par
}
{\xe \v IODevice\:MCHEmul::IOPeripheral}
{\xe \v MCHEmul::IOPeripheral\:IODevice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend MCHEmul::IOPeripheral::IODevice}}
\par
{\bkmkstart AAAAAAACGT}
{\bkmkend AAAAAAACGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b IOPeripheral.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b IOPeripheral.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::IOPeripheralBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::IOPeripheralBuilder}
{\xe \v C64::IOPeripheralBuilder}
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
\par
{
{\f2 #include <IOPBuilder.hpp>}}\par
Inheritance diagram for C64::IOPeripheralBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_i_o_peripheral_builder__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::IOPeripheralBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_i_o_peripheral_builder__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheralBuilder} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MCHEmul::IOPeripheral} * {\b createPeripheral} (int id, const {\b MCHEmul::Attributes} &prms) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It can be even extende to add new peripherals. \par
}{
Definition at line {\b 22} of file {\b IOPBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IOPeripheralBuilder\:C64::IOPeripheralBuilder}
{\xe \v C64::IOPeripheralBuilder\:IOPeripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::IOPeripheralBuilder::IOPeripheralBuilder (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b IOPBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createPeripheral\:C64::IOPeripheralBuilder}
{\xe \v C64::IOPeripheralBuilder\:createPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::IOPeripheral} * C64::IOPeripheralBuilder::createPeripheral (int  {\i id}, const {\b MCHEmul::Attributes} &  {\i prms}) const{\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method must be overloaded to include any new type of peripherals. \par
}{
Implements {\b MCHEmul::IOPeripheralBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 5} of file {\b IOPBuilder.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b IOPBuilder.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b IOPBuilder.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::IOPeripheralBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder}
{\bkmkstart AAAAAAACGU}
{\bkmkend AAAAAAACGU}
\par
{
{\f2 #include <IOPBuilder.hpp>}}\par
Inheritance diagram for MCHEmul::IOPeripheralBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_o_peripheral_builder__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheralBuilder} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheralBuilder} (const {\b IOPeripheralBuilder} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheralBuilder} & {\b operator=} (const {\b IOPeripheralBuilder} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IOPeripheralBuilder} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripheral} * {\b peripheral} (int id, const {\b Attributes} &attrs) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b IOPeripheral} * {\b createPeripheral} (int id, const {\b Attributes} &prms) const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IOPeripherals} {\b _peripherals}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This builder is to create any type of peripherical that might be connected to the computer simulated. \par
The builder is the owner of the periphericals created, and they will be deleted as this object is also deleted. \par
}{
Definition at line {\b 25} of file {\b IOPBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IOPeripheralBuilder\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:IOPeripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IOPeripheralBuilder::IOPeripheralBuilder (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACGV}
{\bkmkend AAAAAAACGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IOPeripheralBuilder\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:IOPeripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IOPeripheralBuilder::IOPeripheralBuilder (const {\b IOPeripheralBuilder} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACGW}
{\bkmkend AAAAAAACGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~IOPeripheralBuilder\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:~IOPeripheralBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::IOPeripheralBuilder::~IOPeripheralBuilder (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACGX}
{\bkmkend AAAAAAACGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b IOPBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createPeripheral\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:createPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b IOPeripheral} * MCHEmul::IOPeripheralBuilder::createPeripheral (int  {\i id}, const {\b Attributes} &  {\i prms}) const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method must be overloaded to include any new type of peripherals. \par
}{
Implemented in {\b C64::IOPeripheralBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_o_peripheral_builder_abf7e3354cb51a1423b8111b0efb706e4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IOPeripheralBuilder} & MCHEmul::IOPeripheralBuilder::operator= (const {\b IOPeripheralBuilder} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACGY}
{\bkmkend AAAAAAACGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v peripheral\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:peripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::IOPeripheral} * MCHEmul::IOPeripheralBuilder::peripheral (int  {\i id}, const {\b Attributes} &  {\i attrs}) const}}
\par
{\bkmkstart AAAAAAACGZ}
{\bkmkend AAAAAAACGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the peripherical requeted already existed (one with the same id) a reference to it would be returned, otherwise it sill created...if any! \par
}{
Definition at line {\b 4} of file {\b IOPBuilder.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_o_peripheral_builder_a28878f805aeabc94cb67e5e02af82107_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _peripherals\:MCHEmul::IOPeripheralBuilder}
{\xe \v MCHEmul::IOPeripheralBuilder\:_peripherals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IOPeripherals} MCHEmul::IOPeripheralBuilder::_peripherals{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHA}
{\bkmkend AAAAAAACHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b IOPBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b IOPBuilder.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b IOPBuilder.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::IPAddress Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress}
{\bkmkstart AAAAAAACHB}
{\bkmkend AAAAAAACHB}
\par
{
{\f2 #include <IPAddress.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IPAddress} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IPAddress} (unsigned char a, unsigned char b, unsigned char c, unsigned char d, unsigned short p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IPAddress} (const std::string &ip)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IPAddress} (const {\b IPAddress} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IPAddress} & {\b operator=} (const {\b IPAddress} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b byte1} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b byte2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b byte3} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b byte4} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b port} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b ipAsString} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b error} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b IPAddress} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b IPAddress} &a) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b IPAddress} &a)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IP {\b Address}. V4 Format. Can have an error when creating from strring. \par
}{
Definition at line {\b 22} of file {\b IPAddress.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IPAddress\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:IPAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IPAddress::IPAddress (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHC}
{\bkmkend AAAAAAACHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b IPAddress.hpp}.}\par
}
{\xe \v IPAddress\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:IPAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IPAddress::IPAddress (unsigned char  {\i a}, unsigned char  {\i b}, unsigned char  {\i c}, unsigned char  {\i d}, unsigned short  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHD}
{\bkmkend AAAAAAACHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b IPAddress.hpp}.}\par
}
{\xe \v IPAddress\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:IPAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IPAddress::IPAddress (const std::string &  {\i ip})}}
\par
{\bkmkstart AAAAAAACHE}
{\bkmkend AAAAAAACHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b IPAddress.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_p_address_aec156d390c32831beff5e73296a7f694_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IPAddress\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:IPAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::IPAddress::IPAddress (const {\b IPAddress} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACHF}
{\bkmkend AAAAAAACHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asString\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::IPAddress::asString () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHG}
{\bkmkend AAAAAAACHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b IPAddress.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_p_address_a93318dd6cf00cbb4a20b9ec47bd4a5b9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v byte1\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:byte1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::IPAddress::byte1 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHH}
{\bkmkend AAAAAAACHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The parts of the ip address \par
}{
Definition at line {\b 40} of file {\b IPAddress.hpp}.}\par
}
{\xe \v byte2\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:byte2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::IPAddress::byte2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHI}
{\bkmkend AAAAAAACHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b IPAddress.hpp}.}\par
}
{\xe \v byte3\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:byte3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::IPAddress::byte3 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHJ}
{\bkmkend AAAAAAACHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b IPAddress.hpp}.}\par
}
{\xe \v byte4\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:byte4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::IPAddress::byte4 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHK}
{\bkmkend AAAAAAACHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b IPAddress.hpp}.}\par
}
{\xe \v error\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::IPAddress::error () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHL}
{\bkmkend AAAAAAACHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b IPAddress.hpp}.}\par
}
{\xe \v ipAsString\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:ipAsString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::IPAddress::ipAsString () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHM}
{\bkmkend AAAAAAACHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b IPAddress.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_p_address_ada639a2780dbca99614fd0ec955eea4b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::IPAddress::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHN}
{\bkmkend AAAAAAACHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To make it more readable whether there is an error. \par
}{
Definition at line {\b 60} of file {\b IPAddress.hpp}.}\par
}
{\xe \v operator!=\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b MCHEmul::IPAddress::operator!}= (const {\b IPAddress} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHO}
{\bkmkend AAAAAAACHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b IPAddress.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IPAddress} & MCHEmul::IPAddress::operator= (const {\b IPAddress} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACHP}
{\bkmkend AAAAAAACHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::IPAddress::operator== (const {\b IPAddress} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHQ}
{\bkmkend AAAAAAACHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b IPAddress.hpp}.}\par
}
{\xe \v port\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short MCHEmul::IPAddress::port () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHR}
{\bkmkend AAAAAAACHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b IPAddress.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_i_p_address_a90d9fcb74865597d0a058564d4141f74_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::IPAddress}
{\xe \v MCHEmul::IPAddress\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b IPAddress} &  {\i a}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACHS}
{\bkmkend AAAAAAACHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b IPAddress.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b IPAddress.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/COMMS/{\b IPAddress.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::IRQInterrupt Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::IRQInterrupt}
{\xe \v F6500::IRQInterrupt}
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
\par
{
{\f2 #include <IRQInterrupt.hpp>}}\par
Inheritance diagram for F6500::IRQInterrupt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_i_r_q_interrupt__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::IRQInterrupt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_i_r_q_interrupt__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IRQInterrupt} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _ID} = 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isTime} ({\b MCHEmul::CPU} *c) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b executeOverImpl} ({\b MCHEmul::CPU} *c, unsigned int &nC) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Maskarable Interrupt. It could be avoided using the bit I of the status flag. \par
}{
Definition at line {\b 22} of file {\b IRQInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IRQInterrupt\:F6500::IRQInterrupt}
{\xe \v F6500::IRQInterrupt\:IRQInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::IRQInterrupt::IRQInterrupt (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b IRQInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOverImpl\:F6500::IRQInterrupt}
{\xe \v F6500::IRQInterrupt\:executeOverImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void F6500::IRQInterrupt::executeOverImpl ({\b MCHEmul::CPU} *  {\i c}, unsigned int &  {\i nC}){\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To really execute the interrupt. \par
 This must be overloaded by the real interrupt. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First high, then low byte\par
Little - endian.\par
}{
Implements {\b MCHEmul::CPUInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 11} of file {\b IRQInterrupt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_i_r_q_interrupt_a753403a67d40373dba534787903e265b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isTime\:F6500::IRQInterrupt}
{\xe \v F6500::IRQInterrupt\:isTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::IRQInterrupt::isTime ({\b MCHEmul::CPU} *  {\i c}) const{\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only when the status flag B allows it. It is a Maskarable Interrupt. \par
}{
Implements {\b MCHEmul::CPUInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 5} of file {\b IRQInterrupt.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:F6500::IRQInterrupt}
{\xe \v F6500::IRQInterrupt\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int F6500::IRQInterrupt::_ID = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b IRQInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b IRQInterrupt.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b IRQInterrupt.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::LabelCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::LabelCommandParser}
{\xe \v MCHEmul::Assembler::LabelCommandParser}
{\bkmkstart AAAAAAADFE}
{\bkmkend AAAAAAADFE}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::LabelCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_label_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::LabelCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_label_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LabelCommandParser} (unsigned char s=':')\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *s) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser a label. \par
}{
Definition at line {\b 157} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LabelCommandParser\:MCHEmul::Assembler::LabelCommandParser}
{\xe \v MCHEmul::Assembler::LabelCommandParser\:LabelCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::LabelCommandParser::LabelCommandParser (unsigned char  {\i s} = {\f2 ':'}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFF}
{\bkmkend AAAAAAADFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::LabelCommandParser}
{\xe \v MCHEmul::Assembler::LabelCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::LabelCommandParser::canParse (const std::string &  {\i l}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCF}
{\bkmkend AAAAAAADCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 169} of file {\b Parser.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_label_command_parser_a213a3173bab02eed6cac1ad99b4fe217_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::Assembler::LabelCommandParser}
{\xe \v MCHEmul::Assembler::LabelCommandParser\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::LabelCommandParser::initialize (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCJ}
{\bkmkend AAAAAAADCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maybe one of them could need it. \par
}{
Reimplemented from {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 166} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::LabelCommandParser}
{\xe \v MCHEmul::Assembler::LabelCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::LabelCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCO}
{\bkmkend AAAAAAADCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 61} of file {\b Parser.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_label_command_parser_a2d1f8da17b1f99c350713bbf677d4a53_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Parser.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::LabelElement Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::LabelElement}
{\xe \v MCHEmul::Assembler::LabelElement}
{\bkmkstart AAAAAAADFG}
{\bkmkend AAAAAAADFG}
\par
{
{\f2 #include <Grammar.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::LabelElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_label_element__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::LabelElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_label_element__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LabelElement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LabelElement} (const {\b LabelElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LabelElement} & {\b operator=} (const {\b LabelElement} &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _name}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
explanation at the beggining of the file. \par
}}}{
Definition at line {\b 164} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LabelElement\:MCHEmul::Assembler::LabelElement}
{\xe \v MCHEmul::Assembler::LabelElement\:LabelElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::LabelElement::LabelElement (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFH}
{\bkmkend AAAAAAADFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b Grammar.hpp}.}\par
}
{\xe \v LabelElement\:MCHEmul::Assembler::LabelElement}
{\xe \v MCHEmul::Assembler::LabelElement\:LabelElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::LabelElement::LabelElement (const {\b LabelElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADFI}
{\bkmkend AAAAAAADFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:MCHEmul::Assembler::LabelElement}
{\xe \v MCHEmul::Assembler::LabelElement\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LabelElement} & MCHEmul::Assembler::LabelElement::operator= (const {\b LabelElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADFJ}
{\bkmkend AAAAAAADFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _name\:MCHEmul::Assembler::LabelElement}
{\xe \v MCHEmul::Assembler::LabelElement\:_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Assembler::LabelElement::_name}}
\par
{\bkmkstart AAAAAAADFK}
{\bkmkend AAAAAAADFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 175} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::LDA_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::LDA_General}
{\xe \v F6500::LDA_General}
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::LDA_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_a___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::LDA_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_a___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LDA_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b LDA_General}: To aggregate common steps in every LDA instruction. \par
}{
Definition at line {\b 335} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LDA_General\:F6500::LDA_General}
{\xe \v F6500::LDA_General\:LDA_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::LDA_General::LDA_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 338} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::LDA_General}
{\xe \v F6500::LDA_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::LDA_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b LDA.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_a___general_af4fc174b52fd4ca7d55c5fc4121bc510_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b LDA.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::LDX_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::LDX_General}
{\xe \v F6500::LDX_General}
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::LDX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_x___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::LDX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_x___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LDX_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b LDX_General}: To aggregate common steps in every LDX instruction. \par
}{
Definition at line {\b 357} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LDX_General\:F6500::LDX_General}
{\xe \v F6500::LDX_General\:LDX_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::LDX_General::LDX_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 360} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::LDX_General}
{\xe \v F6500::LDX_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::LDX_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b LDX.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_x___general_a33ffb50c170f323008eeb86a4daed347_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b LDX.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::LDY_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::LDY_General}
{\xe \v F6500::LDY_General}
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::LDY_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_y___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::LDY_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_y___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LDY_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b LDY_General}: To aggregate common steps in every LDY instruction. \par
}{
Definition at line {\b 376} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LDY_General\:F6500::LDY_General}
{\xe \v F6500::LDY_General\:LDY_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::LDY_General::LDY_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 379} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::LDY_General}
{\xe \v F6500::LDY_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::LDY_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b LDY.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_d_y___general_a2f3c182fb9acbb8e1f56175feb38b68c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b LDY.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::LSR_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::LSR_General}
{\xe \v F6500::LSR_General}
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::LSR_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_s_r___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::LSR_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_s_r___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LSR_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b LSR_General}: To aggregate common steps in every LSR instruction. \par
}{
Definition at line {\b 395} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LSR_General\:F6500::LSR_General}
{\xe \v F6500::LSR_General\:LSR_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::LSR_General::LSR_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 398} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::LSR_General}
{\xe \v F6500::LSR_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::LSR_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0 is put into\par
}{
Definition at line {\b 5} of file {\b LSR.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_l_s_r___general_a5999c7ebf16a1fc3b36e55b91c377f13_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b LSR.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::Macro Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro}
{\bkmkstart AAAAAAADFL}
{\bkmkend AAAAAAADFL}
\par
{
{\f2 #include <Grammar.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Macro} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Macro} (const std::string &n, const std::string &e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Macro} (const {\b Macro} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Macro} & {\b operator=} (const {\b Macro} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b name} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b equivalent} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ErrorType} {\b error} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< {\b UByte} > & {\b value} (const {\b Macros} &ms) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 47} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Macro\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:Macro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Macro::Macro (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFM}
{\bkmkend AAAAAAADFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Grammar.hpp}.}\par
}
{\xe \v Macro\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:Macro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Macro::Macro (const std::string &  {\i n}, const std::string &  {\i e}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFN}
{\bkmkend AAAAAAADFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b Grammar.hpp}.}\par
}
{\xe \v Macro\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:Macro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Macro::Macro (const {\b Macro} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADFO}
{\bkmkend AAAAAAADFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v equivalent\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:equivalent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::Assembler::Macro::equivalent () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFP}
{\bkmkend AAAAAAADFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b Grammar.hpp}.}\par
}
{\xe \v error\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ErrorType} MCHEmul::Assembler::Macro::error () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFQ}
{\bkmkend AAAAAAADFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b Grammar.hpp}.}\par
}
{\xe \v name\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::Assembler::Macro::name () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFR}
{\bkmkend AAAAAAADFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b Grammar.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_macro_a77dced1bc97a74c09e9de8834f5861cf_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::Macro::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFS}
{\bkmkend AAAAAAADFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To make more visual the analysis of the status of macro. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculated already?\par
}{
Definition at line {\b 80} of file {\b Grammar.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_macro_aed324c5b4bef778f159cd333f5e03ade_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Macro} & MCHEmul::Assembler::Macro::operator= (const {\b Macro} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADFT}
{\bkmkend AAAAAAADFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value\:MCHEmul::Assembler::Macro}
{\xe \v MCHEmul::Assembler::Macro\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< {\b UByte} > & MCHEmul::Assembler::Macro::value (const {\b Macros} &  {\i ms}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFU}
{\bkmkend AAAAAAADFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the value of the macro taking into account potential relations with other macros. \par
The first time it is invoked the very real value is calculated if possible. \par
The variable _error will point whether there was and error in the calculus. \par
}{
Definition at line {\b 76} of file {\b Grammar.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_macro_a03c8a569df97a731517cb97f2572c1f8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Grammar.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::MacroCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::MacroCommandParser}
{\xe \v MCHEmul::Assembler::MacroCommandParser}
{\bkmkstart AAAAAAADFV}
{\bkmkend AAAAAAADFV}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::MacroCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_macro_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::MacroCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_macro_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MacroCommandParser} (unsigned char s='=')\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *s) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned char {\b _symbol} = '='\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser a macro. The symbol defining the separation between definition and value can be redefined. \par
}{
Definition at line {\b 112} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MacroCommandParser\:MCHEmul::Assembler::MacroCommandParser}
{\xe \v MCHEmul::Assembler::MacroCommandParser\:MacroCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::MacroCommandParser::MacroCommandParser (unsigned char  {\i s} = {\f2 '='}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFW}
{\bkmkend AAAAAAADFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::MacroCommandParser}
{\xe \v MCHEmul::Assembler::MacroCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::MacroCommandParser::canParse (const std::string &  {\i l}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCD}
{\bkmkend AAAAAAADCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 120} of file {\b Parser.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_macro_command_parser_a3605d61309f0b17bb8956de0165ee179_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v parse\:MCHEmul::Assembler::MacroCommandParser}
{\xe \v MCHEmul::Assembler::MacroCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::MacroCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCM}
{\bkmkend AAAAAAADCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Until a potential comment.\par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 14} of file {\b Parser.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_macro_command_parser_a137ab3cca048f19c555a8bafa20343b3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _symbol\:MCHEmul::Assembler::MacroCommandParser}
{\xe \v MCHEmul::Assembler::MacroCommandParser\:_symbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::Assembler::MacroCommandParser::_symbol = '='{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADFX}
{\bkmkend AAAAAAADFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Parser.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::Memory Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::Memory}
{\xe \v C64::Memory}
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
\par
{
{\f2 #include <Memory.hpp>}}\par
Inheritance diagram for C64::Memory:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_memory__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::Memory:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_memory__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVICIIView} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _RAM} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BASICROM} = 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _CHARROM} = 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _KERNELROM} = 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _PAGEZERO_SUBSET} = 100\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _STACK_SUBSET} = 101\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _RAM0_SUBSET} = 102\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BASICROM_SUBSET} = 103\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BASICRAM_SUBSET} = 104\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _RAM1_SUBSET} = 105\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _CHARROM_SUBSET} = 106\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _VICREGS_SUBSET} = 107\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _SIDREGS_SUBSET} = 108\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _COLOR_SUBSET} = 109\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _CIA1_SUBSET} = 110\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _CIA2_SUBSET} = 111\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _IO1_SUBSET} = 112\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _IO2_SUBSET} = 113\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _KERNELROM_SUBSET} = 114\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _KERNELRAM_SUBSET} = 115\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK0RAM0_SUBSET} = 200\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK0CHARROM_SUBSET} = 201\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK0RAM1_SUBSET} = 202\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK1RAM_SUBSET} = 203\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK2RAM0_SUBSET} = 204\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK2CHARROM_SUBSET} = 205\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK2RAM1_SUBSET} = 206\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _BANK3RAM_SUBSET} = 207\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _CPU_VIEW} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _VICII_VIEW} = 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The memory itself for the commodore 64... \par
}{
Definition at line {\b 22} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Memory\:C64::Memory}
{\xe \v C64::Memory\:Memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::Memory::Memory ()}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b Memory.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_memory_ae0a16640952c2b50d169e932bbbddc3c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::Memory}
{\xe \v C64::Memory\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::Memory::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To activate the right subsets in the CPU view. \par
}{
Reimplemented from {\b MCHEmul::Memory} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 32} of file {\b Memory.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_memory_acd0820d055243e0e32a17bbb0c06c77a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setVICIIView\:C64::Memory}
{\xe \v C64::Memory\:setVICIIView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::Memory::setVICIIView (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To set the {\b VICII} view, useb by the {\b VICII}. \par
}{
Definition at line {\b 66} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _BANK0CHARROM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK0CHARROM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK0CHARROM_SUBSET = 201{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK0RAM0_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK0RAM0_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK0RAM0_SUBSET = 200{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK0RAM1_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK0RAM1_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK0RAM1_SUBSET = 202{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK1RAM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK1RAM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK1RAM_SUBSET = 203{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK2CHARROM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK2CHARROM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK2CHARROM_SUBSET = 205{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK2RAM0_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK2RAM0_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK2RAM0_SUBSET = 204{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK2RAM1_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK2RAM1_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK2RAM1_SUBSET = 206{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b Memory.hpp}.}\par
}
{\xe \v _BANK3RAM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BANK3RAM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BANK3RAM_SUBSET = 207{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b Memory.hpp}.}\par
}
{\xe \v _BASICRAM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BASICRAM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BASICRAM_SUBSET = 104{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b Memory.hpp}.}\par
}
{\xe \v _BASICROM\:C64::Memory}
{\xe \v C64::Memory\:_BASICROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BASICROM = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b Memory.hpp}.}\par
}
{\xe \v _BASICROM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_BASICROM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_BASICROM_SUBSET = 103{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b Memory.hpp}.}\par
}
{\xe \v _CHARROM\:C64::Memory}
{\xe \v C64::Memory\:_CHARROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_CHARROM = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b Memory.hpp}.}\par
}
{\xe \v _CHARROM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_CHARROM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_CHARROM_SUBSET = 106{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b Memory.hpp}.}\par
}
{\xe \v _CIA1_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_CIA1_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_CIA1_SUBSET = 110{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b Memory.hpp}.}\par
}
{\xe \v _CIA2_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_CIA2_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_CIA2_SUBSET = 111{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b Memory.hpp}.}\par
}
{\xe \v _COLOR_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_COLOR_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_COLOR_SUBSET = 109{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b Memory.hpp}.}\par
}
{\xe \v _CPU_VIEW\:C64::Memory}
{\xe \v C64::Memory\:_CPU_VIEW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_CPU_VIEW = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b Memory.hpp}.}\par
}
{\xe \v _IO1_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_IO1_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_IO1_SUBSET = 112{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b Memory.hpp}.}\par
}
{\xe \v _IO2_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_IO2_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_IO2_SUBSET = 113{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Memory.hpp}.}\par
}
{\xe \v _KERNELRAM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_KERNELRAM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_KERNELRAM_SUBSET = 115{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b Memory.hpp}.}\par
}
{\xe \v _KERNELROM\:C64::Memory}
{\xe \v C64::Memory\:_KERNELROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_KERNELROM = 3{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b Memory.hpp}.}\par
}
{\xe \v _KERNELROM_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_KERNELROM_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_KERNELROM_SUBSET = 114{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b Memory.hpp}.}\par
}
{\xe \v _PAGEZERO_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_PAGEZERO_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_PAGEZERO_SUBSET = 100{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b Memory.hpp}.}\par
}
{\xe \v _RAM\:C64::Memory}
{\xe \v C64::Memory\:_RAM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_RAM = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b Memory.hpp}.}\par
}
{\xe \v _RAM0_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_RAM0_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_RAM0_SUBSET = 102{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b Memory.hpp}.}\par
}
{\xe \v _RAM1_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_RAM1_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_RAM1_SUBSET = 105{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b Memory.hpp}.}\par
}
{\xe \v _SIDREGS_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_SIDREGS_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_SIDREGS_SUBSET = 108{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b Memory.hpp}.}\par
}
{\xe \v _STACK_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_STACK_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_STACK_SUBSET = 101{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b Memory.hpp}.}\par
}
{\xe \v _VICII_VIEW\:C64::Memory}
{\xe \v C64::Memory\:_VICII_VIEW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_VICII_VIEW = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b Memory.hpp}.}\par
}
{\xe \v _VICREGS_SUBSET\:C64::Memory}
{\xe \v C64::Memory\:_VICREGS_SUBSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Memory::_VICREGS_SUBSET = 107{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b Memory.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b Memory.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Memory Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Memory}
{\xe \v MCHEmul::Memory}
{\bkmkstart AAAAAAACHT}
{\bkmkend AAAAAAACHT}
\par
{
{\f2 #include <Memory.hpp>}}\par
Inheritance diagram for MCHEmul::Memory:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Memory:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Content}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} (const {\b Content} &cnt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} (const {\b Memory} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory} & {\b operator=} (const {\b Memory} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Memory} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorages} & {\b phisicalStorages} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsPhisicalStorage} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorage} * {\b phisicalStorage} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} * {\b phisicalStorage} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorageSubsets} & {\b Subsets} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsSubset} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorageSubset} * {\b subset} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} * {\b subset} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MemoryViews} & {\b views} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsView} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MemoryView} * {\b view} (int id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} * {\b view} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MemoryView} * {\b activeView} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} * {\b activeView} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setActiveView} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isIn} (const {\b Address} &a, int &dt) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Stack} * {\b stack} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Stack} * {\b stack} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCPUView} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UByte} & {\b value} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const {\b UByte} &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b values} (const {\b Address} &a, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const {\b UBytes} &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b bytes} (const {\b Address} &a, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const std::vector< {\b UByte} > &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadInto} (const std::string &fN, const {\b Address} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetErrors} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Stack} * {\b lookForStack} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b MemoryView} * {\b lookForCPUView} ()=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Content} {\b _content}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} * {\b _activeView}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Stack} * {\b _stack}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} * {\b _cpuView}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Memory} &m)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A memory is just an agregation of eveytthing above: phisical storages, subsets and views. \par
A view has to de declared as the active one. \par
All accesses will be done throught out that active view. \par
This gives the user the possible to have different "views" of the memory in different moments of the execution of the main cycle from, e.g. different elements in the {\b CPU}. \par
}{
Definition at line {\b 293} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Memory\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:Memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::Memory (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACHU}
{\bkmkend AAAAAAACHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Memory\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:Memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::Memory (const {\b Content} &  {\i cnt})}}
\par
{\bkmkstart AAAAAAACHV}
{\bkmkend AAAAAAACHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 291} of file {\b Memory.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_af009a5d025640a556937f9431c77d67b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Memory\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:Memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::Memory (const {\b Memory} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACHW}
{\bkmkend AAAAAAACHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Memory\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:~Memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Memory::~Memory ()}}
\par
{\bkmkstart AAAAAAACHX}
{\bkmkend AAAAAAACHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 313} of file {\b Memory.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v activeView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:activeView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView} * MCHEmul::Memory::activeView (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHY}
{\bkmkend AAAAAAACHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 401} of file {\b Memory.hpp}.}\par
}
{\xe \v activeView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:activeView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MemoryView} * MCHEmul::Memory::activeView () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHZ}
{\bkmkend AAAAAAACHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 399} of file {\b Memory.hpp}.}\par
}
{\xe \v bytes\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b UByte} > MCHEmul::Memory::bytes (const {\b Address} &  {\i a}, size_t  {\i nB}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIA}
{\bkmkend AAAAAAACIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 429} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a036a65fb88cdb72dd63748b304527d83_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a036a65fb88cdb72dd63748b304527d83_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsPhisicalStorage\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:existsPhisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::existsPhisicalStorage (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIB}
{\bkmkend AAAAAAACIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 373} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ab294be0897a52fb9528d16acd7e696e3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsSubset\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:existsSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::existsSubset (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIC}
{\bkmkend AAAAAAACIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 382} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a9edb93cabefc3871a2cb0d41a8daabcd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:existsView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::existsView (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACID}
{\bkmkend AAAAAAACID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 391} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a7428fe90a5918913c9829af09a37907a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a7428fe90a5918913c9829af09a37907a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Memory::initialize (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It can be overloaded later, to set the specific content of specific zones. \par
By default only subsets have to be initialized, and all of them become active and also active for reading. \par
}{
Reimplemented in {\b C64::Memory} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 436} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ae86228095efa537b295ee8059aba7946_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ae86228095efa537b295ee8059aba7946_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isIn\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:isIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::isIn (const {\b Address} &  {\i a}, int &  {\i dt}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIE}
{\bkmkend AAAAAAACIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 406} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_aa5a8838b4fb5a73e3175ea38bdbbcc30_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_aa5a8838b4fb5a73e3175ea38bdbbcc30_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v lastError\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Memory::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIF}
{\bkmkend AAAAAAACIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the last error happend (usually at construction level) \par
}{
Definition at line {\b 443} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ac1aaad333ce6410b4a5d0d42ac9728e8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v loadInto\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:loadInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Memory::loadInto (const std::string &  {\i fN}, const {\b Address} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIG}
{\bkmkend AAAAAAACIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 439} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_aaf28a195f180da4795746ab51c135070_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_aaf28a195f180da4795746ab51c135070_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v lookForCPUView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:lookForCPUView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b MemoryView} * MCHEmul::Memory::lookForCPUView (){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACIH}
{\bkmkend AAAAAAACIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ac8e522f499e969320701fdb1d06c637f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v lookForStack\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:lookForStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b Stack} * MCHEmul::Memory::lookForStack (){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACII}
{\bkmkend AAAAAAACII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_af9cb45e51cbfadb536877df42b5e51f4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Memory} & MCHEmul::Memory::operator= (const {\b Memory} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACIJ}
{\bkmkend AAAAAAACIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v phisicalStorage\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorage} * MCHEmul::Memory::phisicalStorage (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIK}
{\bkmkend AAAAAAACIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 377} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a54c429d2971e105d742f7fef6e74076a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v phisicalStorage\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorage} * MCHEmul::Memory::phisicalStorage (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIL}
{\bkmkend AAAAAAACIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 375} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a86143be6b3cc1a95f9d99d76f3814da6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v phisicalStorages\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:phisicalStorages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorages} & MCHEmul::Memory::phisicalStorages () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIM}
{\bkmkend AAAAAAACIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 371} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a1f4c92d7372028ef49c682d8b49b8e69_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v resetErrors\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:resetErrors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Memory::resetErrors (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIN}
{\bkmkend AAAAAAACIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 445} of file {\b Memory.hpp}.}\par
}
{\xe \v set\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Memory::set (const {\b Address} &  {\i a}, const std::vector< {\b UByte} > &  {\i v}, bool  {\i f} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIO}
{\bkmkend AAAAAAACIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 431} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a56171dad06eb8b4c72f99f60fe478e45_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Memory::set (const {\b Address} &  {\i a}, const {\b UByte} &  {\i v}, bool  {\i f} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIP}
{\bkmkend AAAAAAACIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{To force even when it is a rom. \cell }
{\row }
}
}{
Definition at line {\b 423} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a4b67f0da6600c11c3641134d0617860b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a4b67f0da6600c11c3641134d0617860b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Memory::set (const {\b Address} &  {\i a}, const {\b UBytes} &  {\i v}, bool  {\i f} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIQ}
{\bkmkend AAAAAAACIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 427} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_adbd620564981bb4dbd40eb1c9511c81e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setActiveView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:setActiveView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Memory::setActiveView (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIR}
{\bkmkend AAAAAAACIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 403} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a7f3385216cdb963b345abc250d927ed9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setCPUView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:setCPUView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Memory::setCPUView (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIS}
{\bkmkend AAAAAAACIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To set the {\b CPU} view. This is important for the right {\b CPU} behivour. \par
}{
Definition at line {\b 418} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a69948361a4afe1cbf632b2541c136925_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v stack\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Stack} * MCHEmul::Memory::stack (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIT}
{\bkmkend AAAAAAACIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 413} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a16012beda33bac5b86094470b4d71477_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v stack\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Stack} * MCHEmul::Memory::stack () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIU}
{\bkmkend AAAAAAACIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the stack space reserve in the memory. This is something every implementation must define. \par
}{
Definition at line {\b 411} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a8db3a2f0eabf3254e9e6c52e183f8517_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a8db3a2f0eabf3254e9e6c52e183f8517_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subset\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:subset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorageSubset} * MCHEmul::Memory::subset (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIV}
{\bkmkend AAAAAAACIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 386} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a94ce6e3017290eaaa633898896c1cfb1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subset\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:subset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorageSubset} * MCHEmul::Memory::subset (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIW}
{\bkmkend AAAAAAACIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 384} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a223ed1aacea29bf69f3c1780b83bb30e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a223ed1aacea29bf69f3c1780b83bb30e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Subsets\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:Subsets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorageSubsets} & MCHEmul::Memory::Subsets () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIX}
{\bkmkend AAAAAAACIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 380} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a6fd72110868fc963c12aee3fb2f98e55_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UByte} & MCHEmul::Memory::value (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIY}
{\bkmkend AAAAAAACIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 421} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ad4321644dcebd71bd231f1e9d77c158f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ad4321644dcebd71bd231f1e9d77c158f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v values\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::Memory::values (const {\b Address} &  {\i a}, size_t  {\i nB}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIZ}
{\bkmkend AAAAAAACIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 425} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ac147db5af50628440739732ead9e2f01_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_ac147db5af50628440739732ead9e2f01_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v view\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:view}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView} * MCHEmul::Memory::view (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJA}
{\bkmkend AAAAAAACJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 395} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a183be49bca41775ec13133b79ddee315_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v view\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:view}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MemoryView} * MCHEmul::Memory::view (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJB}
{\bkmkend AAAAAAACJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 393} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a49b480a4471583d77b53274b82cee3a1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_a49b480a4471583d77b53274b82cee3a1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v views\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:views}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MemoryViews} & MCHEmul::Memory::views () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJC}
{\bkmkend AAAAAAACJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 389} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_aad9162029831812736339fa28debbe9c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Memory} &  {\i m}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACJD}
{\bkmkend AAAAAAACJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _activeView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:_activeView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView}* MCHEmul::Memory::_activeView{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACJE}
{\bkmkend AAAAAAACJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 458} of file {\b Memory.hpp}.}\par
}
{\xe \v _content\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:_content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Content} MCHEmul::Memory::_content{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACJF}
{\bkmkend AAAAAAACJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 455} of file {\b Memory.hpp}.}\par
}
{\xe \v _cpuView\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:_cpuView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView}* MCHEmul::Memory::_cpuView{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACJG}
{\bkmkend AAAAAAACJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 460} of file {\b Memory.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::Memory::_lastError{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACJH}
{\bkmkend AAAAAAACJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 461} of file {\b Memory.hpp}.}\par
}
{\xe \v _stack\:MCHEmul::Memory}
{\xe \v MCHEmul::Memory\:_stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Stack}* MCHEmul::Memory::_stack{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACJI}
{\bkmkend AAAAAAACJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 459} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Memory.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b Memory.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::MemoryView Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView}
{\bkmkstart AAAAAAACKH}
{\bkmkend AAAAAAACKH}
\par
{
{\f2 #include <Memory.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} (int {\b id}, {\b PhisicalStorageSubsets} ss)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} (const {\b MemoryView} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MemoryView} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryView} & {\b operator=} (const {\b MemoryView} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorageSubsets} & {\b subsets} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsSubset} (int {\b id}) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorageSubset} * {\b subset} (int {\b id}) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} * {\b subset} (int {\b id})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isIn} (const {\b Address} &a, int &dt) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const {\b UByte} &d, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UByte} & {\b value} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b values} (const {\b Address} &a, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const {\b UBytes} &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b bytes} (const {\b Address} &a, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const std::vector< {\b UByte} > &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadInto} (const std::string &fN, const {\b Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubsets} {\b _subsets}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b MemoryView} &mv)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A memory view represents a set of subsets over phisical storage (one or many). \par
The subsets can combine either RAM or ROM access and can also overlap each other. \par
}{
Definition at line {\b 222} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MemoryView\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:MemoryView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::MemoryView::MemoryView (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACKI}
{\bkmkend AAAAAAACKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MemoryView\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:MemoryView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::MemoryView::MemoryView (int  {\i id}, {\b PhisicalStorageSubsets}  {\i ss}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKJ}
{\bkmkend AAAAAAACKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The memory view is not the owner of the subsets. \par
}{
Definition at line {\b 228} of file {\b Memory.hpp}.}\par
}
{\xe \v MemoryView\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:MemoryView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::MemoryView::MemoryView (const {\b MemoryView} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACKK}
{\bkmkend AAAAAAACKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~MemoryView\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:~MemoryView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::MemoryView::~MemoryView (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACKL}
{\bkmkend AAAAAAACKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 234} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v bytes\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b MCHEmul::UByte} > MCHEmul::MemoryView::bytes (const {\b Address} &  {\i a}, size_t  {\i nB}) const}}
\par
{\bkmkstart AAAAAAACKM}
{\bkmkend AAAAAAACKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b Memory.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_ad609d9f90b113fd815f5576691638a19_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsSubset\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:existsSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::MemoryView::existsSubset (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKN}
{\bkmkend AAAAAAACKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 245} of file {\b Memory.hpp}.}\par
}
{\xe \v id\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::MemoryView::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKO}
{\bkmkend AAAAAAACKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 239} of file {\b Memory.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::MemoryView::initialize (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACKP}
{\bkmkend AAAAAAACKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To init the memory view. It might be overloaded. By default the "defaultData" value is assigned. \par
}{
Definition at line {\b 270} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_a204de1b662289fc0433e30ccbd616955_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_a204de1b662289fc0433e30ccbd616955_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isIn\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:isIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::MemoryView::isIn (const {\b Address} &  {\i a}, int &  {\i dt}) const}}
\par
{\bkmkstart AAAAAAACKQ}
{\bkmkend AAAAAAACKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b Memory.cpp}.}\par
}
{\xe \v loadInto\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:loadInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::MemoryView::loadInto (const std::string &  {\i fN}, const {\b Address} &  {\i a})}}
\par
{\bkmkstart AAAAAAACKR}
{\bkmkend AAAAAAACKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loaded into the first subset holding the address parameter. \par
}{
Definition at line {\b 235} of file {\b Memory.cpp}.}\par
}
{\xe \v operator=\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryView} & MCHEmul::MemoryView::operator= (const {\b MemoryView} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACKS}
{\bkmkend AAAAAAACKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v set\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::MemoryView::set (const {\b Address} &  {\i a}, const std::vector< {\b UByte} > &  {\i v}, bool  {\i f} = {\f2 false})}}
\par
{\bkmkstart AAAAAAACKT}
{\bkmkend AAAAAAACKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v set\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::MemoryView::set (const {\b Address} &  {\i a}, const {\b UByte} &  {\i d}, bool  {\i f} = {\f2 false})}}
\par
{\bkmkstart AAAAAAACKU}
{\bkmkend AAAAAAACKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If there had been several subsets behind, the write operation would happen on the first writtable subset possible. \par
}{
Definition at line {\b 175} of file {\b Memory.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_af58a87df666524b2d2ee39336309dbc4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::MemoryView::set (const {\b Address} &  {\i a}, const {\b UBytes} &  {\i v}, bool  {\i f} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKV}
{\bkmkend AAAAAAACKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 263} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_a0071e08663e0eb5a3ac2879d536264a6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subset\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:subset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorageSubset} * MCHEmul::MemoryView::subset (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKW}
{\bkmkend AAAAAAACKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 249} of file {\b Memory.hpp}.}\par
}
{\xe \v subset\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:subset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorageSubset} * MCHEmul::MemoryView::subset (int  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKX}
{\bkmkend AAAAAAACKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 247} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_a66070b636ff775a1607996f0a65d3f09_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_a66070b636ff775a1607996f0a65d3f09_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subsets\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:subsets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorageSubsets} & MCHEmul::MemoryView::subsets () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKY}
{\bkmkend AAAAAAACKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 243} of file {\b Memory.hpp}.}\par
}
{\xe \v value\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::UByte} & MCHEmul::MemoryView::value (const {\b Address} &  {\i a}) const}}
\par
{\bkmkstart AAAAAAACKZ}
{\bkmkend AAAAAAACKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If there had been several subsets behind, the read operation would happen on the first readable subset possible. \par
}{
Definition at line {\b 187} of file {\b Memory.cpp}.}\par
}
{\xe \v values\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::MemoryView::values (const {\b Address} &  {\i a}, size_t  {\i nB}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLA}
{\bkmkend AAAAAAACLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 261} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_memory_view_a220e052a1c9cb802da7337838f2d3798_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b MemoryView} &  {\i mv}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACLB}
{\bkmkend AAAAAAACLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _id\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::MemoryView::_id{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACLC}
{\bkmkend AAAAAAACLC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b Memory.hpp}.}\par
}
{\xe \v _subsets\:MCHEmul::MemoryView}
{\xe \v MCHEmul::MemoryView\:_subsets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorageSubsets} MCHEmul::MemoryView::_subsets{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACLD}
{\bkmkend AAAAAAACLD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 280} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Memory.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b Memory.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::MessageBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder}
{\bkmkstart AAAAAAACLE}
{\bkmkend AAAAAAACLE}
\par
{
{\f2 #include <Message.hpp>}}\par
Inheritance diagram for MCHEmul::MessageBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_message_builder__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageBuilder} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageBuilder} (const {\b MessageBuilder} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageBuilder} & {\b operator=} (const {\b MessageBuilder} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MessageBuilder} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b CommunicationMessage} * {\b createMessage} (const std::string &)=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b verifyStructure} (const std::string &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Attributes} {\b attributesFromStr} (const std::string &str) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A builder class to create the messages. \par
An instance of this class is created in the {\b Computer}. \par
The structure of the message should be as follow: \par
1 byte (char) indicating the code of the message. \par
1 byte (char) indicating the number of parameters after. \par
a string indicating the ip (and port) origin of the message. X bytes with the parameters of the message. Usually that parameters are in the form NAMEATTR=VALUE. \par
That parameters should be separated using commas. \par
Neither names nor values can have neither equal nor comma sign in the middle. \par
}{
Definition at line {\b 85} of file {\b Message.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MessageBuilder\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:MessageBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::MessageBuilder::MessageBuilder (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLF}
{\bkmkend AAAAAAACLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b Message.hpp}.}\par
}
{\xe \v MessageBuilder\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:MessageBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::MessageBuilder::MessageBuilder (const {\b MessageBuilder} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACLG}
{\bkmkend AAAAAAACLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To avoid later uncontrolable behaviours. \par
}}
{\xe \v ~MessageBuilder\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:~MessageBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::MessageBuilder::~MessageBuilder (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACLH}
{\bkmkend AAAAAAACLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b Message.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attributesFromStr\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:attributesFromStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Attributes} MCHEmul::MessageBuilder::attributesFromStr (const std::string &  {\i str}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACLI}
{\bkmkend AAAAAAACLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create the list of the parameters any message will need from a string. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First char defined the type.\par
}{
Definition at line {\b 25} of file {\b Message.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_message_builder_acbe175ea04abbda12f76a10e7c46836e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_message_builder_acbe175ea04abbda12f76a10e7c46836e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v createMessage\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:createMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b CommunicationMessage} * MCHEmul::MessageBuilder::createMessage (const std::string & ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACLJ}
{\bkmkend AAAAAAACLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b MCHEmul::StandardMessageBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MessageBuilder} & MCHEmul::MessageBuilder::operator= (const {\b MessageBuilder} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACLL}
{\bkmkend AAAAAAACLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v verifyStructure\:MCHEmul::MessageBuilder}
{\xe \v MCHEmul::MessageBuilder\:verifyStructure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::MessageBuilder::verifyStructure (const std::string &  {\i str}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACLM}
{\bkmkend AAAAAAACLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To verify the right structure of the message rerceived. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First char defined the type.\par
}{
Definition at line {\b 45} of file {\b Message.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_message_builder_a8bbd0b8834a7c2a0f54f4140443f203f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_message_builder_a8bbd0b8834a7c2a0f54f4140443f203f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b Message.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/COMMS/{\b Message.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::NMIInterrupt Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::NMIInterrupt}
{\xe \v F6500::NMIInterrupt}
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
\par
{
{\f2 #include <NMIInterrupt.hpp>}}\par
Inheritance diagram for F6500::NMIInterrupt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_n_m_i_interrupt__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::NMIInterrupt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_n_m_i_interrupt__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NMIInterrupt} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _ID} = 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isTime} ({\b MCHEmul::CPU} *c) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b executeOverImpl} ({\b MCHEmul::CPU} *c, unsigned int &nC) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A non Maskarable Interrupt. Any time it is invoked it has to be executed. \par
}{
Definition at line {\b 22} of file {\b NMIInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v NMIInterrupt\:F6500::NMIInterrupt}
{\xe \v F6500::NMIInterrupt\:NMIInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::NMIInterrupt::NMIInterrupt (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b NMIInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOverImpl\:F6500::NMIInterrupt}
{\xe \v F6500::NMIInterrupt\:executeOverImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void F6500::NMIInterrupt::executeOverImpl ({\b MCHEmul::CPU} *  {\i c}, unsigned int &  {\i nC}){\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To really execute the interrupt. \par
 This must be overloaded by the real interrupt. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First high, then low byte\par
Little - endian.\par
}{
Implements {\b MCHEmul::CPUInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 5} of file {\b NMIInterrupt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_n_m_i_interrupt_a258a0bd2096a38121864009d07708720_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isTime\:F6500::NMIInterrupt}
{\xe \v F6500::NMIInterrupt\:isTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool F6500::NMIInterrupt::isTime ({\b MCHEmul::CPU} *  {\i c}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always. It is a Non Maskarable Interrupt. \par
}{
Implements {\b MCHEmul::CPUInterrupt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 33} of file {\b NMIInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:F6500::NMIInterrupt}
{\xe \v F6500::NMIInterrupt\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int F6500::NMIInterrupt::_ID = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b NMIInterrupt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b NMIInterrupt.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b NMIInterrupt.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::NoChip Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::NoChip}
{\xe \v MCHEmul::NoChip}
{\bkmkstart AAAAAAACLN}
{\bkmkend AAAAAAACLN}
\par
{
{\f2 #include <Chip.hpp>}}\par
Inheritance diagram for MCHEmul::NoChip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_no_chip__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::NoChip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_no_chip__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NoChip} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ({\b CPU} *) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A no chip. \par
}{
Definition at line {\b 93} of file {\b Chip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v NoChip\:MCHEmul::NoChip}
{\xe \v MCHEmul::NoChip\:NoChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::NoChip::NoChip (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLO}
{\bkmkend AAAAAAACLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b Chip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:MCHEmul::NoChip}
{\xe \v MCHEmul::NoChip\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::NoChip::initialize (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 100} of file {\b Chip.hpp}.}\par
}
{\xe \v simulate\:MCHEmul::NoChip}
{\xe \v MCHEmul::NoChip\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::NoChip::simulate ({\b CPU} * ){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate th behaviour of the chip. It has to be defined per chip. \par
Returns true if everything was ok, and false in any other circunstance. \par
 The last error could be recovered from the variable _lastError in that case. \par
The clock cyclees is added. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 103} of file {\b Chip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Chip.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::ORA_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::ORA_General}
{\xe \v F6500::ORA_General}
{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::ORA_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_o_r_a___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::ORA_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_o_r_a___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ORA_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ORA_General}: To aggregate common steps in every ORA instruction. \par
}{
Definition at line {\b 417} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ORA_General\:F6500::ORA_General}
{\xe \v F6500::ORA_General\:ORA_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::ORA_General::ORA_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 420} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::ORA_General}
{\xe \v F6500::ORA_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::ORA_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b ORA.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_o_r_a___general_ab48b0f2b7489561a722785517d824633_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b ORA.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UInt::PackagedBCDFormatManager Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UInt::PackagedBCDFormatManager}
{\xe \v MCHEmul::UInt::PackagedBCDFormatManager}
{\bkmkstart AAAAAAACZV}
{\bkmkend AAAAAAACZV}
\par
{
{\f2 #include <UInt.hpp>}}\par
Inheritance diagram for MCHEmul::UInt::PackagedBCDFormatManager:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_packaged_b_c_d_format_manager__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::UInt::PackagedBCDFormatManager:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_packaged_b_c_d_format_manager__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b add} (const {\b UInt} &u1, const {\b UInt} &u2, bool cIn) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b substract} (const {\b UInt} &u1, const {\b UInt} &u2, bool cIn) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b asUnsignedInt} (const {\b UInt} &u) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b fromUnsignedInt} (unsigned int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b UInt} {\b fromInt} (int n)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For _PACKAGEDBCD format. \par
}{
Definition at line {\b 69} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add\:MCHEmul::UInt::PackagedBCDFormatManager}
{\xe \v MCHEmul::UInt::PackagedBCDFormatManager\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UInt} MCHEmul::UInt::PackagedBCDFormatManager::add (const {\b UInt} & , const {\b UInt} & , bool ) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACZM}
{\bkmkend AAAAAAACZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The way the add is executed depends on the format. \par
}{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 93} of file {\b UInt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_packaged_b_c_d_format_manager_a5244fec06eeb8dd53d15d6d0ec0ad5a4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asUnsignedInt\:MCHEmul::UInt::PackagedBCDFormatManager}
{\xe \v MCHEmul::UInt::PackagedBCDFormatManager\:asUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::UInt::PackagedBCDFormatManager::asUnsignedInt (const {\b UInt} &  {\i u}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACZN}
{\bkmkend AAAAAAACZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 158} of file {\b UInt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_packaged_b_c_d_format_manager_a6adb997d1a2b05acf4089d776d78ea66_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fromInt\:MCHEmul::UInt::PackagedBCDFormatManager}
{\xe \v MCHEmul::UInt::PackagedBCDFormatManager\:fromInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UInt} MCHEmul::UInt::PackagedBCDFormatManager::fromInt (int  {\i n}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACZO}
{\bkmkend AAAAAAACZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MSNibble.\par
LSNibble.\par
}{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 187} of file {\b UInt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_packaged_b_c_d_format_manager_a5ea4aa770ffef12f3438f6ad797a3031_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fromUnsignedInt\:MCHEmul::UInt::PackagedBCDFormatManager}
{\xe \v MCHEmul::UInt::PackagedBCDFormatManager\:fromUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UInt} MCHEmul::UInt::PackagedBCDFormatManager::fromUnsignedInt (unsigned int  {\i n}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACZP}
{\bkmkend AAAAAAACZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MSNibble.\par
LSNibble.\par
}{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 170} of file {\b UInt.cpp}.}\par
}
{\xe \v substract\:MCHEmul::UInt::PackagedBCDFormatManager}
{\xe \v MCHEmul::UInt::PackagedBCDFormatManager\:substract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UInt} MCHEmul::UInt::PackagedBCDFormatManager::substract (const {\b UInt} & , const {\b UInt} & , bool ) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACZQ}
{\bkmkend AAAAAAACZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The same for substracting. \par
}{
Implements {\b MCHEmul::UInt::FormatManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACZJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 125} of file {\b UInt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_1_1_packaged_b_c_d_format_manager_afbcb5c7d27567e0e294ffa3e6685b5a9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UInt.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b UInt.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Instruction::Structure::Parameter Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter}
{\bkmkstart AAAAAAACEO}
{\bkmkend AAAAAAACEO}
\par
{
{\f2 #include <Instruction.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Type} \{ {\b _DATA} = 0
, {\b _DIR}
, {\b _RELJUMP}
, {\b _ABSJUMP}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parameter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parameter} ({\b Type} tp, size_t nB)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parameter} (const {\b Parameter} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parameter} & {\b operator=} (const {\b Parameter} &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Type} {\b _type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b _numberBytes}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::map< unsigned char, {\b Type} > {\b _TYPES}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 34} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Type\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b MCHEmul::Instruction::Structure::Parameter::Type}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAACEP}
{\bkmkend AAAAAAACEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _DATA\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_DATA}
{\qr _DATA{\bkmkstart AAAAAAACEQ}
{\bkmkend AAAAAAACEQ}
\cell }{\cell }{\row }
{\xe \v _DIR\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_DIR}
{\qr _DIR{\bkmkstart AAAAAAACER}
{\bkmkend AAAAAAACER}
\cell }{\cell }{\row }
{\xe \v _RELJUMP\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_RELJUMP}
{\qr _RELJUMP{\bkmkstart AAAAAAACES}
{\bkmkend AAAAAAACES}
\cell }{\cell }{\row }
{\xe \v _ABSJUMP\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_ABSJUMP}
{\qr _ABSJUMP{\bkmkstart AAAAAAACET}
{\bkmkend AAAAAAACET}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 36} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Parameter\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:Parameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Structure::Parameter::Parameter (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEU}
{\bkmkend AAAAAAACEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b Instruction.hpp}.}\par
}
{\xe \v Parameter\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:Parameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Structure::Parameter::Parameter ({\b Type}  {\i tp}, size_t  {\i nB}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEV}
{\bkmkend AAAAAAACEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Instruction.hpp}.}\par
}
{\xe \v Parameter\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:Parameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Structure::Parameter::Parameter (const {\b Parameter} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACEW}
{\bkmkend AAAAAAACEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Parameter} & MCHEmul::Instruction::Structure::Parameter::operator= (const {\b Parameter} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACEX}
{\bkmkend AAAAAAACEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _numberBytes\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_numberBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::Instruction::Structure::Parameter::_numberBytes}}
\par
{\bkmkstart AAAAAAACEY}
{\bkmkend AAAAAAACEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Instruction.hpp}.}\par
}
{\xe \v _type\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Type} MCHEmul::Instruction::Structure::Parameter::_type}}
\par
{\bkmkstart AAAAAAACEZ}
{\bkmkend AAAAAAACEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b Instruction.hpp}.}\par
}
{\xe \v _TYPES\:MCHEmul::Instruction::Structure::Parameter}
{\xe \v MCHEmul::Instruction::Structure::Parameter\:_TYPES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<unsigned char, {\b Type}> MCHEmul::Instruction::Structure::Parameter::_TYPES{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACFA}
{\bkmkend AAAAAAACFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To link a char with the type. It used in many places into the code. \par
}{
Definition at line {\b 40} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Instruction.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::Parser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser}
{\bkmkstart AAAAAAADFY}
{\bkmkend AAAAAAADFY}
\par
{
{\f2 #include <Parser.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} (const {\b CPU} *c, const {\b CommandParsers} &lP=\{ new {\b CommentCommandParser}, new {\b IncludeCommandParser}, new {\b MacroCommandParser}, new {\b StartingPointCommandParser}, new {\b LabelCommandParser}, new {\b BytesCommandParser}, new {\b InstructionCommandParser} \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} ({\b Parser} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} & {\b operator=} (const {\b Parser} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Parser} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CPU} * {\b cpu} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CommandParsers} & {\b commandParsers} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b commentSymbol} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Semantic} * {\b parse} (const std::string &fN, const std::string &fA="") const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Errors} {\b errors} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Now it is time to define the parser itself. \par
To convert a file text (or text) into an internal structure. \par
The parser is a line parser. That is, it is only able to parser a line. \par
There can be added specific instruction parsers but always a comment command parser must exist. \par
It is used to determine whether a line finishes or not. \par
}{
Definition at line {\b 228} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Parser\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:Parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Parser::Parser (const {\b CPU} *  {\i c}, const {\b CommandParsers} &  {\i lP} = {\f2 \{\~ new\~ {\b CommentCommandParser},\~ new\~ {\b IncludeCommandParser},\~ new\~ {\b MacroCommandParser},\~ new\~ {\b StartingPointCommandParser},\~ new\~ {\b LabelCommandParser},\~ new\~ {\b BytesCommandParser},\~ new\~ {\b InstructionCommandParser}\~ \}})}}
\par
{\bkmkstart AAAAAAADFZ}
{\bkmkend AAAAAAADFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 173} of file {\b Parser.cpp}.}\par
}
{\xe \v Parser\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:Parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Parser::Parser ({\b Parser} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAADGA}
{\bkmkend AAAAAAADGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Parser\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:~Parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Parser::~Parser (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADGB}
{\bkmkend AAAAAAADGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The parser doesn't own the instructions but the {\b CPU}, but the line parsers. \par
}{
Definition at line {\b 242} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v commandParsers\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:commandParsers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CommandParsers} & MCHEmul::Assembler::Parser::commandParsers () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADGC}
{\bkmkend AAAAAAADGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 247} of file {\b Parser.hpp}.}\par
}
{\xe \v commentSymbol\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:commentSymbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::Assembler::Parser::commentSymbol () const}}
\par
{\bkmkstart AAAAAAADGD}
{\bkmkend AAAAAAADGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b Parser.cpp}.}\par
}
{\xe \v cpu\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CPU} * MCHEmul::Assembler::Parser::cpu () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADGE}
{\bkmkend AAAAAAADGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 245} of file {\b Parser.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_parser_ad01dabf028bb41a8b8f08db70c2c1060_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v errors\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:errors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Errors} MCHEmul::Assembler::Parser::errors () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADGF}
{\bkmkend AAAAAAADGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 282} of file {\b Parser.hpp}.}\par
}
{\xe \v operator!\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::Parser::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADGG}
{\bkmkend AAAAAAADGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify checking whether there was or not an error parsing. \par
}{
Definition at line {\b 286} of file {\b Parser.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Parser} & MCHEmul::Assembler::Parser::operator= (const {\b Parser} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAADGH}
{\bkmkend AAAAAAADGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse\:MCHEmul::Assembler::Parser}
{\xe \v MCHEmul::Assembler::Parser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Assembler::Semantic} * MCHEmul::Assembler::Parser::parse (const std::string &  {\i fN}, const std::string &  {\i fA} = {\f2 ""}) const}}
\par
{\bkmkstart AAAAAAADGI}
{\bkmkend AAAAAAADGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type of code that is is accepted: The example has been written using the machine languaje of the Commodore 64 ; Simple test that everything works \par
; By Ignacio Cea \par
\par
; MACROS \par
FOREGROUND = $D020 \par
BACKGROUND = $D021 \par
\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
= $C000 \par
\par
; Now the code \par
\par
START: LDA #$00 ;Load accumulator \par
 STA BACKGROUND \par
 STA FOREGROUND \par
 BNE START \par
\par
; Very simple Rules: ; Means comment. After that, nothing will be taken into account. \par
MACROS & LABELS are represented using characteres (upper and lower case) and numbers, but never starting with number. \par
NUMBERS AND DIRECTIONS can be represented using decimal, octal (starting with 0) and hexadecimal (with $) numbers. \par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
= xxxx will identify the address from which the code after will be inserted!\par}
The method can receive also another file with "actions" to execute over any line. \par
This action must be simply number. How to interpret them should be determine later. \par
}{
Definition at line {\b 210} of file {\b Parser.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_parser_aa4b3b8007f1698b62de64a8ea996e569_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Parser.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::PeerCommunicationChannel Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel}
{\bkmkstart AAAAAAACLP}
{\bkmkend AAAAAAACLP}
\par
{
{\f2 #include <Channel.hpp>}}\par
Collaboration diagram for MCHEmul::PeerCommunicationChannel:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_peer_communication_channel__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PeerCommunicationChannel} (unsigned short p, unsigned int nC, const {\b IPAddress} &a={\b IPAddress}())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PeerCommunicationChannel} (const {\b PeerCommunicationChannel} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PeerCommunicationChannel} & {\b operator=} (const {\b PeerCommunicationChannel} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~PeerCommunicationChannel} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b listenAtPort} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b simulatenousConnections} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b IPAddress} & {\b connectedTo} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isChannelInitiated} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isChannelConnected} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b finalize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b receive} (std::string &str, {\b IPAddress} &from)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b send} (const std::string &str, const {\b IPAddress} &to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b send} (const {\b CommunicationMessage} &msg, const {\b IPAddress} &to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b send} (const std::string &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b send} (const {\b CommunicationMessage} &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b lastError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _listenAtPort}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _simultaneousConnections}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b IPAddress} {\b _connectedTo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
RakNet::RakPeerInterface * {\b _peer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _channelInitialized}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _channelConnected}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b _lastError}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class {\b PeerCommunicationChannel} allows the communication between pieces of the emulator. e.g. emulator and any external tool. \par
It could be useful e.g. to run in debug mode the emulator or to know which is the status of the computer. \par
}{
Definition at line {\b 28} of file {\b Channel.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PeerCommunicationChannel\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:PeerCommunicationChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PeerCommunicationChannel::PeerCommunicationChannel (unsigned short  {\i p}, unsigned int  {\i nC}, const {\b IPAddress} &  {\i a} = {\f2 {\b IPAddress}\~ ()})}}
\par
{\bkmkstart AAAAAAACLQ}
{\bkmkend AAAAAAACLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To create the communication channel, but not to open it. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{: The communication channel needs to listen at a specific port. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nC} \cell }{: The default number of communications supported. 1 default for a pure peer comm. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i to} \cell }{: The direction this peer is connected to, if any. It could be nothing! \cell }
{\row }
}
}{
Definition at line {\b 6} of file {\b Channel.cpp}.}\par
}
{\xe \v PeerCommunicationChannel\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:PeerCommunicationChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PeerCommunicationChannel::PeerCommunicationChannel (const {\b PeerCommunicationChannel} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACLR}
{\bkmkend AAAAAAACLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~PeerCommunicationChannel\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:~PeerCommunicationChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PeerCommunicationChannel::~PeerCommunicationChannel (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACLS}
{\bkmkend AAAAAAACLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b Channel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v connectedTo\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:connectedTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b IPAddress} & MCHEmul::PeerCommunicationChannel::connectedTo () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLT}
{\bkmkend AAAAAAACLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Channel.hpp}.}\par
}
{\xe \v finalize\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:finalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::finalize ()}}
\par
{\bkmkstart AAAAAAACLU}
{\bkmkend AAAAAAACLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b Channel.cpp}.}\par
}
{\xe \v initialize\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::initialize ()}}
\par
{\bkmkstart AAAAAAACLV}
{\bkmkend AAAAAAACLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b Channel.cpp}.}\par
}
{\xe \v isChannelConnected\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:isChannelConnected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::isChannelConnected (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLW}
{\bkmkend AAAAAAACLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b Channel.hpp}.}\par
}
{\xe \v isChannelInitiated\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:isChannelInitiated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::isChannelInitiated (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLX}
{\bkmkend AAAAAAACLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Channel.hpp}.}\par
}
{\xe \v lastError\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::PeerCommunicationChannel::lastError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLY}
{\bkmkend AAAAAAACLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b Channel.hpp}.}\par
}
{\xe \v listenAtPort\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:listenAtPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short MCHEmul::PeerCommunicationChannel::listenAtPort () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLZ}
{\bkmkend AAAAAAACLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Channel.hpp}.}\par
}
{\xe \v operator!\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMA}
{\bkmkend AAAAAAACMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b Channel.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PeerCommunicationChannel} & MCHEmul::PeerCommunicationChannel::operator= (const {\b PeerCommunicationChannel} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACMB}
{\bkmkend AAAAAAACMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v receive\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:receive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::receive (std::string &  {\i str}, {\b MCHEmul::IPAddress} &  {\i from})}}
\par
{\bkmkstart AAAAAAACMC}
{\bkmkend AAAAAAACMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Receiving a communication. \\ \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true when the communication has been well managed. In that case "str" will hold the string received and "from" the address of the machine sending it through. \par
}}}{
Definition at line {\b 67} of file {\b Channel.cpp}.}\par
}
{\xe \v send\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::send (const {\b CommunicationMessage} &  {\i msg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMD}
{\bkmkend AAAAAAACMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Channel.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_peer_communication_channel_a74da350ef516bac9f35251de065301b6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v send\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::send (const {\b CommunicationMessage} &  {\i msg}, const {\b IPAddress} &  {\i to}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACME}
{\bkmkend AAAAAAACME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b Channel.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_peer_communication_channel_a2e68bb7ea211abfcaa9abc320a988795_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v send\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::send (const std::string &  {\i str}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMF}
{\bkmkend AAAAAAACMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To send a communication to the connected machine if any. Otherwise an error is generated. \par
}{
Definition at line {\b 74} of file {\b Channel.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_peer_communication_channel_ae52999bb409bd0075fe7aa3826e7d7d0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v send\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::send (const std::string &  {\i str}, const {\b IPAddress} &  {\i to})}}
\par
{\bkmkstart AAAAAAACMG}
{\bkmkend AAAAAAACMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To send a communication to another machine. The parameters needed are tyhe string to send it accross and the address of the machine to ssend it to. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true is everything went ok. \par
}}}{
Definition at line {\b 132} of file {\b Channel.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_peer_communication_channel_a92aa0323f108365115aac97107395e11_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_peer_communication_channel_a92aa0323f108365115aac97107395e11_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v simulatenousConnections\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:simulatenousConnections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short MCHEmul::PeerCommunicationChannel::simulatenousConnections () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMH}
{\bkmkend AAAAAAACMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b Channel.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _channelConnected\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_channelConnected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::_channelConnected{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMI}
{\bkmkend AAAAAAACMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b Channel.hpp}.}\par
}
{\xe \v _channelInitialized\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_channelInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PeerCommunicationChannel::_channelInitialized{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMJ}
{\bkmkend AAAAAAACMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b Channel.hpp}.}\par
}
{\xe \v _connectedTo\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_connectedTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b IPAddress} MCHEmul::PeerCommunicationChannel::_connectedTo{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMK}
{\bkmkend AAAAAAACMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b Channel.hpp}.}\par
}
{\xe \v _lastError\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_lastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::PeerCommunicationChannel::_lastError{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACML}
{\bkmkend AAAAAAACML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b Channel.hpp}.}\par
}
{\xe \v _listenAtPort\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_listenAtPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short MCHEmul::PeerCommunicationChannel::_listenAtPort{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMM}
{\bkmkend AAAAAAACMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b Channel.hpp}.}\par
}
{\xe \v _peer\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_peer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
RakNet::RakPeerInterface* MCHEmul::PeerCommunicationChannel::_peer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMN}
{\bkmkend AAAAAAACMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b Channel.hpp}.}\par
}
{\xe \v _simultaneousConnections\:MCHEmul::PeerCommunicationChannel}
{\xe \v MCHEmul::PeerCommunicationChannel\:_simultaneousConnections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short MCHEmul::PeerCommunicationChannel::_simultaneousConnections{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMO}
{\bkmkend AAAAAAACMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b Channel.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b Channel.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/COMMS/{\b Channel.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::PhisicalStorage Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage}
{\bkmkstart AAAAAAACMP}
{\bkmkend AAAAAAACMP}
\par
{
{\f2 #include <Memory.hpp>}}\par
Collaboration diagram for MCHEmul::PhisicalStorage:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Type} \{ {\b _ROM}
, {\b _RAM}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} (int {\b id}, {\b Type} t, size_t s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} (const {\b PhisicalStorage} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} & {\b operator=} (const {\b PhisicalStorage} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Type} {\b type} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canBeWriten} (bool f=false) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b PhisicalStorageSubset}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b UByte} {\b _DEFAULTVALUE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (size_t pB, const {\b UByte} &d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UByte} & {\b value} (size_t pB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b values} (size_t pB, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (size_t pB, const {\b UBytes} &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b bytes} (size_t pB, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (size_t pB, const std::vector< {\b UByte} > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadInto} (const std::string &fN, size_t p=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b _id} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Type} {\b _type} = {\b Type::_RAM}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b MCHEmul::UByte} > {\b _data}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents what phisically speaking the memoy is: \par
Just a place to keep info. \par
It can be either RAM or ROM depending whether is possible to modify data. \par
The phisical storage can only be accesed through a subset, controlling the boundaries of the phisical storage. \par
}{
Definition at line {\b 34} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Type\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b MCHEmul::PhisicalStorage::Type}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAACMQ}
{\bkmkend AAAAAAACMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _ROM\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:_ROM}
{\qr _ROM{\bkmkstart AAAAAAACMR}
{\bkmkend AAAAAAACMR}
\cell }{\cell }{\row }
{\xe \v _RAM\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:_RAM}
{\qr _RAM{\bkmkstart AAAAAAACMS}
{\bkmkend AAAAAAACMS}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 42} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PhisicalStorage\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:PhisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PhisicalStorage::PhisicalStorage (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACMT}
{\bkmkend AAAAAAACMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PhisicalStorage\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:PhisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PhisicalStorage::PhisicalStorage (int  {\i id}, {\b Type}  {\i t}, size_t  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMU}
{\bkmkend AAAAAAACMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Memory.hpp}.}\par
}
{\xe \v PhisicalStorage\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:PhisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PhisicalStorage::PhisicalStorage (const {\b PhisicalStorage} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACMV}
{\bkmkend AAAAAAACMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v bytes\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b MCHEmul::UByte} > MCHEmul::PhisicalStorage::bytes (size_t  {\i pB}, size_t  {\i nB}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMW}
{\bkmkend AAAAAAACMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b Memory.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_ac5783e4ce16e865222118465bccb3c19_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_ac5783e4ce16e865222118465bccb3c19_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v canBeWriten\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:canBeWriten}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorage::canBeWriten (bool  {\i f} = {\f2 false}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMX}
{\bkmkend AAAAAAACMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i f} \cell }{force the writting. \cell }
{\row }
}
}{
Definition at line {\b 62} of file {\b Memory.hpp}.}\par
}
{\xe \v id\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::PhisicalStorage::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMY}
{\bkmkend AAAAAAACMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Memory.hpp}.}\par
}
{\xe \v loadInto\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:loadInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorage::loadInto (const std::string &  {\i fN}, size_t  {\i p} = {\f2 0}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMZ}
{\bkmkend AAAAAAACMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Load the info, as many bytes as possible, from a specific byte of the memory. If nothing is said, the info is load from he vey first bye. \par
}{
Definition at line {\b 107} of file {\b Memory.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_a41a010342c97fc8fcf64e5bdcd9b2e5d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorage} & MCHEmul::PhisicalStorage::operator= (const {\b PhisicalStorage} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACNA}
{\bkmkend AAAAAAACNA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v set\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorage::set (size_t  {\i pB}, const std::vector< {\b UByte} > &  {\i v}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACNB}
{\bkmkend AAAAAAACNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_aaa2a7b109b6f079a4981af035dd7ae42_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorage::set (size_t  {\i pB}, const {\b UByte} &  {\i d}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACNC}
{\bkmkend AAAAAAACNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Managing the content of the memory. \par
Take into account that whether it is a RAM or a ROM is not controlled here. \par
It is something that has to be guarantteed by the subsets built on top of this. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very real write type access.\par
}{
Definition at line {\b 73} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_a5fe8aaaced4e084c132f795186bb2609_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorage::set (size_t  {\i pB}, const {\b UBytes} &  {\i v}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACND}
{\bkmkend AAAAAAACND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_a9c5129fd3b20511defe52306de1cc615_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::PhisicalStorage::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNE}
{\bkmkend AAAAAAACNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b Memory.hpp}.}\par
}
{\xe \v type\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Type} MCHEmul::PhisicalStorage::type () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNF}
{\bkmkend AAAAAAACNF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b Memory.hpp}.}\par
}
{\xe \v value\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UByte} & MCHEmul::PhisicalStorage::value (size_t  {\i pB}) const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACNG}
{\bkmkend AAAAAAACNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very real read type access.\par
}{
Definition at line {\b 75} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_afe23422b938098f54ea9740748789c9c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v values\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::PhisicalStorage::values (size_t  {\i pB}, size_t  {\i nB}) const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACNH}
{\bkmkend AAAAAAACNH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_a5180c00677242ea924fc42d66a3f529f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _data\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b MCHEmul::UByte}> MCHEmul::PhisicalStorage::_data{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACNI}
{\bkmkend AAAAAAACNI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b Memory.hpp}.}\par
}
{\xe \v _DEFAULTVALUE\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:_DEFAULTVALUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} MCHEmul::PhisicalStorage::_DEFAULTVALUE{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACNJ}
{\bkmkend AAAAAAACNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The default value which is used to initialize the memory, can be changed. \par
}{
Definition at line {\b 38} of file {\b Memory.hpp}.}\par
}
{\xe \v _id\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int MCHEmul::PhisicalStorage::_id = -1{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACNK}
{\bkmkend AAAAAAACNK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Memory.hpp}.}\par
}
{\xe \v _type\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Type} MCHEmul::PhisicalStorage::_type = {\b Type::_RAM}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACNL}
{\bkmkend AAAAAAACNL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b Memory.hpp}.}\par
}
{\xe \v PhisicalStorageSubset\:MCHEmul::PhisicalStorage}
{\xe \v MCHEmul::PhisicalStorage\:PhisicalStorageSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend MCHEmul::PhisicalStorage::PhisicalStorageSubset}}
\par
{\bkmkstart AAAAAAACNM}
{\bkmkend AAAAAAACNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Memory.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b Memory.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::PhisicalStorageSubset Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset}
{\bkmkstart AAAAAAACNN}
{\bkmkend AAAAAAACNN}
\par
{
{\f2 #include <Memory.hpp>}}\par
Inheritance diagram for MCHEmul::PhisicalStorageSubset:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::PhisicalStorageSubset:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} (int {\b id}, {\b PhisicalStorage} *pS, size_t pp, const {\b Address} &a, size_t s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} (const {\b PhisicalStorageSubset} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~PhisicalStorageSubset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorageSubset} & {\b operator=} (const {\b PhisicalStorageSubset} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PhisicalStorage} * {\b phisicalStorage} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} * {\b phisicalStorage} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage::Type} {\b type} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Address} & {\b initialAddress} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b active} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setActive} (bool a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b activeForReading} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setActiveForReading} (bool aR)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canBeWriten} (bool f) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isIn} (const {\b Address} &a, int &dt) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const {\b UByte} &d, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UByte} & {\b value} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b values} (const {\b Address} &a, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const {\b UBytes} &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b UByte} > {\b bytes} (const {\b Address} &a, size_t nB) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Address} &a, const std::vector< {\b UByte} > &v, bool f=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b load} (const std::string &fN, size_t sA, bool bE=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadInto} (const std::string &fN, const {\b Address} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadInto} (const std::string &fN)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fixDefaultValues} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b MemoryView}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setValue} (size_t nB, const {\b UByte} &d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b UByte} & {\b readValue} (size_t nB) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b _id} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PhisicalStorage} * {\b _phisicalStorage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b _initialPhisicalPosition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b _initialAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b _size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _active}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _activeForReading}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b MCHEmul::UByte} > {\b _defaultData}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b PhisicalStorageSubset} &ps)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a subset of the physical storage. \par
Many subsets can be created over the same physical location. \par
}{
Definition at line {\b 100} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PhisicalStorageSubset\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:PhisicalStorageSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PhisicalStorageSubset::PhisicalStorageSubset (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACNO}
{\bkmkend AAAAAAACNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PhisicalStorageSubset\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:PhisicalStorageSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PhisicalStorageSubset::PhisicalStorageSubset (int  {\i id}, {\b MCHEmul::PhisicalStorage} *  {\i pS}, size_t  {\i pp}, const {\b Address} &  {\i a}, size_t  {\i s})}}
\par
{\bkmkstart AAAAAAACNP}
{\bkmkend AAAAAAACNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It is guarantteed that it must a subset within the boundaries of the phisical storage behind. \par
Otherwise the view will be have the same size than that. \par
The reference to the phisical storage can't be null at all. \par
 The subset is not the owner of the phisical storage. \par
THe phisical storage can be either active or inactive. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pp} \cell }{link a phisical \cell }
{\row }
}
}{
Definition at line {\b 17} of file {\b Memory.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_ac9f4037e54841056bf7b9b1f58ba8259_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v PhisicalStorageSubset\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:PhisicalStorageSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::PhisicalStorageSubset::PhisicalStorageSubset (const {\b PhisicalStorageSubset} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACNQ}
{\bkmkend AAAAAAACNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~PhisicalStorageSubset\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:~PhisicalStorageSubset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual MCHEmul::PhisicalStorageSubset::~PhisicalStorageSubset (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACNR}
{\bkmkend AAAAAAACNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nothing to do by default.\par
}{
Definition at line {\b 116} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v active\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:active}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::active () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNS}
{\bkmkend AAAAAAACNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b Memory.hpp}.}\par
}
{\xe \v activeForReading\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:activeForReading}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::activeForReading () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNT}
{\bkmkend AAAAAAACNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b Memory.hpp}.}\par
}
{\xe \v bytes\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b MCHEmul::UByte} > MCHEmul::PhisicalStorageSubset::bytes (const {\b Address} &  {\i a}, size_t  {\i nB}) const}}
\par
{\bkmkstart AAAAAAACNU}
{\bkmkend AAAAAAACNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When some of the requested position is out the boundaries, an empty map is returned. \par
}{
Definition at line {\b 81} of file {\b Memory.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_af4ba5b0a04c6097eddd2be7d4bc03463_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v canBeWriten\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:canBeWriten}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::canBeWriten (bool  {\i f}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNV}
{\bkmkend AAAAAAACNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a07b8984d68102d268ca4b62913219e7f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a07b8984d68102d268ca4b62913219e7f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fixDefaultValues\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:fixDefaultValues}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorageSubset::fixDefaultValues (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNW}
{\bkmkend AAAAAAACNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To keep the values for fither initialization. \par
}{
Definition at line {\b 185} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a153d0d6580e4a949af9a5e9d0c963408_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v id\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::PhisicalStorageSubset::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNX}
{\bkmkend AAAAAAACNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Id for the view. It is diiferent than the id of the phisical storage behind. \par
}{
Definition at line {\b 122} of file {\b Memory.hpp}.}\par
}
{\xe \v initialAddress\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:initialAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Address} & MCHEmul::PhisicalStorageSubset::initialAddress () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNY}
{\bkmkend AAAAAAACNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_af5df1745a7a25571923c409533a47d85_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::PhisicalStorageSubset::initialize (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To init the memory. It might be overloaded. By default the "defaultData" value is assigned. It doesn't matter whether the subset is or not active. \par
}{
Reimplemented in {\b C64::CIA1Registers} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAST \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::CIA2Registers} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b C64::VICIIRegisters} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABCX \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b MCHEmul::Stack} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACNZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 170} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_add052e8acc48c2dc020b091a740b91c7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_add052e8acc48c2dc020b091a740b91c7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isIn\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:isIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::isIn (const {\b Address} &  {\i a}, int &  {\i dt}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOA}
{\bkmkend AAAAAAACOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The address may only be "in" when the subset is active. \par
}{
Definition at line {\b 148} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_ab5f145065b365ee0d9c14860eb44a1a3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_ab5f145065b365ee0d9c14860eb44a1a3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v load\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:load}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::load (const std::string &  {\i fN}, size_t  {\i sA}, bool  {\i bE} = {\f2 true})}}
\par
{\bkmkstart AAAAAAACOB}
{\bkmkend AAAAAAACOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First "sA" bytes of the file defining the address where to load the bytes. It is also necessary to define whether that address is or not big endian. \par
}{
Definition at line {\b 39} of file {\b Memory.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a78a69d147183e4b71faa46d40579a7bc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v loadInto\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:loadInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::loadInto (const std::string &  {\i fN}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOC}
{\bkmkend AAAAAAACOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The address where to load things into is always the initial address of the memory. \par
}{
Definition at line {\b 181} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_afeba8c79926f2fba8f3b28ac03e95a51_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v loadInto\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:loadInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::loadInto (const std::string &  {\i fN}, const {\b Address} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOD}
{\bkmkend AAAAAAACOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Everything from the memory position received. \par
}{
Definition at line {\b 177} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a69bdca5529e55d27606fafb806f20301_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a69bdca5529e55d27606fafb806f20301_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorageSubset} & MCHEmul::PhisicalStorageSubset::operator= (const {\b PhisicalStorageSubset} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACOE}
{\bkmkend AAAAAAACOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v phisicalStorage\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorage} * MCHEmul::PhisicalStorageSubset::phisicalStorage (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOF}
{\bkmkend AAAAAAACOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b Memory.hpp}.}\par
}
{\xe \v phisicalStorage\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PhisicalStorage} * MCHEmul::PhisicalStorageSubset::phisicalStorage () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOG}
{\bkmkend AAAAAAACOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b Memory.hpp}.}\par
}
{\xe \v readValue\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:readValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const {\b UByte} & MCHEmul::PhisicalStorageSubset::readValue (size_t  {\i nB}) const{\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACOH}
{\bkmkend AAAAAAACOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 197} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_aceff286e4b286b3dfb15db4b0fabcd46_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_aceff286e4b286b3dfb15db4b0fabcd46_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorageSubset::set (const {\b Address} &  {\i a}, const std::vector< {\b UByte} > &  {\i v}, bool  {\i f} = {\f2 false})}}
\par
{\bkmkstart AAAAAAACOI}
{\bkmkend AAAAAAACOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v set\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorageSubset::set (const {\b Address} &  {\i a}, const {\b UByte} &  {\i d}, bool  {\i f} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOJ}
{\bkmkend AAAAAAACOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The internal method "setValue" is invoked when possible. When the address requested is not "in" the subset, nothing happens. \par
}{
Definition at line {\b 153} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_af6f3e0e996fa65db1b6a4fdb4a89fbbb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_af6f3e0e996fa65db1b6a4fdb4a89fbbb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorageSubset::set (const {\b Address} &  {\i a}, const {\b UBytes} &  {\i v}, bool  {\i f} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOK}
{\bkmkend AAAAAAACOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a1c7bb0e3ee5749b87581313882ca68fe_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setActive\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:setActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorageSubset::setActive (bool  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOL}
{\bkmkend AAAAAAACOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b Memory.hpp}.}\par
}
{\xe \v setActiveForReading\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:setActiveForReading}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::PhisicalStorageSubset::setActiveForReading (bool  {\i aR}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOM}
{\bkmkend AAAAAAACOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b Memory.hpp}.}\par
}
{\xe \v setValue\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:setValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::PhisicalStorageSubset::setValue (size_t  {\i nB}, const {\b UByte} &  {\i d}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACON}
{\bkmkend AAAAAAACON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
They could be overeloaded for specific subsets: Chips registers,... By default, the instructions are transmitted to the physical storage. At this point there is guaranteed that the byte requested exist in the phisical storage. The number of register (relative) with in the phisical storage is received. \par
}{
Definition at line {\b 195} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_af20632928476477041fa71cd4a0d64d1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_af20632928476477041fa71cd4a0d64d1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::PhisicalStorageSubset::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOO}
{\bkmkend AAAAAAACOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b Memory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a3e56c5a3e82014cd33d6b03fb283e74f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v type\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorage::Type} MCHEmul::PhisicalStorageSubset::type () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOP}
{\bkmkend AAAAAAACOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a95d9d90a126d77b0c9c267d81972da95_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a95d9d90a126d77b0c9c267d81972da95_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UByte} & MCHEmul::PhisicalStorageSubset::value (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOQ}
{\bkmkend AAAAAAACOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The internal method "readValue" is invoked when possible. When the address requested is not "in" the subset, -0 is returned. \par
}{
Definition at line {\b 157} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_aed9ce60cb6a01905e430606e4ddac55c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_aed9ce60cb6a01905e430606e4ddac55c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v values\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::PhisicalStorageSubset::values (const {\b Address} &  {\i a}, size_t  {\i nB}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOR}
{\bkmkend AAAAAAACOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b Memory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a94ed29e6e921f2bc74135b22b383be72_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_phisical_storage_subset_a94ed29e6e921f2bc74135b22b383be72_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b PhisicalStorageSubset} &  {\i ps}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACOS}
{\bkmkend AAAAAAACOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _active\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_active}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::_active{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOT}
{\bkmkend AAAAAAACOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 211} of file {\b Memory.hpp}.}\par
}
{\xe \v _activeForReading\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_activeForReading}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::PhisicalStorageSubset::_activeForReading{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOU}
{\bkmkend AAAAAAACOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b Memory.hpp}.}\par
}
{\xe \v _defaultData\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_defaultData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b MCHEmul::UByte}> MCHEmul::PhisicalStorageSubset::_defaultData{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOV}
{\bkmkend AAAAAAACOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 213} of file {\b Memory.hpp}.}\par
}
{\xe \v _id\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int MCHEmul::PhisicalStorageSubset::_id = -1{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOW}
{\bkmkend AAAAAAACOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 201} of file {\b Memory.hpp}.}\par
}
{\xe \v _initialAddress\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_initialAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::PhisicalStorageSubset::_initialAddress{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOX}
{\bkmkend AAAAAAACOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Which address does the initial position defined above represent ? \par
}{
Definition at line {\b 206} of file {\b Memory.hpp}.}\par
}
{\xe \v _initialPhisicalPosition\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_initialPhisicalPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::PhisicalStorageSubset::_initialPhisicalPosition{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOY}
{\bkmkend AAAAAAACOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The position on the phisical storage, this subset is connected to. \par
}{
Definition at line {\b 204} of file {\b Memory.hpp}.}\par
}
{\xe \v _phisicalStorage\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_phisicalStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PhisicalStorage}* MCHEmul::PhisicalStorageSubset::_phisicalStorage{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOZ}
{\bkmkend AAAAAAACOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b Memory.hpp}.}\par
}
{\xe \v _size\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::PhisicalStorageSubset::_size{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACPA}
{\bkmkend AAAAAAACPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
How many bytes of info does this subset represent? \par
}{
Definition at line {\b 208} of file {\b Memory.hpp}.}\par
}
{\xe \v MemoryView\:MCHEmul::PhisicalStorageSubset}
{\xe \v MCHEmul::PhisicalStorageSubset\:MemoryView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend MCHEmul::PhisicalStorageSubset::MemoryView}}
\par
{\bkmkstart AAAAAAACPB}
{\bkmkend AAAAAAACPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b Memory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Memory.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b Memory.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::ProgramCounter Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter}
{\bkmkstart AAAAAAACPC}
{\bkmkend AAAAAAACPC}
\par
{
{\f2 #include <ProgramCounter.hpp>}}\par
Inheritance diagram for MCHEmul::ProgramCounter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::ProgramCounter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} (size_t sz)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} (const {\b ProgramCounter} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} & {\b operator=} (const {\b ProgramCounter} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b asAddress} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAddress} (const {\b Address} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b increment} (size_t n=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b decrement} (size_t n=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b Address} &a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} {\b operator+} (size_t n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} & {\b operator+=} (size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} {\b operator-} (size_t n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ProgramCounter} & {\b operator-=} (size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} ({\b UByte::OutputFormat} oF) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b ProgramCounter} &pc)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The program counter is an special register within any {\b CPU}, keeping an address inside that is incremented or decremented as the program is executed. \par
}{
Definition at line {\b 23} of file {\b ProgramCounter.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ProgramCounter\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:ProgramCounter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::ProgramCounter::ProgramCounter (size_t  {\i sz}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPD}
{\bkmkend AAAAAAACPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b ProgramCounter.hpp}.}\par
}
{\xe \v ProgramCounter\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:ProgramCounter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::ProgramCounter::ProgramCounter (const {\b ProgramCounter} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACPE}
{\bkmkend AAAAAAACPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asAddress\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:asAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::ProgramCounter::asAddress () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPF}
{\bkmkend AAAAAAACPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a37f6d97a9a28f686911eaa804c25813c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a37f6d97a9a28f686911eaa804c25813c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asString\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::ProgramCounter::asString ({\b UByte::OutputFormat}  {\i oF}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPG}
{\bkmkend AAAAAAACPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_afa46699ae0f9236f4bd411c549ece6d3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_afa46699ae0f9236f4bd411c549ece6d3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v decrement\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:decrement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ProgramCounter::decrement (size_t  {\i n} = {\f2 1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPH}
{\bkmkend AAAAAAACPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a300dddf55abc81115157f449e1dcad76_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a300dddf55abc81115157f449e1dcad76_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v increment\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:increment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ProgramCounter::increment (size_t  {\i n} = {\f2 1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPI}
{\bkmkend AAAAAAACPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_aa0a210c1950d4ec3a0f4dadf14b599aa_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_aa0a210c1950d4ec3a0f4dadf14b599aa_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ProgramCounter::initialize (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPJ}
{\bkmkend AAAAAAACPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a2432a6271d74859b75cf911ffd879646_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!=\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::ProgramCounter::operator!= (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPK}
{\bkmkend AAAAAAACPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a47c8cd077a4efceee5ceabc7542d0dfe_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} MCHEmul::ProgramCounter::operator+ (size_t  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPL}
{\bkmkend AAAAAAACPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a3da67432f3dc05ea54ae28b4db0e8936_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} & MCHEmul::ProgramCounter::operator+= (size_t  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPM}
{\bkmkend AAAAAAACPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a6f48b74c791c3920bd6e008dd1225aa8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} MCHEmul::ProgramCounter::operator- (size_t  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPN}
{\bkmkend AAAAAAACPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a6e4f87a22062e9839c22c81c23341455_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-=\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} & MCHEmul::ProgramCounter::operator-= (size_t  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPO}
{\bkmkend AAAAAAACPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a83319dd60a1d4abdef9b784c098d71bd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::ProgramCounter::operator< (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPP}
{\bkmkend AAAAAAACPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_af61ca6b4ac51660df9721c8ca4acd749_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<=\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::ProgramCounter::operator<= (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPQ}
{\bkmkend AAAAAAACPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a4957772843354b05b252f6197c40749e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ProgramCounter} & MCHEmul::ProgramCounter::operator= (const {\b ProgramCounter} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACPR}
{\bkmkend AAAAAAACPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::ProgramCounter::operator== (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPS}
{\bkmkend AAAAAAACPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a5f4b26061f9a2d470ccc07e4e8cb243d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator>\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::ProgramCounter::operator> (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPT}
{\bkmkend AAAAAAACPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a5921d8bfd55bae5fefd33b8fcf7e7c64_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator>=\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::ProgramCounter::operator>= (const {\b Address} &  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPU}
{\bkmkend AAAAAAACPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_ac0f071a36524a5ce8e645a918fb26ff3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setAddress\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:setAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ProgramCounter::setAddress (const {\b Address} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPV}
{\bkmkend AAAAAAACPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b ProgramCounter.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a2ed19e71f6a49c25fde7b13bb29d2126_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_program_counter_a2ed19e71f6a49c25fde7b13bb29d2126_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::ProgramCounter}
{\xe \v MCHEmul::ProgramCounter\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b ProgramCounter} &  {\i pc}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACPW}
{\bkmkend AAAAAAACPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b ProgramCounter.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::VICII::Raster Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::VICII::Raster}
{\xe \v C64::VICII::Raster}
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
\par
{
{\f2 #include <VICII.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Raster} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Raster} (const {\b Raster} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Raster} & {\b operator=} (const {\b Raster} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Raster} (const {\b RasterData} &vD, const {\b RasterData} &hD)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b RasterData} & {\b vData} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RasterData} & {\b vData} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b RasterData} & {\b hData} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RasterData} & {\b hData} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentLine} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentLineAtBase0} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentColumn} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentColumnAtBase0} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInPotentialBadLine} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInVBlank} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInLastVBlank} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInVisibleZone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b currentVisiblePosition} (unsigned short &x, unsigned short &y) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInDisplayZone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b firstScreenPosition} (unsigned short &x, unsigned short &y, bool o=false) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b currentScreenPosition} (unsigned short &x, unsigned short &y) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b screenPositions} (unsigned short &x1, unsigned short &y1, unsigned short &x2, unsigned short &y2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b visibleLines} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b visibleColumns} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reduceDisplayZone} (bool v, bool h)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveCycles} (unsigned short nC)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned short {\b _FIRSTBADLINE} = 0x33\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned short {\b _LASTBADLINE} = 0xfa\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Raster} simulates the set of sequential horizontal lines that, in a CRT monitor, draws an image in the screen. \par
}{
Definition at line {\b 138} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Raster\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:Raster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::Raster::Raster (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Raster\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:Raster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::Raster::Raster (const {\b Raster} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Raster\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:Raster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::Raster::Raster (const {\b RasterData} &  {\i vD}, const {\b RasterData} &  {\i hD}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 150} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v currentColumn\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:currentColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::Raster::currentColumn () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a60ce4d0a456d5fd74f96cbb4fabce915_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentColumnAtBase0\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:currentColumnAtBase0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::Raster::currentColumnAtBase0 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a37d5f6a38e74961bfb9d6708e50455d1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentLine\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:currentLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::Raster::currentLine () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 163} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a763c998ab4887751a2fd6c1d859ab005_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentLineAtBase0\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:currentLineAtBase0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::Raster::currentLineAtBase0 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_aa32038bd6509576afe13f99af8180362_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentScreenPosition\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:currentScreenPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::Raster::currentScreenPosition (unsigned short &  {\i x}, unsigned short &  {\i y}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 193} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a344a9be2d1b044b3391669223d6d412d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentVisiblePosition\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:currentVisiblePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::Raster::currentVisiblePosition (unsigned short &  {\i x}, unsigned short &  {\i y}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 185} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a60801b608ceab266864bf15e9607fc19_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v firstScreenPosition\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:firstScreenPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::Raster::firstScreenPosition (unsigned short &  {\i x}, unsigned short &  {\i y}, bool  {\i o} = {\f2 false}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 191} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a164ab566772b70d1c3156cdb7f9d892a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v hData\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:hData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RasterData} & C64::VICII::Raster::hData (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b VICII.hpp}.}\par
}
{\xe \v hData\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:hData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b RasterData} & C64::VICII::Raster::hData () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b VICII.hpp}.}\par
}
{\xe \v initialize\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::Raster::initialize (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 214} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a1a1f4dc4457948cb28df42ac34799e1c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInDisplayZone\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:isInDisplayZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::Raster::isInDisplayZone () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 188} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_ae506e602ca4a1f19e39c44e8f9f4c379_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInLastVBlank\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:isInLastVBlank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::Raster::isInLastVBlank () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 180} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_aaf2a6bfbc53f0700b6833de465275d10_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInPotentialBadLine\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:isInPotentialBadLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::Raster::isInPotentialBadLine () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is not complete. It would have to consider the position of the vertical scroll and also whether the display is or not disconnected. \par
}{
Definition at line {\b 174} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a1a0555d2c47e5a34364b72cae0b60146_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInVBlank\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:isInVBlank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::Raster::isInVBlank () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_ae9f1d4a3d2f9bd19700e173b5ea844f8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInVisibleZone\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:isInVisibleZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::Raster::isInVisibleZone () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 183} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_afb593aa36edda6f25c07488fe5965749_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v moveCycles\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:moveCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::Raster::moveCycles (unsigned short  {\i nC}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true when the raster goes to the next line. The Parameter is the number of cycles to move the raster. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
columuns = piexels per cycle.\par
}{
Definition at line {\b 209} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_ac04f64107a4bb730c6d14328816771b6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Raster} & C64::VICII::Raster::operator= (const {\b Raster} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reduceDisplayZone\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:reduceDisplayZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::Raster::reduceDisplayZone (bool  {\i v}, bool  {\i h}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 204} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_aab0e6f04e1835fcdc62f510f6d404c35_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v screenPositions\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:screenPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::Raster::screenPositions (unsigned short &  {\i x1}, unsigned short &  {\i y1}, unsigned short &  {\i x2}, unsigned short &  {\i y2}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 195} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_a3a3d52909185e8a37afa805787726c08_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v vData\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:vData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RasterData} & C64::VICII::Raster::vData (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 156} of file {\b VICII.hpp}.}\par
}
{\xe \v vData\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:vData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b RasterData} & C64::VICII::Raster::vData () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b VICII.hpp}.}\par
}
{\xe \v visibleColumns\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:visibleColumns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::Raster::visibleColumns () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 201} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_ae5125c6b2050c7b015e1729d479494e0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v visibleLines\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:visibleLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::Raster::visibleLines () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_ab95bf391f680ffa344ee255594f2c31b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _FIRSTBADLINE\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:_FIRSTBADLINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::Raster::_FIRSTBADLINE = 0x33{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b VICII.hpp}.}\par
}
{\xe \v _LASTBADLINE\:C64::VICII::Raster}
{\xe \v C64::VICII::Raster\:_LASTBADLINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::Raster::_LASTBADLINE = 0xfa{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b VICII.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::VICII::RasterData Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData}
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
\par
{
{\f2 #include <VICII.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RasterData} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RasterData} (unsigned short fp, unsigned short fvp, unsigned short fdp, unsigned short ldp, unsigned short lvp, unsigned short lp, unsigned short mp, unsigned short pr1, unsigned short pr2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RasterData} (const {\b RasterData} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RasterData} & {\b operator=} (const {\b RasterData} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentPosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentPositionAtBase0} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInBlankZone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInLastBlankZone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInVisibleZone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentVisiblePosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b visiblePositions} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInDisplayZone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b firstScreenPosition} (bool o=false) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b lastScreenPosition} (bool o=false) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentScreenPosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b screenPositions} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b add} (unsigned short i)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b next} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reduceDisplayZone} (bool s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isDisplayZoneReduced} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b toBase0} (unsigned short m) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _firstPosition} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _firstVisiblePosition} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _firstDisplayPosition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _originalFirstDisplayPosition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _lastDisplayPosition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _originalLastDisplayPosition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _lastVisiblePosition} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _lastPosition} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _maxPositions} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _positionsToReduce1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned short {\b _positionsToReduce2} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _firstPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _firstVisiblePosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _firstDisplayPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _originalFirstDisplayPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _lastDisplayPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _originalLastDisplayPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _lastVisiblePosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _lastPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _currentPosition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b _currentPosition_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _displayZoneReducted}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b RasterData} describes the infomation the raster need to move across the screen. \par
}{
Definition at line {\b 28} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v RasterData\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:RasterData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::RasterData::RasterData (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v RasterData\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:RasterData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::RasterData::RasterData (unsigned short  {\i fp}, unsigned short  {\i fvp}, unsigned short  {\i fdp}, unsigned short  {\i ldp}, unsigned short  {\i lvp}, unsigned short  {\i lp}, unsigned short  {\i mp}, unsigned short  {\i pr1}, unsigned short  {\i pr2})}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b VICII.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_aa8092cc444ec924a41715deab99e9259_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v RasterData\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:RasterData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::RasterData::RasterData (const {\b RasterData} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::add (unsigned short  {\i i})}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true when the limit of the raster is reached. The parameter is the number of positions to increment the rasterData. \par
}{
Definition at line {\b 70} of file {\b VICII.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a63e5f5a995d1f5abb81a6ab693baaecb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:currentPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::currentPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_ad5d80774aef3ca3ca06f33c8bda054d6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentPositionAtBase0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:currentPositionAtBase0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::currentPositionAtBase0 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a6cecf7df8641e0404055f2b493ba7d31_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentScreenPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:currentScreenPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::currentScreenPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a07700f08dba3eccdb615e7d1441160b2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v currentVisiblePosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:currentVisiblePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::currentVisiblePosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a0e24632b25e42b9f5d3e96809cf27de8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v firstScreenPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:firstScreenPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::firstScreenPosition (bool  {\i o} = {\f2 false}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
o == true when the original display position has to be taken into account. false by default. \par
}{
Definition at line {\b 77} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a0414d48a489e6e9aba7fedb63e230a77_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::RasterData::initialize (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a8b2aa4283dd4ee43ba98bed012a7263e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isDisplayZoneReduced\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:isDisplayZoneReduced}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::isDisplayZoneReduced () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b VICII.hpp}.}\par
}
{\xe \v isInBlankZone\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:isInBlankZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::isInBlankZone () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_aa7294d516acfb335034f6f7ac91fb474_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInDisplayZone\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:isInDisplayZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::isInDisplayZone () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Doesn't take into account potential reductions in the size. \par
}{
Definition at line {\b 72} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a619ff1c5a901c73b0f84387715379e20_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInLastBlankZone\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:isInLastBlankZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::isInLastBlankZone () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_aa6d4f46fdaa81bfbd8ddb3f3d403dbf8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInVisibleZone\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:isInVisibleZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::isInVisibleZone () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_ab5f4092f394079068440354f4d33a86e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v lastScreenPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:lastScreenPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::lastScreenPosition (bool  {\i o} = {\f2 false}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a7a8571339a03d46435ab42ad619d2558_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v next\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::next (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_ac8a7d7a6b48bece35248ae6f26c8179b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_ac8a7d7a6b48bece35248ae6f26c8179b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RasterData} & C64::VICII::RasterData::operator= (const {\b RasterData} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reduceDisplayZone\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:reduceDisplayZone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::RasterData::reduceDisplayZone (bool  {\i s})}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The display zone will reduced in both sides by half of the _positionsToReduce value. \par
}{
Definition at line {\b 48} of file {\b VICII.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_ab62ed76a5d8833e76aafd96edf57544c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v screenPositions\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:screenPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::screenPositions () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b VICII.hpp}.}\par
}
{\xe \v toBase0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:toBase0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::toBase0 (unsigned short  {\i m}) const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal method used return a value considering the firrst position as 0. \par
}{
Definition at line {\b 102} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_acf335c00501e02ce6635c0bd137e1cce_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v visiblePositions\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:visiblePositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::visiblePositions () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b VICII.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_1_1_raster_data_a39ea66cf6eaa1482b02832ba4378e742_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _currentPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_currentPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_currentPosition{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b VICII.hpp}.}\par
}
{\xe \v _currentPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_currentPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_currentPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b VICII.hpp}.}\par
}
{\xe \v _displayZoneReducted\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_displayZoneReducted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::RasterData::_displayZoneReducted{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b VICII.hpp}.}\par
}
{\xe \v _firstDisplayPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_firstDisplayPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_firstDisplayPosition{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b VICII.hpp}.}\par
}
{\xe \v _firstDisplayPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_firstDisplayPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_firstDisplayPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 123} of file {\b VICII.hpp}.}\par
}
{\xe \v _firstPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_firstPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_firstPosition = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b VICII.hpp}.}\par
}
{\xe \v _firstPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_firstPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_firstPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b VICII.hpp}.}\par
}
{\xe \v _firstVisiblePosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_firstVisiblePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_firstVisiblePosition = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b VICII.hpp}.}\par
}
{\xe \v _firstVisiblePosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_firstVisiblePosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_firstVisiblePosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b VICII.hpp}.}\par
}
{\xe \v _lastDisplayPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_lastDisplayPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_lastDisplayPosition{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b VICII.hpp}.}\par
}
{\xe \v _lastDisplayPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_lastDisplayPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_lastDisplayPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b VICII.hpp}.}\par
}
{\xe \v _lastPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_lastPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_lastPosition = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b VICII.hpp}.}\par
}
{\xe \v _lastPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_lastPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_lastPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b VICII.hpp}.}\par
}
{\xe \v _lastVisiblePosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_lastVisiblePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_lastVisiblePosition = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b VICII.hpp}.}\par
}
{\xe \v _lastVisiblePosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_lastVisiblePosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_lastVisiblePosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b VICII.hpp}.}\par
}
{\xe \v _maxPositions\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_maxPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_maxPositions = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b VICII.hpp}.}\par
}
{\xe \v _originalFirstDisplayPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_originalFirstDisplayPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_originalFirstDisplayPosition{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b VICII.hpp}.}\par
}
{\xe \v _originalFirstDisplayPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_originalFirstDisplayPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_originalFirstDisplayPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b VICII.hpp}.}\par
}
{\xe \v _originalLastDisplayPosition\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_originalLastDisplayPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_originalLastDisplayPosition{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b VICII.hpp}.}\par
}
{\xe \v _originalLastDisplayPosition_0\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_originalLastDisplayPosition_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::RasterData::_originalLastDisplayPosition_0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b VICII.hpp}.}\par
}
{\xe \v _positionsToReduce1\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_positionsToReduce1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_positionsToReduce1 = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b VICII.hpp}.}\par
}
{\xe \v _positionsToReduce2\:C64::VICII::RasterData}
{\xe \v C64::VICII::RasterData\:_positionsToReduce2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::RasterData::_positionsToReduce2 = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b VICII.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b VICII.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Register Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Register}
{\xe \v MCHEmul::Register}
{\bkmkstart AAAAAAACPX}
{\bkmkend AAAAAAACPX}
\par
{
{\f2 #include <Register.hpp>}}\par
Inheritance diagram for MCHEmul::Register:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Register:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} (int {\b id}, const std::string &n, const {\b UBytes} &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} (int {\b id}, const std::string &n, const std::vector< {\b UByte} > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} (const {\b Register} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Register} & {\b operator=} (const {\b Register} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b name} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UBytes} & {\b values} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< {\b UByte} > & {\b bytes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b asUInt} (bool bE) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b asAddress} (bool bE) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b accept} (const {\b UBytes} &v) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const std::vector< {\b UByte} > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b UBytes} &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b Register} &r)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b Register} &r) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b Register} &r) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator[]} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} ({\b UByte::OutputFormat} oF, char s, size_t l=0) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b _id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b _name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b _values}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Register} &r)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A register is an internal storage area within any {\b CPU}. Depending on the {\b CPU}'s architecture, the length of a register can vary. \par
}{
Definition at line {\b 25} of file {\b Register.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Register\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:Register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Register::Register (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACPY}
{\bkmkend AAAAAAACPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Register\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:Register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Register::Register (int  {\i id}, const std::string &  {\i n}, const {\b UBytes} &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPZ}
{\bkmkend AAAAAAACPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i v} \cell }{variable \cell }
{\row }
}
}{
Definition at line {\b 30} of file {\b Register.hpp}.}\par
}
{\xe \v Register\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:Register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Register::Register (int  {\i id}, const std::string &  {\i n}, const std::vector< {\b UByte} > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQA}
{\bkmkend AAAAAAACQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i v} \cell }{variable \cell }
{\row }
}
}{
Definition at line {\b 34} of file {\b Register.hpp}.}\par
}
{\xe \v Register\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:Register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Register::Register (const {\b Register} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACQB}
{\bkmkend AAAAAAACQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v accept\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Register::accept (const {\b UBytes} &  {\i v}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQC}
{\bkmkend AAAAAAACQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The values can be accepted only if they have the same length than the register. \par
}{
Definition at line {\b 64} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a710bcc78e23deb68902c0973e2b0bc9b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a710bcc78e23deb68902c0973e2b0bc9b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asAddress\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:asAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Address} MCHEmul::Register::asAddress (bool  {\i bE}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQD}
{\bkmkend AAAAAAACQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b Register.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a8e709601ac945687c3a813beed70c206_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asString\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Register::asString ({\b UByte::OutputFormat}  {\i oF}, char  {\i s}, size_t  {\i l} = {\f2 0}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQE}
{\bkmkend AAAAAAACQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i s} \cell }{separator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i l} \cell }{Minimum length per {\b UByte} \cell }
{\row }
}
}{
Definition at line {\b 84} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_af13dcc80f643840968e556cac3dc763e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asUInt\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:asUInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::Register::asUInt (bool  {\i bE}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQF}
{\bkmkend AAAAAAACQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b Register.hpp}.}\par
}
{\xe \v bytes\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< {\b UByte} > & MCHEmul::Register::bytes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQG}
{\bkmkend AAAAAAACQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_afd5cacb72bd02974510772d87a4b7314_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_afd5cacb72bd02974510772d87a4b7314_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v id\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::Register::id () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQH}
{\bkmkend AAAAAAACQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Register.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Register::initialize (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQI}
{\bkmkend AAAAAAACQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize. \par
}{
Definition at line {\b 43} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a6d7eba569d72c9df7e2b26dab372553f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a6d7eba569d72c9df7e2b26dab372553f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v name\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & MCHEmul::Register::name () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQJ}
{\bkmkend AAAAAAACQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b Register.hpp}.}\par
}
{\xe \v operator!=\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Register::operator!= (const {\b Register} &  {\i r}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQK}
{\bkmkend AAAAAAACQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Register.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Register} & MCHEmul::Register::operator= (const {\b Register} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACQL}
{\bkmkend AAAAAAACQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Register::operator== (const {\b Register} &  {\i r}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQM}
{\bkmkend AAAAAAACQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Register.hpp}.}\par
}
{\xe \v operator[]\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::Register::operator[] (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQN}
{\bkmkend AAAAAAACQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b Register.hpp}.}\par
}
{\xe \v set\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Register::set (const {\b Register} &  {\i r}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQO}
{\bkmkend AAAAAAACQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the values from another register, only if they can be accepted. \par
}{
Definition at line {\b 73} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_aef98a70b6004a92fcf9d11d84dd16912_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Register::set (const std::vector< {\b UByte} > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQP}
{\bkmkend AAAAAAACQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set values only if they can be accepted. \par
}{
Definition at line {\b 68} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a391d4d4664456f5c02495686d1863ce4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_a391d4d4664456f5c02495686d1863ce4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Register::set (const {\b UBytes} &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQQ}
{\bkmkend AAAAAAACQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_ad6cbb5c24ed0c16421e0e350e26a7d34_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::Register::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQR}
{\bkmkend AAAAAAACQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b Register.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_afc012e0bff4fdaf9e725d52e1d52e52c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_afc012e0bff4fdaf9e725d52e1d52e52c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v values\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UBytes} & MCHEmul::Register::values () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQS}
{\bkmkend AAAAAAACQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b Register.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_register_ac64fce41d57ca96dc59c4c88da8832a2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Register} &  {\i r}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACQT}
{\bkmkend AAAAAAACQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _id\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int MCHEmul::Register::_id{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQU}
{\bkmkend AAAAAAACQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Register.hpp}.}\par
}
{\xe \v _name\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string MCHEmul::Register::_name{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQV}
{\bkmkend AAAAAAACQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b Register.hpp}.}\par
}
{\xe \v _values\:MCHEmul::Register}
{\xe \v MCHEmul::Register\:_values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::Register::_values{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQW}
{\bkmkend AAAAAAACQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b Register.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Register.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::ROL_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::ROL_General}
{\xe \v F6500::ROL_General}
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::ROL_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_r_o_l___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::ROL_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_r_o_l___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ROL_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ROL_General}: To aggregate common steps in every ROL instruction. \par
}{
Definition at line {\b 451} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ROL_General\:F6500::ROL_General}
{\xe \v F6500::ROL_General\:ROL_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::ROL_General::ROL_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 454} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::ROL_General}
{\xe \v F6500::ROL_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::ROL_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The carry is put into.\par
}{
Definition at line {\b 5} of file {\b ROL.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_r_o_l___general_a62bcaf107f65e2655776716bda172045_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b ROL.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::ROR_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::ROR_General}
{\xe \v F6500::ROR_General}
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::ROR_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_r_o_r___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::ROR_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_r_o_r___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ROR_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ROR_General}: To aggregate common steps in every ROR instruction. \par
}{
Definition at line {\b 470} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ROR_General\:F6500::ROR_General}
{\xe \v F6500::ROR_General\:ROR_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::ROR_General::ROR_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 473} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::ROR_General}
{\xe \v F6500::ROR_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::ROR_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The carry is put into.\par
}{
Definition at line {\b 5} of file {\b ROR.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_r_o_r___general_a457596fdde546e4041c4c92dc2d514f4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b ROR.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::SBC_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::SBC_General}
{\xe \v F6500::SBC_General}
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::SBC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_b_c___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::SBC_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_b_c___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SBC_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeWith} ({\b MCHEmul::UByte} u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SBC_General}: To aggregate common steps in every SBC instruction. \par
}{
Definition at line {\b 495} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SBC_General\:F6500::SBC_General}
{\xe \v F6500::SBC_General\:SBC_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::SBC_General::SBC_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 498} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeWith\:F6500::SBC_General}
{\xe \v F6500::SBC_General\:executeWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::SBC_General::executeWith ({\b MCHEmul::UByte}  {\i u}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 byte long.\par
}{
Definition at line {\b 5} of file {\b SBC.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_b_c___general_a102c8651d5e025b59ff291af2adbcfb5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b SBC.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::Screen Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::Screen}
{\xe \v C64::Screen}
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
\par
{
{\f2 #include <Screen.hpp>}}\par
Inheritance diagram for C64::Screen:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_screen__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::Screen:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_screen__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Screen} (double hz, int w, int h, const {\b MCHEmul::Attributes} &attrs=\{ \})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _ID} = 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 22} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Screen\:C64::Screen}
{\xe \v C64::Screen\:Screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::Screen::Screen (double  {\i hz}, int  {\i w}, int  {\i h}, const {\b MCHEmul::Attributes} &  {\i attrs} = {\f2 \{\~ \}})}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b Screen.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::Screen}
{\xe \v C64::Screen\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::Screen::_ID = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b Screen.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b Screen.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Screen Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Screen}
{\xe \v MCHEmul::Screen}
{\bkmkstart AAAAAAACQX}
{\bkmkend AAAAAAACQX}
\par
{
{\f2 #include <Screen.hpp>}}\par
Inheritance diagram for MCHEmul::Screen:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_screen__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Screen:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_screen__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Screen} (const std::string &n, int {\b id}, unsigned int sc, unsigned int sr, unsigned int vF, double hz, const {\b Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Screen} (const {\b Screen} *)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Screen} & {\b operator=} (const {\b Screen} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Screen} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b linkToChips} (const {\b Chips} &c) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b GraphicalChip} * {\b graphicalChip} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GraphicalChip} * {\b graphicalChip} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b screenName} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b screenColumns} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b screenRows} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b visibilityFactor} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b hertzs} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b _screenName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b _screenColumns}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b _screenRows}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b _visibilityFactor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b _hertzs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GraphicalChip} * {\b _graphicalChip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SDL_Window * {\b _window}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SDL_Renderer * {\b _renderer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SDL_Texture * {\b _texture}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b _refreshRate}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the very typical output device of any computer: The {\b Screen}. \par
}{
Definition at line {\b 24} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Screen\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:Screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Screen::Screen (const std::string &  {\i n}, int  {\i id}, unsigned int  {\i sc}, unsigned int  {\i sr}, unsigned int  {\i vF}, double  {\i hz}, const {\b Attributes} &  {\i attrs} = {\f2 \{\~ \}})}}
\par
{\bkmkstart AAAAAAACQY}
{\bkmkend AAAAAAACQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates the instance of the window. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i n} \cell }{: The title of the windo to show. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i id} \cell }{: The id of the device. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{: The list of the chips related with this device. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sc} \cell }{: The number of columns of the screen. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sr} \cell }{: The number of rows of the screen. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vF} \cell }{: The visibility factor. That is hw many visible pixels represents a pixel in the computer. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nC} \cell }{: The number of colors. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hz} \cell }{: The speed of the refresh in Hz. \cell }
{\row }
}
}{
Definition at line {\b 5} of file {\b Screen.cpp}.}\par
}
{\xe \v Screen\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:Screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Screen::Screen (const {\b Screen} * ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACQZ}
{\bkmkend AAAAAAACQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Screen\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:~Screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Screen::~Screen (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACRA}
{\bkmkend AAAAAAACRA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b Screen.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v graphicalChip\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:graphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GraphicalChip} * MCHEmul::Screen::graphicalChip (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRB}
{\bkmkend AAAAAAACRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b Screen.hpp}.}\par
}
{\xe \v graphicalChip\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:graphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b GraphicalChip} * MCHEmul::Screen::graphicalChip () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRC}
{\bkmkend AAAAAAACRC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The reference to the graphical chip. \par
}{
Definition at line {\b 51} of file {\b Screen.hpp}.}\par
}
{\xe \v hertzs\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:hertzs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double MCHEmul::Screen::hertzs () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRD}
{\bkmkend AAAAAAACRD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b Screen.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Screen::initialize (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFP}
{\bkmkend AAAAAAACFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the device. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACCO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 68} of file {\b Screen.hpp}.}\par
}
{\xe \v linkToChips\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:linkToChips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Screen::linkToChips (const {\b Chips} &  {\i c}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFR}
{\bkmkend AAAAAAACFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To link to the right chips. The IO device never owns the chips. By default all chips are linked. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 42} of file {\b Screen.cpp}.}\par
}
{\xe \v operator=\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Screen} & MCHEmul::Screen::operator= (const {\b Screen} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACRE}
{\bkmkend AAAAAAACRE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v screenColumns\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:screenColumns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Screen::screenColumns () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRF}
{\bkmkend AAAAAAACRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b Screen.hpp}.}\par
}
{\xe \v screenName\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:screenName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string MCHEmul::Screen::screenName () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRG}
{\bkmkend AAAAAAACRG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the value of all parameters. \par
}{
Definition at line {\b 57} of file {\b Screen.hpp}.}\par
}
{\xe \v screenRows\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:screenRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Screen::screenRows () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRH}
{\bkmkend AAAAAAACRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b Screen.hpp}.}\par
}
{\xe \v simulate\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Screen::simulate (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFV}
{\bkmkend AAAAAAACFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the screen using the info of the frame. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACCR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 53} of file {\b Screen.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_screen_ad8c7125f3f4e6ef6d973c39e70b9009a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v visibilityFactor\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:visibilityFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Screen::visibilityFactor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRI}
{\bkmkend AAAAAAACRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _graphicalChip\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_graphicalChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GraphicalChip}* MCHEmul::Screen::_graphicalChip{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRJ}
{\bkmkend AAAAAAACRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set when initialize after assigning the chips. The graphical chip managing the graphical memory. That the screen displays. \par
}{
Definition at line {\b 85} of file {\b Screen.hpp}.}\par
}
{\xe \v _hertzs\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_hertzs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double MCHEmul::Screen::_hertzs{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRK}
{\bkmkend AAAAAAACRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b Screen.hpp}.}\par
}
{\xe \v _refreshRate\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_refreshRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MCHEmul::Screen::_refreshRate{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRL}
{\bkmkend AAAAAAACRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
At construction time, to speed up calculus. \par
}{
Definition at line {\b 93} of file {\b Screen.hpp}.}\par
}
{\xe \v _renderer\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_renderer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SDL_Renderer* MCHEmul::Screen::_renderer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRM}
{\bkmkend AAAAAAACRM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b Screen.hpp}.}\par
}
{\xe \v _screenColumns\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_screenColumns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Screen::_screenColumns{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRN}
{\bkmkend AAAAAAACRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Screen.hpp}.}\par
}
{\xe \v _screenName\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_screenName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string MCHEmul::Screen::_screenName{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRO}
{\bkmkend AAAAAAACRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b Screen.hpp}.}\par
}
{\xe \v _screenRows\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_screenRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Screen::_screenRows{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRP}
{\bkmkend AAAAAAACRP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b Screen.hpp}.}\par
}
{\xe \v _texture\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_texture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SDL_Texture* MCHEmul::Screen::_texture{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRQ}
{\bkmkend AAAAAAACRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Screen.hpp}.}\par
}
{\xe \v _visibilityFactor\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_visibilityFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int MCHEmul::Screen::_visibilityFactor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRR}
{\bkmkend AAAAAAACRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Screen.hpp}.}\par
}
{\xe \v _window\:MCHEmul::Screen}
{\xe \v MCHEmul::Screen\:_window}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SDL_Window* MCHEmul::Screen::_window{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRS}
{\bkmkend AAAAAAACRS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Screen.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b Screen.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::ScreenMemory Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory}
{\bkmkstart AAAAAAACRT}
{\bkmkend AAAAAAACRT}
\par
{
{\f2 #include <ScreenMemory.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenMemory} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenMemory} (size_t c, size_t r, unsigned int *p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenMemory} (const {\b ScreenMemory} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenMemory} & {\b operator=} (const {\b ScreenMemory} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ScreenMemory} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b columns} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b rows} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int * {\b frameData} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPixel} (size_t x, size_t y, unsigned int color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHorizontalLine} (size_t x, size_t y, size_t nP, unsigned int color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVerticalLine} (size_t x, size_t y, size_t nP, unsigned int color)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It represents a the memory where all things to be sent to the screen are store. \par
It is actually a matrix of unsigned int, representing each one the color of a pixel in the screen. \par
}{
Definition at line {\b 22} of file {\b ScreenMemory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ScreenMemory\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:ScreenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::ScreenMemory::ScreenMemory (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACRU}
{\bkmkend AAAAAAACRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ScreenMemory\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:ScreenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::ScreenMemory::ScreenMemory (size_t  {\i c}, size_t  {\i r}, unsigned int *  {\i p})}}
\par
{\bkmkstart AAAAAAACRV}
{\bkmkend AAAAAAACRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b ScreenMemory.cpp}.}\par
}
{\xe \v ScreenMemory\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:ScreenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::ScreenMemory::ScreenMemory (const {\b ScreenMemory} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACRW}
{\bkmkend AAAAAAACRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~ScreenMemory\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:~ScreenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::ScreenMemory::~ScreenMemory (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRX}
{\bkmkend AAAAAAACRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b ScreenMemory.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v columns\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:columns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::ScreenMemory::columns () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRY}
{\bkmkend AAAAAAACRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b ScreenMemory.hpp}.}\par
}
{\xe \v frameData\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:frameData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int * MCHEmul::ScreenMemory::frameData () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRZ}
{\bkmkend AAAAAAACRZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b ScreenMemory.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScreenMemory} & MCHEmul::ScreenMemory::operator= (const {\b ScreenMemory} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACSA}
{\bkmkend AAAAAAACSA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rows\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:rows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::ScreenMemory::rows () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSB}
{\bkmkend AAAAAAACSB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b ScreenMemory.hpp}.}\par
}
{\xe \v setHorizontalLine\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:setHorizontalLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ScreenMemory::setHorizontalLine (size_t  {\i x}, size_t  {\i y}, size_t  {\i nP}, unsigned int  {\i color}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSC}
{\bkmkend AAAAAAACSC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b ScreenMemory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_screen_memory_a0b58f09381a138dbcc90f66f6a25074f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setPixel\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:setPixel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ScreenMemory::setPixel (size_t  {\i x}, size_t  {\i y}, unsigned int  {\i color}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSD}
{\bkmkend AAAAAAACSD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b ScreenMemory.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_screen_memory_a600ff5a6b2b617c853f25a3655a01c51_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setVerticalLine\:MCHEmul::ScreenMemory}
{\xe \v MCHEmul::ScreenMemory\:setVerticalLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::ScreenMemory::setVerticalLine (size_t  {\i x}, size_t  {\i y}, size_t  {\i nP}, unsigned int  {\i color}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSE}
{\bkmkend AAAAAAACSE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b ScreenMemory.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_screen_memory_a6fa40cc84aa0c1f0e38282515dd715ff_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b ScreenMemory.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b ScreenMemory.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::ScreenNTSC Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::ScreenNTSC}
{\xe \v C64::ScreenNTSC}
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
\par
{
{\f2 #include <Screen.hpp>}}\par
Inheritance diagram for C64::ScreenNTSC:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_screen_n_t_s_c__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::ScreenNTSC:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_screen_n_t_s_c__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenNTSC} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 29} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ScreenNTSC\:C64::ScreenNTSC}
{\xe \v C64::ScreenNTSC\:ScreenNTSC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::ScreenNTSC::ScreenNTSC (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b Screen.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::ScreenPAL Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::ScreenPAL}
{\xe \v C64::ScreenPAL}
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
\par
{
{\f2 #include <Screen.hpp>}}\par
Inheritance diagram for C64::ScreenPAL:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_screen_p_a_l__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::ScreenPAL:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_screen_p_a_l__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScreenPAL} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 38} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ScreenPAL\:C64::ScreenPAL}
{\xe \v C64::ScreenPAL\:ScreenPAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::ScreenPAL::ScreenPAL (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b Screen.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b Screen.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::Semantic Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic}
{\bkmkstart AAAAAAADGJ}
{\bkmkend AAAAAAADGJ}
\par
{
{\f2 #include <Grammar.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Semantic} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Semantic} (const {\b Semantic} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Semantic} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Semantic} & {\b operator=} (const {\b Semantic} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Macros} & {\b macros} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addMacro} (const {\b Macro} &m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b StartingPointElements} & {\b startingPoints} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartingPointElement} * {\b addNewStartingPoint} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addGrammaticalElement} ({\b GrammaticalElement} *g)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b GrammaticalElement} * {\b lastGrammaticalElementAdded} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GrammaticalElement} * {\b lastGrammaticalElementAdded} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ErrorType} {\b error} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addFrom} (const {\b Semantic} *s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsLabel} (const std::string &l) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Address} {\b addressForLabel} (const std::string &l) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< const {\b LabelElement} * > {\b labels} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< std::string, {\b Address} > {\b labelAddresses} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
friend {\b CommandParser}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 261} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Semantic\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:Semantic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Semantic::Semantic (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADGK}
{\bkmkend AAAAAAADGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 266} of file {\b Grammar.hpp}.}\par
}
{\xe \v Semantic\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:Semantic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Semantic::Semantic (const {\b Semantic} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAADGL}
{\bkmkend AAAAAAADGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Semantic\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:~Semantic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::Semantic::~Semantic (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADGM}
{\bkmkend AAAAAAADGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 273} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addFrom\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:addFrom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::Semantic::addFrom (const {\b Semantic} *  {\i s})}}
\par
{\bkmkstart AAAAAAADGN}
{\bkmkend AAAAAAADGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The semantic can add elements from other (macros are also added). \par
}{
Definition at line {\b 413} of file {\b Grammar.cpp}.}\par
}
{\xe \v addGrammaticalElement\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:addGrammaticalElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::Semantic::addGrammaticalElement ({\b GrammaticalElement} *  {\i g})}}
\par
{\bkmkstart AAAAAAADGO}
{\bkmkend AAAAAAADGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 376} of file {\b Grammar.cpp}.}\par
}
{\xe \v addMacro\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:addMacro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::Semantic::addMacro (const {\b Macro} &  {\i m})}}
\par
{\bkmkstart AAAAAAADGP}
{\bkmkend AAAAAAADGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 356} of file {\b Grammar.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_semantic_a76305f81cbc456232d8cc1587af89d13_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v addNewStartingPoint\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:addNewStartingPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Assembler::StartingPointElement} * MCHEmul::Assembler::Semantic::addNewStartingPoint ()}}
\par
{\bkmkstart AAAAAAADGQ}
{\bkmkend AAAAAAADGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 365} of file {\b Grammar.cpp}.}\par
}
{\xe \v addressForLabel\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:addressForLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Address} MCHEmul::Assembler::Semantic::addressForLabel (const std::string &  {\i l}) const}}
\par
{\bkmkstart AAAAAAADGR}
{\bkmkend AAAAAAADGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To determine the distance of an {\b Address} with that label. If the label has't been defined in the semantic, 0 is returnd but it wouldn't mean anything. \par
}{
Definition at line {\b 449} of file {\b Grammar.cpp}.}\par
}
{\xe \v error\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ErrorType} MCHEmul::Assembler::Semantic::error () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADGS}
{\bkmkend AAAAAAADGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 291} of file {\b Grammar.hpp}.}\par
}
{\xe \v existsLabel\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:existsLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::Semantic::existsLabel (const std::string &  {\i l}) const}}
\par
{\bkmkstart AAAAAAADGT}
{\bkmkend AAAAAAADGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To verify whether exists a label. \par
}{
Definition at line {\b 430} of file {\b Grammar.cpp}.}\par
}
{\xe \v labelAddresses\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:labelAddresses}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map< std::string, {\b MCHEmul::Address} > MCHEmul::Assembler::Semantic::labelAddresses () const}}
\par
{\bkmkstart AAAAAAADGU}
{\bkmkend AAAAAAADGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
to get the list of labels and addrresses associated. \par
}{
Definition at line {\b 480} of file {\b Grammar.cpp}.}\par
}
{\xe \v labels\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:labels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< const {\b MCHEmul::Assembler::LabelElement} * > MCHEmul::Assembler::Semantic::labels () const}}
\par
{\bkmkstart AAAAAAADGV}
{\bkmkend AAAAAAADGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To get the list of all labels. \par
}{
Definition at line {\b 467} of file {\b Grammar.cpp}.}\par
}
{\xe \v lastGrammaticalElementAdded\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:lastGrammaticalElementAdded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GrammaticalElement} * MCHEmul::Assembler::Semantic::lastGrammaticalElementAdded (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADGW}
{\bkmkend AAAAAAADGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 288} of file {\b Grammar.hpp}.}\par
}
{\xe \v lastGrammaticalElementAdded\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:lastGrammaticalElementAdded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b GrammaticalElement} * MCHEmul::Assembler::Semantic::lastGrammaticalElementAdded () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADGX}
{\bkmkend AAAAAAADGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 286} of file {\b Grammar.hpp}.}\par
}
{\xe \v macros\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:macros}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Macros} & MCHEmul::Assembler::Semantic::macros () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADGY}
{\bkmkend AAAAAAADGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b Grammar.hpp}.}\par
}
{\xe \v operator!\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Assembler::Semantic::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADGZ}
{\bkmkend AAAAAAADGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the analysis of the macro. \par
}{
Definition at line {\b 295} of file {\b Grammar.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Semantic} & MCHEmul::Assembler::Semantic::operator= (const {\b Semantic} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAADHA}
{\bkmkend AAAAAAADHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v startingPoints\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:startingPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b StartingPointElements} & MCHEmul::Assembler::Semantic::startingPoints () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADHB}
{\bkmkend AAAAAAADHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 282} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v CommandParser\:MCHEmul::Assembler::Semantic}
{\xe \v MCHEmul::Assembler::Semantic\:CommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend MCHEmul::Assembler::Semantic::CommandParser}}
\par
{\bkmkstart AAAAAAADHC}
{\bkmkend AAAAAAADHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 264} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Grammar.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::SpecialFunctionsChip Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::SpecialFunctionsChip}
{\xe \v C64::SpecialFunctionsChip}
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
\par
{
{\f2 #include <SFChip.hpp>}}\par
Inheritance diagram for C64::SpecialFunctionsChip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_special_functions_chip__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::SpecialFunctionsChip:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_special_functions_chip__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SpecialFunctionsChip} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ({\b MCHEmul::CPU} *cpu) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _ID} = 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 21} of file {\b SFChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SpecialFunctionsChip\:C64::SpecialFunctionsChip}
{\xe \v C64::SpecialFunctionsChip\:SpecialFunctionsChip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::SpecialFunctionsChip::SpecialFunctionsChip (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b SFChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::SpecialFunctionsChip}
{\xe \v C64::SpecialFunctionsChip\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::SpecialFunctionsChip::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 5} of file {\b SFChip.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_special_functions_chip_a8ed92f0e2cf5dc51ee1964eb87f5d98e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v simulate\:C64::SpecialFunctionsChip}
{\xe \v C64::SpecialFunctionsChip\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::SpecialFunctionsChip::simulate ({\b MCHEmul::CPU} * ){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate th behaviour of the chip. It has to be defined per chip. \par
Returns true if everything was ok, and false in any other circunstance. \par
 The last error could be recovered from the variable _lastError in that case. \par
The clock cyclees is added. \par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 24} of file {\b SFChip.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_special_functions_chip_a99603624ff85cf9a38d6984f91aea865_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::SpecialFunctionsChip}
{\xe \v C64::SpecialFunctionsChip\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int C64::SpecialFunctionsChip::_ID = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b SFChip.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b SFChip.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b SFChip.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::STA_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::STA_General}
{\xe \v F6500::STA_General}
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::STA_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_a___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::STA_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_a___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b STA_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b STA_General}: To aggregate common steps in every STA instruction. \par
}{
Definition at line {\b 526} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v STA_General\:F6500::STA_General}
{\xe \v F6500::STA_General\:STA_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::STA_General::STA_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 529} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::STA_General}
{\xe \v F6500::STA_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::STA_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b STA.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_a___general_a8d374d67bc77bf1761c947e4bd5a7cc7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b STA.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Stack Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Stack}
{\xe \v MCHEmul::Stack}
{\bkmkstart AAAAAAACSF}
{\bkmkend AAAAAAACSF}
\par
{
{\f2 #include <Stack.hpp>}}\par
Inheritance diagram for MCHEmul::Stack:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_stack__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Stack:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_stack__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Stack} (int {\b id}, {\b PhisicalStorage} *ps, size_t pp, const {\b Address} &iA, size_t s, bool b=true, bool e=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b position} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPosition} (int p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push} (const {\b UBytes} &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b pull} (size_t nV)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b stackOverflow} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b Stack} &s)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 21} of file {\b Stack.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Stack\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:Stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Stack::Stack (int  {\i id}, {\b PhisicalStorage} *  {\i ps}, size_t  {\i pp}, const {\b Address} &  {\i iA}, size_t  {\i s}, bool  {\i b} = {\f2 true}, bool  {\i e} = {\f2 true}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSG}
{\bkmkend AAAAAAACSG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor: {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i b} \cell }{: From the end of the memory to the beggining or the other way around \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e} \cell }{: Poining always to the empty place or pointing to the last position kept. \cell }
{\row }
}
}{
Definition at line {\b 29} of file {\b Stack.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Stack::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACNZ}
{\bkmkend AAAAAAACNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To init the memory. It might be overloaded. By default the "defaultData" value is assigned. It doesn't matter whether the subset is or not active. \par
}{
Reimplemented from {\b MCHEmul::PhisicalStorageSubset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 4} of file {\b Stack.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_stack_a94d9b603a2afb9a4269d0c917cdc7c3d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v position\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::Stack::position () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSH}
{\bkmkend AAAAAAACSH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b Stack.hpp}.}\par
}
{\xe \v pull\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:pull}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UBytes} MCHEmul::Stack::pull (size_t  {\i nV})}}
\par
{\bkmkstart AAAAAAACSI}
{\bkmkend AAAAAAACSI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b Stack.cpp}.}\par
}
{\xe \v push\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Stack::push (const {\b UBytes} &  {\i v})}}
\par
{\bkmkstart AAAAAAACSJ}
{\bkmkend AAAAAAACSJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b Stack.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_stack_a4a48072ed39c54c20093414ec53564a4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setPosition\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:setPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Stack::setPosition (int  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSK}
{\bkmkend AAAAAAACSK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Take care using this method. No checks are done on regards to the speed. And it is not the same a back-stack than a foward one. \par
}{
Definition at line {\b 40} of file {\b Stack.hpp}.}\par
}
{\xe \v stackOverflow\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:stackOverflow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Stack::stackOverflow () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSL}
{\bkmkend AAAAAAACSL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It is set to true when something happens after push or pull actions. \par
}{
Definition at line {\b 49} of file {\b Stack.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::Stack}
{\xe \v MCHEmul::Stack\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b Stack} &  {\i s}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACSM}
{\bkmkend AAAAAAACSM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Stack.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b Stack.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::StandardCommandBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::StandardCommandBuilder}
{\xe \v MCHEmul::StandardCommandBuilder}
{\bkmkstart AAAAAAACSN}
{\bkmkend AAAAAAACSN}
\par
{
{\f2 #include <CommandBuilder.hpp>}}\par
Inheritance diagram for MCHEmul::StandardCommandBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_standard_command_builder__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::StandardCommandBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_standard_command_builder__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Command} * {\b createEmptyCommand} (const std::string &cmdName) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very basic command builer creates the basic commands. \par
}{
Definition at line {\b 39} of file {\b CommandBuilder.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createEmptyCommand\:MCHEmul::StandardCommandBuilder}
{\xe \v MCHEmul::StandardCommandBuilder\:createEmptyCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::Command} * MCHEmul::StandardCommandBuilder::createEmptyCommand (const std::string &  {\i cmdName}) const{\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::CommandBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 90} of file {\b CommandBuilder.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b CommandBuilder.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b CommandBuilder.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::StandardMessageBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::StandardMessageBuilder}
{\xe \v MCHEmul::StandardMessageBuilder}
{\bkmkstart AAAAAAACSO}
{\bkmkend AAAAAAACSO}
\par
{
{\f2 #include <StdMessages.hpp>}}\par
Inheritance diagram for MCHEmul::StandardMessageBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_standard_message_builder__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::StandardMessageBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_standard_message_builder__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StandardMessageBuilder} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b CommunicationMessage} * {\b createMessage} (const std::string &str) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The standard message builder. \par
This class instantiates the default message supported by the standard {\b MCHEmul} library. \par
}{
Definition at line {\b 23} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v StandardMessageBuilder\:MCHEmul::StandardMessageBuilder}
{\xe \v MCHEmul::StandardMessageBuilder\:StandardMessageBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::StandardMessageBuilder::StandardMessageBuilder (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSP}
{\bkmkend AAAAAAACSP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b StdMessages.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createMessage\:MCHEmul::StandardMessageBuilder}
{\xe \v MCHEmul::StandardMessageBuilder\:createMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::CommunicationMessage} * MCHEmul::StandardMessageBuilder::createMessage (const std::string &  {\i str}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACLK}
{\bkmkend AAAAAAACLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b MCHEmul::MessageBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 4} of file {\b StdMessages.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_standard_message_builder_a2db6a47b325b233e30c094eae5049d31_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/{\b StdMessages.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/COMMS/{\b StdMessages.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::StartingPointCommandParser Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::StartingPointCommandParser}
{\xe \v MCHEmul::Assembler::StartingPointCommandParser}
{\bkmkstart AAAAAAADHD}
{\bkmkend AAAAAAADHD}
\par
{
{\f2 #include <Parser.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::StartingPointCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_starting_point_command_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::StartingPointCommandParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_starting_point_command_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartingPointCommandParser} (unsigned char s='=')\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b canParse} (const std::string &l) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parse} (std::string &l, unsigned int lC, {\b Semantic} *s) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To parser an address macro. The symbol defining the separation between definition and value can be redefined. Qhen parser the address assigned is incremented. \par
}{
Definition at line {\b 132} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v StartingPointCommandParser\:MCHEmul::Assembler::StartingPointCommandParser}
{\xe \v MCHEmul::Assembler::StartingPointCommandParser\:StartingPointCommandParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::StartingPointCommandParser::StartingPointCommandParser (unsigned char  {\i s} = {\f2 '='}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADHE}
{\bkmkend AAAAAAADHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b Parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v canParse\:MCHEmul::Assembler::StartingPointCommandParser}
{\xe \v MCHEmul::Assembler::StartingPointCommandParser\:canParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MCHEmul::Assembler::StartingPointCommandParser::canParse (const std::string &  {\i l}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCE}
{\bkmkend AAAAAAADCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a line can or not be parsed by this {\b Command} {\b Parser}. \par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 144} of file {\b Parser.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_starting_point_command_parser_add2b6e6fafe28125d429514cf5d7d203_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:MCHEmul::Assembler::StartingPointCommandParser}
{\xe \v MCHEmul::Assembler::StartingPointCommandParser\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void MCHEmul::Assembler::StartingPointCommandParser::initialize (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCI}
{\bkmkend AAAAAAADCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maybe one of them could need it. \par
}{
Reimplemented from {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 141} of file {\b Parser.hpp}.}\par
}
{\xe \v parse\:MCHEmul::Assembler::StartingPointCommandParser}
{\xe \v MCHEmul::Assembler::StartingPointCommandParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::Assembler::StartingPointCommandParser::parse (std::string &  {\i l}, unsigned int  {\i lC}, {\b Semantic} *  {\i s}) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADCN}
{\bkmkend AAAAAAADCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse the line, obviously when it is able. \par
Wheen parsing the line being parsed and the code structure are modified. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Until a potential comment.\par
}{
Implements {\b MCHEmul::Assembler::CommandParser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADBS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 36} of file {\b Parser.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_assembler_1_1_starting_point_command_parser_a25a0f317f668469ad83ab28f3ebb1938_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Parser.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Parser.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Assembler::StartingPointElement Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Assembler::StartingPointElement}
{\xe \v MCHEmul::Assembler::StartingPointElement}
{\bkmkstart AAAAAAADHF}
{\bkmkend AAAAAAADHF}
\par
{
{\f2 #include <Grammar.hpp>}}\par
Inheritance diagram for MCHEmul::Assembler::StartingPointElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_starting_point_element__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::Assembler::StartingPointElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_starting_point_element__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartingPointElement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartingPointElement} (const {\b StartingPointElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartingPointElement} & {\b operator=} (const {\b StartingPointElement} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Address} {\b address} (const {\b Semantic} *s) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _value}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
explanation at the beggining of the file. \par
}}}{
Definition at line {\b 232} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v StartingPointElement\:MCHEmul::Assembler::StartingPointElement}
{\xe \v MCHEmul::Assembler::StartingPointElement\:StartingPointElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::StartingPointElement::StartingPointElement (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADHG}
{\bkmkend AAAAAAADHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 234} of file {\b Grammar.hpp}.}\par
}
{\xe \v StartingPointElement\:MCHEmul::Assembler::StartingPointElement}
{\xe \v MCHEmul::Assembler::StartingPointElement\:StartingPointElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Assembler::StartingPointElement::StartingPointElement (const {\b StartingPointElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADHH}
{\bkmkend AAAAAAADHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v address\:MCHEmul::Assembler::StartingPointElement}
{\xe \v MCHEmul::Assembler::StartingPointElement\:address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b Address} MCHEmul::Assembler::StartingPointElement::address (const {\b Semantic} *  {\i s}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADEA}
{\bkmkend AAAAAAADEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know the address of the grammatical element. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
, big Endian implicit.\par
}{
Reimplemented from {\b MCHEmul::Assembler::GrammaticalElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADDZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 243} of file {\b Grammar.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_m_c_h_emul_1_1_assembler_1_1_starting_point_element_a6842f2ea721af17220cda990be2515b9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::Assembler::StartingPointElement}
{\xe \v MCHEmul::Assembler::StartingPointElement\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StartingPointElement} & MCHEmul::Assembler::StartingPointElement::operator= (const {\b StartingPointElement} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAADHI}
{\bkmkend AAAAAAADHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _value\:MCHEmul::Assembler::StartingPointElement}
{\xe \v MCHEmul::Assembler::StartingPointElement\:_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Assembler::StartingPointElement::_value}}
\par
{\bkmkstart AAAAAAADHJ}
{\bkmkend AAAAAAADHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 246} of file {\b Grammar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/{\b Grammar.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/{\b Grammar.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::StatusRegister Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister}
{\bkmkstart AAAAAAACSQ}
{\bkmkend AAAAAAACSQ}
\par
{
{\f2 #include <StatusRegister.hpp>}}\par
Inheritance diagram for MCHEmul::StatusRegister:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MCHEmul::StatusRegister:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b BitNames} = std::map< std::string, int >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StatusRegister} (size_t nB, const {\b BitNames} &bN)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StatusRegister} (const {\b StatusRegister} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StatusRegister} & {\b operator=} (const {\b StatusRegister} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b BitNames} & {\b bitNames} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existsBitStatus} (const std::string &bN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b bitStatus} (const std::string &bN) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBitStatus} (const std::string &bN, bool s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UBytes} & {\b values} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< {\b UByte} > & {\b bytes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b valuesWithout} (const std::vector< std::string > &bN)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const std::vector< {\b UByte} > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b UBytes} &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b StatusRegister} &r)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In the register avery bit could have a different meaning. \par
}{
Definition at line {\b 22} of file {\b StatusRegister.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v BitNames\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:BitNames}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b MCHEmul::StatusRegister::BitNames} =  std::map <std::string, int>}}
\par
{\bkmkstart AAAAAAACSR}
{\bkmkend AAAAAAACSR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b StatusRegister.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v StatusRegister\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:StatusRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::StatusRegister::StatusRegister (size_t  {\i nB}, const {\b BitNames} &  {\i bN}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSS}
{\bkmkend AAAAAAACSS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b StatusRegister.hpp}.}\par
}
{\xe \v StatusRegister\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:StatusRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::StatusRegister::StatusRegister (const {\b StatusRegister} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACST}
{\bkmkend AAAAAAACST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asString\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::StatusRegister::asString () const}}
\par
{\bkmkstart AAAAAAACSU}
{\bkmkend AAAAAAACSU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b StatusRegister.cpp}.}\par
}
{\xe \v bitNames\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:bitNames}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b BitNames} & MCHEmul::StatusRegister::bitNames () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSV}
{\bkmkend AAAAAAACSV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b StatusRegister.hpp}.}\par
}
{\xe \v bitStatus\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:bitStatus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::StatusRegister::bitStatus (const std::string &  {\i bN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSW}
{\bkmkend AAAAAAACSW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Take care using these methods, no check about the name used are don for speed reasons. \par
}{
Definition at line {\b 44} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_aed0762785e1eb7c313f5363c28dd28c7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_aed0762785e1eb7c313f5363c28dd28c7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bytes\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< {\b UByte} > & MCHEmul::StatusRegister::bytes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSX}
{\bkmkend AAAAAAACSX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_acdb36c8eee632df662155ed2e49772e7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existsBitStatus\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:existsBitStatus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::StatusRegister::existsBitStatus (const std::string &  {\i bN}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSY}
{\bkmkend AAAAAAACSY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b StatusRegister.hpp}.}\par
}
{\xe \v initialize\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::StatusRegister::initialize (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSZ}
{\bkmkend AAAAAAACSZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a34c637ea437ce75e65d3ea8524353542_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StatusRegister} & MCHEmul::StatusRegister::operator= (const {\b StatusRegister} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACTA}
{\bkmkend AAAAAAACTA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v set\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::StatusRegister::set (const std::vector< {\b UByte} > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTB}
{\bkmkend AAAAAAACTB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a6ba184706ff7a78294dae0c3b481a242_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::StatusRegister::set (const {\b UBytes} &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTC}
{\bkmkend AAAAAAACTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a57f310b336ee5f65551e11de0683a9d9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setBitStatus\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:setBitStatus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::StatusRegister::setBitStatus (const std::string &  {\i bN}, bool  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTD}
{\bkmkend AAAAAAACTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a8ddec9ec56dba64dc1180dad06185d9e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a8ddec9ec56dba64dc1180dad06185d9e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v values\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UBytes} & MCHEmul::StatusRegister::values () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTE}
{\bkmkend AAAAAAACTE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b StatusRegister.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a13d609342da424f52c633cd40fd2362b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a13d609342da424f52c633cd40fd2362b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v valuesWithout\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:valuesWithout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UBytes} MCHEmul::StatusRegister::valuesWithout (const std::vector< std::string > &  {\i bN})}}
\par
{\bkmkstart AAAAAAACTF}
{\bkmkend AAAAAAACTF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b StatusRegister.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a6dfedf4b8809d4d271e63be2cde615a6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_status_register_a6dfedf4b8809d4d271e63be2cde615a6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::StatusRegister}
{\xe \v MCHEmul::StatusRegister\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b StatusRegister} &  {\i r}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACTG}
{\bkmkend AAAAAAACTG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b StatusRegister.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b StatusRegister.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b StatusRegister.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::Instruction::Structure Struct Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure}
{\bkmkstart AAAAAAACEE}
{\bkmkend AAAAAAACEE}
\par
{
{\f2 #include <Instruction.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Parameter}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Structure} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Structure} (const std::string &t, const std::string &wM, const std::vector< {\b Parameter} > &prms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Structure} (const {\b Structure} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Structure} & {\b operator=} (const {\b Structure} &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _error}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _templateWithNoParameters}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _waterMark}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b _waterMarkPlus}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Parameter} > {\b _parameters}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the internal structure of a instruction. It is quite useful to be managed later by the parsers! \par
}{
Definition at line {\b 32} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Structure\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:Structure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Structure::Structure (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEF}
{\bkmkend AAAAAAACEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b Instruction.hpp}.}\par
}
{\xe \v Structure\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:Structure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Structure::Structure (const std::string &  {\i t}, const std::string &  {\i wM}, const std::vector< {\b Parameter} > &  {\i prms}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEG}
{\bkmkend AAAAAAACEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b Instruction.hpp}.}\par
}
{\xe \v Structure\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:Structure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::Instruction::Structure::Structure (const {\b Structure} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACEH}
{\bkmkend AAAAAAACEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Structure} & MCHEmul::Instruction::Structure::operator= (const {\b Structure} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACEI}
{\bkmkend AAAAAAACEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _error\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::Instruction::Structure::_error}}
\par
{\bkmkstart AAAAAAACEJ}
{\bkmkend AAAAAAACEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To indicate whether there was or not a mistake after the analysis of the instruction... In that error-case the _templateWithNoParameters will hold either "-" (instruction error) or "?" (parameter error). \par
}{
Definition at line {\b 74} of file {\b Instruction.hpp}.}\par
}
{\xe \v _parameters\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:_parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b Parameter}> MCHEmul::Instruction::Structure::_parameters}}
\par
{\bkmkstart AAAAAAACEK}
{\bkmkend AAAAAAACEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Instruction.hpp}.}\par
}
{\xe \v _templateWithNoParameters\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:_templateWithNoParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Instruction::Structure::_templateWithNoParameters}}
\par
{\bkmkstart AAAAAAACEL}
{\bkmkend AAAAAAACEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b Instruction.hpp}.}\par
}
{\xe \v _waterMark\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:_waterMark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Instruction::Structure::_waterMark}}
\par
{\bkmkstart AAAAAAACEM}
{\bkmkend AAAAAAACEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Instruction.hpp}.}\par
}
{\xe \v _waterMarkPlus\:MCHEmul::Instruction::Structure}
{\xe \v MCHEmul::Instruction::Structure\:_waterMarkPlus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::Instruction::Structure::_waterMarkPlus}}
\par
{\bkmkstart AAAAAAACEN}
{\bkmkend AAAAAAACEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b Instruction.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b Instruction.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::STX_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::STX_General}
{\xe \v F6500::STX_General}
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::STX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_x___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::STX_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_x___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b STX_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b STX_General}: To aggregate common steps in every STX instruction. \par
}{
Definition at line {\b 547} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v STX_General\:F6500::STX_General}
{\xe \v F6500::STX_General\:STX_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::STX_General::STX_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 550} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::STX_General}
{\xe \v F6500::STX_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::STX_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b STX.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_x___general_ab8d656dce47741a455254247dbac69eb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b STX.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F6500::STY_General Class Reference\par \pard\plain 
{\tc\tcl2 \v F6500::STY_General}
{\xe \v F6500::STY_General}
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
\par
{
{\f2 #include <Instructions.hpp>}}\par
Inheritance diagram for F6500::STY_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_y___general__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for F6500::STY_General:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_y___general__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b STY_General} (unsigned int c, unsigned int mp, unsigned int cc, const std::string &t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b executeOn} (const {\b MCHEmul::Address} &a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b STY_General}: To aggregate common steps in every STY instruction. \par
}{
Definition at line {\b 564} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v STY_General\:F6500::STY_General}
{\xe \v F6500::STY_General\:STY_General}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
F6500::STY_General::STY_General (unsigned int  {\i c}, unsigned int  {\i mp}, unsigned int  {\i cc}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 567} of file {\b Instructions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v executeOn\:F6500::STY_General}
{\xe \v F6500::STY_General\:executeOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool F6500::STY_General::executeOn (const {\b MCHEmul::Address} &  {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b STY.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_f6500_1_1_s_t_y___general_a4d2b3a39ce61b5a6964c1dca7d8b2d20_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/{\b Instructions.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/{\b STY.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UByte Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UByte}
{\xe \v MCHEmul::UByte}
{\bkmkstart AAAAAAACTH}
{\bkmkend AAAAAAACTH}
\par
{
{\f2 #include <UByte.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b OutputFormat} \{ {\b _DECIMAL}
, {\b _BINARY}
, {\b _OCTAL}
, {\b _HEXA}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} (unsigned char v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} (const {\b UByte} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator=} (const {\b UByte} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b value} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b bit} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBit} (size_t p, bool s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b LSNibble} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b MSNibble} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b complement} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shiftLeftC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b shiftLeft} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shiftRightC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b shiftRight} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rotateLeftC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b rotateLeft} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rotateRightC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b rotateRight} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b bitAdding} (const {\b UByte} &u, bool cin, bool &cout, bool &o) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator&} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator&=} (const {\b UByte} &u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator|} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator|=} (const {\b UByte} &u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator^} (const {\b UByte} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator^=} (const {\b UByte} &u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator~} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator[]} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator<<} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator>>} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} ({\b OutputFormat} oF, size_t l=0) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b size} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b sizeBits} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _0} = 0x00\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _1} = 0x01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _FF} = 0xff\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _0F} = 0x0f\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _F0} = 0xf0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _80} = 0x80\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _09} = 0x09\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _90} = 0x90\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _09N} = ~{\b _09} + 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _90N} = ~{\b _90} + 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _06} = 0x06\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _60} = 0x60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _06N} = ~{\b _06} + {\b _1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _60N} = ~{\b _60} + {\b _1}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b UByte} &u)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing the minimum piece of addressable info in a computer. MSB is the bit 7, LSB is the bit 0. Read bits from right to left. \par
}{
Definition at line {\b 24} of file {\b UByte.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v OutputFormat\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:OutputFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b MCHEmul::UByte::OutputFormat}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAACTI}
{\bkmkend AAAAAAACTI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _DECIMAL\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_DECIMAL}
{\qr _DECIMAL{\bkmkstart AAAAAAACTJ}
{\bkmkend AAAAAAACTJ}
\cell }{\cell }{\row }
{\xe \v _BINARY\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_BINARY}
{\qr _BINARY{\bkmkstart AAAAAAACTK}
{\bkmkend AAAAAAACTK}
\cell }{\cell }{\row }
{\xe \v _OCTAL\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_OCTAL}
{\qr _OCTAL{\bkmkstart AAAAAAACTL}
{\bkmkend AAAAAAACTL}
\cell }{\cell }{\row }
{\xe \v _HEXA\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_HEXA}
{\qr _HEXA{\bkmkstart AAAAAAACTM}
{\bkmkend AAAAAAACTM}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 27} of file {\b UByte.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v UByte\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:UByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UByte::UByte (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTN}
{\bkmkend AAAAAAACTN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b UByte.hpp}.}\par
}
{\xe \v UByte\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:UByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UByte::UByte (unsigned char  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTO}
{\bkmkend AAAAAAACTO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b UByte.hpp}.}\par
}
{\xe \v UByte\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:UByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UByte::UByte (const {\b UByte} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACTP}
{\bkmkend AAAAAAACTP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asString\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::UByte::asString ({\b OutputFormat}  {\i oF}, size_t  {\i l} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAACTQ}
{\bkmkend AAAAAAACTQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i l} \cell }{Minimum length. \cell }
{\row }
}
}{
Definition at line {\b 91} of file {\b UByte.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a62b130af3764ec25c949b897243809f1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bit\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:bit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::bit (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTR}
{\bkmkend AAAAAAACTR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you requested for a bit bigger than sizeBits, the crash is guaranteed. No checks are done to increase the speed. \par
}{
Definition at line {\b 73} of file {\b UByte.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_ad00c1228bc2fbb11f54e397f862c77d4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bitAdding\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:bitAdding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::bitAdding (const {\b UByte} &  {\i u}, bool  {\i cin}, bool &  {\i cout}, bool &  {\i o}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTS}
{\bkmkend AAAAAAACTS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Just to do a bit adding. But very interesting method. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i u} \cell }{The byte to add. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cin} \cell }{Is there any carry at the beginning to take into account? \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cout} \cell }{It is actualized whether a carry is generated from the adding. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i o} \cell }{Is is actualized whether an overflow is generated, that is when the MSBits of inputs are equal and different from the output. \cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
instead {\b UByte::_1} to guaranttee it is online.\par
unsigned short = 2 bytes long.\par
cut it.\par
}{
Definition at line {\b 156} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a59a815aa4e01f3e9c7fc45bea9fa49f5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v complement\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:complement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::complement () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTT}
{\bkmkend AAAAAAACTT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To calculate the complement (bits 0 to 1 and the other way around). \par
}{
Definition at line {\b 84} of file {\b UByte.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a4735d2470f263a206dd316325524e63e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v LSNibble\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:LSNibble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::LSNibble () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTU}
{\bkmkend AAAAAAACTU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b UByte.hpp}.}\par
}
{\xe \v MSNibble\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:MSNibble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::MSNibble () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTV}
{\bkmkend AAAAAAACTV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b UByte.hpp}.}\par
}
{\xe \v operator!=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator!= (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTW}
{\bkmkend AAAAAAACTW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b UByte.hpp}.}\par
}
{\xe \v operator&\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator&}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::operator& (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTX}
{\bkmkend AAAAAAACTX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 123} of file {\b UByte.hpp}.}\par
}
{\xe \v operator&=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator&=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::operator&= (const {\b UByte} &  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTY}
{\bkmkend AAAAAAACTY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b UByte.hpp}.}\par
}
{\xe \v operator<\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator< (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTZ}
{\bkmkend AAAAAAACTZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b UByte.hpp}.}\par
}
{\xe \v operator<<\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::operator<< (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUA}
{\bkmkend AAAAAAACUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 140} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_ac386c477bb018876918a8a266a05e7e8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator<= (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUB}
{\bkmkend AAAAAAACUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 120} of file {\b UByte.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::operator= (const {\b UByte} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACUC}
{\bkmkend AAAAAAACUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator== (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUD}
{\bkmkend AAAAAAACUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b UByte.hpp}.}\par
}
{\xe \v operator>\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator> (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUE}
{\bkmkend AAAAAAACUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b UByte.hpp}.}\par
}
{\xe \v operator>=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator>= (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUF}
{\bkmkend AAAAAAACUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b UByte.hpp}.}\par
}
{\xe \v operator>>\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::operator>> (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUG}
{\bkmkend AAAAAAACUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_ab9b8b8d957ad445e13eeedd03786bfde_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator[]\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::operator[] (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUH}
{\bkmkend AAAAAAACUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_aa4efd0e14568ef52f1056c83e4315ee2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator^\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator^}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::operator^ (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUI}
{\bkmkend AAAAAAACUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b UByte.hpp}.}\par
}
{\xe \v operator^=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator^=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::operator^= (const {\b UByte} &  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUJ}
{\bkmkend AAAAAAACUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b UByte.hpp}.}\par
}
{\xe \v operator|\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::operator| (const {\b UByte} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUK}
{\bkmkend AAAAAAACUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b UByte.hpp}.}\par
}
{\xe \v operator|=\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator|=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::operator|= (const {\b UByte} &  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUL}
{\bkmkend AAAAAAACUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b UByte.hpp}.}\par
}
{\xe \v operator~\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator~}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UByte::operator~ () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUM}
{\bkmkend AAAAAAACUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a6fda0b5a0881ff1a17af7f15dc3b6839_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rotateLeft\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:rotateLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} & MCHEmul::UByte::rotateLeft (size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACUN}
{\bkmkend AAAAAAACUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{without carry flag \cell }
{\row }
}
}{
Definition at line {\b 63} of file {\b UByte.cpp}.}\par
}
{\xe \v rotateLeftC\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:rotateLeftC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::rotateLeftC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACUO}
{\bkmkend AAAAAAACUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{carry flag \cell }
{\row }
}
}{
Definition at line {\b 53} of file {\b UByte.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a5324943b7654b77969bad3a482d6cefb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rotateRight\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:rotateRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UByte} & MCHEmul::UByte::rotateRight (size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACUP}
{\bkmkend AAAAAAACUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b UByte.cpp}.}\par
}
{\xe \v rotateRightC\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:rotateRightC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::rotateRightC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACUQ}
{\bkmkend AAAAAAACUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b UByte.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_ab0b65477bf0a010d3d3bfa9ee5cbf1f3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setBit\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:setBit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UByte::setBit (size_t  {\i p}, bool  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUR}
{\bkmkend AAAAAAACUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b UByte.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a80464dba61fe07f3b59e41c8d979581f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftLeft\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:shiftLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::shiftLeft (size_t  {\i p} = {\f2 1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUS}
{\bkmkend AAAAAAACUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a4c999ba07989d95512306a08fa2371f8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a4c999ba07989d95512306a08fa2371f8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftLeftC\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:shiftLeftC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::shiftLeftC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACUT}
{\bkmkend AAAAAAACUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{carry flag \cell }
{\row }
}
}{
Definition at line {\b 5} of file {\b UByte.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a9d041167514be07bd773e13c966c24d7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a9d041167514be07bd773e13c966c24d7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftRight\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:shiftRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UByte::shiftRight (size_t  {\i p} = {\f2 1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUU}
{\bkmkend AAAAAAACUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b UByte.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a59f283bc83e142563dc79fe0dc563012_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a59f283bc83e142563dc79fe0dc563012_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftRightC\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:shiftRightC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UByte::shiftRightC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACUV}
{\bkmkend AAAAAAACUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b UByte.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a0926228fa4243b2ec132ade2a122c9ab_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a0926228fa4243b2ec132ade2a122c9ab_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static size_t MCHEmul::UByte::size (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACUW}
{\bkmkend AAAAAAACUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
COmmon to every UByt. \par
}{
Definition at line {\b 63} of file {\b UByte.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a684f3c15d5b2746075af96e1ab1a81cd_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sizeBits\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:sizeBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static size_t MCHEmul::UByte::sizeBits (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACUX}
{\bkmkend AAAAAAACUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b UByte.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_byte_a256a022714d442b93208eff11967e44c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v value\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::UByte::value () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACUY}
{\bkmkend AAAAAAACUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b UByte.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b UByte} &  {\i u}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACUZ}
{\bkmkend AAAAAAACUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b UByte.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _0\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_0 = 0x00{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVA}
{\bkmkend AAAAAAACVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b UByte.hpp}.}\par
}
{\xe \v _06\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_06}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_06 = 0x06{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVB}
{\bkmkend AAAAAAACVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b UByte.hpp}.}\par
}
{\xe \v _06N\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_06N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_06N = ~{\b _06} + {\b _1}{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVC}
{\bkmkend AAAAAAACVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b UByte.hpp}.}\par
}
{\xe \v _09\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_09}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_09 = 0x09{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVD}
{\bkmkend AAAAAAACVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b UByte.hpp}.}\par
}
{\xe \v _09N\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_09N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_09N = ~{\b _09} + 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVE}
{\bkmkend AAAAAAACVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b UByte.hpp}.}\par
}
{\xe \v _0F\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_0F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_0F = 0x0f{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVF}
{\bkmkend AAAAAAACVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b UByte.hpp}.}\par
}
{\xe \v _1\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_1 = 0x01{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVG}
{\bkmkend AAAAAAACVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b UByte.hpp}.}\par
}
{\xe \v _60\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_60}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_60 = 0x60{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVH}
{\bkmkend AAAAAAACVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b UByte.hpp}.}\par
}
{\xe \v _60N\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_60N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_60N = ~{\b _60} + {\b _1}{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVI}
{\bkmkend AAAAAAACVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b UByte.hpp}.}\par
}
{\xe \v _80\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_80}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_80 = 0x80{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVJ}
{\bkmkend AAAAAAACVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b UByte.hpp}.}\par
}
{\xe \v _90\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_90}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_90 = 0x90{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVK}
{\bkmkend AAAAAAACVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b UByte.hpp}.}\par
}
{\xe \v _90N\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_90N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_90N = ~{\b _90} + 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVL}
{\bkmkend AAAAAAACVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b UByte.hpp}.}\par
}
{\xe \v _F0\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_F0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_F0 = 0xf0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVM}
{\bkmkend AAAAAAACVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b UByte.hpp}.}\par
}
{\xe \v _FF\:MCHEmul::UByte}
{\xe \v MCHEmul::UByte\:_FF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UByte::_FF = 0xff{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACVN}
{\bkmkend AAAAAAACVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b UByte.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UByte.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b UByte.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UBytes Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes}
{\bkmkstart AAAAAAACVO}
{\bkmkend AAAAAAACVO}
\par
{
{\f2 #include <UBytes.hpp>}}\par
Collaboration diagram for MCHEmul::UBytes:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} (const std::vector< {\b UByte} > &v, bool bE=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} (const {\b UBytes} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b operator=} (const {\b UBytes} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b sizeBits} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinLength} (size_t l, bool r=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UByte} & {\b value} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b value} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< {\b UByte} > & {\b bytes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b LSUBytes} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b MSUBytes} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b bit} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBit} (size_t p, bool s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b to0} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b toFF} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b complement} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shiftLeftC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b shiftLeft} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shiftRightC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b shiftRight} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rotateLeftC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b rotateLeft} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rotateRightC} (bool c=false, size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b rotateRight} (size_t p=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b bitAdding} (const {\b UBytes} &u, bool cin, bool &cout, bool &o) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} {\b reverse} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b UBytes} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b UBytes} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator[]} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator[]} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b operator<<} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UBytes} & {\b operator>>} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} ({\b UByte::OutputFormat} oF, char s, size_t l=0) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b UBytes} {\b _E} = {\b MCHEmul::UBytes} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b UBytes} &u)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing a set of {\b UByte}. \par
}{
Definition at line {\b 23} of file {\b UBytes.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v UBytes\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:UBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UBytes::UBytes (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVP}
{\bkmkend AAAAAAACVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b UBytes.hpp}.}\par
}
{\xe \v UBytes\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:UBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UBytes::UBytes (const std::vector< {\b UByte} > &  {\i v}, bool  {\i bE} = {\f2 true}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVQ}
{\bkmkend AAAAAAACVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a46f7572e931f16a2daf1eaf8516782f8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v UBytes\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:UBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UBytes::UBytes (const {\b UBytes} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACVR}
{\bkmkend AAAAAAACVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v asString\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::UBytes::asString ({\b UByte::OutputFormat}  {\i oF}, char  {\i s}, size_t  {\i l} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAACVS}
{\bkmkend AAAAAAACVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i s} \cell }{separator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i l} \cell }{Minimum length per {\b UByte} \cell }
{\row }
}
}{
Definition at line {\b 153} of file {\b UBytes.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a569d44bb0910bf5b70751eea6c237481_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bit\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:bit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::bit (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVT}
{\bkmkend AAAAAAACVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you requested for a bit bigger than sizeBits, the crash is guaranteed. No checks are done to increase the speed. \par
}{
Definition at line {\b 63} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ab64194ba0a31b71cd5c52058f82dbd69_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ab64194ba0a31b71cd5c52058f82dbd69_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bitAdding\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:bitAdding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UBytes} MCHEmul::UBytes::bitAdding (const {\b UBytes} &  {\i u}, bool  {\i cin}, bool &  {\i cout}, bool &  {\i o}) const}}
\par
{\bkmkstart AAAAAAACVU}
{\bkmkend AAAAAAACVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Just to do a bit adding. But very interesting method. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i u} \cell }{The bytes to add. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cin} \cell }{Is there any carry at the beginning to take into account? \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cout} \cell }{It is actualized whether a carry is generated from the adding. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i o} \cell }{Is is actualized whether an overflow is generated, that is when the MSBits of inputs are equal and different from the output. \cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the loop.\par
at the beginning the additional 0.\par
}{
Definition at line {\b 110} of file {\b UBytes.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a1982e073989b0b8649c7cbc4615308eb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a1982e073989b0b8649c7cbc4615308eb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bytes\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< {\b UByte} > & MCHEmul::UBytes::bytes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVV}
{\bkmkend AAAAAAACVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b UBytes.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a9b529aaf9012ace5c489db4b4415f66b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v complement\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:complement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UBytes} MCHEmul::UBytes::complement () const}}
\par
{\bkmkstart AAAAAAACVW}
{\bkmkend AAAAAAACVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b UBytes.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_aa572ca25f24322808002099ee8c4ac75_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_aa572ca25f24322808002099ee8c4ac75_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v LSUBytes\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:LSUBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::UBytes::LSUBytes (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVX}
{\bkmkend AAAAAAACVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a5ccb09b87bc7d1d2bf1980e9d6cb14a7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a5ccb09b87bc7d1d2bf1980e9d6cb14a7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v MSUBytes\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:MSUBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} MCHEmul::UBytes::MSUBytes (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVY}
{\bkmkend AAAAAAACVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a08eb7d9b22435525b5df0404f82d4cab_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a08eb7d9b22435525b5df0404f82d4cab_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!=\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::operator!= (const {\b UBytes} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVZ}
{\bkmkend AAAAAAACVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b UBytes.hpp}.}\par
}
{\xe \v operator<<\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} & MCHEmul::UBytes::operator<< (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWA}
{\bkmkend AAAAAAACWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_aa6c50511aa80ea0fe8abdf132310842d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} & MCHEmul::UBytes::operator= (const {\b UBytes} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACWB}
{\bkmkend AAAAAAACWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::operator== (const {\b UBytes} &  {\i u}) const}}
\par
{\bkmkstart AAAAAAACWC}
{\bkmkend AAAAAAACWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b UBytes.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ae1ff29eb5f01db35b9d4930292854398_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator>>\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} & MCHEmul::UBytes::operator>> (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWD}
{\bkmkend AAAAAAACWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ab4d82f6dc5c8e1a9a07a1c377a40cf3c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator[]\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UBytes::operator[] (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWE}
{\bkmkend AAAAAAACWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a84220d00737f71e13e085fb0fe10ff3a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator[]\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UBytes::operator[] (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWF}
{\bkmkend AAAAAAACWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a15119f55479a4be269628cdf3d316da0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v reverse\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:reverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UBytes} MCHEmul::UBytes::reverse () const}}
\par
{\bkmkstart AAAAAAACWG}
{\bkmkend AAAAAAACWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b UBytes.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a37afbd3ddd2eae21369221b7152784a0_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rotateLeft\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:rotateLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UBytes} & MCHEmul::UBytes::rotateLeft (size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACWH}
{\bkmkend AAAAAAACWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b UBytes.cpp}.}\par
}
{\xe \v rotateLeftC\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:rotateLeftC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::rotateLeftC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACWI}
{\bkmkend AAAAAAACWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b UBytes.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a33550e7f83bc017eaaa114432a0985d5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rotateRight\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:rotateRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UBytes} & MCHEmul::UBytes::rotateRight (size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACWJ}
{\bkmkend AAAAAAACWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b UBytes.cpp}.}\par
}
{\xe \v rotateRightC\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:rotateRightC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::rotateRightC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACWK}
{\bkmkend AAAAAAACWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b UBytes.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ae58100ca2b69ed86d369c4da324af4a5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setBit\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:setBit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UBytes::setBit (size_t  {\i p}, bool  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWL}
{\bkmkend AAAAAAACWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a407367e314e9c6f743b508c7f5290a35_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a407367e314e9c6f743b508c7f5290a35_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setMinLength\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:setMinLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UBytes::setMinLength (size_t  {\i l}, bool  {\i r} = {\f2 true})}}
\par
{\bkmkstart AAAAAAACWM}
{\bkmkend AAAAAAACWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i r} \cell }{right or not? where to introduce the additional byte. \cell }
{\row }
}
}{
Definition at line {\b 8} of file {\b UBytes.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ad2c051f71547ffdd77a312cc4b9c30f3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ad2c051f71547ffdd77a312cc4b9c30f3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftLeft\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:shiftLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} & MCHEmul::UBytes::shiftLeft (size_t  {\i p} = {\f2 1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWN}
{\bkmkend AAAAAAACWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a41fa4ee71cdb19180fc83f940bed1289_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a41fa4ee71cdb19180fc83f940bed1289_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftLeftC\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:shiftLeftC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::shiftLeftC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACWO}
{\bkmkend AAAAAAACWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{value to introduce. \cell }
{\row }
}
}{
Definition at line {\b 32} of file {\b UBytes.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a8e361d84aa0a85d1fc2cda324c8ae48c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftRight\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:shiftRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UBytes} & MCHEmul::UBytes::shiftRight (size_t  {\i p} = {\f2 1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWP}
{\bkmkend AAAAAAACWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_aa1b0011cbd21bec559680bfaf8fe447f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_aa1b0011cbd21bec559680bfaf8fe447f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shiftRightC\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:shiftRightC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UBytes::shiftRightC (bool  {\i c} = {\f2 false}, size_t  {\i p} = {\f2 1})}}
\par
{\bkmkstart AAAAAAACWQ}
{\bkmkend AAAAAAACWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b UBytes.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_ab341011b5d5a164af709e95a1d63c9ae_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::UBytes::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWR}
{\bkmkend AAAAAAACWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b UBytes.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a0a0201f78ada888f8475c2782ba8cd1e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sizeBits\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:sizeBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::UBytes::sizeBits () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWS}
{\bkmkend AAAAAAACWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b UBytes.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a788832acadf3399299f9cafaac860d7b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a788832acadf3399299f9cafaac860d7b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v to0\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:to0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UBytes::to0 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWT}
{\bkmkend AAAAAAACWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b UBytes.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_a4013593b66dfe6d120de1b7fed986565_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v toFF\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:toFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UBytes::toFF (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWU}
{\bkmkend AAAAAAACWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b UBytes.hpp}.}\par
}
{\xe \v value\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UBytes::value (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWV}
{\bkmkend AAAAAAACWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b UBytes.hpp}.}\par
}
{\xe \v value\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UByte} & MCHEmul::UBytes::value (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWW}
{\bkmkend AAAAAAACWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b UBytes.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_bytes_af70c05c4b1952a11a61ef1e35830ca5b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b UBytes} &  {\i u}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACWX}
{\bkmkend AAAAAAACWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b UBytes.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _E\:MCHEmul::UBytes}
{\xe \v MCHEmul::UBytes\:_E}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::UBytes} MCHEmul::UBytes::_E = {\b MCHEmul::UBytes} (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACWY}
{\bkmkend AAAAAAACWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b UBytes.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UBytes.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b UBytes.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MCHEmul::UInt Class Reference\par \pard\plain 
{\tc\tcl2 \v MCHEmul::UInt}
{\xe \v MCHEmul::UInt}
{\bkmkstart AAAAAAACWZ}
{\bkmkend AAAAAAACWZ}
\par
{
{\f2 #include <UInt.hpp>}}\par
Collaboration diagram for MCHEmul::UInt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BinaryFormatManager}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FormatManager}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FormatManagers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PackagedBCDFormatManager}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} (const {\b UBytes} &u, bool bE=true, unsigned char f={\b _BINARY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} (const std::vector< {\b UByte} > &u, bool bE=true, unsigned char f={\b _BINARY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} (const {\b UInt} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} & {\b operator=} (const {\b UInt} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b format} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b sizeBits} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b negative} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b positive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b carry} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetCarry} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b overflow} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetOverflow} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinLength} (size_t l)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UBytes} & {\b values} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< {\b UByte} > & {\b bytes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b LSUInt} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b MSUInt} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b add} (const {\b UInt} &u, bool iC=false) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b complement} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b complement_2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b substract} (const {\b UInt} &u, bool iC=true) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b multiply} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b operator+} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} & {\b operator+=} (const {\b UInt} &u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b operator-} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b operator-} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} & {\b operator-=} (const {\b UInt} &u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} {\b operator*} (const {\b UInt} &u) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt} & {\b operator*=} (const {\b UInt} &u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} {\b operator[]} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UByte} & {\b operator[]} (size_t p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b asString} ({\b UByte::OutputFormat} oF, char s, size_t l=0) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b asUnsignedInt} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b asInt} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b UInt} {\b fromUnsignedInt} (unsigned int n, unsigned char f={\b _BINARY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b UInt} {\b fromInt} (int n, unsigned char f={\b _BINARY})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b UInt} {\b fromStr} (const std::string &s, unsigned char f={\b _BINARY})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _BINARY} = 0x00\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned char {\b _PACKAGEDBCD} = 0x01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::map< unsigned char, {\b FormatManager} * > {\b _formatManagers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b UInt} {\b _0} = {\b MCHEmul::UInt} (\{ MCHEmul::UByte::_0 \}, false, false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b UInt} {\b _1} = {\b MCHEmul::UInt} (\{ MCHEmul::UByte::_1 \}, false, false)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b UInt} &u)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing a Integer, with and without sign. \par
It might by said that this class represents actually {\b CPU}'s ALU (Arithmetic Logic Unit) as well. \par
A number is represented by several {\b UBytes}. Those {\b UBytes} can be given either in big-endian format or low-endian one. \par
That number can be represented in many different formats. \par
The _BINARY one is the default and the most commonly used. \par
The type of format used in many computers at 80's was the packaged BCD. \par
The class is prepared to support additional formats further than those two ones. It can be extended somehow. See later. \par
The negative numbers are always kept and "understood" using complement 2. \par
The basic operation in an {\b UInt} is "adding". The rest are always refer to this one. \par
}{
Definition at line {\b 33} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v UInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:UInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::UInt (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXA}
{\bkmkend AAAAAAACXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b UInt.hpp}.}\par
}
{\xe \v UInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:UInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::UInt (const {\b UBytes} &  {\i u}, bool  {\i bE} = {\f2 true}, unsigned char  {\i f} = {\f2 {\b _BINARY}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXB}
{\bkmkend AAAAAAACXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always kept in Big-endian format. Negative numbers are complement_2. \par
}{
Definition at line {\b 126} of file {\b UInt.hpp}.}\par
}
{\xe \v UInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:UInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::UInt (const std::vector< {\b UByte} > &  {\i u}, bool  {\i bE} = {\f2 true}, unsigned char  {\i f} = {\f2 {\b _BINARY}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXC}
{\bkmkend AAAAAAACXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b UInt.hpp}.}\par
}
{\xe \v UInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:UInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MCHEmul::UInt::UInt (const {\b UInt} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACXD}
{\bkmkend AAAAAAACXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UInt} MCHEmul::UInt::add (const {\b UInt} &  {\i u}, bool  {\i iC} = {\f2 false}) const}}
\par
{\bkmkstart AAAAAAACXE}
{\bkmkend AAAAAAACXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b UInt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_ac3208016a838042c285d2588445cf7bc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_ac3208016a838042c285d2588445cf7bc_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:asInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MCHEmul::UInt::asInt () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXF}
{\bkmkend AAAAAAACXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 227} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a69895a56a3f5089dc0fae7c3256bcd8d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a69895a56a3f5089dc0fae7c3256bcd8d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asString\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:asString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string MCHEmul::UInt::asString ({\b UByte::OutputFormat}  {\i oF}, char  {\i s}, size_t  {\i l} = {\f2 0}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXG}
{\bkmkend AAAAAAACXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i s} \cell }{separator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i l} \cell }{Minimum length per {\b UByte} \cell }
{\row }
}
}{
Definition at line {\b 222} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a8d39849593b56ff98bee006dc488f78c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a8d39849593b56ff98bee006dc488f78c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v asUnsignedInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:asUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int MCHEmul::UInt::asUnsignedInt () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXH}
{\bkmkend AAAAAAACXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_adf1f7d84c1647993854f8f969ca2e046_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_adf1f7d84c1647993854f8f969ca2e046_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v bytes\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< {\b UByte} > & MCHEmul::UInt::bytes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXI}
{\bkmkend AAAAAAACXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_ab50dc6a66f9443223c709414cd8cc6c2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_ab50dc6a66f9443223c709414cd8cc6c2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v carry\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:carry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::carry () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXJ}
{\bkmkend AAAAAAACXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These 2 flags are set after operations. \par
}{
Definition at line {\b 155} of file {\b UInt.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_ae643afe7f0e47d036c3d9306b2c214eb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v complement\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:complement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::complement () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXK}
{\bkmkend AAAAAAACXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a8b4523ec9dab7d4b77fed1effa0c707a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a8b4523ec9dab7d4b77fed1effa0c707a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v complement_2\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:complement_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::complement_2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXL}
{\bkmkend AAAAAAACXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 180} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a6560087cf01e093c17e2e7999fdf3ceb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a6560087cf01e093c17e2e7999fdf3ceb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v format\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:format}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char MCHEmul::UInt::format () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXM}
{\bkmkend AAAAAAACXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b UInt.hpp}.}\par
}
{\xe \v fromInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:fromInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b UInt} MCHEmul::UInt::fromInt (int  {\i n}, unsigned char  {\i f} = {\f2 {\b _BINARY}}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACXN}
{\bkmkend AAAAAAACXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 232} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_af202e81e55b0ed33844c69fca3386987_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_af202e81e55b0ed33844c69fca3386987_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fromStr\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:fromStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UInt} MCHEmul::UInt::fromStr (const std::string &  {\i s}, unsigned char  {\i f} = {\f2 {\b _BINARY}}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACXO}
{\bkmkend AAAAAAACXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 278} of file {\b UInt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_aa666b883f579565564b203f297139b9a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_aa666b883f579565564b203f297139b9a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v fromUnsignedInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:fromUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b UInt} MCHEmul::UInt::fromUnsignedInt (unsigned int  {\i n}, unsigned char  {\i f} = {\f2 {\b _BINARY}}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACXP}
{\bkmkend AAAAAAACXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 230} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a250354dac605e024f2a5f9fcec55fed0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a250354dac605e024f2a5f9fcec55fed0_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v LSUInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:LSUInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::LSUInt (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXQ}
{\bkmkend AAAAAAACXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 172} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a83f10c95ae097b359aac068193bee8c6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v MSUInt\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:MSUInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::MSUInt (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXR}
{\bkmkend AAAAAAACXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_ae391b6179d8dd69d9ac771c003f0a210_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v multiply\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:multiply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UInt} MCHEmul::UInt::multiply (const {\b UInt} &  {\i u}) const}}
\par
{\bkmkstart AAAAAAACXS}
{\bkmkend AAAAAAACXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
always positive here.\par
}{
Definition at line {\b 254} of file {\b UInt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a0ec5d7b39c4b879168a92eb9e275e195_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a0ec5d7b39c4b879168a92eb9e275e195_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v negative\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:negative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::negative () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXT}
{\bkmkend AAAAAAACXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a82fd7c37e7e192031cc4918c86a22c41_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a82fd7c37e7e192031cc4918c86a22c41_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::operator!= (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXU}
{\bkmkend AAAAAAACXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 188} of file {\b UInt.hpp}.}\par
}
{\xe \v operator*\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::operator* (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXV}
{\bkmkend AAAAAAACXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_adf15164451cbe8f24df871bf35d6511f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} & MCHEmul::UInt::operator*= (const {\b UInt} &  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXW}
{\bkmkend AAAAAAACXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 214} of file {\b UInt.hpp}.}\par
}
{\xe \v operator+\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::operator+ (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXX}
{\bkmkend AAAAAAACXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a292f7be53607321b32d2e5a53ba2f0cd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} & MCHEmul::UInt::operator+= (const {\b UInt} &  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXY}
{\bkmkend AAAAAAACXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 204} of file {\b UInt.hpp}.}\par
}
{\xe \v operator-\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::operator- () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXZ}
{\bkmkend AAAAAAACXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 206} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a8ac5fdf971f0305b2a3d97a5decabb20_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} MCHEmul::UInt::operator- (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYA}
{\bkmkend AAAAAAACYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 208} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a1ed7bfdfcbb3fac32be79470ddb8c00d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} & MCHEmul::UInt::operator-= (const {\b UInt} &  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYB}
{\bkmkend AAAAAAACYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 210} of file {\b UInt.hpp}.}\par
}
{\xe \v operator<\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::operator< (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYC}
{\bkmkend AAAAAAACYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 197} of file {\b UInt.hpp}.}\par
}
{\xe \v operator<=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::operator<= (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYD}
{\bkmkend AAAAAAACYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b UInt.hpp}.}\par
}
{\xe \v operator=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt} & MCHEmul::UInt::operator= (const {\b UInt} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACYE}
{\bkmkend AAAAAAACYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::operator== (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYF}
{\bkmkend AAAAAAACYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b UInt.hpp}.}\par
}
{\xe \v operator>\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::operator> (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYG}
{\bkmkend AAAAAAACYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It is bigger when the difference between two quantities is positive and then the carry generated is 1. \par
}{
Definition at line {\b 193} of file {\b UInt.hpp}.}\par
}
{\xe \v operator>=\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::operator>= (const {\b UInt} &  {\i u}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYH}
{\bkmkend AAAAAAACYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 195} of file {\b UInt.hpp}.}\par
}
{\xe \v operator[]\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} & MCHEmul::UInt::operator[] (size_t  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYI}
{\bkmkend AAAAAAACYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 219} of file {\b UInt.hpp}.}\par
}
{\xe \v operator[]\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UByte} MCHEmul::UInt::operator[] (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYJ}
{\bkmkend AAAAAAACYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 217} of file {\b UInt.hpp}.}\par
}
{\xe \v overflow\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:overflow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::overflow () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYK}
{\bkmkend AAAAAAACYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b UInt.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a9aaca9ca5409530eaf765f1a25cb3c5d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v positive\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:positive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MCHEmul::UInt::positive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYL}
{\bkmkend AAAAAAACYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_ae56c8ff272c39138e55551f9311a1f05_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_ae56c8ff272c39138e55551f9311a1f05_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v resetCarry\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:resetCarry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UInt::resetCarry (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYM}
{\bkmkend AAAAAAACYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b UInt.hpp}.}\par
}
{\xe \v resetOverflow\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:resetOverflow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UInt::resetOverflow (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYN}
{\bkmkend AAAAAAACYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 161} of file {\b UInt.hpp}.}\par
}
{\xe \v setMinLength\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:setMinLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MCHEmul::UInt::setMinLength (size_t  {\i l}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYO}
{\bkmkend AAAAAAACYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
_0 at the left.\par
}{
Definition at line {\b 164} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a0b31f9c6b80e4f014f0ecb872af107a1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a0b31f9c6b80e4f014f0ecb872af107a1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::UInt::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYP}
{\bkmkend AAAAAAACYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a24cfc763638097abb54c8440eb30e2b0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a24cfc763638097abb54c8440eb30e2b0_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sizeBits\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:sizeBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MCHEmul::UInt::sizeBits () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYQ}
{\bkmkend AAAAAAACYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b UInt.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a2b9ffcdf5f9256fe6236b9da2d0e5816_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v substract\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:substract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MCHEmul::UInt} MCHEmul::UInt::substract (const {\b UInt} &  {\i u}, bool  {\i iC} = {\f2 true}) const}}
\par
{\bkmkstart AAAAAAACYR}
{\bkmkend AAAAAAACYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 233} of file {\b UInt.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a5ff2fdea1893b3e6e665108e29e59973_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_a5ff2fdea1893b3e6e665108e29e59973_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v values\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UBytes} & MCHEmul::UInt::values () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYS}
{\bkmkend AAAAAAACYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b UInt.hpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_c_h_emul_1_1_u_int_aa0f3a57c9a16e1716dfb8621fc0a95df_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i o}, const {\b UInt} &  {\i u}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACYT}
{\bkmkend AAAAAAACYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 236} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _0\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::UInt} MCHEmul::UInt::_0 = {\b MCHEmul::UInt} (\{ MCHEmul::UByte::_0 \}, false, false){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACYU}
{\bkmkend AAAAAAACYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The very basic numbers, represented in binary. \par
}{
Definition at line {\b 115} of file {\b UInt.hpp}.}\par
}
{\xe \v _1\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::UInt} MCHEmul::UInt::_1 = {\b MCHEmul::UInt} (\{ MCHEmul::UByte::_1 \}, false, false){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACYV}
{\bkmkend AAAAAAACYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b UInt.hpp}.}\par
}
{\xe \v _BINARY\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:_BINARY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UInt::_BINARY = 0x00{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACYW}
{\bkmkend AAAAAAACYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The default one . \par
}{
Definition at line {\b 83} of file {\b UInt.hpp}.}\par
}
{\xe \v _formatManagers\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:_formatManagers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<unsigned char, {\b FormatManager}*> MCHEmul::UInt::_formatManagers{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACYX}
{\bkmkend AAAAAAACYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The different format managers are kept in a public static map. The map is loaded with the basic formaters (BINARY and BCD), buy others can be added if needed. \par
}{
Definition at line {\b 112} of file {\b UInt.hpp}.}\par
}
{\xe \v _PACKAGEDBCD\:MCHEmul::UInt}
{\xe \v MCHEmul::UInt\:_PACKAGEDBCD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char MCHEmul::UInt::_PACKAGEDBCD = 0x01{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACYY}
{\bkmkend AAAAAAACYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
...and also the Packaged BCD very common in 80's computers \par
}{
Definition at line {\b 85} of file {\b UInt.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/{\b UInt.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/{\b UInt.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::UserIONoPeripheral Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::UserIONoPeripheral}
{\xe \v C64::UserIONoPeripheral}
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
\par
{
{\f2 #include <UserPeripherals.hpp>}}\par
Inheritance diagram for C64::UserIONoPeripheral:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_user_i_o_no_peripheral__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::UserIONoPeripheral:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_user_i_o_no_peripheral__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UserIONoPeripheral} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _ID} = -1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a no device, just for simulation purposes. This is the one created when no other is defined for the commodore 64. \par
}{
Definition at line {\b 32} of file {\b UserPeripherals.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v UserIONoPeripheral\:C64::UserIONoPeripheral}
{\xe \v C64::UserIONoPeripheral\:UserIONoPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::UserIONoPeripheral::UserIONoPeripheral (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b UserPeripherals.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:C64::UserIONoPeripheral}
{\xe \v C64::UserIONoPeripheral\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::UserIONoPeripheral::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the peripheral. The initialization should return true when everything is ok, and false in other case. \par
}{
Implements {\b MCHEmul::IOPeripheral} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 4} of file {\b UserPeripherals.cpp}.}\par
}
{\xe \v simulate\:C64::UserIONoPeripheral}
{\xe \v C64::UserIONoPeripheral\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::UserIONoPeripheral::simulate (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To emulate the way it works. \par
Should return true if everything was ok. \par
}{
Implements {\b MCHEmul::IOPeripheral} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 12} of file {\b UserPeripherals.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::UserIONoPeripheral}
{\xe \v C64::UserIONoPeripheral\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::UserIONoPeripheral::_ID = -1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b UserPeripherals.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b UserPeripherals.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b UserPeripherals.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::UserIOPeripheral Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::UserIOPeripheral}
{\xe \v C64::UserIOPeripheral}
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
\par
{
{\f2 #include <UserPeripherals.hpp>}}\par
Inheritance diagram for C64::UserIOPeripheral:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_user_i_o_peripheral__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::UserIOPeripheral:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_user_i_o_peripheral__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UserIOPeripheral} (int {\b id})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents any peripheral connected to the User Port. \par
}{
Definition at line {\b 22} of file {\b UserPeripherals.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v UserIOPeripheral\:C64::UserIOPeripheral}
{\xe \v C64::UserIOPeripheral\:UserIOPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::UserIOPeripheral::UserIOPeripheral (int  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b UserPeripherals.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b UserPeripherals.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::UserIOPort Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::UserIOPort}
{\xe \v C64::UserIOPort}
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
\par
{
{\f2 #include <UserPort.hpp>}}\par
Inheritance diagram for C64::UserIOPort:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_user_i_o_port__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::UserIOPort:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_user_i_o_port__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UserIOPort} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b addPeripheral} ({\b MCHEmul::IOPeripheral} *p) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b _ID} = 3\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class represents the {\b UserIOPort}. \par
}{
Definition at line {\b 24} of file {\b UserPort.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v UserIOPort\:C64::UserIOPort}
{\xe \v C64::UserIOPort\:UserIOPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::UserIOPort::UserIOPort ()}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b UserPort.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addPeripheral\:C64::UserIOPort}
{\xe \v C64::UserIOPort\:addPeripheral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::UserIOPort::addPeripheral ({\b MCHEmul::IOPeripheral} *  {\i p}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It verifies before adding it that whether the Peripherial is a UserIOPeripherial, as they are the only ones compatible with this type of Port. \par
}{
Reimplemented from {\b MCHEmul::IODevice} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 14} of file {\b UserPort.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_user_i_o_port_a024d0cd799ff291070b12607507df49b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _ID\:C64::UserIOPort}
{\xe \v C64::UserIOPort\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int C64::UserIOPort::_ID = 3{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b UserPort.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b UserPort.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b UserPort.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::VICII Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::VICII}
{\xe \v C64::VICII}
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
\par
{
{\f2 #include <VICII.hpp>}}\par
Inheritance diagram for C64::VICII:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::VICII:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Raster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RasterData}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VICII} (const {\b RasterData} &vd, const {\b RasterData} &hd, const {\b MCHEmul::Attributes} &attrs=\{ \})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~VICII} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b bank} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBank} (unsigned char bk)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b initialize} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b simulate} ({\b MCHEmul::CPU} *cpu) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _ID} = 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned short {\b _GRAPHMAXCHARLINES} = 25\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned short {\b _GRAPHMAXCHARCOLUMNS} = 40\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned short {\b _GRAPHMAXBITMAPCOLUMNS} = 320\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned short {\b _GRAPHMAXBITMAPROWS} = 200\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const unsigned int {\b _CPUCYCLESWHENREADGRAPHS} = 40\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b MCHEmul::Address} {\b _COLORMEMORY}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The chip that takes care of anything around the graphics in Commodore 64. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b GraphicalChip}. \par
}}}{
Definition at line {\b 24} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v VICII\:C64::VICII}
{\xe \v C64::VICII\:VICII}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::VICII (const {\b RasterData} &  {\i vd}, const {\b RasterData} &  {\i hd}, const {\b MCHEmul::Attributes} &  {\i attrs} = {\f2 \{\~ \}})}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specific classes for PAL & NTSC have been created giving this data as default. \par
}{
Definition at line {\b 91} of file {\b VICII.cpp}.}\par
}
{\xe \v ~VICII\:C64::VICII}
{\xe \v C64::VICII\:~VICII}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII::~VICII ()}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b VICII.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v bank\:C64::VICII}
{\xe \v C64::VICII\:bank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICII::bank () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To change and get the bank. \par
}{
Definition at line {\b 241} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_a6ed0683e01b203fffea51ee3a333e78c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_a6ed0683e01b203fffea51ee3a333e78c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initialize\:C64::VICII}
{\xe \v C64::VICII\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To initialize the chip, when "the power is set up". \par
 It could be defined per chip. By default it does nothing. \par
Returns true, when verything was ok, and false in any other circusntance. \par
}{
Reimplemented from {\b MCHEmul::GraphicalChip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 115} of file {\b VICII.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_adda4b290b7fd2a55b2d05c1a7c3abb1e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setBank\:C64::VICII}
{\xe \v C64::VICII\:setBank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICII::setBank (unsigned char  {\i bk}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 243} of file {\b VICII.hpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_af0eb6c544a59218110b5ab8b61c0a2f2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_af0eb6c544a59218110b5ab8b61c0a2f2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v simulate\:C64::VICII}
{\xe \v C64::VICII\:simulate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICII::simulate ({\b MCHEmul::CPU} * ){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simulate th behaviour of the chip. It has to be defined per chip. \par
Returns true if everything was ok, and false in any other circunstance. \par
 The last error could be recovered from the variable _lastError in that case. \par
The clock cyclees is added. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The three last bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
definition above.\par
}}false = real.\par
false = real.\par
false = real.\par
false = real.\par
}{
Implements {\b MCHEmul::Chip} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 148} of file {\b VICII.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _COLORMEMORY\:C64::VICII}
{\xe \v C64::VICII\:_COLORMEMORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::Address} C64::VICII::_COLORMEMORY{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static address. The color memory cann't be changed. \par
}{
Definition at line {\b 233} of file {\b VICII.hpp}.}\par
}
{\xe \v _CPUCYCLESWHENREADGRAPHS\:C64::VICII}
{\xe \v C64::VICII\:_CPUCYCLESWHENREADGRAPHS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int C64::VICII::_CPUCYCLESWHENREADGRAPHS = 40{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CPU Cycles when the graphics are read. \par
}{
Definition at line {\b 230} of file {\b VICII.hpp}.}\par
}
{\xe \v _GRAPHMAXBITMAPCOLUMNS\:C64::VICII}
{\xe \v C64::VICII\:_GRAPHMAXBITMAPCOLUMNS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::_GRAPHMAXBITMAPCOLUMNS = 320{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 226} of file {\b VICII.hpp}.}\par
}
{\xe \v _GRAPHMAXBITMAPROWS\:C64::VICII}
{\xe \v C64::VICII\:_GRAPHMAXBITMAPROWS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::_GRAPHMAXBITMAPROWS = 200{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 227} of file {\b VICII.hpp}.}\par
}
{\xe \v _GRAPHMAXCHARCOLUMNS\:C64::VICII}
{\xe \v C64::VICII\:_GRAPHMAXCHARCOLUMNS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::_GRAPHMAXCHARCOLUMNS = 40{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b VICII.hpp}.}\par
}
{\xe \v _GRAPHMAXCHARLINES\:C64::VICII}
{\xe \v C64::VICII\:_GRAPHMAXCHARLINES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned short C64::VICII::_GRAPHMAXCHARLINES = 25{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data about the size of the screen \par
}{
Definition at line {\b 224} of file {\b VICII.hpp}.}\par
}
{\xe \v _ID\:C64::VICII}
{\xe \v C64::VICII\:_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int C64::VICII::_ID = 4{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 221} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b VICII.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b VICII.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::VICII_NTSC Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::VICII_NTSC}
{\xe \v C64::VICII_NTSC}
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
\par
{
{\f2 #include <VICII.hpp>}}\par
Inheritance diagram for C64::VICII_NTSC:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i___n_t_s_c__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::VICII_NTSC:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i___n_t_s_c__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VICII_NTSC} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b RasterData} {\b _VRASTERDATA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b RasterData} {\b _HRASTERDATA}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The version para NTSC systems. \par
}{
Definition at line {\b 331} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v VICII_NTSC\:C64::VICII_NTSC}
{\xe \v C64::VICII_NTSC\:VICII_NTSC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII_NTSC::VICII_NTSC ()}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 442} of file {\b VICII.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _HRASTERDATA\:C64::VICII_NTSC}
{\xe \v C64::VICII_NTSC\:_HRASTERDATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b C64::VICII::RasterData} C64::VICII_NTSC::_HRASTERDATA{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 335} of file {\b VICII.hpp}.}\par
}
{\xe \v _VRASTERDATA\:C64::VICII_NTSC}
{\xe \v C64::VICII_NTSC\:_VRASTERDATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b C64::VICII::RasterData} C64::VICII_NTSC::_VRASTERDATA{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 334} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b VICII.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b VICII.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::VICII_PAL Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::VICII_PAL}
{\xe \v C64::VICII_PAL}
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
\par
{
{\f2 #include <VICII.hpp>}}\par
Inheritance diagram for C64::VICII_PAL:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i___p_a_l__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::VICII_PAL:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i___p_a_l__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VICII_PAL} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b RasterData} {\b _VRASTERDATA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b RasterData} {\b _HRASTERDATA}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The version para PAL systems. \par
}{
Definition at line {\b 341} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v VICII_PAL\:C64::VICII_PAL}
{\xe \v C64::VICII_PAL\:VICII_PAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICII_PAL::VICII_PAL ()}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 454} of file {\b VICII.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _HRASTERDATA\:C64::VICII_PAL}
{\xe \v C64::VICII_PAL\:_HRASTERDATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b C64::VICII::RasterData} C64::VICII_PAL::_HRASTERDATA{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 345} of file {\b VICII.hpp}.}\par
}
{\xe \v _VRASTERDATA\:C64::VICII_PAL}
{\xe \v C64::VICII_PAL\:_VRASTERDATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b C64::VICII::RasterData} C64::VICII_PAL::_VRASTERDATA{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 344} of file {\b VICII.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b VICII.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b VICII.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64::VICIIRegisters Class Reference\par \pard\plain 
{\tc\tcl2 \v C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters}
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
\par
{
{\f2 #include <VICIIRegisters.hpp>}}\par
Inheritance diagram for C64::VICIIRegisters:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_registers__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for C64::VICIIRegisters:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_registers__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b GraphicMode} \{ {\b _CHARMODE} = 0
, {\b _MULTICOLORCHARMODE}
, {\b _BITMAPMODE}
, {\b _MULTICOLORBITMAPMODE}
, {\b _EXTENDEDBACKGROUNDMODE}
, {\b _ILLEGALMODE}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VICIIRegisters} (int {\b id}, {\b MCHEmul::PhisicalStorage} *ps)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b borderColor} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b backgroundColor} (size_t p=0) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b spriteXCoord} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b spriteYCoord} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b spriteColor} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b spriteSharedColor} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteEnable} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteDoubleWidth} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteDoubleHeight} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteToForegroundPriority} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b verticalScrollPosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b horizontalScrollPosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b textDisplay25RowsActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b textDisplay40ColumnsActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b screenSameColorBorderActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b videoResetActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b graphicBitModeActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b graphicExtendedColorTextModeActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b graphicMulticolorTextModeActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GraphicMode} {\b graphicModeActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rasterIRQActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteCollisionWithDataIRQActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteCollisionsIRQActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b lightPenIRQActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b IRQRasterLineAt} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MCHEmul::Address} {\b charDataMemory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MCHEmul::Address} {\b screenMemory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MCHEmul::Address} {\b bitmapMemory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentRasterLine} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCurrentRasterLine} (unsigned short rL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentLightPenHorizontalPosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b currentLightPenVerticalPosition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCurrentLightPenPosition} (unsigned char x, unsigned char y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rasterAtIRQLine} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRasterAtLine} (bool rL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spritesCollisionWithDataHappened} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpritesCollisionWithData} (bool c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteCollisionWithDataHappened} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpriteCollisionWithDataHappened} (size_t p, bool c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spritesCollisionHappened} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpritesCollision} (bool c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b spriteCollisionHappened} (size_t p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpriteCollision} (size_t p, bool c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b lightPenOnScreenHappened} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLightPenOnScreen} (bool l)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b vicIItoGenerateIRQ} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVicIItoGenerateIRQ} (bool v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b bank} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBank} (unsigned char bk)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In the {\b VICII} Registers, there are a couple of records that behave different when they are read that when they are written. \par
}{
Definition at line {\b 25} of file {\b VICIIRegisters.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v GraphicMode\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:GraphicMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b C64::VICIIRegisters::GraphicMode}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v _CHARMODE\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:_CHARMODE}
{\qr _CHARMODE{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
\cell }{\cell }{\row }
{\xe \v _MULTICOLORCHARMODE\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:_MULTICOLORCHARMODE}
{\qr _MULTICOLORCHARMODE{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
\cell }{\cell }{\row }
{\xe \v _BITMAPMODE\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:_BITMAPMODE}
{\qr _BITMAPMODE{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
\cell }{\cell }{\row }
{\xe \v _MULTICOLORBITMAPMODE\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:_MULTICOLORBITMAPMODE}
{\qr _MULTICOLORBITMAPMODE{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
\cell }{\cell }{\row }
{\xe \v _EXTENDEDBACKGROUNDMODE\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:_EXTENDEDBACKGROUNDMODE}
{\qr _EXTENDEDBACKGROUNDMODE{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
\cell }{\cell }{\row }
{\xe \v _ILLEGALMODE\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:_ILLEGALMODE}
{\qr _ILLEGALMODE{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 28} of file {\b VICIIRegisters.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v VICIIRegisters\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:VICIIRegisters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
C64::VICIIRegisters::VICIIRegisters (int  {\i id}, {\b MCHEmul::PhisicalStorage} *  {\i ps}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b VICIIRegisters.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v backgroundColor\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:backgroundColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::backgroundColor (size_t  {\i p} = {\f2 0}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v bank\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:bank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::bank () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v bitmapMemory\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:bitmapMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::Address} C64::VICIIRegisters::bitmapMemory () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v borderColor\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:borderColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::borderColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v charDataMemory\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:charDataMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::Address} C64::VICIIRegisters::charDataMemory () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VICII} Only addresses 16k.\par
}{
Definition at line {\b 109} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v currentLightPenHorizontalPosition\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:currentLightPenHorizontalPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICIIRegisters::currentLightPenHorizontalPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v currentLightPenVerticalPosition\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:currentLightPenVerticalPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICIIRegisters::currentLightPenVerticalPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v currentRasterLine\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:currentRasterLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICIIRegisters::currentRasterLine () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v graphicBitModeActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:graphicBitModeActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::graphicBitModeActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v graphicExtendedColorTextModeActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:graphicExtendedColorTextModeActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::graphicExtendedColorTextModeActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v graphicModeActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:graphicModeActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GraphicMode} C64::VICIIRegisters::graphicModeActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v graphicMulticolorTextModeActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:graphicMulticolorTextModeActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::graphicMulticolorTextModeActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v horizontalScrollPosition\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:horizontalScrollPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::horizontalScrollPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v initialize\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To init the memory. It might be overloaded. By default the "defaultData" value is assigned. It doesn't matter whether the subset is or not active. \par
}{
Reimplemented from {\b MCHEmul::PhisicalStorageSubset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 5} of file {\b VICIIRegisters.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c64_1_1_v_i_c_i_i_registers_af1aa9ca73be269a905470ac794e38f9e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v IRQRasterLineAt\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:IRQRasterLineAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICIIRegisters::IRQRasterLineAt () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v lightPenIRQActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:lightPenIRQActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::lightPenIRQActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v lightPenOnScreenHappened\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:lightPenOnScreenHappened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::lightPenOnScreenHappened () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v rasterAtIRQLine\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:rasterAtIRQLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::rasterAtIRQLine () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v rasterIRQActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:rasterIRQActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::rasterIRQActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v screenMemory\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:screenMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MCHEmul::Address} C64::VICIIRegisters::screenMemory () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v screenSameColorBorderActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:screenSameColorBorderActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::screenSameColorBorderActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setBank\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setBank}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setBank (unsigned char  {\i bk}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setCurrentLightPenPosition\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setCurrentLightPenPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setCurrentLightPenPosition (unsigned char  {\i x}, unsigned char  {\i y}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setCurrentRasterLine\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setCurrentRasterLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setCurrentRasterLine (unsigned short  {\i rL}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setLightPenOnScreen\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setLightPenOnScreen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setLightPenOnScreen (bool  {\i l}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setRasterAtLine\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setRasterAtLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setRasterAtLine (bool  {\i rL}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setSpriteCollision\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setSpriteCollision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setSpriteCollision (size_t  {\i p}, bool  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setSpriteCollisionWithDataHappened\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setSpriteCollisionWithDataHappened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setSpriteCollisionWithDataHappened (size_t  {\i p}, bool  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setSpritesCollision\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setSpritesCollision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setSpritesCollision (bool  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 145} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setSpritesCollisionWithData\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setSpritesCollisionWithData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setSpritesCollisionWithData (bool  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v setVicIItoGenerateIRQ\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:setVicIItoGenerateIRQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void C64::VICIIRegisters::setVicIItoGenerateIRQ (bool  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteCollisionHappened\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteCollisionHappened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteCollisionHappened (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteCollisionsIRQActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteCollisionsIRQActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteCollisionsIRQActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteCollisionWithDataHappened\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteCollisionWithDataHappened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteCollisionWithDataHappened (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteCollisionWithDataIRQActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteCollisionWithDataIRQActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteCollisionWithDataIRQActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteColor\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::spriteColor (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteDoubleHeight\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteDoubleHeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteDoubleHeight (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteDoubleWidth\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteDoubleWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteDoubleWidth (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteEnable\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteEnable (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spritesCollisionHappened\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spritesCollisionHappened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spritesCollisionHappened () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spritesCollisionWithDataHappened\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spritesCollisionWithDataHappened}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spritesCollisionWithDataHappened () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteSharedColor\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteSharedColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::spriteSharedColor (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteToForegroundPriority\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteToForegroundPriority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::spriteToForegroundPriority (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteXCoord\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteXCoord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short C64::VICIIRegisters::spriteXCoord (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v spriteYCoord\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:spriteYCoord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::spriteYCoord (size_t  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v textDisplay25RowsActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:textDisplay25RowsActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::textDisplay25RowsActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v textDisplay40ColumnsActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:textDisplay40ColumnsActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::textDisplay40ColumnsActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v verticalScrollPosition\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:verticalScrollPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char C64::VICIIRegisters::verticalScrollPosition () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v vicIItoGenerateIRQ\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:vicIItoGenerateIRQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::vicIItoGenerateIRQ () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b VICIIRegisters.hpp}.}\par
}
{\xe \v videoResetActive\:C64::VICIIRegisters}
{\xe \v C64::VICIIRegisters\:videoResetActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool C64::VICIIRegisters::videoResetActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b VICIIRegisters.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/{\b VICIIRegisters.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/{\b VICIIRegisters.cpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Compiler.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Compiler.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Compiler.hpp}
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Incs.hpp>}\par
{\f2 #include <ASSEMBLER/Grammar.hpp>}\par
{\f2 #include <ASSEMBLER/Parser.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::ByteCodeLine}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::ByteCode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::Compiler}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul::Assembler}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Compiler.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Compiler.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Compiler.hpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __ASSEMBLER_COMPILER__}\par
00015 {\cf21 #define __ASSEMBLER_COMPILER__}\par
00016 \par
00017 {\cf21 #include <CORE/Incs.hpp>}\par
00018 {\cf21 #include <ASSEMBLER/Grammar.hpp>}\par
00019 {\cf21 #include <ASSEMBLER/Parser.hpp>}\par
00020 \par
00021 {\cf17 namespace }MCHEmul\par
00022 \{\par
00023     {\cf17 namespace }Assembler\par
00024     \{\par
00026         {\cf17 struct }ByteCodeLine final\par
00027         \{\par
00028             ByteCodeLine ()\par
00029                 : _address (\{ 0x00 \}), _bytes (), _label ({\cf22 ""}), _instruction ({\cf17 nullptr}), _actionOn (0)\par
00030                             \{ \}\par
00031 \par
00032             ByteCodeLine ({\cf17 const} Address& a, {\cf17 const} std::vector <UByte>& b, {\cf17 const} std::string& n, \par
00033                     {\cf17 const} Instruction* i, {\cf18 unsigned} {\cf18 int} act)\par
00034                 : _address (a), _bytes (b), _label (n), _instruction (i), _actionOn (act)\par
00035                             \{ \}\par
00036 \par
00037             ByteCodeLine ({\cf17 const} ByteCodeLine&) = {\cf19 default};\par
00038 \par
00039             ByteCodeLine& operator = ({\cf17 const} ByteCodeLine&) = {\cf19 default};\par
00040 \par
00041             {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} ByteCodeLine& c);\par
00042 \par
00043             Address _address;\par
00044             std::vector <UByte> _bytes;\par
00045             std::string _label;\par
00046             {\cf17 const} Instruction* _instruction;\par
00047             {\cf18 unsigned} {\cf18 int} _actionOn;\par
00048         \};\par
00049 \par
00051         {\cf17 struct }ByteCode final\par
00052         \{\par
00053             ByteCode () = {\cf19 default};\par
00054 \par
00055             ByteCode ({\cf17 const} ByteCode&) = {\cf19 default};\par
00056 \par
00057             ByteCode& operator = ({\cf17 const} ByteCode&) = {\cf19 default};\par
00058 \par
00061             std::vector <UByte> asSetOfBytes (Address& iA) {\cf17 const};\par
00062 \par
00065             std::map <Address, unsigned int> listOfActions () {\cf17 const};\par
00066 \par
00068             {\cf18 void} loadIntoMemory (Memory* m);\par
00069 \par
00070             {\cf17 static} ByteCode createFromMemory ({\cf17 const} Address& a, {\cf18 unsigned} {\cf18 int} b, Memory* m, CPU* cpu);\par
00071 \par
00072             std::vector <ByteCodeLine> _lines;\par
00073         \};\par
00074 \par
00078         {\cf17 class }Compiler final\par
00079         \{\par
00080             {\cf17 public}:\par
00081             Compiler ({\cf17 const} Parser& p)\par
00082                 : _parser (p)\par
00083                             \{ \}\par
00084 \par
00089             ByteCode compile ({\cf17 const} std::string& fN) {\cf17 const};\par
00090 \par
00091             {\cf17 const} CPU* cpu (){\cf17  const}\par
00092 {\cf17                             }\{ {\cf19 return} (_parser.cpu ()); \}\par
00093 \par
00094             Errors errors (){\cf17  const}\par
00095 {\cf17                             }\{ {\cf19 return} (_errors); \}\par
00096 \par
00098             {\cf18 bool} operator ! (){\cf17  const}\par
00099 {\cf17                             }\{ {\cf19 return} (!_errors.empty ()); \}\par
00100 \par
00101             {\cf17 private}:\par
00102             {\cf17 const} Parser& _parser;\par
00103 \par
00104             {\cf20 // Implementation}\par
00105             {\cf17 mutable} Errors _errors;\par
00106         \};\par
00107     \}\par
00108 \}\par
00109 \par
00110 {\cf21 #endif}\par
00111   \par
00112 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Error.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Error.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Error.hpp}
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::Error}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul::Assembler}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Assembler::Errors} = std::vector< Error >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b MCHEmul::Assembler::ErrorType} \{ {\b MCHEmul::Assembler::_NOERROR} = 0
, {\b MCHEmul::Assembler::_MACROBADDEFINED}
, {\b MCHEmul::Assembler::_MACRONOTDEFINED}
, {\b MCHEmul::Assembler::_LABELNOTVALID}
, {\b MCHEmul::Assembler::_LABELNOTDEFINED}
, {\b MCHEmul::Assembler::_BYTESNOTVALID}
, {\b MCHEmul::Assembler::_INSTRUCTIONNOTVALID}
, {\b MCHEmul::Assembler::_INSTRUCTIONNOTDEFINED}
, {\b MCHEmul::Assembler::_STARTINGPOINTNOTVALID}
, {\b MCHEmul::Assembler::_GRAMARELEMENTNOTVALID}
, {\b MCHEmul::Assembler::_STARTINGPOINTNOTDEFINED}
, {\b MCHEmul::Assembler::_DUPLICATEMACRO}
, {\b MCHEmul::Assembler::_SEMANTICERROR}
, {\b MCHEmul::Assembler::_FILEEMPTY}
, {\b MCHEmul::Assembler::_PARSERNOTFOUND}
 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Error.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Error.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Error.hpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __ASSEMBLER_ERROR__}\par
00015 {\cf21 #define __ASSEMBLER_ERROR__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00021     {\cf17 namespace }Assembler\par
00022     \{\par
00024         {\cf17 enum class} ErrorType\par
00025         \{ \par
00026             _NOERROR = 0, \par
00027             {\cf20 // Related with Macros}\par
00028             _MACROBADDEFINED, \par
00029             _MACRONOTDEFINED, \par
00030             {\cf20 // Related with Semantic Elements}\par
00031             _LABELNOTVALID,\par
00032             _LABELNOTDEFINED,\par
00033             _BYTESNOTVALID,\par
00034             _INSTRUCTIONNOTVALID,\par
00035             _INSTRUCTIONNOTDEFINED,\par
00036             _STARTINGPOINTNOTVALID,\par
00037             {\cf20 // Related with Semantic structure}\par
00038             _GRAMARELEMENTNOTVALID, \par
00039             _STARTINGPOINTNOTDEFINED,\par
00040             _DUPLICATEMACRO,\par
00041             _SEMANTICERROR,\par
00042             {\cf20 // Related with Parser errors}\par
00043             _FILEEMPTY, \par
00044             _PARSERNOTFOUND, \par
00045         \};\par
00046 \par
00048         {\cf17 struct }Error\par
00049         \{\par
00050             Error ()\par
00051                 : _type (ErrorType::_NOERROR), \par
00052                   _file ({\cf22 ""}),\par
00053                   _line (0), _column (0)\par
00054                             \{ \}\par
00055 \par
00056             Error (ErrorType eT, {\cf17 const} std::string& f, {\cf18 unsigned} {\cf18 int} l, {\cf18 unsigned} {\cf18 int} c)\par
00057                 : _type (eT), _file (f), _line (l), _column (c)\par
00058                             \{ \}\par
00059 \par
00060             Error ({\cf17 const} Error&) = {\cf19 default};\par
00061 \par
00062             Error& operator = ({\cf17 const} Error&) = {\cf19 default};\par
00063 \par
00064             {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Error& e);\par
00065 \par
00066             ErrorType _type;\par
00067             std::string _file;\par
00068             {\cf18 unsigned} {\cf18 int} _line;\par
00069             {\cf18 unsigned} {\cf18 int} _column;\par
00070         \};\par
00071 \par
00072         {\cf17 using} Errors = std::vector <Error>;\par
00073     \}\par
00074 \}\par
00075 \par
00076 {\cf21 #endif}\par
00077   \par
00078 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Grammar.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Grammar.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Grammar.hpp}
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <ASSEMBLER/Error.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::Macro}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::GrammaticalElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::LabelElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::BytesInMemoryElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::InstructionElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Assembler::StartingPointElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::Semantic}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul::Assembler}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Assembler::Macros} = std::map< std::string, Macro >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Assembler::StartingPointElements} = std::vector< StartingPointElement * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Grammar.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Grammar.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Grammar.hpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00031 {\cf21 #ifndef __ASSEMBLER_GRAMMAR__}\par
00032 {\cf21 #define __ASSEMBLER_GRAMMAR__}\par
00033 \par
00034 {\cf21 #include <CORE/incs.hpp>}\par
00035 {\cf21 #include <ASSEMBLER/Error.hpp>}\par
00036 \par
00037 {\cf17 namespace }MCHEmul\par
00038 \{\par
00039     {\cf17 namespace }Assembler\par
00040     \{\par
00045         {\cf17 class }Macro;\par
00046         {\cf17 using} Macros = std::map <std::string, Macro>;\par
00047         {\cf17 class }Macro\par
00048         \{\par
00049             {\cf17 public}:\par
00050             Macro ()\par
00051                 : _name ({\cf22 ""}), _equivalent ({\cf22 ""}),\par
00052                   _value (\{ \}), \par
00053                   _error (ErrorType::_NOERROR) \par
00054                                 \{ \}\par
00055 \par
00056             Macro ({\cf17 const} std::string& n, {\cf17 const} std::string& e)\par
00057                 : _name (n), _equivalent (e),\par
00058                   _value (\{ \}),\par
00059                   _error (ErrorType::_NOERROR)\par
00060                             \{ \}\par
00061 \par
00062             Macro ({\cf17 const} Macro&) = {\cf19 default};\par
00063 \par
00064             Macro& operator = ({\cf17 const} Macro&) = {\cf19 default};\par
00065 \par
00066             {\cf17 const} std::string& name (){\cf17  const}\par
00067 {\cf17                             }\{ {\cf19 return} (_name); \}\par
00068             {\cf17 const} std::string& equivalent (){\cf17  const}\par
00069 {\cf17                             }\{ {\cf19 return} (_equivalent); \}\par
00070             ErrorType error (){\cf17  const}\par
00071 {\cf17                             }\{ {\cf19 return} (_error); \}\par
00072 \par
00076             {\cf17 const} std::vector <UByte>& value ({\cf17 const} Macros& ms){\cf17  const}\par
00077 {\cf17                             }\{ {\cf19 return} (_value.empty () ? _value = calculateValue (_equivalent, ms) : _value ); \}\par
00078 \par
00080             {\cf18 bool} operator ! (){\cf17  const}\par
00081 {\cf17                             }\{ value (\{ \}) ; {\cf19 return} (_error != ErrorType::_NOERROR); \}\par
00082 \par
00083             {\cf17 private}:\par
00086             std::vector <UByte> calculateValue ({\cf17 const} std::string& e, {\cf17 const} Macros& ms) {\cf17 const};\par
00087 \par
00088             {\cf17 private}:\par
00090             {\cf17 const} std::string _name;\par
00092             {\cf17 const} std::string _equivalent; \par
00093 \par
00094             {\cf20 // Implementation}\par
00095             {\cf17 mutable} std::vector <UByte> _value;\par
00096             {\cf17 mutable} ErrorType _error;\par
00097         \};\par
00098 \par
00100         {\cf17 class }Semantic;\par
00101         {\cf17 struct }GrammaticalElement\par
00102         \{\par
00103             {\cf17 enum} Type \{ _LABEL = 0, _BYTESINMEMORY, _INSTRUCTION, _STARTINGPOINT  \};\par
00104 \par
00105             GrammaticalElement ()\par
00106                 : _type (_BYTESINMEMORY), _id (0), _line (0), _actionOn (0),\par
00107                   _nextElement (nullptr), _previousElement (nullptr),\par
00108                   _error (ErrorType::_NOERROR), _codeBytes ()\par
00109                             \{ \}\par
00110 \par
00111             GrammaticalElement ({\cf17 const} GrammaticalElement&) = {\cf19 default};\par
00112 \par
00113             GrammaticalElement& operator = ({\cf17 const} GrammaticalElement&) = {\cf19 default};\par
00114 \par
00115             {\cf17 virtual} ~GrammaticalElement ()\par
00116                             \{ {\cf17 delete} (_nextElement);  \}\par
00117 \par
00120             {\cf17 virtual} {\cf18 size_t} size ({\cf17 const} Semantic* s){\cf17  const }\par
00121 {\cf17                             }\{ {\cf19 return} (0); \}\par
00122 \par
00126             std::vector <UByte> codeBytes ({\cf17 const} Semantic* s, {\cf18 bool} bE = {\cf17 true}){\cf17  const}\par
00127 {\cf17                             }\{ {\cf19 return} (_codeBytes.empty () ? _codeBytes = calculateCodeBytes (s, bE) : _codeBytes); \}\par
00128 \par
00130             {\cf17 virtual} Address address ({\cf17 const} MCHEmul::Assembler::Semantic* s) {\cf17 const};\par
00131 \par
00132             ErrorType error (){\cf17  const}\par
00133 {\cf17                             }\{ {\cf19 return} (_error); \}\par
00134 \par
00136             {\cf18 bool} operator ! (){\cf17  const}\par
00137 {\cf17                             }\{ {\cf19 return} (_error != ErrorType::_NOERROR); \}\par
00138 \par
00139             Type _type;\par
00140             {\cf18 unsigned} {\cf18 int} _id; {\cf20 // Sequential...}\par
00141             {\cf18 unsigned} {\cf18 int} _line; {\cf20 // The line where the definition appears...}\par
00142             {\cf18 unsigned} {\cf18 int} _actionOn; {\cf20 // It might be understand by the compiler...}\par
00144 {\cf20 }            GrammaticalElement* _nextElement; {\cf20 // Could be nullptr (in the last gramatical element of a semantic block)}\par
00146 {\cf20 }            GrammaticalElement* _previousElement; {\cf20 // It could also be nullptr (in the first gramatical element of a semantic block)}\par
00148 {\cf20 }            {\cf17 mutable} ErrorType _error;\par
00149             \par
00150             {\cf17 protected}:\par
00151             {\cf20 // Implementation}\par
00152             {\cf17 mutable} std::vector <UByte> _codeBytes;\par
00153 \par
00154             {\cf17 protected}:\par
00156             {\cf17 virtual} std::vector <UByte> calculateCodeBytes ({\cf17 const} Semantic* s, {\cf18 bool} bE = {\cf17 true}){\cf17  const}\par
00157 {\cf17                             }\{ {\cf19 return} (std::vector <UByte> ()); \}\par
00158 \par
00159             {\cf20 // Implementation}\par
00160             std::vector <UByte> bytesFromExpression ({\cf17 const} std::string& e, {\cf17 const} Macros& ms, {\cf18 bool}& er) {\cf17 const};\par
00161         \};\par
00162 \par
00164         {\cf17 struct }LabelElement final : {\cf17 public} GrammaticalElement\par
00165         \{\par
00166             LabelElement ()\par
00167                 : GrammaticalElement (), \par
00168                   _name ()\par
00169                             \{ _type = Type::_LABEL; \}\par
00170 \par
00171             LabelElement ({\cf17 const} LabelElement&) = {\cf19 default};\par
00172 \par
00173             LabelElement& operator = ({\cf17 const} LabelElement&) = {\cf19 default};\par
00174 \par
00175             std::string _name;\par
00176         \};\par
00177 \par
00179         {\cf17 struct }BytesInMemoryElement : {\cf17 public} GrammaticalElement\par
00180         \{\par
00181             BytesInMemoryElement ()\par
00182                 : GrammaticalElement (), _elements ()\par
00183                             \{ _type = Type::_BYTESINMEMORY; \}\par
00184 \par
00185             BytesInMemoryElement ({\cf17 const} BytesInMemoryElement&) = {\cf19 default};\par
00186 \par
00187             BytesInMemoryElement& operator = ({\cf17 const} BytesInMemoryElement&) = {\cf19 default};\par
00188 \par
00189             std::vector <std::string> _elements;\par
00190 \par
00191             {\cf17 private}:\par
00192             {\cf17 virtual} std::vector <UByte> calculateCodeBytes ({\cf17 const} Semantic* s, {\cf18 bool} bE = {\cf17 true}) {\cf17 const override};\par
00193         \};\par
00194 \par
00197         {\cf17 struct }InstructionElement final : {\cf17 public} GrammaticalElement\par
00198         \{\par
00199             InstructionElement ()\par
00200                 : GrammaticalElement (), \par
00201                   _possibleInstructions (),\par
00202                   _parameters (),\par
00203                   _selectedInstruction (nullptr)\par
00204                             \{ _type = Type::_INSTRUCTION; \}\par
00205 \par
00206             InstructionElement ({\cf17 const} InstructionElement&) = {\cf19 default};\par
00207 \par
00208             InstructionElement& operator = ({\cf17 const} InstructionElement&) = {\cf19 default};\par
00209 \par
00210             {\cf17 virtual} {\cf18 size_t} size ({\cf17 const} Semantic* s) {\cf17 const}; \par
00211 \par
00213             {\cf18 bool} hasAnyLabelAsParameter ({\cf17 const} Semantic* s) {\cf17 const};\par
00215             std::vector <size_t> labelParameters ({\cf17 const} Semantic* s) {\cf17 const};\par
00216 \par
00217             std::vector <Instruction*> _possibleInstructions;\par
00218             std::vector <std::string> _parameters;\par
00219             {\cf17 mutable} Instruction* _selectedInstruction;\par
00220 \par
00221             {\cf17 private}:\par
00224             {\cf17 virtual} std::vector <UByte> calculateCodeBytes ({\cf17 const} Semantic* s, {\cf18 bool} bE = {\cf17 true}) {\cf17 const override};\par
00225 \par
00226             {\cf20 // Implementation}\par
00227             std::vector <UByte> calculateCodeBytesForInstruction \par
00228                 ({\cf17 const} Instruction* inst, {\cf17 const} Semantic* s, {\cf18 bool} bE = {\cf17 true}) {\cf17 const};\par
00229         \};\par
00230 \par
00232         {\cf17 struct }StartingPointElement final : {\cf17 public} GrammaticalElement\par
00233         \{\par
00234             StartingPointElement ()\par
00235                 : GrammaticalElement (), \par
00236                   _value ()\par
00237                             \{ _type = Type::_STARTINGPOINT; \}\par
00238 \par
00239             StartingPointElement ({\cf17 const} StartingPointElement&) = {\cf19 default};\par
00240 \par
00241             StartingPointElement& operator = ({\cf17 const} StartingPointElement&) = {\cf19 default};\par
00242 \par
00243             {\cf17 virtual} Address address ({\cf17 const} Semantic* s){\cf17  const override}\par
00244 {\cf17                             }\{ {\cf19 return} (Address (codeBytes (s ))); \}\par
00245 \par
00246             std::string _value;\par
00247 \par
00248             {\cf17 private}:\par
00249             {\cf17 virtual} std::vector <UByte> calculateCodeBytes ({\cf17 const} Semantic* s, {\cf18 bool} bE = {\cf17 true}) {\cf17 const override};\par
00250         \};\par
00251 \par
00253         {\cf17 using} StartingPointElements = std::vector <StartingPointElement*>;\par
00254 \par
00260         {\cf17 class }CommandParser;\par
00261         {\cf17 class }Semantic\par
00262         \{\par
00263             {\cf17 public}:\par
00264             {\cf17 friend} CommandParser;\par
00265 \par
00266             Semantic ()\par
00267                 : _macros (), _startingPoints (), \par
00268                   _error (ErrorType::_NOERROR), _lastGrammaticalElementAdded (nullptr)\par
00269                             \{ \}\par
00270 \par
00271             Semantic ({\cf17 const} Semantic&) = {\cf17 delete};\par
00272 \par
00273             ~Semantic ()\par
00274                             \{ {\cf19 for} ({\cf17 auto} i : _startingPoints) {\cf17 delete} (i); \}\par
00275 \par
00276             Semantic& operator = ({\cf17 const} Semantic&) = {\cf17 delete};\par
00277 \par
00278             {\cf20 // Managing the semantic...}\par
00279             {\cf17 const} Macros& macros (){\cf17  const}\par
00280 {\cf17                             }\{ {\cf19 return} (_macros); \}\par
00281             {\cf18 void} addMacro ({\cf17 const} Macro& m);\par
00282             {\cf17 const} StartingPointElements& startingPoints (){\cf17  const}\par
00283 {\cf17                             }\{ {\cf19 return} (_startingPoints); \}\par
00284             StartingPointElement* addNewStartingPoint ();\par
00285             {\cf18 void} addGrammaticalElement (GrammaticalElement* g);\par
00286             {\cf17 const} GrammaticalElement* lastGrammaticalElementAdded (){\cf17  const}\par
00287 {\cf17                             }\{ {\cf19 return} (_lastGrammaticalElementAdded); \}\par
00288             GrammaticalElement* lastGrammaticalElementAdded ()\par
00289                             \{ {\cf19 return} (_lastGrammaticalElementAdded); \}\par
00290 \par
00291             ErrorType error (){\cf17  const}\par
00292 {\cf17                             }\{ {\cf19 return} (_error); \}\par
00293 \par
00295             {\cf18 bool} operator ! (){\cf17  const}\par
00296 {\cf17                             }\{ {\cf19 return} (_error != ErrorType::_NOERROR); \}\par
00297 \par
00299             {\cf18 void} addFrom ({\cf17 const} Semantic* s);\par
00300 \par
00302             {\cf18 bool} existsLabel ({\cf17 const} std::string& l) {\cf17 const};\par
00305             Address addressForLabel ({\cf17 const} std::string& l) {\cf17 const};\par
00307             std::vector <const LabelElement*> labels () {\cf17 const};\par
00309             std::map <std::string, Address> labelAddresses () {\cf17 const};\par
00310 \par
00311             {\cf17 private}:\par
00312             Macros _macros;\par
00313             StartingPointElements _startingPoints;\par
00314 \par
00315             {\cf20 // Implementation}\par
00316             {\cf17 mutable} ErrorType _error;\par
00317             {\cf17 mutable} GrammaticalElement* _lastGrammaticalElementAdded;\par
00318         \};\par
00319     \}\par
00320 \}\par
00321 \par
00322 {\cf21 #endif}\par
00323   \par
00324 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/incs.hpp}
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ASSEMBLER/Error.hpp>}\par
{\f2 #include <ASSEMBLER/Grammar.hpp>}\par
{\f2 #include <ASSEMBLER/Parser.hpp>}\par
{\f2 #include <ASSEMBLER/Compiler.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/incs.hpp}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __ASSEMBLER_INCS__}\par
00015 {\cf21 #define __ASSEMBLER_INCS__}\par
00016 \par
00017 {\cf21 #include <ASSEMBLER/Error.hpp>}\par
00018 {\cf21 #include <ASSEMBLER/Grammar.hpp>}\par
00019 {\cf21 #include <ASSEMBLER/Parser.hpp>}\par
00020 {\cf21 #include <ASSEMBLER/Compiler.hpp>}\par
00021 \par
00022 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/incs.hpp}
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/incs.hpp>}\par
{\f2 #include <C64/global.hpp>}\par
{\f2 #include <C64/C64.hpp>}\par
{\f2 #include <C64/Memory.hpp>}\par
{\f2 #include <C64/VICII.hpp>}\par
{\f2 #include <C64/VICIIRegisters.hpp>}\par
{\f2 #include <C64/CIATimer.hpp>}\par
{\f2 #include <C64/CIAClock.hpp>}\par
{\f2 #include <C64/CIA1.hpp>}\par
{\f2 #include <C64/CIA1Registers.hpp>}\par
{\f2 #include <C64/CIA2.hpp>}\par
{\f2 #include <C64/CIA2Registers.hpp>}\par
{\f2 #include <C64/Screen.hpp>}\par
{\f2 #include <C64/OSIO.hpp>}\par
{\f2 #include <C64/UserPort.hpp>}\par
{\f2 #include <C64/UserPeripherals.hpp>}\par
{\f2 #include <C64/IOPBuilder.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/incs.hpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_INCS__}\par
00015 {\cf21 #define __C64_INCS__}\par
00016 \par
00017 {\cf21 #include <F6500/incs.hpp>}\par
00018 {\cf21 #include <C64/global.hpp>}\par
00019 {\cf21 #include <C64/C64.hpp>}\par
00020 {\cf21 #include <C64/Memory.hpp>}\par
00021 {\cf21 #include <C64/VICII.hpp>}\par
00022 {\cf21 #include <C64/VICIIRegisters.hpp>}\par
00023 {\cf21 #include <C64/CIATimer.hpp>}\par
00024 {\cf21 #include <C64/CIAClock.hpp>}\par
00025 {\cf21 #include <C64/CIA1.hpp>}\par
00026 {\cf21 #include <C64/CIA1Registers.hpp>}\par
00027 {\cf21 #include <C64/CIA2.hpp>}\par
00028 {\cf21 #include <C64/CIA2Registers.hpp>}\par
00029 {\cf21 #include <C64/Screen.hpp>}\par
00030 {\cf21 #include <C64/OSIO.hpp>}\par
00031 {\cf21 #include <C64/UserPort.hpp>}\par
00032 {\cf21 #include <C64/UserPeripherals.hpp>}\par
00033 {\cf21 #include <C64/IOPBuilder.hpp>}\par
00034 \par
00035 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/incs.hpp}
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <COMMS/IPAddress.hpp>}\par
{\f2 #include <COMMS/Message.hpp>}\par
{\f2 #include <COMMS/Channel.hpp>}\par
{\f2 #include <COMMS/System.hpp>}\par
{\f2 #include <COMMS/StdMessages.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/incs.hpp}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __COMMS_INCS__}\par
00015 {\cf21 #define __COMMS_INCS__}\par
00016 \par
00017 {\cf21 #include <COMMS/IPAddress.hpp>}\par
00018 {\cf21 #include <COMMS/Message.hpp>}\par
00019 {\cf21 #include <COMMS/Channel.hpp>}\par
00020 {\cf21 #include <COMMS/System.hpp>}\par
00021 {\cf21 #include <COMMS/StdMessages.hpp>}\par
00022 \par
00023 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CONSOLE/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CONSOLE/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CONSOLE/incs.hpp}
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CONSOLE/Console.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CONSOLE/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CONSOLE/incs.hpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __CONSOLE_INCS__}\par
00015 {\cf21 #define __CONSOLE_INCS__}\par
00016 \par
00017 {\cf21 #include <CONSOLE/Console.hpp>}\par
00018 \par
00019 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/incs.hpp}
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/Address.hpp>}\par
{\f2 #include <CORE/Chip.hpp>}\par
{\f2 #include <CORE/Computer.hpp>}\par
{\f2 #include <CORE/CPU.hpp>}\par
{\f2 #include <CORE/CPUArchitecture.hpp>}\par
{\f2 #include <CORE/CPUInterrupt.hpp>}\par
{\f2 #include <CORE/Memory.hpp>}\par
{\f2 #include <CORE/ProgramCounter.hpp>}\par
{\f2 #include <CORE/Register.hpp>}\par
{\f2 #include <CORE/Stack.hpp>}\par
{\f2 #include <CORE/StatusRegister.hpp>}\par
{\f2 #include <CORE/UByte.hpp>}\par
{\f2 #include <CORE/UBytes.hpp>}\par
{\f2 #include <CORE/UInt.hpp>}\par
{\f2 #include <CORE/Instruction.hpp>}\par
{\f2 #include <CORE/IO.hpp>}\par
{\f2 #include <CORE/Screen.hpp>}\par
{\f2 #include <CORE/ScreenMemory.hpp>}\par
{\f2 #include <CORE/OSIO.hpp>}\par
{\f2 #include <CORE/IOPeripheral.hpp>}\par
{\f2 #include <CORE/IOPBuilder.hpp>}\par
{\f2 #include <CORE/Command.hpp>}\par
{\f2 #include <CORE/CommandBuilder.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/incs.hpp}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_INCS__}\par
00015 {\cf21 #define __MCHEMUL_INCS__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/Address.hpp>}\par
00019 {\cf21 #include <CORE/Chip.hpp>}\par
00020 {\cf21 #include <CORE/Computer.hpp>}\par
00021 {\cf21 #include <CORE/CPU.hpp>}\par
00022 {\cf21 #include <CORE/CPUArchitecture.hpp>}\par
00023 {\cf21 #include <CORE/CPUInterrupt.hpp>}\par
00024 {\cf21 #include <CORE/Memory.hpp>}\par
00025 {\cf21 #include <CORE/ProgramCounter.hpp>}\par
00026 {\cf21 #include <CORE/Register.hpp>}\par
00027 {\cf21 #include <CORE/Stack.hpp>}\par
00028 {\cf21 #include <CORE/StatusRegister.hpp>}\par
00029 {\cf21 #include <CORE/UByte.hpp>}\par
00030 {\cf21 #include <CORE/UBytes.hpp>}\par
00031 {\cf21 #include <CORE/UInt.hpp>}\par
00032 {\cf21 #include <CORE/Instruction.hpp>}\par
00033 {\cf21 #include <CORE/IO.hpp>}\par
00034 {\cf21 #include <CORE/Screen.hpp>}\par
00035 {\cf21 #include <CORE/ScreenMemory.hpp>}\par
00036 {\cf21 #include <CORE/OSIO.hpp>}\par
00037 {\cf21 #include <CORE/IOPeripheral.hpp>}\par
00038 {\cf21 #include <CORE/IOPBuilder.hpp>}\par
00039 {\cf21 #include <CORE/Command.hpp>}\par
00040 {\cf21 #include <CORE/CommandBuilder.hpp>}\par
00041 \par
00042 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/EMULATORS/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/EMULATORS/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/EMULATORS/incs.hpp}
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/incs.hpp>}\par
{\f2 #include <EMULATORS/Emulator.hpp>}\par
{\f2 #include <EMULATORS/C64Emulator.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/EMULATORS/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/EMULATORS/incs.hpp}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64EMULATOR_INCS__}\par
00015 {\cf21 #define __C64EMULATOR_INCS__}\par
00016 \par
00017 {\cf21 #include <C64/incs.hpp>}\par
00018 {\cf21 #include <EMULATORS/Emulator.hpp>}\par
00019 {\cf21 #include <EMULATORS/C64Emulator.hpp>}\par
00020 \par
00021 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/incs.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/incs.hpp}
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <F6500/C6500.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
{\f2 #include <F6500/IRQInterrupt.hpp>}\par
{\f2 #include <F6500/NMIInterrupt.hpp>}\par
{\f2 #include <F6500/Instructions.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
incs.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/incs.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/incs.hpp}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __F6500_INCS__}\par
00015 {\cf21 #define __F6500_INCS__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <F6500/C6500.hpp>}\par
00019 {\cf21 #include <F6500/C6510.hpp>}\par
00020 {\cf21 #include <F6500/IRQInterrupt.hpp>}\par
00021 {\cf21 #include <F6500/NMIInterrupt.hpp>}\par
00022 {\cf21 #include <F6500/Instructions.hpp>}\par
00023 \par
00024 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Parser.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Parser.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Parser.hpp}
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Incs.hpp>}\par
{\f2 #include <ASSEMBLER/Grammar.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::CommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::CommentCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::IncludeCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::MacroCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::StartingPointCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::LabelCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::BytesCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::InstructionCommandParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Assembler::Parser}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul::Assembler}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Assembler::CommandParsers} = std::vector< CommandParser * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Parser.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Parser.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/ASSEMBLER/Parser.hpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __ASSEMBLER_PARSER__}\par
00015 {\cf21 #define __ASSEMBLER_PARSER__}\par
00016 \par
00017 {\cf21 #include <CORE/Incs.hpp>}\par
00018 {\cf21 #include <ASSEMBLER/Grammar.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00022     {\cf17 namespace }Assembler\par
00023     \{\par
00028         {\cf17 class }Parser;\par
00029         {\cf17 class }CommandParser\par
00030         \{\par
00031             {\cf17 public}:\par
00032             {\cf17 friend} Parser;\par
00033 \par
00034             CommandParser ()\par
00035                 : _cpu (nullptr), _parser (nullptr)\par
00036                             \{ \}\par
00037 \par
00038             {\cf17 virtual} ~CommandParser ()\par
00039                             \{ \}\par
00040 \par
00041             {\cf17 const} CPU* cpu (){\cf17  const}\par
00042 {\cf17                             }\{ {\cf19 return} (_cpu); \}\par
00043             {\cf17 const} Parser* parser (){\cf17  const}\par
00044 {\cf17                             }\{ {\cf19 return} (_parser); \}\par
00045 \par
00047             {\cf17 virtual} {\cf18 void} initialize ()\par
00048                             \{ \}\par
00049 \par
00051             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l) {\cf17 const} = 0;\par
00054             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* s) {\cf17 const} = 0;\par
00055 \par
00057             {\cf18 void} setCPU ({\cf17 const} CPU* c)\par
00058                             \{ assert (c != {\cf17 nullptr}); _cpu = c; \}\par
00059             {\cf18 void} setParser ({\cf17 const} Parser* p)\par
00060                             \{ assert (p!= {\cf17 nullptr}); _parser = p; \}\par
00061 \par
00062             {\cf17 protected}:\par
00063             {\cf17 const} CPU* _cpu;\par
00064             {\cf17 const} Parser* _parser;\par
00065         \};\par
00066 \par
00068         {\cf17 using} CommandParsers = std::vector <CommandParser*>;\par
00069 \par
00072         {\cf17 class }CommentCommandParser final : {\cf17 public} CommandParser\par
00073         \{\par
00074             {\cf17 public}:\par
00075             CommentCommandParser ({\cf18 unsigned} {\cf18 char} s = {\cf23 ';'})\par
00076                 : CommandParser (),\par
00077                   _symbol (s)\par
00078                             \{ \}\par
00079 \par
00080             {\cf18 unsigned} {\cf18 char} symbol (){\cf17  const}\par
00081 {\cf17                             }\{ {\cf19 return} (_symbol); \}\par
00082 \par
00083             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l){\cf17  const override}\par
00084 {\cf17                             }\{ {\cf19 return} (l [0] == _symbol); \}\par
00085             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int}, Semantic*){\cf17  const override}\par
00086 {\cf17                             }\{ l = {\cf22 ""}; \}\par
00087 \par
00088             {\cf17 private}:\par
00089             {\cf17 const} {\cf18 unsigned} {\cf18 char} _symbol = {\cf23 ';'}; {\cf20 // Adjusted at construction level}\par
00090         \};\par
00091 \par
00094         {\cf17 class }IncludeCommandParser final : {\cf17 public} CommandParser\par
00095         \{\par
00096             {\cf17 public}:\par
00097             IncludeCommandParser ({\cf18 unsigned} {\cf18 char} s = {\cf23 '#'})\par
00098                 : CommandParser (),\par
00099                   _symbol (s)\par
00100                             \{ \}\par
00101 \par
00102             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l){\cf17  const override}\par
00103 {\cf17                             }\{ {\cf19 return} (l [0] == _symbol); \}\par
00104             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* c) {\cf17 const override};\par
00105 \par
00106             {\cf17 private}:\par
00107             {\cf17 const} {\cf18 unsigned} {\cf18 char} _symbol = {\cf23 '#'}; {\cf20 // Adjusted at construction level}\par
00108         \};\par
00109 \par
00112         {\cf17 class }MacroCommandParser : {\cf17 public} CommandParser\par
00113         \{\par
00114             {\cf17 public}:\par
00115             MacroCommandParser ({\cf18 unsigned} {\cf18 char} s = {\cf23 '='})\par
00116                 : CommandParser (),\par
00117                   _symbol (s)\par
00118                             \{ \}\par
00119 \par
00120             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l){\cf17  const override}\par
00121 {\cf17                             }\{ {\cf18 size_t} eP = l.find (_symbol); \par
00122                               {\cf19 return} (eP != std::string::npos && validLabel (trim (l.substr (0, eP)))); \}\par
00123             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* s) {\cf17 const override};\par
00124 \par
00125             {\cf17 protected}:\par
00126             {\cf17 const} {\cf18 unsigned} {\cf18 char} _symbol = {\cf23 '='};\par
00127         \};\par
00128 \par
00132         {\cf17 class }StartingPointCommandParser final : {\cf17 public} CommandParser\par
00133         \{\par
00134             {\cf17 public}:\par
00135             StartingPointCommandParser ({\cf18 unsigned} {\cf18 char} s = {\cf23 '='})\par
00136                 : CommandParser (),\par
00137                   _symbol (s),\par
00138                   _lastStartingPointId (0)\par
00139                             \{ \}\par
00140 \par
00141             {\cf17 virtual} {\cf18 void} initialize (){\cf17  override}\par
00142 {\cf17                             }\{ _lastStartingPointId = 0; \}\par
00143 \par
00144             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l){\cf17  const override}\par
00145 {\cf17                             }\{ {\cf18 size_t} eP = l.find (_symbol); \par
00146                               {\cf19 return} (eP != std::string::npos && trim (l.substr (0, eP)) == {\cf22 "*"}); \}\par
00147             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* s) {\cf17 const override};\par
00148 \par
00149             {\cf17 private}:\par
00150             {\cf17 const} {\cf18 unsigned} {\cf18 char} _symbol = {\cf23 '='};\par
00151 \par
00152             {\cf20 // Implementation}\par
00153             {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastStartingPointId;\par
00154         \};\par
00155 \par
00157         {\cf17 class }LabelCommandParser final : {\cf17 public} CommandParser\par
00158         \{\par
00159             {\cf17 public}:\par
00160             LabelCommandParser ({\cf18 unsigned} {\cf18 char} s = {\cf23 ':'})\par
00161                 : CommandParser (),\par
00162                   _symbol (s),\par
00163                   _lastLabelId (0)\par
00164                             \{ \}\par
00165 \par
00166             {\cf17 virtual} {\cf18 void} initialize (){\cf17  override}\par
00167 {\cf17                             }\{ _lastLabelId = 0; \}\par
00168 \par
00169             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l){\cf17  const override}\par
00170 {\cf17                             }\{ {\cf18 size_t} eP = l.find (_symbol); \par
00171                               {\cf19 return} (eP != std::string::npos && validLabel (trim (l.substr (0, eP)))); \}\par
00172             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* s) {\cf17 const override};\par
00173 \par
00174             {\cf17 private}:\par
00175             {\cf17 const} {\cf18 unsigned} {\cf18 char} _symbol = {\cf23 ':'};\par
00176 \par
00177             {\cf20 // Implementation}\par
00178             {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastLabelId;\par
00179         \};\par
00180 \par
00182         {\cf17 class }BytesCommandParser final : {\cf17 public} CommandParser\par
00183         \{\par
00184             {\cf17 public}:\par
00185             BytesCommandParser ()\par
00186                 : CommandParser (),\par
00187                   _lastBytesId (0)\par
00188                             \{ \}\par
00189 \par
00190             {\cf17 virtual} {\cf18 void} initialize (){\cf17  override}\par
00191 {\cf17                             }\{ _lastBytesId = 0; \}\par
00192 \par
00193             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l){\cf17  const override}\par
00194 {\cf17                             }\{ {\cf18 size_t} eP = l.find ({\cf23 ' '}); \par
00195                               {\cf19 return} (eP != std::string::npos && upper (trim (l.substr (0, eP))) == {\cf22 "BYTES"}); \}\par
00196             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* s) {\cf17 const override};\par
00197 \par
00198             {\cf17 private}:\par
00199             {\cf20 // Implementation}\par
00200             {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastBytesId;\par
00201         \};\par
00202 \par
00204         {\cf17 class }InstructionCommandParser final : {\cf17 public} CommandParser\par
00205         \{\par
00206             {\cf17 public}:\par
00207             InstructionCommandParser ()\par
00208                 : CommandParser (),\par
00209                   _lastInstructionId (0)\par
00210                             \{ \}\par
00211 \par
00212             {\cf17 virtual} {\cf18 void} initialize (){\cf17  override}\par
00213 {\cf17                             }\{ _lastInstructionId = 0; \}\par
00214 \par
00215             {\cf17 virtual} {\cf18 bool} canParse ({\cf17 const} std::string& l) {\cf17 const override};\par
00216             {\cf17 virtual} {\cf18 void} parse (std::string& l, {\cf18 unsigned} {\cf18 int} lC, Semantic* s) {\cf17 const override};\par
00217 \par
00218             {\cf17 private}:\par
00219             {\cf20 // Implementation}\par
00220             {\cf17 mutable} {\cf18 unsigned} {\cf18 char} _lastInstructionId;\par
00221         \};\par
00222 \par
00228         {\cf17 class }Parser final\par
00229         \{\par
00230             {\cf17 public}:\par
00231             Parser ({\cf17 const} CPU* c, {\cf17 const} CommandParsers& lP = {\cf20 // With the standard line parsers...}\par
00232                     \{ {\cf17 new} CommentCommandParser, {\cf17 new} IncludeCommandParser, \par
00233                       {\cf17 new} MacroCommandParser, {\cf17 new} StartingPointCommandParser, \par
00234                       {\cf17 new} LabelCommandParser, {\cf17 new} BytesCommandParser,\par
00235                       {\cf17 new} InstructionCommandParser \});\par
00236 \par
00237             Parser (Parser&) = {\cf17 delete};\par
00238 \par
00239             Parser& operator = ({\cf17 const} Parser&) = {\cf17 delete};\par
00240 \par
00242             ~Parser ()\par
00243                             \{ {\cf19 for} ({\cf17 auto} i : _commandParsers) {\cf17 delete} (i); \}\par
00244 \par
00245             {\cf17 const} CPU* cpu (){\cf17  const}\par
00246 {\cf17                             }\{ {\cf19 return} (_cpu); \}\par
00247             {\cf17 const} CommandParsers& commandParsers (){\cf17  const}\par
00248 {\cf17                             }\{ {\cf19 return} (_commandParsers); \}\par
00249             {\cf18 unsigned} {\cf18 char} commentSymbol () {\cf17 const};\par
00250 \par
00280             Semantic* parse ({\cf17 const} std::string& fN, {\cf17 const} std::string& fA = {\cf22 ""}) {\cf17 const};\par
00281 \par
00282             Errors errors (){\cf17  const}\par
00283 {\cf17                             }\{ {\cf19 return} (_errors); \}\par
00284 \par
00286             {\cf18 bool} operator ! (){\cf17  const}\par
00287 {\cf17                             }\{ {\cf19 return} (!_errors.empty ()); \}\par
00288 \par
00289             {\cf17 private}:\par
00291             std::vector <std::string> readLines ({\cf17 const} std::string& fN) {\cf17 const};\par
00292 \par
00293             {\cf17 private}:\par
00294             {\cf17 const} CPU* _cpu;\par
00295             CommandParsers _commandParsers;\par
00296 \par
00297             {\cf20 // Implementation}\par
00298             {\cf17 mutable} Errors _errors;\par
00299             {\cf17 mutable} {\cf18 unsigned} {\cf18 char} _commentSymbol;\par
00300         \};\par
00301     \}\par
00302 \}\par
00303 \par
00304 {\cf21 #endif}\par
00305   \par
00306 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/C64.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/C64.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/C64.hpp}
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/Screen.hpp>}\par
{\f2 #include <C64/UserPeripherals.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::Commodore64}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/C64.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/C64.hpp}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_C64__}\par
00015 {\cf21 #define __C64_C64__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <C64/Screen.hpp>}\par
00019 {\cf21 #include <C64/UserPeripherals.hpp>}\par
00020 \par
00021 {\cf17 namespace }C64\par
00022 \{\par
00028     {\cf17 class }Commodore64 final : {\cf17 public} MCHEmul::Computer\par
00029     \{\par
00030         {\cf17 public}:\par
00031         {\cf17 enum class} VisualSystem \{ _NTSC, _PAL \};\par
00032 \par
00033         Commodore64 (VisualSystem vS = VisualSystem::_PAL );\par
00034 \par
00035         {\cf17 virtual} {\cf18 bool} connect (MCHEmul::IOPeripheral* p, MCHEmul::IODevice* d) {\cf17 override};\par
00036 \par
00037         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00038 \par
00039         {\cf17 private}:\par
00040         {\cf20 // Implementation}\par
00041         {\cf17 static} MCHEmul::Chips standardChips (VisualSystem vS);\par
00042         {\cf17 static} MCHEmul::IODevices standardDevices (VisualSystem vS);\par
00043 \par
00044         {\cf17 protected}:\par
00046         VisualSystem _visualSystem;\par
00048         MCHEmul::Attributes _parameters;\par
00049     \};\par
00050 \}\par
00051 \par
00052 {\cf21 #endif}\par
00053   \par
00054 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/CIA1.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA1.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA1.hpp}
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/CIA1Registers.hpp>}\par
{\f2 #include <C64/CIATimer.hpp>}\par
{\f2 #include <C64/CIAClock.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::CIA1}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIA1.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA1.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA1.hpp}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_CIA1__}\par
00015 {\cf21 #define __C64_CIA1__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <C64/CIA1Registers.hpp>}\par
00019 {\cf21 #include <C64/CIATimer.hpp>}\par
00020 {\cf21 #include <C64/CIAClock.hpp>}\par
00021 \par
00022 {\cf17 namespace }C64\par
00023 \{\par
00024     {\cf17 class }InputOSSystem;\par
00025 \par
00028     {\cf17 class }CIA1 : {\cf17 public} MCHEmul::Chip\par
00029     \{\par
00030         {\cf17 public}:\par
00031         {\cf17 friend} InputOSSystem;\par
00032 \par
00033         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _ID = 2;\par
00034 \par
00035         CIA1 ()\par
00036             : MCHEmul::Chip (_ID,\par
00037                 \{ \{ {\cf22 "Name"}, {\cf22 "CIA1"} \},\par
00038                   \{ {\cf22 "Code"}, {\cf22 "6526/6526A/8521"} \},\par
00039                   \{ {\cf22 "Manufacturer"}, {\cf22 "Commodore Business Machines CBM"} \},\par
00040                   \{ {\cf22 "Year"}, {\cf22 "1980"} \} \}),\par
00041               _CIA1Registers ({\cf17 nullptr}),\par
00042               _timerA (0), _timerB (1), _clock (0)\par
00043                             \{ \}\par
00044 \par
00045         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00046 \par
00047         {\cf17 virtual} {\cf18 bool} simulate (MCHEmul::CPU* cpu) {\cf17 override};\par
00048 \par
00049         {\cf17 private}:\par
00050         {\cf20 // These methods are invoked from InputOSSystem...  }\par
00051         {\cf20 // To manage the joystick}\par
00052         {\cf18 unsigned} {\cf18 char} joystick2Status (){\cf17  const}\par
00053 {\cf17                             }\{ {\cf19 return} (_CIA1Registers -> joystick2Status ()); \}\par
00054         {\cf18 void} setJoystick2Status ({\cf18 unsigned} {\cf18 char} js)\par
00055                             \{ _CIA1Registers -> setJoystick2Status (js); \}\par
00056 \par
00057         {\cf20 // To manage status of the data ports}\par
00058         {\cf18 bool} keyboardStatusMatrix ({\cf18 size_t} r, {\cf18 size_t} c){\cf17  const}\par
00059 {\cf17                             }\{ {\cf19 return} (_CIA1Registers -> keyboardStatusMatrix (r, c)); \}\par
00060         {\cf17 const} MCHEmul::UByte& keyboardStatusMatrix ({\cf18 size_t} r){\cf17  const}\par
00061 {\cf17                             }\{ {\cf19 return} (_CIA1Registers -> keyboardStatusMatrix (r)); \}\par
00062         {\cf18 void} setKeyboardStatusMatrix ({\cf18 size_t} r, {\cf18 size_t} c, {\cf18 bool} s)\par
00063                             \{ _CIA1Registers -> setKeyboardStatusMatrix (r, c, s); \}\par
00064         {\cf18 void} setKeyboardStatusMatrix ({\cf18 size_t} r, {\cf17 const} MCHEmul::UByte& u)\par
00065                             \{ _CIA1Registers -> setKeyboardStatusMatrix (r, u); \}\par
00066 \par
00067         {\cf17 private}:\par
00068         C64::CIA1Registers* _CIA1Registers;\par
00070         CIATimer _timerA, _timerB;\par
00071         CIAClock _clock;\par
00072     \};\par
00073 \}\par
00074 \par
00075 {\cf21 #endif}\par
00076   \par
00077 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/CIA1Registers.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA1Registers.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA1Registers.hpp}
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::CIA1Registers}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIA1Registers.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA1Registers.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA1Registers.hpp}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_CIA1REGISTERS__}\par
00015 {\cf21 #define __C64_CIA1REGISTERS__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00021     {\cf17 class }CIA1;\par
00022     {\cf17 class }CIATimer;\par
00023     {\cf17 class }CIAClock;\par
00024 \par
00027     {\cf17 class }CIA1Registers final : {\cf17 public} MCHEmul::PhisicalStorageSubset\par
00028     \{\par
00029         {\cf17 public}:\par
00030         {\cf17 friend} CIA1;\par
00031 \par
00032         CIA1Registers ({\cf18 int} {\cf18 id}, MCHEmul::PhisicalStorage* pS);\par
00033 \par
00034         {\cf17 virtual} {\cf18 void} initialize () {\cf17 override};\par
00035 \par
00036         {\cf17 private}:\par
00037         {\cf17 virtual} {\cf18 void} setValue ({\cf18 size_t} p, {\cf17 const} MCHEmul::UByte& v) {\cf17 override};\par
00038         {\cf17 virtual} {\cf17 const} MCHEmul::UByte& readValue ({\cf18 size_t} p) {\cf17 const override};\par
00039 \par
00040         {\cf20 // Implementation}\par
00041         {\cf18 void} initializeInternalValues ();\par
00042 \par
00043         {\cf20 // This methods are invoked from CIA chip...}\par
00045 {\cf20 }        {\cf18 unsigned} {\cf18 char} joystick2Status (){\cf17  const}\par
00046 {\cf17                             }\{ {\cf19 return} (_joystick2Status); \}\par
00047         {\cf18 void} setJoystick2Status ({\cf18 unsigned} {\cf18 char} js)\par
00048                             \{ _joystick2Status = js; \}\par
00049 \par
00052         {\cf18 bool} keyboardStatusMatrix ({\cf18 size_t} r, {\cf18 size_t} c){\cf17  const}\par
00053 {\cf17                             }\{ {\cf19 return} (_keyboardStatusMatrix [r].bit (c)); \}\par
00054         {\cf17 const} MCHEmul::UByte& keyboardStatusMatrix ({\cf18 size_t} r){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} (_keyboardStatusMatrix [r]); \}\par
00056         {\cf18 void} setKeyboardStatusMatrix ({\cf18 size_t} r, {\cf18 size_t} c, {\cf18 bool} s)\par
00057                             \{ _keyboardStatusMatrix [r].setBit (c, s); \}\par
00058         {\cf18 void} setKeyboardStatusMatrix ({\cf18 size_t} r, {\cf17 const} MCHEmul::UByte& u)\par
00059                             \{ _keyboardStatusMatrix [r] = u; \}\par
00060 \par
00062         {\cf18 void} lookAtTimers (CIATimer* tA, CIATimer* tB)\par
00063                             \{ _timerA = tA, _timerB = tB; \}\par
00065         {\cf18 void} lookAtClock (CIAClock* c)\par
00066                             \{ _clock = c; \}\par
00067 \par
00068         {\cf17 private}:\par
00070         {\cf18 unsigned} {\cf18 char} _joystick2Status;\par
00073         MCHEmul::UByte _keyboardStatusMatrix [8];\par
00074         {\cf20 // Reference to the timers...}\par
00075         CIATimer* _timerA;\par
00076         CIATimer* _timerB;\par
00077         {\cf20 // Reference to the clock...}\par
00078         CIAClock* _clock;\par
00079 \par
00080         {\cf20 // Implementation}\par
00081         {\cf18 unsigned} {\cf18 char} _keyboardRowToRead; {\cf20 // bit = 0, means row to be read!}\par
00082         {\cf18 unsigned} {\cf18 char} _dataPortADir, _dataPortBDir;\par
00083 \par
00084         {\cf17 mutable} MCHEmul::UByte _lastValueRead;\par
00085     \};\par
00086 \}\par
00087 \par
00088 {\cf21 #endif}\par
00089   \par
00090 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/CIA2.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA2.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA2.hpp}
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/CIA2Registers.hpp>}\par
{\f2 #include <C64/CIATimer.hpp>}\par
{\f2 #include <C64/CIAClock.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::CIA2}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIA2.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA2.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA2.hpp}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_CIA2__}\par
00015 {\cf21 #define __C64_CIA2__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <C64/CIA2Registers.hpp>}\par
00019 {\cf21 #include <C64/CIATimer.hpp>}\par
00020 {\cf21 #include <C64/CIAClock.hpp>}\par
00021 \par
00022 {\cf17 namespace }C64\par
00023 \{\par
00024     {\cf17 class }VICII;\par
00025     {\cf17 class }Commodore64;\par
00026 \par
00028     {\cf17 class }CIA2 : {\cf17 public} MCHEmul::Chip\par
00029     \{\par
00030         {\cf17 public}:\par
00031         {\cf17 friend} Commodore64;\par
00032 \par
00033         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _ID = 3;\par
00034 \par
00035         CIA2 ()\par
00036             : MCHEmul::Chip (_ID,\par
00037                 \{ \{ {\cf22 "Name"}, {\cf22 "CIA2"} \},\par
00038                   \{ {\cf22 "Code"}, {\cf22 "6526/6526A/8521"} \},\par
00039                   \{ {\cf22 "Manufacturer"}, {\cf22 "Commodore Business Machines CBM"} \},\par
00040                   \{ {\cf22 "Year"}, {\cf22 "1980"} \} \}),\par
00041               _CIA2Registers ({\cf17 nullptr}),\par
00042               _timerA (0), _timerB (1), _clock (0)\par
00043                             \{ \}\par
00044 \par
00045         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00046 \par
00047         {\cf17 virtual} {\cf18 bool} simulate (MCHEmul::CPU* cpu) {\cf17 override};\par
00048 \par
00049         {\cf17 private}:\par
00050         C64::CIA2Registers* _CIA2Registers;\par
00052         VICII* _VICIIRef;\par
00053         CIATimer _timerA, _timerB;\par
00054         CIAClock _clock;\par
00055 \par
00056         {\cf20 // Implementation}\par
00057         {\cf18 unsigned} {\cf18 int} _lastClockCycles;\par
00058     \};\par
00059 \}\par
00060 \par
00061 {\cf21 #endif}\par
00062   \par
00063 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/CIA2Registers.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA2Registers.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA2Registers.hpp}
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::CIA2Registers}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIA2Registers.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIA2Registers.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIA2Registers.hpp}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_CIA2REGISTERS__}\par
00015 {\cf21 #define __C64_CIA2REGISTERS__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00021     {\cf17 class }CIA2;\par
00022     {\cf17 class }CIATimer;\par
00023     {\cf17 class }CIAClock;\par
00024 \par
00027     {\cf17 class }CIA2Registers final : {\cf17 public} MCHEmul::PhisicalStorageSubset\par
00028     \{\par
00029         {\cf17 public}:\par
00030         {\cf17 friend} CIA2;\par
00031 \par
00032         CIA2Registers ({\cf18 int} {\cf18 id}, MCHEmul::PhisicalStorage* pS);\par
00033 \par
00034         {\cf18 unsigned} {\cf18 char} VICIIBank (){\cf17  const}\par
00035 {\cf17                             }\{ {\cf19 return} (_VICBank); \}\par
00036 \par
00037         {\cf17 virtual} {\cf18 void} initialize () {\cf17 override};\par
00038 \par
00039         {\cf17 private}:\par
00040         {\cf17 virtual} {\cf18 void} setValue ({\cf18 size_t} p, {\cf17 const} MCHEmul::UByte& v) {\cf17 override};\par
00041         {\cf17 virtual} {\cf17 const} MCHEmul::UByte& readValue ({\cf18 size_t} p) {\cf17 const override};\par
00042 \par
00043         {\cf20 // Implementation}\par
00044         {\cf18 void} initializeInternalValues ();\par
00045 \par
00046         {\cf20 // This methods are invoked from CIA chip...}\par
00048 {\cf20 }        {\cf18 void} lookAtTimers (CIATimer* tA, CIATimer* tB)\par
00049                             \{ _timerA = tA, _timerB = tB; \}\par
00051         {\cf18 void} lookAtClock (CIAClock* c)\par
00052                             \{ _clock = c; \}\par
00053 \par
00054         {\cf17 private}:\par
00055         {\cf20 // Reference to the timers...}\par
00056         CIATimer* _timerA;\par
00057         CIATimer* _timerB;\par
00058         {\cf20 // Reference to the clock...}\par
00059         CIAClock* _clock;\par
00060 \par
00062         {\cf18 unsigned} {\cf18 char} _VICBank;\par
00063 \par
00064         {\cf20 // Implementation}\par
00065         {\cf17 mutable} MCHEmul::UByte _lastValueRead;\par
00066     \};\par
00067 \}\par
00068 \par
00069 {\cf21 #endif}\par
00070   \par
00071 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/CIAClock.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIAClock.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIAClock.hpp}
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/global.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::CIAClock}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIAClock.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIAClock.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIAClock.hpp}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_CIACLOCK__}\par
00015 {\cf21 #define __C64_CIACLOCK__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <C64/global.hpp>}\par
00019 \par
00020 {\cf17 namespace }C64\par
00021 \{\par
00022     {\cf17 class }CIAClock\par
00023     \{\par
00024         {\cf17 public}:\par
00025         CIAClock ({\cf18 int} {\cf18 id} )\par
00026             : _id (id) \par
00027                             \{ initialize (); \}\par
00028 \par
00030         {\cf17 virtual} {\cf18 void} initialize ();\par
00031 \par
00032         {\cf18 int} id (){\cf17  const}\par
00033 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00034 \par
00037         {\cf18 bool} reachesAlarm (){\cf17  const}\par
00038 {\cf17                             }\{ {\cf19 return} (_reachesAlarm); \}\par
00039 \par
00040         {\cf18 bool} IRQEnabled (){\cf17  const}\par
00041 {\cf17                             }\{ {\cf19 return} (_IRQEnabled); \}\par
00042         {\cf18 void} setIRQEnabled ({\cf18 bool} e)\par
00043                             \{ _IRQEnabled = e; \}\par
00044         {\cf18 bool} IRQRequested (){\cf17  const}\par
00045 {\cf17                             }\{ {\cf18 bool} r = _IRQRequested; _IRQRequested = {\cf17 false}; {\cf19 return} (r); \}\par
00046 \par
00049         {\cf18 void} setAlarmHours ({\cf18 unsigned} {\cf18 char} h)\par
00050                             \{ _stopped = {\cf17 true}, _alarmHours = h; \}\par
00051         {\cf18 void} setAlarmMinutes ({\cf18 unsigned} {\cf18 char} m)\par
00052                             \{ _alarmMinutes = m; \}\par
00053         {\cf18 void} setAlarmSeconds ({\cf18 unsigned} {\cf18 char} s)\par
00054                             \{ _alarmSeconds = s; \}\par
00055         {\cf18 void} setAlarmTenthSeconds ({\cf18 unsigned} {\cf18 char} ts)\par
00056                             \{ _alarmTenthsSecond = ts; _stopped = {\cf17 true};\}\par
00057 \par
00058         {\cf18 void} setHours ({\cf18 unsigned} {\cf18 char} h)\par
00059                             \{ _stopped = {\cf17 true}, _hours = h; \}\par
00060         {\cf18 void} setMinutes ({\cf18 unsigned} {\cf18 char} m)\par
00061                             \{ _minutes = m; \}\par
00062         {\cf18 void} setSeconds ({\cf18 unsigned} {\cf18 char} s)\par
00063                             \{ _seconds = s; \}\par
00064         {\cf18 void} setTenthSeconds ({\cf18 unsigned} {\cf18 char} ts)\par
00065                             \{ _tenthsSecond = ts; _stopped = {\cf17 true};\}\par
00066 \par
00070         {\cf18 unsigned} {\cf18 char} hours (){\cf17  const}\par
00071 {\cf17                             }\{ _timeLatched = {\cf17 true}; {\cf19 return} (_hours); \}\par
00072         {\cf18 unsigned} {\cf18 char} minutes (){\cf17  const}\par
00073 {\cf17                             }\{ {\cf19 return} (_timeLatched ? _minutesL : _minutes); \}\par
00074         {\cf18 unsigned} {\cf18 char} seconds (){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_timeLatched ? _secondsL : _seconds); \}\par
00076         {\cf18 unsigned} {\cf18 char} tenthsSecond (){\cf17  const}\par
00077 {\cf17                             }\{ {\cf18 unsigned} {\cf18 char} r = _timeLatched ? _tenthsSecondL : _tenthsSecond; _timeLatched = {\cf17 false}; {\cf19 return} (r); \}\par
00078 \par
00083         {\cf18 void} simulate (MCHEmul::CPU* cpu);\par
00084 \par
00085         {\cf17 private}:\par
00086         {\cf20 // Managing the timer...}\par
00088 {\cf20 }        {\cf18 void} actualizeTime ();\par
00089 \par
00090         {\cf17 private}:\par
00091         {\cf18 int} _id;\par
00092 \par
00093         {\cf20 // The variables that define a timer...}\par
00094         {\cf18 bool} _IRQEnabled;\par
00095         {\cf18 unsigned} {\cf18 char} _alarmHours, _alarmMinutes, _alarmSeconds, _alarmTenthsSecond;\par
00096 \par
00097         {\cf20 // It is actualized continiously thorugh the method actualizeTime...}\par
00098         {\cf20 // The time counts only hours in the day...}\par
00099         Time _time;\par
00100 \par
00101         {\cf20 // Implementation}\par
00103 {\cf20 }        {\cf18 unsigned} {\cf18 int} _lastClockCycles;\par
00105         {\cf18 unsigned} {\cf18 char} _hours, _minutes, _seconds, _tenthsSecond;\par
00109         {\cf17 mutable} {\cf18 unsigned} {\cf18 char} _minutesL, _secondsL, _tenthsSecondL;\par
00110         {\cf17 mutable} {\cf18 bool} _timeLatched;\par
00112         {\cf17 mutable} {\cf18 bool} _stopped;\par
00114         {\cf18 bool} _reachesAlarm;\par
00116         {\cf17 mutable} {\cf18 bool} _IRQRequested;\par
00117     \};\par
00118 \}\par
00119 \par
00120 {\cf21 #endif}\par
00121   \par
00122 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/CIATimer.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIATimer.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIATimer.hpp}
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/global.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::CIATimer}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIATimer.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/CIATimer.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/CIATimer.hpp}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_CIATIMER__}\par
00015 {\cf21 #define __C64_CIATIMER__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <C64/global.hpp>}\par
00019 \par
00020 {\cf17 namespace }C64\par
00021 \{\par
00022     {\cf17 class }CIATimer\par
00023     \{\par
00024         {\cf17 public}:\par
00026         {\cf17 enum class} RunMode\par
00027         \{\par
00028             _RESTART = 0,           {\cf20 // The timer restarts once it reaches 0}\par
00029             _ONETIME                {\cf20 // The timer stops when it reaches 0 (becomes not enabled)}\par
00030         \};                        \par
00031 \par
00033         {\cf17 enum class} CountMode\par
00034         \{\par
00035             {\cf20 // The names are related directly with numbers to simplify later and quicker conversions...}\par
00036             _PROCESSORCYCLES = 0,       {\cf20 // Processor cycle }\par
00037             _SIGNALSONCNTLINE = 1,      {\cf20 // Signal present on the CNT line at pin 4 of User Port }\par
00038             _TIMERCOUNTSDOWNTO0 = 2,    {\cf20 // When other Timer reaches 0}\par
00039             _0ONCNTPULSES = 3           {\cf20 // When other Timer reaches 0 and _SIGNALSONCNTLINE in this timer is also on}\par
00040             {\cf20 // These two last types of timers helps to generate long time timers...}\par
00041         \};\par
00042 \par
00052         CIATimer ({\cf18 int} {\cf18 id} )\par
00053             : _id (id) \par
00054                             \{ initialize (); \}\par
00055 \par
00057         {\cf17 virtual} {\cf18 void} initialize ();\par
00058 \par
00059         {\cf18 int} id (){\cf17  const}\par
00060 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00061 \par
00062         {\cf20 // Managing the type...}\par
00063         RunMode runMode (){\cf17  const}\par
00064 {\cf17                             }\{ {\cf19 return} (_runMode); \}\par
00065         {\cf18 void} setRunMode (RunMode rm)\par
00066                             \{ _runMode = rm; \}\par
00067         CountMode countMode (){\cf17  const}\par
00068 {\cf17                             }\{ {\cf19 return} (_countMode); \}\par
00069         {\cf18 void} setCountMode (CountMode cm)\par
00070                             \{ _countMode = cm; \}\par
00071 \par
00074         {\cf18 bool} reaches0 (){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_reaches0); \}\par
00076 \par
00077         {\cf20 // Managing the status...}\par
00078         {\cf18 bool} enabled (){\cf17  const}\par
00079 {\cf17                             }\{ {\cf19 return} (_enabled); \}\par
00080         {\cf18 void} setEnabled ({\cf18 bool} e)\par
00081                             \{ _enabled = e; \}\par
00082 \par
00083         {\cf18 bool} IRQEnabled (){\cf17  const}\par
00084 {\cf17                             }\{ {\cf19 return} (_IRQEnabled); \}\par
00085         {\cf18 void} setIRQEnabled ({\cf18 bool} e)\par
00086                             \{ _IRQEnabled = e; \}\par
00087         {\cf18 bool} IRQRequested (){\cf17  const}\par
00088 {\cf17                             }\{ {\cf18 bool} r = _IRQRequested; _IRQRequested = {\cf17 false}; {\cf19 return} (r); \}\par
00089 \par
00090         {\cf20 // Managing the values...}\par
00092 {\cf20 }        {\cf18 unsigned} {\cf18 short} initialValue (){\cf17  const}\par
00093 {\cf17                             }\{ {\cf19 return} (_initialValue); \}\par
00094         {\cf18 void} setInitialValue ({\cf18 unsigned} {\cf18 char} iV)\par
00095                             \{ _initialValue = iV; _currentValue = _initialValue; \}\par
00097         {\cf18 unsigned} {\cf18 short} currentValue (){\cf17  const}\par
00098 {\cf17                             }\{ {\cf19 return} (_currentValue); \}\par
00100         {\cf18 void} reset ()\par
00101                             \{ _currentValue = _initialValue; \}\par
00102 \par
00105         {\cf18 void} simulate (MCHEmul::CPU* cpu, CIATimer* t = {\cf17 nullptr});\par
00106 \par
00107         {\cf17 private}:\par
00108         {\cf20 // Managing the timer...}\par
00118 {\cf20 }        {\cf18 bool} countDown (MCHEmul::CPU* cpu, CIATimer* t = {\cf17 nullptr});\par
00119 \par
00120         {\cf17 private}:\par
00121         {\cf18 int} _id;\par
00122 \par
00123         {\cf20 // The variables that define a timer...}\par
00124         RunMode _runMode;\par
00125         CountMode _countMode;\par
00126         {\cf18 bool} _enabled;\par
00127         {\cf18 bool} _IRQEnabled;\par
00128         {\cf18 unsigned} {\cf18 short} _initialValue;\par
00129 \par
00130         {\cf20 // It is actualized continiously through the method actualizeTime...}\par
00131         {\cf20 // The time counts only hours in the day...}\par
00132         Time _time;\par
00133 \par
00134         {\cf20 // Implementation}\par
00136 {\cf20 }        {\cf18 unsigned} {\cf18 short} _currentValue; \par
00138         {\cf18 unsigned} {\cf18 int} _lastClockCycles;\par
00140         {\cf18 bool} _reaches0;\par
00142         {\cf17 mutable} {\cf18 bool} _IRQRequested;\par
00143     \};\par
00144 \}\par
00145 \par
00146 {\cf21 #endif}\par
00147   \par
00148 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/ColorMemory.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/ColorMemory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/ColorMemory.hpp}
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::ColorRAMMemory}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ColorMemory.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/ColorMemory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/ColorMemory.hpp}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_COLORMEMORY__}\par
00015 {\cf21 #define __C64_COLORMEMORY__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00022     {\cf17 class }ColorRAMMemory final : {\cf17 public} MCHEmul::PhisicalStorageSubset\par
00023     \{\par
00024         {\cf17 public}:\par
00025         ColorRAMMemory ({\cf18 int} {\cf18 id}, MCHEmul::PhisicalStorage* ps)\par
00026             : MCHEmul::PhisicalStorageSubset (id, ps, 0xd800, MCHEmul::Address (\{ 0x00, 0xd8 \}, {\cf17 false}), 0x0400),\par
00027               _lastValue (MCHEmul::PhisicalStorage::_DEFAULTVALUE)\par
00028                             \{ \}\par
00029 \par
00030         {\cf17 private}:\par
00033         {\cf17 virtual} {\cf17 const} MCHEmul::UByte& readValue ({\cf18 size_t} p){\cf17  const override}\par
00034 {\cf17                             }\{ {\cf19 return} (_lastValue = MCHEmul::PhisicalStorageSubset::readValue (p) & 0x0f | \par
00035                                 ({\cf18 unsigned} {\cf18 char}) ((rand () % 0x10) << 4)); \}\par
00036 \par
00037         {\cf17 private}:\par
00038         {\cf20 // Implementation}\par
00039         {\cf17 mutable} MCHEmul::UByte _lastValue;\par
00040     \};\par
00041 \}\par
00042 \par
00043 {\cf21 #endif}\par
00044   \par
00045 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/global.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/global.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/global.hpp}
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <chrono>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b C64::Duration} = std::chrono::duration< unsigned long, std::deci >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b C64::Time} = std::chrono::time_point< std::chrono::steady_clock, Duration >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b C64::actualizeGlobalTime} ()\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
global.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/global.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/global.hpp}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_GLOBAL__}\par
00015 {\cf21 #define __C64_GLOBAL__}\par
00016 \par
00017 {\cf21 #include <chrono>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00022     {\cf17 using} Duration = std::chrono::duration <unsigned long, std::deci>;\par
00023     {\cf17 using} Time = std::chrono::time_point <std::chrono::steady_clock, Duration>;\par
00024 \par
00026     {\cf17 static} {\cf17 const} Time _STARTINGTIME = std::chrono::time_point_cast <Duration> (std::chrono::steady_clock::now ());\par
00028     {\cf17 static} Time _NOW = std::chrono::time_point_cast <Duration> (std::chrono::steady_clock::now ());\par
00030     {\cf17 static} Duration _TENTHSSECONDPAST = Duration ();\par
00031 \par
00033     {\cf18 void} actualizeGlobalTime ();\par
00034 \}\par
00035 \par
00036 {\cf21 #endif}\par
00037   \par
00038 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/global.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/global.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/global.hpp}
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <assert.h>}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
{\f2 #include <map>}\par
{\f2 #include <ostream>}\par
{\f2 #include <iostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Attributes} = std::map< std::string, std::string >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b MCHEmul::operator<<} (std::ostream &o, const Attributes &attrs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::ltrim} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::rtrim} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::trim} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::upper} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::lower} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::noSpaces} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::onlyAlphanumeric} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::noneOf} (const std::string &s, const std::string &chrs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b MCHEmul::removeAllFrom} (const std::string &s, std::vector< std::string > &strs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b MCHEmul::getElementsFrom} (const std::string &txt, unsigned char ch, size_t nE=std::numeric_limits< size_t >::max())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MCHEmul::validLabel} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MCHEmul::validBytesOctal} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MCHEmul::validBytesHexadecimal} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MCHEmul::validBytesDecimal} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MCHEmul::validBytes} (const std::string &s)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
global.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/global.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/global.hpp}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_GLOBAL__}\par
00015 {\cf21 #define __MCHEMUL_GLOBAL__}\par
00016 \par
00017 {\cf21 #include <assert.h>}\par
00018 {\cf21 #include <string>}\par
00019 {\cf21 #include <vector>}\par
00020 {\cf21 #include <map>}\par
00021 {\cf21 #include <ostream>}\par
00022 {\cf21 #include <iostream>}\par
00023 \par
00024 {\cf17 namespace }MCHEmul\par
00025 \{\par
00027     {\cf17 using} Attributes = std::map <std::string, std::string>;\par
00029     {\cf17 static} {\cf17 const} std::string AttributedNotDefined = {\cf22 ""};\par
00031     std::ostream& operator << (std::ostream& o, {\cf17 const} Attributes& attrs);\par
00032 \par
00034     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _NOERROR                      = 0;\par
00035     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _INIT_ERROR                   = 1;\par
00036     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _CPU_ERROR                    = 2;\par
00037     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _CHIP_ERROR                   = 3;\par
00038     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _DEVICE_ERROR                 = 4;\par
00039     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _COMMSNOTOPENED_ERROR         = 5;\par
00040     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _COMMSCHANNELNOTOPENED_ERROR  = 6;\par
00041     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _COMMSINTNOTCREATED_ERROR     = 7;\par
00042     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _CHANNELREADERROR_ERROR       = 8;\par
00043     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _CHANNELWRITEERROR_ERROR      = 9;\par
00044 \par
00046     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _MAXBYTESMANAGED              = 2;\par
00047 \par
00049     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _DEBUGNOTHING                 = 0;\par
00050     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _DEBUGERRORS                  = 1;\par
00051     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _DEBUGERRORANDWARNINGS        = 2;\par
00052     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _DEBUGALL                     = 3;\par
00053     {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _DEBUGTRACEINTERNALS          = 4;\par
00054 \par
00056     {\cf17 static} {\cf17 const} std::string _SPACES (20, {\cf23 ' '});\par
00057     {\cf17 static} {\cf17 const} std::string _CEROS (20, {\cf23 '0'});\par
00058     {\cf17 static} {\cf17 const} std::string _TABS (20, {\cf23 '\\t'});\par
00059 \par
00061     std::string ltrim ({\cf17 const} std::string& s);\par
00062     std::string rtrim ({\cf17 const} std::string& s);\par
00063     std::string trim ({\cf17 const} std::string& s);\par
00064     std::string upper ({\cf17 const} std::string& s);\par
00065     std::string lower ({\cf17 const} std::string& s);\par
00066     std::string noSpaces ({\cf17 const} std::string& s);\par
00067     std::string onlyAlphanumeric ({\cf17 const} std::string& s);\par
00068     std::string noneOf ({\cf17 const} std::string& s, {\cf17 const} std::string& chrs);\par
00069     std::string removeAllFrom ({\cf17 const} std::string& s, std::vector <std::string>& strs);\par
00070     std::vector <std::string> getElementsFrom ({\cf17 const} std::string& txt, {\cf18 unsigned} {\cf18 char} ch, \par
00071         {\cf18 size_t} nE = std::numeric_limits <size_t>::max ());\par
00072 \par
00075     {\cf18 bool} validLabel ({\cf17 const} std::string& s); \par
00076     {\cf18 bool} validBytesOctal ({\cf17 const} std::string& s); \par
00077     {\cf18 bool} validBytesHexadecimal ({\cf17 const} std::string& s); \par
00078     {\cf18 bool} validBytesDecimal ({\cf17 const} std::string& s); \par
00079     {\cf18 bool} validBytes ({\cf17 const} std::string& s); \par
00080 \}\par
00081 \par
00082 {\cf21 #endif}\par
00083   \par
00084 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/IOPBuilder.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/IOPBuilder.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/IOPBuilder.hpp}
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::IOPeripheralBuilder}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IOPBuilder.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/IOPBuilder.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/IOPBuilder.hpp}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_IOPBUILDER__}\par
00015 {\cf21 #define __C64_IOPBUILDER__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00022     {\cf17 class }IOPeripheralBuilder : {\cf17 public} MCHEmul::IOPeripheralBuilder\par
00023     \{\par
00024         {\cf17 public}:\par
00025         IOPeripheralBuilder ()\par
00026             : MCHEmul::IOPeripheralBuilder ()\par
00027                 \{ \}\par
00028 \par
00029         {\cf17 protected}:\par
00031         {\cf17 virtual} MCHEmul::IOPeripheral* createPeripheral ({\cf18 int} {\cf18 id}, {\cf17 const} MCHEmul::Attributes& prms) {\cf17 const override};\par
00032     \};\par
00033 \}\par
00034 \par
00035 {\cf21 #endif}\par
00036   \par
00037 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/IOPBuilder.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/IOPBuilder.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/IOPBuilder.hpp}
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/IOPeripheral.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::IOPeripheralBuilder}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IOPBuilder.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/IOPBuilder.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/IOPBuilder.hpp}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_IOPBUILDER__}\par
00015 {\cf21 #define __MCHEMUL_IOPBUILDER__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/IOPeripheral.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00025     {\cf17 class }IOPeripheralBuilder\par
00026     \{\par
00027         {\cf17 public}:\par
00028         IOPeripheralBuilder () = {\cf19 default};\par
00029 \par
00030         IOPeripheralBuilder ({\cf17 const} IOPeripheralBuilder&) = {\cf17 delete};\par
00031 \par
00032         IOPeripheralBuilder& operator = ({\cf17 const} IOPeripheralBuilder&) = {\cf17 delete};\par
00033 \par
00034         {\cf17 virtual} ~IOPeripheralBuilder () \par
00035                             \{ {\cf19 for} ({\cf17 auto} i : _peripherals) {\cf17 delete} (i.second); \}\par
00036 \par
00039         IOPeripheral* peripheral ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& attrs) {\cf17 const};\par
00040 \par
00041         {\cf17 protected}:\par
00043         {\cf17 virtual} IOPeripheral* createPeripheral ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& prms) {\cf17 const} = 0;\par
00044 \par
00045         {\cf17 protected}:\par
00046         {\cf17 mutable} IOPeripherals _peripherals;\par
00047     \};\par
00048 \}\par
00049 \par
00050 {\cf21 #endif}\par
00051   \par
00052 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/Memory.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/Memory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/Memory.hpp}
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::Memory}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Memory.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/Memory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/Memory.hpp}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_MEMORY__}\par
00015 {\cf21 #define __C64_MEMORY__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00022     {\cf17 class }Memory final : {\cf17 public} MCHEmul::Memory\par
00023     \{\par
00024         {\cf17 public}:\par
00025         {\cf20 // Phisical Storages}\par
00026         {\cf17 static} {\cf17 const} {\cf18 int} _RAM                   = 0;\par
00027         {\cf17 static} {\cf17 const} {\cf18 int} _BASICROM              = 1;\par
00028         {\cf17 static} {\cf17 const} {\cf18 int} _CHARROM               = 2;\par
00029         {\cf17 static} {\cf17 const} {\cf18 int} _KERNELROM             = 3;\par
00030 \par
00031         {\cf20 // Subsets}\par
00032         {\cf20 // Fom CPU}\par
00033         {\cf17 static} {\cf17 const} {\cf18 int} _PAGEZERO_SUBSET       = 100;\par
00034         {\cf17 static} {\cf17 const} {\cf18 int} _STACK_SUBSET          = 101;\par
00035         {\cf17 static} {\cf17 const} {\cf18 int} _RAM0_SUBSET           = 102;\par
00036         {\cf17 static} {\cf17 const} {\cf18 int} _BASICROM_SUBSET       = 103;\par
00037         {\cf17 static} {\cf17 const} {\cf18 int} _BASICRAM_SUBSET       = 104;\par
00038         {\cf17 static} {\cf17 const} {\cf18 int} _RAM1_SUBSET           = 105;\par
00039         {\cf17 static} {\cf17 const} {\cf18 int} _CHARROM_SUBSET        = 106;\par
00040         {\cf17 static} {\cf17 const} {\cf18 int} _VICREGS_SUBSET        = 107;\par
00041         {\cf17 static} {\cf17 const} {\cf18 int} _SIDREGS_SUBSET        = 108;\par
00042         {\cf17 static} {\cf17 const} {\cf18 int} _COLOR_SUBSET          = 109;\par
00043         {\cf17 static} {\cf17 const} {\cf18 int} _CIA1_SUBSET           = 110;\par
00044         {\cf17 static} {\cf17 const} {\cf18 int} _CIA2_SUBSET           = 111;\par
00045         {\cf17 static} {\cf17 const} {\cf18 int} _IO1_SUBSET            = 112;\par
00046         {\cf17 static} {\cf17 const} {\cf18 int} _IO2_SUBSET            = 113;\par
00047         {\cf17 static} {\cf17 const} {\cf18 int} _KERNELROM_SUBSET      = 114;\par
00048         {\cf17 static} {\cf17 const} {\cf18 int} _KERNELRAM_SUBSET      = 115;\par
00049         {\cf20 // From VICII}\par
00050         {\cf17 static} {\cf17 const} {\cf18 int} _BANK0RAM0_SUBSET      = 200;\par
00051         {\cf17 static} {\cf17 const} {\cf18 int} _BANK0CHARROM_SUBSET   = 201;\par
00052         {\cf17 static} {\cf17 const} {\cf18 int} _BANK0RAM1_SUBSET      = 202;\par
00053         {\cf17 static} {\cf17 const} {\cf18 int} _BANK1RAM_SUBSET       = 203;\par
00054         {\cf17 static} {\cf17 const} {\cf18 int} _BANK2RAM0_SUBSET      = 204;\par
00055         {\cf17 static} {\cf17 const} {\cf18 int} _BANK2CHARROM_SUBSET   = 205;\par
00056         {\cf17 static} {\cf17 const} {\cf18 int} _BANK2RAM1_SUBSET      = 206;\par
00057         {\cf17 static} {\cf17 const} {\cf18 int} _BANK3RAM_SUBSET       = 207;\par
00058 \par
00059         {\cf20 // Views}\par
00060         {\cf17 static} {\cf17 const} {\cf18 int} _CPU_VIEW              = 0;\par
00061         {\cf17 static} {\cf17 const} {\cf18 int} _VICII_VIEW            = 1;\par
00062 \par
00063         Memory ();\par
00064 \par
00066         {\cf18 void} setVICIIView ()\par
00067                             \{ _activeView = (_VICIIView == {\cf17 nullptr}) ? (_VICIIView = lookForVICIIView ()) : _VICIIView; \}\par
00068 \par
00070         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00071 \par
00072         {\cf17 private}:\par
00073         {\cf17 virtual} MCHEmul::Stack* lookForStack (){\cf17  override}\par
00074 {\cf17                             }\{ {\cf19 return} ({\cf17 dynamic_cast <}MCHEmul::Stack*{\cf17 >} (subset (_STACK_SUBSET))); \}\par
00075         {\cf17 virtual} MCHEmul::MemoryView* lookForCPUView (){\cf17  override}\par
00076 {\cf17                             }\{ {\cf19 return} (view (_CPU_VIEW)); \}\par
00077         MCHEmul::MemoryView* lookForVICIIView ()\par
00078                             \{ {\cf19 return} (view (_VICII_VIEW)); \}\par
00079 \par
00080         {\cf17 static} MCHEmul::Memory::Content standardMemoryContent ();\par
00081 \par
00082         {\cf17 private}:\par
00083         MCHEmul::MemoryView* _VICIIView;\par
00084     \};\par
00085 \}\par
00086 \par
00087 {\cf21 #endif}\par
00088   \par
00089 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Memory.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Memory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Memory.hpp}
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/Address.hpp>}\par
{\f2 #include <CORE/UByte.hpp>}\par
{\f2 #include <CORE/UBytes.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::PhisicalStorage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::PhisicalStorageSubset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::MemoryView}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Memory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Memory::Content}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::PhisicalStorages} = std::map< int, PhisicalStorage * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::PhisicalStorageSubsets} = std::map< int, PhisicalStorageSubset * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::PhisicalStorageSubsetsList} = std::vector< PhisicalStorageSubset * >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::MemoryViews} = std::map< int, MemoryView * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Memory.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Memory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Memory.hpp}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00016 {\cf21 #ifndef __MCHEMUL_MEMORY__}\par
00017 {\cf21 #define __MCHEMUL_MEMORY__}\par
00018 \par
00019 {\cf21 #include <CORE/global.hpp>}\par
00020 {\cf21 #include <CORE/Address.hpp>}\par
00021 {\cf21 #include <CORE/UByte.hpp>}\par
00022 {\cf21 #include <CORE/UBytes.hpp>}\par
00023 \par
00024 {\cf17 namespace }MCHEmul\par
00025 \{\par
00026     {\cf17 class }PhisicalStorageSubset;\par
00027     {\cf17 class }MemoryView;\par
00028     {\cf17 class }Stack;\par
00029 \par
00034     {\cf17 class }PhisicalStorage final\par
00035     \{\par
00036         {\cf17 public}:\par
00038         {\cf17 static} UByte _DEFAULTVALUE;\par
00039 \par
00040         {\cf17 friend} PhisicalStorageSubset;\par
00041 \par
00042         {\cf17 enum class} Type \{ _ROM, _RAM \};\par
00043 \par
00044         PhisicalStorage () = {\cf17 delete};\par
00045 \par
00046         PhisicalStorage ({\cf18 int} {\cf18 id}, Type t, {\cf18 size_t} s)\par
00047             : _id (id), _type (t), \par
00048               _data (s, UByte::_0)\par
00049                             \{ \}\par
00050 \par
00051         PhisicalStorage ({\cf17 const} PhisicalStorage&) = {\cf19 default};\par
00052 \par
00053         PhisicalStorage& operator = ({\cf17 const} PhisicalStorage&) = {\cf19 default};\par
00054 \par
00055         {\cf18 int} id (){\cf17  const}\par
00056 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00057         Type type (){\cf17  const}\par
00058 {\cf17                             }\{ {\cf19 return} (_type); \}\par
00059         {\cf18 size_t} size (){\cf17  const}\par
00060 {\cf17                             }\{ {\cf19 return} (_data.size ()); \}\par
00061         \par
00062         {\cf18 bool} canBeWriten ({\cf18 bool} f = {\cf17 false} ){\cf17  const}\par
00063 {\cf17                             }\{ {\cf19 return} (_type == Type::_RAM || (_type == Type::_ROM && f)); \}\par
00064 \par
00065         {\cf17 protected}:\par
00066         {\cf20 // This methods can only be invoked from PhisicalMemorySubset class}\par
00067         {\cf20 // IMPORTANT NOTE: }\par
00068         {\cf20 // They go direclty to the memory and can be dangerous for the stability of the system!}\par
00069 \par
00073         {\cf18 void} set ({\cf18 size_t} pB, {\cf17 const} UByte& d)\par
00074                             \{ _data [pB] = d; \}\par
00075         {\cf17 const} UByte& value ({\cf18 size_t} pB){\cf17  const}\par
00076 {\cf17                             }\{ {\cf19 return} (_data [pB]); \}\par
00077         UBytes values ({\cf18 size_t} pB, {\cf18 size_t} nB){\cf17  const}\par
00078 {\cf17                             }\{ {\cf19 return} (UBytes (bytes (pB, nB))); \}\par
00079         {\cf18 void} set ({\cf18 size_t} pB, {\cf17 const} UBytes& v)\par
00080                             \{ set (pB, v.bytes ()); \}\par
00081         std::vector <UByte> bytes ({\cf18 size_t} pB, {\cf18 size_t} nB) {\cf17 const};\par
00082         {\cf18 void} set ({\cf18 size_t} pB, {\cf17 const} std::vector <UByte>& v)\par
00083                             \{ {\cf19 for} ({\cf18 size_t} i = 0; i < v.size (); i++) set (pB + i, v [i]); \}\par
00084 \par
00087         {\cf18 bool} loadInto ({\cf17 const} std::string& fN, {\cf18 size_t} p = 0);\par
00088 \par
00089         {\cf17 protected}:\par
00090         {\cf17 const} {\cf18 int} _id = -1; {\cf20 // Modified at construction level}\par
00091         {\cf17 const} Type _type = Type::_RAM; {\cf20 // Modified also at construction level}\par
00092         std::vector <MCHEmul::UByte> _data;\par
00093     \};\par
00094 \par
00096     {\cf17 using} PhisicalStorages = std::map <int, PhisicalStorage*>;\par
00097 \par
00100     {\cf17 class }PhisicalStorageSubset\par
00101     \{\par
00102         {\cf17 public}:\par
00103         {\cf17 friend} MemoryView;\par
00104 \par
00105         PhisicalStorageSubset () = {\cf17 delete};\par
00106 \par
00112         PhisicalStorageSubset ({\cf18 int} {\cf18 id}, PhisicalStorage* pS, {\cf18 size_t} pp , {\cf17 const} Address& a, {\cf18 size_t} s);\par
00113 \par
00114         PhisicalStorageSubset ({\cf17 const} PhisicalStorageSubset&) = {\cf19 default};\par
00115 \par
00116         {\cf17 virtual} ~PhisicalStorageSubset () \par
00117                             \{  \}\par
00118 \par
00119         PhisicalStorageSubset& operator = ({\cf17 const} PhisicalStorageSubset&) = {\cf19 default};\par
00120 \par
00122         {\cf18 int} id (){\cf17  const}\par
00123 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00124         {\cf17 const} PhisicalStorage* phisicalStorage (){\cf17  const}\par
00125 {\cf17                             }\{ {\cf19 return} (_phisicalStorage); \}\par
00126         PhisicalStorage* phisicalStorage ()\par
00127                             \{ {\cf19 return} (_phisicalStorage); \}\par
00128         PhisicalStorage::Type type (){\cf17  const}\par
00129 {\cf17                             }\{ {\cf19 return} (_phisicalStorage -> type ()); \}\par
00130         {\cf17 const} Address& initialAddress (){\cf17  const}\par
00131 {\cf17                             }\{ {\cf19 return} (_initialAddress); \}\par
00132         {\cf18 size_t} size (){\cf17  const}\par
00133 {\cf17                             }\{ {\cf19 return} (_size); \}\par
00134         \par
00135         {\cf18 bool} active (){\cf17  const}\par
00136 {\cf17                             }\{ {\cf19 return} (_active); \}\par
00137         {\cf18 void} setActive ({\cf18 bool} a)\par
00138                             \{ _active = a; \}\par
00139         {\cf18 bool} activeForReading (){\cf17  const}\par
00140 {\cf17                             }\{ {\cf19 return} (_activeForReading); \}\par
00141         {\cf18 void} setActiveForReading ({\cf18 bool} aR)\par
00142                             \{ _activeForReading = aR; \}\par
00143 \par
00144         {\cf18 bool} canBeWriten ({\cf18 bool} f){\cf17  const}\par
00145 {\cf17                             }\{ {\cf19 return} (_active && _phisicalStorage -> canBeWriten (f)); \}\par
00146 \par
00148         {\cf18 bool} isIn ({\cf17 const} Address& a, {\cf18 int}& dt){\cf17  const}\par
00149 {\cf17                             }\{ {\cf19 return} (_active && (a >= _initialAddress && (dt = _initialAddress.distanceWith (a)) < ({\cf18 int}) _size)); \}\par
00150 \par
00153         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} UByte& d, {\cf18 bool} f = {\cf17 false})\par
00154                             \{ {\cf18 int} dt = 0; {\cf19 if} (_phisicalStorage -> canBeWriten (f) && isIn (a, dt)) setValue (dt, d); \}\par
00157         {\cf17 const} UByte& value ({\cf17 const} Address& a){\cf17  const}\par
00158 {\cf17                             }\{ {\cf18 int} dt = 0; {\cf19 return} (_activeForReading && (isIn (a, dt)) \par
00159                                 ? readValue (dt) : PhisicalStorage::_DEFAULTVALUE); \}\par
00160         UBytes values ({\cf17 const} Address& a, {\cf18 size_t} nB){\cf17  const}\par
00161 {\cf17                             }\{ {\cf19 return} (UBytes (bytes (a, nB))); \}\par
00162         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} UBytes& v, {\cf18 bool} f = {\cf17 false})\par
00163                             \{ set (a, v.bytes (), f); \}\par
00165         std::vector <UByte> bytes ({\cf17 const} Address& a, {\cf18 size_t} nB) {\cf17 const};\par
00166         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} std::vector <UByte>& v, {\cf18 bool} f = {\cf17 false});\par
00167 \par
00170         {\cf17 virtual} {\cf18 void} initialize ()\par
00171                             \{ {\cf19 for} ({\cf18 size_t} i = 0; i < _size; i++) setValue (i, _defaultData [i]); \}\par
00172 \par
00175         {\cf18 bool} load ({\cf17 const} std::string& fN, {\cf18 size_t} sA, {\cf18 bool} bE = {\cf17 true});\par
00177         {\cf18 bool} loadInto ({\cf17 const} std::string& fN, {\cf17 const} Address& a)\par
00178                             \{ {\cf19 return} ((a >= _initialAddress) \par
00179                                 ? _phisicalStorage -> loadInto (fN, _initialAddress.distanceWith (a)) : {\cf17 false}); \}\par
00181         {\cf18 bool} loadInto ({\cf17 const} std::string& fN)\par
00182                             \{ {\cf19 return} (loadInto (fN, initialAddress ())); \}\par
00183 \par
00185         {\cf18 void} fixDefaultValues ()\par
00186                             \{ _defaultData = _phisicalStorage -> values (_initialPhisicalPosition, _size).bytes (); \}\par
00187 \par
00188         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} PhisicalStorageSubset& ps);\par
00189 \par
00190         {\cf17 protected}:\par
00195         {\cf17 virtual} {\cf18 void} setValue ({\cf18 size_t} nB, {\cf17 const} UByte& d)\par
00196                             \{ _phisicalStorage -> set (nB + _initialPhisicalPosition, d); \}\par
00197         {\cf17 virtual} {\cf17 const} UByte& readValue ({\cf18 size_t} nB){\cf17  const}\par
00198 {\cf17                             }\{ {\cf19 return} (_phisicalStorage -> value (nB + _initialPhisicalPosition)); \}\par
00199 \par
00200         {\cf17 protected}:\par
00201         {\cf17 const} {\cf18 int} _id = -1; \par
00202         PhisicalStorage* _phisicalStorage;\par
00204         {\cf18 size_t} _initialPhisicalPosition;\par
00206         Address _initialAddress;\par
00208         {\cf18 size_t} _size;\par
00209 \par
00210         {\cf20 // Implementation}\par
00211         {\cf18 bool} _active;\par
00212         {\cf18 bool} _activeForReading;\par
00213         std::vector <MCHEmul::UByte> _defaultData;\par
00214     \};\par
00215 \par
00217     {\cf17 using} PhisicalStorageSubsets = std::map <int, PhisicalStorageSubset*>;\par
00218     {\cf17 using} PhisicalStorageSubsetsList = std::vector <PhisicalStorageSubset*>;\par
00219 \par
00222     {\cf17 class }MemoryView\par
00223     \{\par
00224         {\cf17 public}:\par
00225         MemoryView () = {\cf17 delete};\par
00226 \par
00228         MemoryView ({\cf18 int} {\cf18 id}, PhisicalStorageSubsets ss)\par
00229             : _id (id), _subsets (ss)\par
00230                             \{ \}\par
00231 \par
00232         MemoryView ({\cf17 const} MemoryView&) = {\cf19 default};\par
00233 \par
00234         {\cf17 virtual} ~MemoryView ()\par
00235                             \{ \}\par
00236 \par
00237         MemoryView& operator = ({\cf17 const} MemoryView&) = {\cf19 default};\par
00238 \par
00239         {\cf18 int} id (){\cf17  const}\par
00240 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00241 \par
00242         {\cf20 // To manage the subsets...}\par
00243         {\cf17 const} PhisicalStorageSubsets& subsets (){\cf17  const}\par
00244 {\cf17                             }\{ {\cf19 return} (_subsets); \}\par
00245         {\cf18 bool} existsSubset ({\cf18 int} {\cf18 id}){\cf17  const}\par
00246 {\cf17                             }\{ {\cf19 return} (_subsets.find ({\cf18 id}) != _subsets.end ()); \}\par
00247         {\cf17 const} PhisicalStorageSubset* subset ({\cf18 int} {\cf18 id}){\cf17  const}\par
00248 {\cf17                             }\{ {\cf19 return} (({\cf17 const} PhisicalStorageSubset*) (((MemoryView*) ({\cf17 this})) -> subset ({\cf18 id}))); \}\par
00249         PhisicalStorageSubset* subset ({\cf18 int} {\cf18 id})\par
00250                             \{ PhisicalStorageSubsets::const_iterator i = _subsets.find ({\cf18 id}); \par
00251                                 {\cf19 return} ((i != _subsets.end ()) ? (*i).second : {\cf17 nullptr}); \}\par
00252         \par
00253         {\cf18 bool} isIn ({\cf17 const} Address& a, {\cf18 int} & dt) {\cf17 const};\par
00254 \par
00257         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} UByte& d, {\cf18 bool} f = {\cf17 false});\par
00260         {\cf17 const} UByte& value ({\cf17 const} Address& a) {\cf17 const};\par
00261         UBytes values ({\cf17 const} Address& a, {\cf18 size_t} nB){\cf17  const}\par
00262 {\cf17                             }\{ {\cf19 return} (UBytes (bytes (a, nB))); \}\par
00263         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} UBytes& v, {\cf18 bool} f = {\cf17 false})\par
00264                             \{ set (a, v.bytes (), f); \}\par
00265         std::vector <UByte> bytes ({\cf17 const} Address& a, {\cf18 size_t} nB) {\cf17 const};\par
00266         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} std::vector <UByte>& v, {\cf18 bool} f = {\cf17 false});\par
00267 \par
00270         {\cf17 virtual} {\cf18 void} initialize () \par
00271                             \{ {\cf19 for} ({\cf17 auto} i : _subsets) i.second -> initialize (); \}\par
00272 \par
00274         {\cf18 bool} loadInto ({\cf17 const} std::string& fN, {\cf17 const} Address& a);\par
00275 \par
00276         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} MemoryView& mv);\par
00277 \par
00278         {\cf17 protected}:\par
00279         {\cf18 int} _id;\par
00280         PhisicalStorageSubsets _subsets;\par
00281     \};\par
00282 \par
00284     {\cf17 using} MemoryViews = std::map <int, MemoryView*>;\par
00285 \par
00293     {\cf17 class }Memory\par
00294     \{\par
00295         {\cf17 public}:\par
00297         {\cf17 class }Content final\par
00298         \{\par
00299             {\cf17 public}:\par
00300             Content ()\par
00301                 : _phisicalStorages (), _subsets (), _views (),\par
00302                   _error (true)\par
00303                             \{ \}\par
00304 \par
00305             Content ({\cf17 const} Content&) = {\cf19 default};\par
00306 \par
00307             ~Content () = {\cf19 default};\par
00308 \par
00309             Content& operator = ({\cf17 const} Content&) = {\cf19 default};\par
00310 \par
00312             {\cf18 bool} verifyCoherence () {\cf17 const};\par
00313 \par
00314             {\cf17 const} PhisicalStorages& phisicalStorages (){\cf17  const}\par
00315 {\cf17                             }\{ {\cf19 return} (_phisicalStorages); \}\par
00316             {\cf18 bool} existsPhisicalStorage ({\cf18 int} {\cf18 id}){\cf17  const}\par
00317 {\cf17                             }\{ {\cf19 return} (_phisicalStorages.find ({\cf18 id}) != _phisicalStorages.end ()); \}\par
00318             {\cf17 const} PhisicalStorage* phisicalStorage ({\cf18 int} {\cf18 id}){\cf17  const}\par
00319 {\cf17                             }\{ {\cf19 return} (({\cf17 const} PhisicalStorage*) (((Content*) ({\cf17 this})) -> phisicalStorage ({\cf18 id}))); \}\par
00320             PhisicalStorage* phisicalStorage ({\cf18 int} {\cf18 id})\par
00321                             \{ PhisicalStorages::const_iterator i = _phisicalStorages.find ({\cf18 id}); \par
00322                                 {\cf19 return} ((i != _phisicalStorages.end ()) ? (*i).second : {\cf17 nullptr}); \}\par
00323 \par
00324             {\cf17 const} PhisicalStorageSubsets& Subsets ( ){\cf17  const}\par
00325 {\cf17                             }\{ {\cf19 return} (_subsets); \}\par
00326             {\cf18 bool} existsSubset ({\cf18 int} {\cf18 id}){\cf17  const}\par
00327 {\cf17                             }\{ {\cf19 return} (_subsets.find ({\cf18 id}) != _subsets.end ()); \}\par
00328             {\cf17 const} PhisicalStorageSubset* subset ({\cf18 int} {\cf18 id}){\cf17  const}\par
00329 {\cf17                             }\{ {\cf19 return} (({\cf17 const} PhisicalStorageSubset*) (((Content*) ({\cf17 this})) -> subset ({\cf18 id}))); \}\par
00330             PhisicalStorageSubset* subset ({\cf18 int} {\cf18 id})\par
00331                             \{ PhisicalStorageSubsets::const_iterator i = _subsets.find ({\cf18 id}); \par
00332                                 {\cf19 return} ((i != _subsets.end ()) ? (*i).second : {\cf17 nullptr}); \}\par
00333 \par
00334             {\cf17 const} MemoryViews& views (){\cf17  const}\par
00335 {\cf17                             }\{ {\cf19 return} (_views); \}\par
00336             {\cf18 bool} existsView ({\cf18 int} {\cf18 id}){\cf17  const}\par
00337 {\cf17                             }\{ {\cf19 return} (_views.find ({\cf18 id}) != _views.end ()); \}\par
00338             {\cf17 const} MemoryView* view ({\cf18 int} {\cf18 id}){\cf17  const}\par
00339 {\cf17                             }\{ {\cf19 return} (({\cf17 const} MemoryView*) (((Content*) ({\cf17 this})) -> view ({\cf18 id}))); \}\par
00340             MemoryView* view ({\cf18 int} {\cf18 id})\par
00341                             \{ MemoryViews::const_iterator i = _views.find ({\cf18 id}); \par
00342                                 {\cf19 return} ((i != _views.end ()) ? (*i).second : {\cf17 nullptr}); \}\par
00343             MemoryView* firstView (){\cf17  const}\par
00344 {\cf17                             }\{ {\cf19 return} ((*_views.begin ()).second); \}\par
00345 \par
00346             {\cf18 bool} initialize ();\par
00347 \par
00348             {\cf18 bool} error (){\cf17  const}\par
00349 {\cf17                             }\{ {\cf19 return} (_error); \}\par
00350 \par
00352             PhisicalStorages _phisicalStorages;\par
00353             PhisicalStorageSubsets _subsets;\par
00354             MemoryViews _views;\par
00355 \par
00356             {\cf17 private}:\par
00357             {\cf20 // Implementation}\par
00358             {\cf17 mutable} {\cf18 bool} _error;\par
00359         \};\par
00360 \par
00361         Memory () = {\cf17 delete};\par
00362 \par
00363         Memory ({\cf17 const} Content& cnt);\par
00364 \par
00365         Memory ({\cf17 const} Memory&) = {\cf19 default};\par
00366 \par
00367         Memory& operator = ({\cf17 const} Memory&) = {\cf19 default};\par
00368 \par
00369         ~Memory ();\par
00370 \par
00371         {\cf17 const} PhisicalStorages& phisicalStorages (){\cf17  const}\par
00372 {\cf17                             }\{ {\cf19 return} (_content.phisicalStorages ()); \}\par
00373         {\cf18 bool} existsPhisicalStorage ({\cf18 int} {\cf18 id}){\cf17  const}\par
00374 {\cf17                             }\{ {\cf19 return} (_content.existsPhisicalStorage ({\cf18 id})); \} \par
00375         {\cf17 const} PhisicalStorage* phisicalStorage ({\cf18 int} {\cf18 id}){\cf17  const}\par
00376 {\cf17                             }\{ {\cf19 return} (_content.phisicalStorage ({\cf18 id})); \}\par
00377         PhisicalStorage* phisicalStorage ({\cf18 int} {\cf18 id})\par
00378                             \{ {\cf19 return} (_content.phisicalStorage ({\cf18 id})); \}\par
00379 \par
00380         {\cf17 const} PhisicalStorageSubsets& Subsets (){\cf17  const}\par
00381 {\cf17                             }\{ {\cf19 return} (_content.Subsets ()); \}\par
00382         {\cf18 bool} existsSubset ({\cf18 int} {\cf18 id}){\cf17  const}\par
00383 {\cf17                             }\{ {\cf19 return} (_content.existsSubset ({\cf18 id})); \}\par
00384         {\cf17 const} PhisicalStorageSubset* subset ({\cf18 int} {\cf18 id}){\cf17  const}\par
00385 {\cf17                             }\{ {\cf19 return} (_content.subset ({\cf18 id})); \}\par
00386         PhisicalStorageSubset* subset ({\cf18 int} {\cf18 id})\par
00387                             \{ {\cf19 return} (_content.subset ({\cf18 id})); \}\par
00388 \par
00389         {\cf17 const} MemoryViews& views (){\cf17  const}\par
00390 {\cf17                             }\{ {\cf19 return} (_content.views ()); \}\par
00391         {\cf18 bool} existsView ({\cf18 int} {\cf18 id}){\cf17  const}\par
00392 {\cf17                             }\{ {\cf19 return} (_content.existsView ({\cf18 id})); \}\par
00393         {\cf17 const} MemoryView* view ({\cf18 int} {\cf18 id}){\cf17  const}\par
00394 {\cf17                             }\{ {\cf19 return} (_content.view ({\cf18 id}));  \}\par
00395         MemoryView* view ({\cf18 int} {\cf18 id})\par
00396                             \{ {\cf19 return} (_content.view ({\cf18 id}));  \}\par
00397 \par
00398         {\cf20 // Managing the active view of the memory...}\par
00399         {\cf17 const} MemoryView* activeView (){\cf17  const}\par
00400 {\cf17                             }\{ {\cf19 return} (_activeView); \}\par
00401         MemoryView* activeView ()\par
00402                             \{ {\cf19 return} (_activeView); \}\par
00403         {\cf18 void} setActiveView ({\cf18 int} {\cf18 id})\par
00404                             \{ {\cf19 if} (existsView ({\cf18 id})) _activeView = view ({\cf18 id}); \}\par
00405 \par
00406         {\cf18 bool} isIn ({\cf17 const} Address& a, {\cf18 int} & dt){\cf17  const}\par
00407 {\cf17                             }\{ {\cf19 return} (_activeView -> isIn (a, dt)); \}\par
00408 \par
00411         {\cf17 const} Stack* stack (){\cf17  const}\par
00412 {\cf17                             }\{ {\cf19 return} (({\cf17 const} Stack*) (((Memory*) ({\cf17 this})) -> stack ())); \}\par
00413         Stack* stack () \par
00414                             \{ {\cf19 return} ((_stack == {\cf17 nullptr}) ? (_stack = lookForStack ()) : _stack); \}\par
00415 \par
00418         {\cf18 void} setCPUView ()\par
00419                             \{ _activeView = (_cpuView == {\cf17 nullptr}) ? (_cpuView = lookForCPUView ()) : _cpuView; \}\par
00420 \par
00421         {\cf17 const} UByte& value ({\cf17 const} Address& a){\cf17  const}\par
00422 {\cf17                             }\{ {\cf19 return} (_activeView -> value (a)); \}\par
00423         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} UByte& v, {\cf18 bool} f = {\cf17 false} )\par
00424                             \{ _activeView -> set (a, v, f); \}\par
00425         UBytes values ({\cf17 const} Address& a, {\cf18 size_t} nB){\cf17  const}\par
00426 {\cf17                             }\{ {\cf19 return} (_activeView -> values (a, nB)); \}\par
00427         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} UBytes& v, {\cf18 bool} f = {\cf17 false})\par
00428                             \{ _activeView -> set (a, v, f); \}\par
00429         std::vector <UByte> bytes ({\cf17 const} Address& a, {\cf18 size_t} nB){\cf17  const}\par
00430 {\cf17                             }\{ {\cf19 return} (_activeView -> bytes (a, nB)); \}\par
00431         {\cf18 void} set ({\cf17 const} Address& a, {\cf17 const} std::vector <UByte>& v, {\cf18 bool} f = {\cf17 false})\par
00432                             \{ _activeView -> set (a, v, f); \}\par
00433 \par
00436         {\cf17 virtual} {\cf18 bool} initialize ()\par
00437                             \{ {\cf19 return} ((_lastError == MCHEmul::_NOERROR) ? _content.initialize () : {\cf17 false}); \}\par
00438 \par
00439         {\cf18 bool} loadInto ({\cf17 const} std::string& fN, {\cf17 const} Address& a)\par
00440                             \{ {\cf19 return} (_activeView -> loadInto (fN, a)); \}\par
00441 \par
00443         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00444 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00445         {\cf18 void} resetErrors ()\par
00446                             \{ _lastError = _NOERROR; \}\par
00447 \par
00448         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Memory& m);\par
00449 \par
00450         {\cf17 protected}:\par
00451         {\cf17 virtual} Stack* lookForStack () = 0;\par
00452         {\cf17 virtual} MemoryView* lookForCPUView () = 0;\par
00453 \par
00454         {\cf17 protected}:\par
00455         Content _content;\par
00456 \par
00457         {\cf20 // Implementation}\par
00458         MemoryView* _activeView;\par
00459         {\cf17 mutable} Stack* _stack;\par
00460         {\cf17 mutable} MemoryView* _cpuView;\par
00461         {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastError;\par
00462     \};\par
00463 \}\par
00464 \par
00465 {\cf21 #endif}\par
00466   \par
00467 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/OSIO.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/OSIO.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/OSIO.hpp}
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::InputOSSystem}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OSIO.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/OSIO.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/OSIO.hpp}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_OSIO__}\par
00015 {\cf21 #define __C64_OSIO__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00021     {\cf17 class }CIA1;\par
00022 \par
00026     {\cf17 class }InputOSSystem final : {\cf17 public} MCHEmul::InputOSSystem\par
00027     \{\par
00028         {\cf17 public}:\par
00029         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _ID = 2;\par
00030 \par
00031         InputOSSystem ({\cf17 const} MCHEmul::Attributes& attrs = \{ \})\par
00032             : MCHEmul::InputOSSystem (_ID, attrs),\par
00033               _cia1 ({\cf17 nullptr})\par
00034                             \{ \}\par
00035 \par
00036         {\cf17 virtual} {\cf18 void} linkToChips ({\cf17 const} MCHEmul::Chips& c) {\cf17 override};\par
00037 \par
00038         {\cf17 private}:\par
00039         {\cf17 virtual} {\cf18 void} whenKeyPressed (SDL_Scancode k) {\cf17 override};\par
00040         {\cf17 virtual} {\cf18 void} whenKeyReleased (SDL_Scancode k) {\cf17 override};\par
00041         {\cf17 virtual} {\cf18 void} whenJoystickMoved ({\cf17 const} MCHEmul::InputOSSystem::SDL_JoyAxisEvents& js) {\cf17 override};\par
00042         {\cf17 virtual} {\cf18 void} whenJoystickButtonPressed (SDL_JoyButtonEvent jb) {\cf17 override};\par
00043         {\cf17 virtual} {\cf18 void} whenJoystickButtonReleased (SDL_JoyButtonEvent jb) {\cf17 override};\par
00044 \par
00045         {\cf17 private}:\par
00046         CIA1* _cia1;\par
00047 \par
00063         {\cf17 using} KeyMPos = std::pair <{\cf18 unsigned} {\cf18 short} , {\cf18 unsigned} {\cf18 short} >;\par
00064         {\cf17 static} {\cf17 const} std::map <SDL_Scancode, KeyMPos> _C64KEYS;\par
00065     \};\par
00066 \}\par
00067 \par
00068 {\cf21 #endif}\par
00069   \par
00070 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/OSIO.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/OSIO.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/OSIO.hpp}
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/IO.hpp>}\par
{\f2 #include <SDL_events.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::InputOSSystem}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OSIO.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/OSIO.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/OSIO.hpp}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_OSIO__}\par
00015 {\cf21 #define __MCHEMUL_OSIO__}\par
00016 \par
00017 {\cf21 #include <CORE/IO.hpp>}\par
00018 {\cf21 #include <SDL_events.h>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00023     {\cf17 class }InputOSSystem : {\cf17 public} IODevice\par
00024     \{\par
00025         {\cf17 public}:\par
00026         InputOSSystem ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& attrs = \{ \})\par
00027             : IODevice (Type::_OUTPUT, {\cf18 id}, attrs),\par
00028               _quitRequested ({\cf17 false})\par
00029                             \{ \}\par
00030 \par
00031         {\cf18 bool} quitRequested (){\cf17  const}\par
00032 {\cf17                             }\{ {\cf19 return} (_quitRequested); \}\par
00033 \par
00034         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00035 \par
00037         {\cf17 virtual} {\cf18 bool} simulate () {\cf17 override};\par
00038 \par
00039         {\cf17 protected}:\par
00040         {\cf20 // To manage events related with the keyboard...}\par
00042 {\cf20 }        {\cf17 virtual} {\cf18 void} whenKeyPressed (SDL_Scancode) = 0;\par
00044         {\cf17 virtual} {\cf18 void} whenKeyReleased (SDL_Scancode) = 0;\par
00045 \par
00046         {\cf20 // To manage events related with the joystick...}\par
00047         {\cf17 using} SDL_JoyAxisEvents = std::vector <SDL_JoyAxisEvent>;\par
00051         {\cf17 virtual} {\cf18 void} whenJoystickMoved ({\cf17 const} SDL_JoyAxisEvents&) = 0;\par
00053         {\cf17 virtual} {\cf18 void} whenJoystickButtonPressed (SDL_JoyButtonEvent) = 0;\par
00055         {\cf17 virtual} {\cf18 void} whenJoystickButtonReleased (SDL_JoyButtonEvent) = 0;\par
00056 \par
00057         {\cf17 protected}:\par
00058         {\cf18 bool} _quitRequested;\par
00059     \};\par
00060 \}\par
00061 \par
00062 {\cf21 #endif}\par
00063   \par
00064 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/Screen.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/Screen.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/Screen.hpp}
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/VICII.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::Screen}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::ScreenNTSC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::ScreenPAL}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Screen.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/Screen.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/Screen.hpp}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_SCREEN__}\par
00015 {\cf21 #define __C64_SCREEN__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <C64/VICII.hpp>}\par
00019 \par
00020 {\cf17 namespace }C64\par
00021 \{\par
00022     {\cf17 class }Screen : {\cf17 public} MCHEmul::Screen\par
00023     \{\par
00024         {\cf17 public}:\par
00025         {\cf17 static} {\cf17 const} {\cf18 int} _ID = 1;\par
00026         Screen ({\cf18 double} hz, {\cf18 int} w, {\cf18 int} h, {\cf17 const} MCHEmul::Attributes& attrs = \{ \});\par
00027     \};\par
00028 \par
00029     {\cf17 class }ScreenNTSC final : {\cf17 public} Screen\par
00030     \{\par
00031         {\cf17 public}:\par
00032         ScreenNTSC ()\par
00033             : Screen (59.940f, \par
00034                 (int) VICII_NTSC::_HRASTERDATA.visiblePositions (), (int) VICII_NTSC::_VRASTERDATA.visiblePositions ())\par
00035                             \{ \}\par
00036     \};\par
00037 \par
00038     {\cf17 class }ScreenPAL final : {\cf17 public} Screen\par
00039     \{\par
00040         {\cf17 public}:\par
00041         ScreenPAL ()\par
00042             : Screen (50.125f,\par
00043                 (int) VICII_PAL::_HRASTERDATA.visiblePositions (), (int) VICII_PAL::_VRASTERDATA.visiblePositions ())\par
00044                             \{ \}\par
00045     \};\par
00046 \}\par
00047 \par
00048 {\cf21 #endif}\par
00049   \par
00050 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Screen.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Screen.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Screen.hpp}
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/IO.hpp>}\par
{\f2 #include <CORE/GraphicalChip.hpp>}\par
{\f2 #include <SDL.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Screen}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Screen.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Screen.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Screen.hpp}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_SCREEN__}\par
00015 {\cf21 #define __MCHEMUL_SCREEN__}\par
00016 \par
00017 {\cf21 #include <CORE/IO.hpp>}\par
00018 {\cf21 #include <CORE/GraphicalChip.hpp>}\par
00019 {\cf21 #include <SDL.h>}\par
00020 \par
00021 {\cf17 namespace }MCHEmul\par
00022 \{\par
00024     {\cf17 class }Screen : {\cf17 public} IODevice\par
00025     \{\par
00026         {\cf17 public}:\par
00038         Screen ({\cf17 const} std::string& n, {\cf18 int} {\cf18 id},\par
00039             {\cf18 unsigned} {\cf18 int} sc, {\cf18 unsigned} {\cf18 int} sr, {\cf18 unsigned} {\cf18 int} vF, {\cf18 double} hz,\par
00040             {\cf17 const} Attributes& attrs = \{ \});\par
00041 \par
00042         Screen ({\cf17 const} Screen*) = {\cf17 delete};\par
00043 \par
00044         Screen& operator = ({\cf17 const} Screen&) = {\cf17 delete};\par
00045 \par
00046         {\cf17 virtual} ~Screen () {\cf17 override};\par
00047 \par
00048         {\cf17 virtual} {\cf18 void} linkToChips ({\cf17 const} Chips& c) {\cf17 override};\par
00049 \par
00051         {\cf17 const} GraphicalChip* graphicalChip (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_graphicalChip); \}\par
00053         GraphicalChip* graphicalChip ()\par
00054                             \{ {\cf19 return} (_graphicalChip); \}\par
00055 \par
00057         {\cf17 const} std::string screenName (){\cf17  const}\par
00058 {\cf17                             }\{ {\cf19 return} (_screenName); \}\par
00059         {\cf17 const} {\cf18 unsigned} {\cf18 int} screenColumns (){\cf17  const}\par
00060 {\cf17                             }\{ {\cf19 return} (_screenColumns); \}\par
00061         {\cf17 const} {\cf18 unsigned} {\cf18 int} screenRows (){\cf17  const}\par
00062 {\cf17                             }\{ {\cf19 return} (_screenRows); \}\par
00063         {\cf17 const} {\cf18 unsigned} {\cf18 int} visibilityFactor (){\cf17  const}\par
00064 {\cf17                             }\{ {\cf19 return} (_visibilityFactor); \}\par
00065         {\cf17 const} {\cf18 double} hertzs (){\cf17  const}\par
00066 {\cf17                             }\{ {\cf19 return} (_hertzs); \}\par
00067 \par
00068         {\cf17 virtual} {\cf18 bool} initialize (){\cf17  override}\par
00069 {\cf17                             }\{ {\cf19 return} ({\cf17 true}); \}\par
00070 \par
00072         {\cf17 virtual} {\cf18 bool} simulate () {\cf17 override};\par
00073 \par
00074         {\cf17 protected}:\par
00075         {\cf17 const} std::string _screenName;\par
00076         {\cf17 const} {\cf18 unsigned} {\cf18 int} _screenColumns;\par
00077         {\cf17 const} {\cf18 unsigned} {\cf18 int} _screenRows;\par
00078         {\cf17 const} {\cf18 unsigned} {\cf18 int} _visibilityFactor;\par
00079         {\cf17 const} {\cf18 double} _hertzs;\par
00080 \par
00081         {\cf17 protected}:\par
00085         GraphicalChip* _graphicalChip;\par
00086 \par
00087         {\cf20 // Implementation}\par
00088         SDL_Window* _window;\par
00089         SDL_Renderer* _renderer;\par
00090         SDL_Texture* _texture;\par
00091 \par
00093         {\cf18 double} _refreshRate;\par
00094     \};\par
00095 \}\par
00096 \par
00097 {\cf21 #endif}\par
00098   \par
00099 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/SFChip.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/SFChip.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/SFChip.hpp}
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::SpecialFunctionsChip}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SFChip.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/SFChip.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/SFChip.hpp}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_SFCHIP__}\par
00015 {\cf21 #define __C64_SFCHIP__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00021     {\cf17 class }SpecialFunctionsChip final : {\cf17 public} MCHEmul::Chip\par
00022     \{\par
00023         {\cf17 public}:\par
00024         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _ID = 1;\par
00025 \par
00026         SpecialFunctionsChip ()\par
00027             : MCHEmul::Chip (_ID, \par
00028                 \{ \{ {\cf22 "Name"}, {\cf22 "SFChip"} \},\par
00029                   \{ {\cf22 "Manufacturer"}, {\cf22 "Ignacio Cea"} \},\par
00030                   \{ {\cf22 "Year"}, {\cf22 "2022"} \} \}),\par
00031               _BasicRAM ({\cf17 nullptr}), _BasicROM ({\cf17 nullptr}), _KernelROM ({\cf17 nullptr}), _KernelRAM ({\cf17 nullptr}),\par
00032               _CharROM ({\cf17 nullptr}), _VICIIRegisters ({\cf17 nullptr}), _SIDRegisters ({\cf17 nullptr}), _ColorRAM ({\cf17 nullptr}),\par
00033               _CIA1Registers ({\cf17 nullptr}), _CIA2registers ({\cf17 nullptr}), _IO1Registers ({\cf17 nullptr}), _IO2registers ({\cf17 nullptr})\par
00034                             \{ \}\par
00035 \par
00036         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00037 \par
00038         {\cf17 virtual} {\cf18 bool} simulate (MCHEmul::CPU* cpu) {\cf17 override};\par
00039 \par
00040         {\cf17 private}:\par
00041         MCHEmul::PhisicalStorageSubset* _BasicROM;\par
00042         MCHEmul::PhisicalStorageSubset* _BasicRAM;\par
00043         MCHEmul::PhisicalStorageSubset* _KernelROM;\par
00044         MCHEmul::PhisicalStorageSubset* _KernelRAM;\par
00045         MCHEmul::PhisicalStorageSubset* _CharROM;\par
00046         MCHEmul::PhisicalStorageSubset* _VICIIRegisters;\par
00047         MCHEmul::PhisicalStorageSubset* _SIDRegisters;\par
00048         MCHEmul::PhisicalStorageSubset* _ColorRAM;\par
00049         MCHEmul::PhisicalStorageSubset* _CIA1Registers;\par
00050         MCHEmul::PhisicalStorageSubset* _CIA2registers;\par
00051         MCHEmul::PhisicalStorageSubset* _IO1Registers;\par
00052         MCHEmul::PhisicalStorageSubset* _IO2registers;\par
00053     \};\par
00054 \}\par
00055 \par
00056 {\cf21 #endif}\par
00057   \par
00058 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/UserPeripherals.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/UserPeripherals.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/UserPeripherals.hpp}
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::UserIOPeripheral}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::UserIONoPeripheral}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UserPeripherals.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/UserPeripherals.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/UserPeripherals.hpp}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __C64_USERPERIPHERIALS__}\par
00015 {\cf21 #define __C64_USERPERIPHERIALS__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }C64\par
00020 \{\par
00022     {\cf17 class }UserIOPeripheral : {\cf17 public} MCHEmul::IOPeripheral\par
00023     \{\par
00024         {\cf17 public}:\par
00025         UserIOPeripheral ({\cf18 int} {\cf18 id})\par
00026             : MCHEmul::IOPeripheral (id, \{ \})\par
00027                             \{ \}\par
00028     \};\par
00029 \par
00032     {\cf17 class }UserIONoPeripheral final : {\cf17 public} UserIOPeripheral\par
00033     \{\par
00034         {\cf17 public}:\par
00035         {\cf17 static} {\cf17 const} {\cf18 int} _ID = -1;\par
00036 \par
00037         UserIONoPeripheral ()\par
00038             : UserIOPeripheral (_ID)\par
00039                             \{ \}\par
00040 \par
00041         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00042 \par
00043         {\cf17 virtual} {\cf18 bool} simulate () {\cf17 override};\par
00044     \};\par
00045 \}\par
00046 \par
00047 {\cf21 #endif}\par
00048   \par
00049 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/UserPort.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/UserPort.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/UserPort.hpp}
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::UserIOPort}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UserPort.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/UserPort.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/UserPort.hpp}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00016 {\cf21 #ifndef __C64_USERPORT__}\par
00017 {\cf21 #define __C64_USERPORT__}\par
00018 \par
00019 {\cf21 #include <CORE/incs.hpp>}\par
00020 \par
00021 {\cf17 namespace }C64\par
00022 \{\par
00024     {\cf17 class }UserIOPort final : {\cf17 public} MCHEmul::IODevice\par
00025     \{\par
00026         {\cf17 public}:\par
00027         {\cf17 static} {\cf17 const} {\cf18 int} _ID = 3;\par
00028 \par
00029         UserIOPort ();\par
00030 \par
00033         {\cf17 virtual} {\cf18 void} addPeripheral (MCHEmul::IOPeripheral* p) {\cf17 override};\par
00034     \};\par
00035 \}\par
00036 \par
00037 {\cf21 #endif}\par
00038   \par
00039 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/VICII.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/VICII.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/VICII.hpp}
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <C64/VICIIRegisters.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::VICII}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::VICII::RasterData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::VICII::Raster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::VICII_NTSC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::VICII_PAL}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VICII.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/VICII.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/VICII.hpp}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00015 {\cf21 #ifndef __C64_VICII__}\par
00016 {\cf21 #define __C64_VICII__}\par
00017 \par
00018 {\cf21 #include <CORE/incs.hpp>}\par
00019 {\cf21 #include <C64/VICIIRegisters.hpp>}\par
00020 \par
00021 {\cf17 namespace }C64\par
00022 \{\par
00024     {\cf17 class }VICII : {\cf17 public} MCHEmul::GraphicalChip\par
00025     \{\par
00026         {\cf17 public}:\par
00028         {\cf17 class }RasterData\par
00029         \{\par
00030             {\cf17 public}:\par
00031             RasterData () = {\cf17 delete};\par
00032 \par
00033             RasterData (\par
00034                         {\cf18 unsigned} {\cf18 short} fp,      {\cf20 // First position}\par
00035                         {\cf18 unsigned} {\cf18 short} fvp,     {\cf20 // First Visible position}\par
00036                         {\cf18 unsigned} {\cf18 short} fdp,     {\cf20 // First Display position}\par
00037                         {\cf18 unsigned} {\cf18 short} ldp,     {\cf20 // Last Display Sync osition}\par
00038                         {\cf18 unsigned} {\cf18 short} lvp,     {\cf20 // Last Visible position}\par
00039                         {\cf18 unsigned} {\cf18 short} lp,      {\cf20 // Last position}\par
00040                         {\cf18 unsigned} {\cf18 short} mp,      {\cf20 // Maximum positions}\par
00041                         {\cf18 unsigned} {\cf18 short} pr1,     {\cf20 // Positions to reduce in the visible zone 1 & 2}\par
00042                         {\cf18 unsigned} {\cf18 short} pr2\par
00043                       );\par
00044 \par
00045             RasterData ({\cf17 const} RasterData&) = {\cf19 default};\par
00046 \par
00047             RasterData& operator = ({\cf17 const} RasterData&) = {\cf19 default};\par
00048 \par
00049             {\cf18 unsigned} {\cf18 short} currentPosition (){\cf17  const}\par
00050 {\cf17                             }\{ {\cf19 return} (_currentPosition); \}\par
00051             {\cf18 unsigned} {\cf18 short} currentPositionAtBase0 (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_currentPosition_0); \}\par
00053 \par
00054             {\cf18 bool} isInBlankZone (){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} ((_currentPosition_0 >= _firstPosition_0 && \par
00056                                             _currentPosition_0 < _firstVisiblePosition_0) ||\par
00057                                       (_currentPosition_0 > _lastVisiblePosition_0 && \par
00058                                             _currentPosition_0 <= _lastPosition_0)); \}\par
00059             {\cf18 bool} isInLastBlankZone (){\cf17  const}\par
00060 {\cf17                             }\{ {\cf19 return} (_currentPosition_0 > _lastVisiblePosition_0 && \par
00061                                       _currentPosition_0 <= _lastPosition_0); \}\par
00062 \par
00063             {\cf18 bool} isInVisibleZone (){\cf17  const }\par
00064 {\cf17                             }\{ {\cf19 return} ((_currentPosition_0 >= _firstVisiblePosition_0 && \par
00065                                        _currentPosition_0 <= _lastVisiblePosition_0)); \}\par
00066             {\cf18 unsigned} {\cf18 short} currentVisiblePosition () const {\cf20 // The }\par
00067                             \{ {\cf19 return} (_currentPosition_0 - _firstVisiblePosition_0); \}\par
00068             {\cf18 unsigned} {\cf18 short} visiblePositions (){\cf17  const}\par
00069 {\cf17                             }\{ {\cf19 return} (_lastVisiblePosition_0 - _firstVisiblePosition_0 + 1); \}\par
00070 \par
00072             {\cf18 bool} isInDisplayZone (){\cf17  const}\par
00073 {\cf17                             }\{ {\cf19 return} (_currentPosition_0 >= _originalFirstDisplayPosition_0 && \par
00074                                       _currentPosition_0 <= _originalLastDisplayPosition_0); \}\par
00075 \par
00077             {\cf18 unsigned} {\cf18 short} firstScreenPosition ({\cf18 bool} o = {\cf17 false}){\cf17  const}\par
00078 {\cf17                             }\{ {\cf19 return} ((o ? _originalFirstDisplayPosition_0 : _firstDisplayPosition_0) - _firstVisiblePosition_0); \}\par
00079             {\cf18 unsigned} {\cf18 short} lastScreenPosition ({\cf18 bool} o = {\cf17 false}){\cf17  const}\par
00080 {\cf17                             }\{ {\cf19 return} ((o ? _originalLastDisplayPosition_0 : _lastDisplayPosition_0) - _firstVisiblePosition_0); \}\par
00081             {\cf18 unsigned} {\cf18 short} currentScreenPosition (){\cf17  const}\par
00082 {\cf17                             }\{ {\cf19 return} (_currentPosition_0 - _firstVisiblePosition_0); \}\par
00083             {\cf18 unsigned} {\cf18 short} screenPositions (){\cf17  const}\par
00084 {\cf17                             }\{ {\cf19 return} (_lastDisplayPosition_0 - _firstDisplayPosition_0 + 1); \}\par
00085 \par
00088             {\cf18 bool} add ({\cf18 unsigned} {\cf18 short} i);\par
00089             {\cf18 bool} next ()\par
00090                             \{ {\cf19 return} (add (1)); \}\par
00091 \par
00093             {\cf18 void} reduceDisplayZone ({\cf18 bool} s);\par
00094             {\cf18 bool} isDisplayZoneReduced (){\cf17  const}\par
00095 {\cf17                             }\{ {\cf19 return} (_displayZoneReducted); \}\par
00096 \par
00097             {\cf18 void} initialize ()\par
00098                             \{ _currentPosition = _firstPosition; _currentPosition_0 = _firstPosition_0; \}\par
00099 \par
00100             {\cf17 protected}:\par
00102             {\cf18 unsigned} {\cf18 short} toBase0 ({\cf18 unsigned} {\cf18 short} m){\cf17  const}\par
00103 {\cf17                             }\{ {\cf18 int} t = (int) m - ({\cf18 int}) _firstPosition; \par
00104                               {\cf19 return} ((t < 0) ? ({\cf18 unsigned} short) t + _maxPositions : ({\cf18 unsigned} {\cf18 short}) t); \}\par
00105 \par
00106             {\cf17 protected}:\par
00107             {\cf17 const} {\cf18 unsigned} {\cf18 short} _firstPosition = 0; {\cf20 // Adjusted at construction time.}\par
00108             {\cf17 const} {\cf18 unsigned} {\cf18 short} _firstVisiblePosition = 0;\par
00109             {\cf18 unsigned} {\cf18 short} _firstDisplayPosition; {\cf20 // Both can be changed by the method reduceDisplayZone...}\par
00110             {\cf17 const} {\cf18 unsigned} {\cf18 short} _originalFirstDisplayPosition; {\cf20 // Before reducing or extending the area...}\par
00111             {\cf18 unsigned} {\cf18 short} _lastDisplayPosition;\par
00112             {\cf17 const} {\cf18 unsigned} {\cf18 short} _originalLastDisplayPosition; {\cf20 // Before reduucing or extending the area...}\par
00113             {\cf17 const} {\cf18 unsigned} {\cf18 short} _lastVisiblePosition = 0;\par
00114             {\cf17 const} {\cf18 unsigned} {\cf18 short} _lastPosition = 0;\par
00115             {\cf17 const} {\cf18 unsigned} {\cf18 short} _maxPositions = 0;\par
00116             {\cf17 const} {\cf18 unsigned} {\cf18 short} _positionsToReduce1 = 0;\par
00117             {\cf17 const} {\cf18 unsigned} {\cf18 short} _positionsToReduce2 = 0;\par
00118 \par
00119             {\cf20 // Implementation}\par
00120             {\cf20 // To speeed up calculus...}\par
00121             {\cf18 unsigned} {\cf18 short} _firstPosition_0; \par
00122             {\cf18 unsigned} {\cf18 short} _firstVisiblePosition_0;\par
00123             {\cf18 unsigned} {\cf18 short} _firstDisplayPosition_0; \par
00124             {\cf18 unsigned} {\cf18 short} _originalFirstDisplayPosition_0; \par
00125             {\cf18 unsigned} {\cf18 short} _lastDisplayPosition_0;\par
00126             {\cf18 unsigned} {\cf18 short} _originalLastDisplayPosition_0; \par
00127             {\cf18 unsigned} {\cf18 short} _lastVisiblePosition_0;\par
00128             {\cf18 unsigned} {\cf18 short} _lastPosition_0;\par
00129 \par
00130             {\cf20 // Implementation}\par
00131             {\cf18 unsigned} {\cf18 short} _currentPosition;\par
00132             {\cf18 unsigned} {\cf18 short} _currentPosition_0;\par
00133             {\cf18 bool} _displayZoneReducted;\par
00134         \};\par
00135 \par
00138         {\cf17 class }Raster final\par
00139         \{\par
00140             {\cf17 public}:\par
00141             {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 short} _FIRSTBADLINE   = 0x33;\par
00142             {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 short} _LASTBADLINE    = 0xfa;\par
00143 \par
00144             Raster () = {\cf17 delete};\par
00145 \par
00146             Raster ({\cf17 const} Raster&) = {\cf19 default};\par
00147 \par
00148             Raster& operator = ({\cf17 const} Raster&) = {\cf19 default};\par
00149 \par
00150             Raster ({\cf17 const} RasterData& vD, {\cf17 const} RasterData& hD)\par
00151                 : _vRasterData (vD), _hRasterData (hD)\par
00152                             \{ \}\par
00153 \par
00154             {\cf17 const} RasterData& vData (){\cf17  const}\par
00155 {\cf17                             }\{ {\cf19 return} (_vRasterData); \}\par
00156             RasterData& vData ()\par
00157                             \{ {\cf19 return} (_vRasterData); \}\par
00158             {\cf17 const} RasterData& hData (){\cf17  const}\par
00159 {\cf17                             }\{ {\cf19 return} (_hRasterData); \}\par
00160             RasterData& hData ()\par
00161                             \{ {\cf19 return} (_hRasterData); \}\par
00162 \par
00163             {\cf18 unsigned} {\cf18 short} currentLine (){\cf17  const}\par
00164 {\cf17                             }\{ {\cf19 return} (_vRasterData.currentPosition ()); \}\par
00165             {\cf18 unsigned} {\cf18 short} currentLineAtBase0 (){\cf17  const}\par
00166 {\cf17                             }\{ {\cf19 return} (_vRasterData.currentPositionAtBase0 ()); \}\par
00167             {\cf18 unsigned} {\cf18 short} currentColumn (){\cf17  const}\par
00168 {\cf17                             }\{ {\cf19 return} (_hRasterData.currentPosition ()); \}\par
00169             {\cf18 unsigned} {\cf18 short} currentColumnAtBase0 (){\cf17  const}\par
00170 {\cf17                             }\{ {\cf19 return} (_hRasterData.currentPositionAtBase0 ()); \}\par
00171 \par
00174             {\cf18 bool} isInPotentialBadLine (){\cf17  const}\par
00175 {\cf17                             }\{ {\cf19 return} (_vRasterData.currentPosition () >= _FIRSTBADLINE && \par
00176                                       _vRasterData.currentPosition () <= _LASTBADLINE); \}\par
00177 \par
00178             {\cf18 bool} isInVBlank (){\cf17  const}\par
00179 {\cf17                             }\{ {\cf19 return} (_vRasterData.isInBlankZone ()); \}\par
00180             {\cf18 bool} isInLastVBlank (){\cf17  const}\par
00181 {\cf17                             }\{ {\cf19 return} (_vRasterData.isInLastBlankZone ()); \}\par
00182 \par
00183             {\cf18 bool} isInVisibleZone (){\cf17  const}\par
00184 {\cf17                             }\{ {\cf19 return} (_vRasterData.isInVisibleZone () && _hRasterData.isInVisibleZone ()); \}\par
00185             {\cf18 void} currentVisiblePosition ({\cf18 unsigned} {\cf18 short}& x, {\cf18 unsigned} {\cf18 short}& y){\cf17  const}\par
00186 {\cf17                             }\{ x = _hRasterData.currentVisiblePosition (); y = _vRasterData.currentVisiblePosition (); \}\par
00187 \par
00188             {\cf18 bool} isInDisplayZone (){\cf17  const}\par
00189 {\cf17                             }\{ {\cf19 return} (_vRasterData.isInDisplayZone () && _hRasterData.isInDisplayZone ()); \}\par
00190 \par
00191             {\cf18 void} firstScreenPosition ({\cf18 unsigned} {\cf18 short}& x, {\cf18 unsigned} {\cf18 short}& y, {\cf18 bool} o = {\cf17 false}){\cf17  const}\par
00192 {\cf17                             }\{ x = _hRasterData.firstScreenPosition (o); y = _vRasterData.firstScreenPosition (o); \}\par
00193             {\cf18 void} currentScreenPosition ({\cf18 unsigned} {\cf18 short}& x, {\cf18 unsigned} {\cf18 short}& y){\cf17  const}\par
00194 {\cf17                             }\{ x = _hRasterData.currentScreenPosition (); y = _vRasterData.currentScreenPosition (); \}\par
00195             {\cf18 void} screenPositions ({\cf18 unsigned} {\cf18 short}& x1, {\cf18 unsigned} {\cf18 short}& y1, {\cf18 unsigned} {\cf18 short}& x2, {\cf18 unsigned} {\cf18 short}& y2)\par
00196                             \{ x1 = _hRasterData.firstScreenPosition (); y1 = _vRasterData.firstScreenPosition ();\par
00197                               x2 = _hRasterData.lastScreenPosition (); y2 = _vRasterData.lastScreenPosition (); \}\par
00198 \par
00199             {\cf18 unsigned} {\cf18 short} visibleLines (){\cf17  const}\par
00200 {\cf17                             }\{ {\cf19 return} (_vRasterData.visiblePositions ()); \}\par
00201             {\cf18 unsigned} {\cf18 short} visibleColumns (){\cf17  const}\par
00202 {\cf17                             }\{ {\cf19 return} (_hRasterData.visiblePositions ()); \}\par
00203 \par
00204             {\cf18 void} reduceDisplayZone ({\cf18 bool} v, {\cf18 bool} h)\par
00205                             \{ _vRasterData.reduceDisplayZone (v); _hRasterData.reduceDisplayZone (h); \}\par
00206             \par
00209             {\cf18 bool} moveCycles ({\cf18 unsigned} {\cf18 short} nC)\par
00210                             \{ {\cf18 bool} result = _hRasterData.add (nC * 8 );\par
00211                               {\cf19 if} (result) _vRasterData.next (); \par
00212                               {\cf19 return} (result); \}\par
00213 \par
00214             {\cf18 void} initialize ()\par
00215                             \{ _vRasterData.initialize (); _hRasterData.initialize (); \}\par
00216 \par
00217             {\cf17 private}:\par
00218             RasterData _vRasterData, _hRasterData;\par
00219         \};\par
00220 \par
00221         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _ID = 4;\par
00222 \par
00224         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 short} _GRAPHMAXCHARLINES      = 25; {\cf20 // Not taking into account reductions in the size}\par
00225         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 short} _GRAPHMAXCHARCOLUMNS    = 40;\par
00226         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 short} _GRAPHMAXBITMAPCOLUMNS  = 320; {\cf20 // Not taking into account double coulors}\par
00227         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 short} _GRAPHMAXBITMAPROWS     = 200;\par
00228 \par
00230         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _CPUCYCLESWHENREADGRAPHS  = 40;\par
00231 \par
00233         {\cf17 static} {\cf17 const} MCHEmul::Address _COLORMEMORY;\par
00234 \par
00236         VICII ({\cf17 const} RasterData& vd, {\cf17 const} RasterData& hd, {\cf17 const} MCHEmul::Attributes& attrs = \{ \});\par
00237 \par
00238         ~VICII ();\par
00239 \par
00241         {\cf18 unsigned} {\cf18 short} bank (){\cf17  const}\par
00242 {\cf17                             }\{ {\cf19 return} (_VICIIRegisters -> bank ()); \}\par
00243         {\cf18 void} setBank ({\cf18 unsigned} {\cf18 char} bk)\par
00244                             \{ _VICIIRegisters -> setBank (bk); \}\par
00245 \par
00246         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00247 \par
00248         {\cf17 virtual} {\cf18 bool} simulate (MCHEmul::CPU* cpu) {\cf17 override};\par
00249 \par
00250         {\cf17 private}:\par
00252         {\cf17 struct }DrawContext\par
00253         \{\par
00254             {\cf18 unsigned} {\cf18 short} _ICD;    {\cf20 // Initial Column of the Display (Not taken into account reductions in size).}\par
00255             {\cf18 unsigned} {\cf18 short} _ICS;    {\cf20 // Initial Column Screen (Screen = Display with reductions in the size considered).}\par
00256             {\cf18 unsigned} {\cf18 short} _LCD;    {\cf20 // Last Column of the Display }\par
00257             {\cf18 unsigned} {\cf18 short} _LCS;    {\cf20 // Last Column of the Screen}\par
00258             {\cf18 unsigned} {\cf18 short} _SC;     {\cf20 // Scroll X}\par
00259             {\cf18 unsigned} {\cf18 short} _RC;     {\cf20 // Raster X (from the beginning of the visible zone)}\par
00260             {\cf18 unsigned} {\cf18 short} _RCA;    {\cf20 // Raster X adjusted (Moves 8 by 8, so = Raster X >> 3 << 3)}\par
00261             {\cf18 unsigned} {\cf18 short} _IRD;    {\cf20 // Initial Row Display}\par
00262             {\cf18 unsigned} {\cf18 short} _IRS;    {\cf20 // Initial Row Screen}\par
00263             {\cf18 unsigned} {\cf18 short} _LRD;    {\cf20 // Last Row of the Display }\par
00264             {\cf18 unsigned} {\cf18 short} _LRS;    {\cf20 // Last Row of the Screen}\par
00265             {\cf18 unsigned} {\cf18 short} _SR;     {\cf20 // Scroll Y}\par
00266             {\cf18 unsigned} {\cf18 short} _RR;     {\cf20 // Raster Y (Moves 1 by 1. No adjusted neadd)}\par
00267         \};\par
00268 \par
00270         {\cf18 void} readGraphicsInfo ();\par
00271 \par
00273         {\cf18 void} drawGraphics ({\cf17 const} DrawContext& dC);\par
00274         {\cf18 void} drawSprites ({\cf17 const} DrawContext& dC);\par
00275 \par
00278         {\cf17 virtual} MCHEmul::ScreenMemory* createScreenMemory () {\cf17 override};\par
00279 \par
00280         {\cf20 // Read screen data}\par
00282 {\cf20 }        MCHEmul::UBytes readCharCodeDataAt ({\cf18 unsigned} {\cf18 short} l){\cf17  const}\par
00283 {\cf17                             }\{ {\cf19 return} (memoryRef () -> values (_VICIIRegisters -> screenMemory () + \par
00284                                 ({\cf18 size_t}) (l * _GRAPHMAXCHARCOLUMNS), _GRAPHMAXCHARCOLUMNS)); \}\par
00286         MCHEmul::UBytes readCharDataFor ({\cf17 const} MCHEmul::UBytes& chrs) {\cf17 const};\par
00290         MCHEmul::UBytes readBitmapDataAt ({\cf18 unsigned} {\cf18 short} l) {\cf17 const};\par
00293         MCHEmul::UBytes readColorDataAt ({\cf18 unsigned} {\cf18 short} l){\cf17  const}\par
00294 {\cf17                             }\{ {\cf19 return} (memoryRef () -> values (_COLORMEMORY + \par
00295                                 ({\cf18 size_t}) (l * _GRAPHMAXCHARCOLUMNS), _GRAPHMAXCHARCOLUMNS)); \}\par
00297         MCHEmul::UBytes readSpriteDataAt ({\cf18 unsigned} {\cf18 short} l) {\cf17 const};\par
00298 \par
00299         {\cf20 // Draw the graphics in detail...}\par
00301 {\cf20 }        {\cf18 void} drawMonoColorBytes ({\cf18 int} cb, {\cf18 size_t} r, \par
00302             {\cf17 const} MCHEmul::UBytes& bt, {\cf17 const} MCHEmul::UBytes& clr, {\cf17 const} DrawContext& dC);\par
00304         {\cf18 void} drawMultiColorBytes ({\cf18 int} cb, {\cf18 size_t} r, \par
00305             {\cf17 const} MCHEmul::UBytes& bt, {\cf17 const} MCHEmul::UBytes& clr, {\cf17 const} DrawContext& dC);\par
00306 \par
00307         {\cf17 private}:\par
00309         C64::VICIIRegisters* _VICIIRegisters;\par
00311         Raster _raster;\par
00312 \par
00313         {\cf20 // Implementation}\par
00316 {\cf20 }        {\cf18 unsigned} {\cf18 int} _lastCPUCycles;\par
00318         SDL_PixelFormat* _format;\par
00320         MCHEmul::UBytes _graphicsCharCodeData;\par
00321         MCHEmul::UBytes _graphicsCharData;\par
00322         MCHEmul::UBytes _graphicsBitmapData;\par
00323         MCHEmul::UBytes _graphicsColorData;\par
00325         {\cf18 bool} _isNewRasterLine; \par
00327         {\cf18 bool} _lastVBlankEntered;\par
00328     \};\par
00329 \par
00331     {\cf17 class }VICII_NTSC final : {\cf17 public} VICII\par
00332     \{\par
00333         {\cf17 public}:\par
00334         {\cf17 static} {\cf17 const} RasterData _VRASTERDATA;\par
00335         {\cf17 static} {\cf17 const} RasterData _HRASTERDATA;\par
00336 \par
00337         VICII_NTSC ();\par
00338     \};\par
00339 \par
00341     {\cf17 class }VICII_PAL final : {\cf17 public} VICII\par
00342     \{\par
00343         {\cf17 public}:\par
00344         {\cf17 static} {\cf17 const} RasterData _VRASTERDATA;\par
00345         {\cf17 static} {\cf17 const} RasterData _HRASTERDATA;\par
00346 \par
00347         VICII_PAL ();\par
00348     \};\par
00349 \}\par
00350 \par
00351 {\cf21 #endif}\par
00352   \par
00353 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/C64/VICIIRegisters.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/VICIIRegisters.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/VICIIRegisters.hpp}
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b C64::VICIIRegisters}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b C64}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VICIIRegisters.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/C64/VICIIRegisters.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/C64/VICIIRegisters.hpp}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00015 {\cf21 #ifndef __C64_VICIIREGISTERS__}\par
00016 {\cf21 #define __C64_VICIIREGISTERS__}\par
00017 \par
00018 {\cf21 #include <CORE/incs.hpp>}\par
00019 \par
00020 {\cf17 namespace }C64\par
00021 \{\par
00025     {\cf17 class }VICIIRegisters final : {\cf17 public} MCHEmul::PhisicalStorageSubset\par
00026     \{\par
00027         {\cf17 public}:\par
00028         {\cf17 enum class} GraphicMode\par
00029         \{\par
00030             _CHARMODE = 0,\par
00031             _MULTICOLORCHARMODE,\par
00032             _BITMAPMODE,\par
00033             _MULTICOLORBITMAPMODE,\par
00034             _EXTENDEDBACKGROUNDMODE,\par
00035             _ILLEGALMODE\par
00036         \};\par
00037 \par
00038         VICIIRegisters ({\cf18 int} {\cf18 id}, MCHEmul::PhisicalStorage* ps)\par
00039             : MCHEmul::PhisicalStorageSubset (id, ps, 0xd000, MCHEmul::Address (\{ 0x00, 0xd0 \}, {\cf17 false}), 0x0400),\par
00040               _lastValueRead (MCHEmul::PhisicalStorage::_DEFAULTVALUE),\par
00041               _backgroundColor (4, 0x00),\par
00042               _spriteXCoord (8, 0x0000), _spriteYCoord (8, 0x0000),\par
00043               _spriteColor (8, 0x0000),\par
00044               _spriteSharedColor (2, 0x0000), _spriteMulticolor (8, {\cf17 false}),\par
00045               _spriteEnabled (8, {\cf17 false}), \par
00046               _spriteDoubleWidth (8, {\cf17 false}), _spriteDoubleHeight (8, {\cf17 false}),\par
00047               _spriteToForegroundPriority (8, {\cf17 false})\par
00048               {\cf20 // At this point the rest internal variables will have random values...}\par
00049               {\cf20 // The vector are initialized just to given them a default size!}\par
00050                             \{ initializeInternalValues (); \}\par
00051 \par
00052         {\cf18 unsigned} {\cf18 char} borderColor (){\cf17  const}\par
00053 {\cf17                             }\{ {\cf19 return} (_borderColor); \}\par
00054         {\cf18 unsigned} {\cf18 char} backgroundColor ({\cf18 size_t} p = 0){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} ( _backgroundColor [p]); \}\par
00056 \par
00057         {\cf18 unsigned} {\cf18 short} spriteXCoord ({\cf18 size_t} p){\cf17  const}\par
00058 {\cf17                             }\{ {\cf19 return} (_spriteXCoord [p]); \}\par
00059         {\cf18 unsigned} {\cf18 char} spriteYCoord ({\cf18 size_t} p){\cf17  const}\par
00060 {\cf17                             }\{ {\cf19 return} (_spriteYCoord [p]); \}\par
00061         {\cf18 unsigned} {\cf18 char} spriteColor ({\cf18 size_t} p){\cf17  const}\par
00062 {\cf17                             }\{ {\cf19 return} (_spriteColor [p]); \}\par
00063         {\cf18 unsigned} {\cf18 char} spriteSharedColor ({\cf18 size_t} p){\cf17  const}\par
00064 {\cf17                             }\{ {\cf19 return} (_spriteSharedColor [p]); \}\par
00065         {\cf18 bool} spriteEnable ({\cf18 size_t} p){\cf17  const}\par
00066 {\cf17                             }\{ {\cf19 return} (_spriteEnabled [p]); \}\par
00067         {\cf18 bool} spriteDoubleWidth ({\cf18 size_t} p){\cf17  const}\par
00068 {\cf17                             }\{ {\cf19 return} (_spriteDoubleWidth [p]); \}\par
00069         {\cf18 bool} spriteDoubleHeight ({\cf18 size_t} p){\cf17  const}\par
00070 {\cf17                             }\{ {\cf19 return} (_spriteDoubleHeight [p]); \}\par
00071         {\cf18 bool} spriteToForegroundPriority ({\cf18 size_t} p){\cf17  const}\par
00072 {\cf17                             }\{ {\cf19 return} (_spriteToForegroundPriority [p]); \}\par
00073         \par
00074         {\cf18 unsigned} {\cf18 char} verticalScrollPosition (){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_verticalScrollPosition); \}\par
00076         {\cf18 unsigned} {\cf18 char} horizontalScrollPosition (){\cf17  const}\par
00077 {\cf17                             }\{ {\cf19 return} (_horizontalScrollPosition); \}\par
00078 \par
00079         {\cf18 bool} textDisplay25RowsActive (){\cf17  const}\par
00080 {\cf17                             }\{ {\cf19 return} (_textDisplay25RowsActive); \}\par
00081         {\cf18 bool} textDisplay40ColumnsActive (){\cf17  const}\par
00082 {\cf17                             }\{ {\cf19 return} (_textDisplay40ColumnsActive); \}\par
00083         {\cf18 bool} screenSameColorBorderActive (){\cf17  const}\par
00084 {\cf17                             }\{ {\cf19 return} (_screenSameColorBorderActive); \}\par
00085         {\cf18 bool} videoResetActive (){\cf17  const}\par
00086 {\cf17                             }\{ {\cf19 return} (_videoResetActive); \}\par
00087 \par
00088         {\cf18 bool} graphicBitModeActive (){\cf17  const}\par
00089 {\cf17                             }\{ {\cf19 return} (_graphicBitModeActive); \}\par
00090         {\cf18 bool} graphicExtendedColorTextModeActive (){\cf17  const}\par
00091 {\cf17                             }\{ {\cf19 return} (_graphicExtendedColorTextModeActive); \}\par
00092         {\cf18 bool} graphicMulticolorTextModeActive (){\cf17  const}\par
00093 {\cf17                             }\{ {\cf19 return} (_graphicMulticolorTextModeActive); \}\par
00094         GraphicMode graphicModeActive (){\cf17  const}\par
00095 {\cf17                             }\{ {\cf19 return} (_graphicModeActive); \}\par
00096 \par
00097         {\cf18 bool} rasterIRQActive (){\cf17  const}\par
00098 {\cf17                             }\{ {\cf19 return} (_rasterIRQActive); \}\par
00099         {\cf18 bool} spriteCollisionWithDataIRQActive (){\cf17  const}\par
00100 {\cf17                             }\{ {\cf19 return} (_spriteCollisionWithDataIRQActive); \}\par
00101         {\cf18 bool} spriteCollisionsIRQActive (){\cf17  const}\par
00102 {\cf17                             }\{ {\cf19 return} (_spriteCollisionsIRQActive); \}\par
00103         {\cf18 bool} lightPenIRQActive (){\cf17  const}\par
00104 {\cf17                             }\{ {\cf19 return} (_lightPenIRQActive); \}\par
00105 \par
00106         {\cf18 unsigned} {\cf18 short} IRQRasterLineAt (){\cf17  const}\par
00107 {\cf17                             }\{ {\cf19 return} (_IRQRasterLineAt);  \}\par
00108 \par
00109         {\cf17 const} MCHEmul::Address charDataMemory (){\cf17  const}\par
00110 {\cf17                             }\{ {\cf19 return} (_charDataMemory + \par
00111                                 ({\cf18 size_t}) (0x4000 {\cf20 /* 16284 = 16k */} * _bank) ); \}\par
00112         {\cf17 const} MCHEmul::Address screenMemory (){\cf17  const }\par
00113 {\cf17                             }\{ {\cf19 return} (_screenMemory + ({\cf18 size_t}) (0x4000 * _bank)); \}\par
00114         {\cf17 const} MCHEmul::Address bitmapMemory (){\cf17  const }\par
00115 {\cf17                             }\{ {\cf19 return} (_bitmapMemory + ({\cf18 size_t}) (0x4000 * _bank)); \}\par
00116 \par
00117         {\cf20 // Managed from VICII Chip Emulator}\par
00118         {\cf20 // The VICII chip also uses this object as a temporary storage}\par
00119         {\cf18 unsigned} {\cf18 short} currentRasterLine (){\cf17  const}\par
00120 {\cf17                             }\{ {\cf19 return} (_currentRasterLine); \}\par
00121         {\cf18 void} setCurrentRasterLine ({\cf18 unsigned} {\cf18 short} rL)\par
00122                             \{ _currentRasterLine = rL; \}\par
00123 \par
00124         {\cf18 unsigned} {\cf18 short} currentLightPenHorizontalPosition (){\cf17  const}\par
00125 {\cf17                             }\{ {\cf19 return} (_currentLightPenHorizontalPosition); \}\par
00126         {\cf18 unsigned} {\cf18 short} currentLightPenVerticalPosition (){\cf17  const}\par
00127 {\cf17                             }\{ {\cf19 return} (_currentLightPenVerticalPosition); \}\par
00128         {\cf18 void} setCurrentLightPenPosition ({\cf18 unsigned} {\cf18 char} x, {\cf18 unsigned} {\cf18 char} y)\par
00129                             \{ _currentLightPenHorizontalPosition = x; _currentLightPenVerticalPosition = y; \}\par
00130 \par
00131         {\cf18 bool} rasterAtIRQLine (){\cf17  const}\par
00132 {\cf17                             }\{ {\cf19 return} (_rasterAtIRQLine); \}\par
00133         {\cf18 void} setRasterAtLine ({\cf18 bool} rL)\par
00134                             \{ _rasterAtIRQLine = rL; \}\par
00135         {\cf18 bool} spritesCollisionWithDataHappened (){\cf17  const}\par
00136 {\cf17                             }\{ {\cf19 return} (_spritesCollisionWithDataHappened); \}\par
00137         {\cf18 void} setSpritesCollisionWithData ({\cf18 bool} c)\par
00138                             \{ _spritesCollisionWithDataHappened = c; \}\par
00139         {\cf18 bool} spriteCollisionWithDataHappened ({\cf18 size_t} p){\cf17  const}\par
00140 {\cf17                             }\{ {\cf19 return} (_spriteCollisionWithDataHappened [p]); \}\par
00141         {\cf18 void} setSpriteCollisionWithDataHappened ({\cf18 size_t} p, {\cf18 bool} c)\par
00142                             \{ _spriteCollisionWithDataHappened [p] = c; \}\par
00143         {\cf18 bool} spritesCollisionHappened (){\cf17  const}\par
00144 {\cf17                             }\{ {\cf19 return} (_spritesCollisionHappened); \}\par
00145         {\cf18 void} setSpritesCollision ({\cf18 bool} c)\par
00146                             \{ _spritesCollisionHappened = c; \}\par
00147         {\cf18 bool} spriteCollisionHappened ({\cf18 size_t} p){\cf17  const}\par
00148 {\cf17                             }\{ {\cf19 return} (_spriteCollisionHappened [p]); \}\par
00149         {\cf18 void} setSpriteCollision ({\cf18 size_t} p, {\cf18 bool} c)\par
00150                             \{ _spriteCollisionHappened [p] = c; \}\par
00151         {\cf18 bool} lightPenOnScreenHappened (){\cf17  const}\par
00152 {\cf17                             }\{ {\cf19 return} (_lightPenOnScreenHappened); \}\par
00153         {\cf18 void} setLightPenOnScreen ({\cf18 bool} l)\par
00154                             \{ _lightPenOnScreenHappened = l; \}\par
00155         {\cf18 bool} vicIItoGenerateIRQ (){\cf17  const}\par
00156 {\cf17                             }\{ {\cf19 return} (_vicIItoGenerateIRQ); \}\par
00157         {\cf18 void} setVicIItoGenerateIRQ ({\cf18 bool} v)\par
00158                             \{ _vicIItoGenerateIRQ = v; \}\par
00159 \par
00160         {\cf18 unsigned} {\cf18 char} bank (){\cf17  const}\par
00161 {\cf17                             }\{ {\cf19 return} (_bank); \}\par
00162         {\cf18 void} setBank ({\cf18 unsigned} {\cf18 char} bk)\par
00163                             \{ {\cf19 if} (bk == 0 || bk == 1 || bk == 2 || bk == 3) _bank = bk; \}\par
00164         \par
00165         {\cf17 virtual} {\cf18 void} initialize () {\cf17 override};\par
00166 \par
00167         {\cf17 private}:\par
00168         {\cf17 virtual} {\cf18 void} setValue ({\cf18 size_t} p, {\cf17 const} MCHEmul::UByte& v) {\cf17 override};\par
00169         {\cf17 virtual} {\cf17 const} MCHEmul::UByte& readValue ({\cf18 size_t} p) {\cf17 const override};\par
00170 \par
00171         {\cf20 // Implementation}\par
00173 {\cf20 }        {\cf18 void} initializeInternalValues ();\par
00175         {\cf18 void} setGraphicModeActive ();\par
00176 \par
00177         {\cf17 private}:\par
00178         {\cf20 // The VICII registers}\par
00180 {\cf20 }        {\cf18 unsigned} {\cf18 char} _borderColor;\par
00181         std::vector <unsigned char> _backgroundColor;\par
00183         std::vector <unsigned short> _spriteXCoord; \par
00184         std::vector <unsigned char> _spriteYCoord;\par
00185         std::vector <unsigned char> _spriteColor;\par
00186         std::vector <unsigned char> _spriteSharedColor;\par
00187         std::vector <bool> _spriteMulticolor;\par
00188         std::vector <bool> _spriteEnabled;\par
00189         std::vector <bool> _spriteDoubleWidth, _spriteDoubleHeight;\par
00190         std::vector <bool> _spriteToForegroundPriority;\par
00192         {\cf18 unsigned} {\cf18 char} _verticalScrollPosition, _horizontalScrollPosition;\par
00194         {\cf18 bool} _textDisplay25RowsActive, _textDisplay40ColumnsActive;\par
00195         {\cf18 bool} _screenSameColorBorderActive;\par
00196         {\cf18 bool} _videoResetActive;\par
00198         {\cf18 bool} _graphicBitModeActive;\par
00199         {\cf18 bool} _graphicExtendedColorTextModeActive;\par
00200         {\cf18 bool} _graphicMulticolorTextModeActive;\par
00201         GraphicMode _graphicModeActive;\par
00203         {\cf18 bool} _rasterIRQActive;\par
00204         {\cf18 bool} _spriteCollisionWithDataIRQActive;\par
00205         {\cf18 bool} _spriteCollisionsIRQActive;\par
00206         {\cf18 bool} _lightPenIRQActive;\par
00208         {\cf18 unsigned} {\cf18 short} _IRQRasterLineAt; {\cf20 // To define where to launch the IRQ. When reading therre is other variable...}\par
00210 {\cf20 }        MCHEmul::Address _charDataMemory; {\cf20 // Info about the characters (the address with in the first 16k)}\par
00211         MCHEmul::Address _screenMemory; {\cf20 // Where the characters to draw are (The address within the first 16k)}\par
00212         MCHEmul::Address _bitmapMemory; {\cf20 // Where the bitmap to draw is (The address within the first 16k)}\par
00213 \par
00214         {\cf20 // Some of this variables are set by the emulation of the VICII}\par
00215         {\cf20 // The VICII chip also uses this object as a temporary storage}\par
00216         {\cf18 unsigned} {\cf18 short} _currentRasterLine;\par
00217         {\cf18 unsigned} {\cf18 short} _currentLightPenHorizontalPosition, _currentLightPenVerticalPosition;\par
00218         {\cf18 bool} _rasterAtIRQLine;\par
00219         {\cf18 bool} _spritesCollisionWithDataHappened; \par
00220         {\cf17 mutable} std::vector <bool> _spriteCollisionWithDataHappened; {\cf20 // Are modified when reading...}\par
00221         {\cf18 bool} _spritesCollisionHappened; \par
00222         {\cf17 mutable} std::vector <bool> _spriteCollisionHappened;\par
00223         {\cf18 bool} _lightPenOnScreenHappened;\par
00224         {\cf18 bool} _vicIItoGenerateIRQ;\par
00225 \par
00229         {\cf18 unsigned} {\cf18 char} _bank; \par
00230 \par
00231         {\cf20 // Implementation}\par
00232         {\cf17 mutable} MCHEmul::UByte _lastValueRead;\par
00233     \};\par
00234 \}\par
00235 \par
00236 {\cf21 #endif}\par
00237   \par
00238 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/Channel.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/Channel.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/Channel.hpp}
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <COMMS/IPAddress.hpp>}\par
{\f2 #include <COMMS/Message.hpp>}\par
{\f2 #include <RakPeerInterface.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::PeerCommunicationChannel}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Channel.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/Channel.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/Channel.hpp}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_COMMCHANNEL__}\par
00015 {\cf21 #define __MCHEMUL_COMMCHANNEL__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <COMMS/IPAddress.hpp>}\par
00019 {\cf21 #include <COMMS/Message.hpp>}\par
00020 {\cf21 #include <RakPeerInterface.h>}\par
00021 \par
00022 {\cf17 namespace }MCHEmul\par
00023 \{\par
00028     {\cf17 class }PeerCommunicationChannel\par
00029     \{\par
00030         {\cf17 public}:\par
00037         PeerCommunicationChannel ({\cf18 unsigned} {\cf18 short} p, {\cf18 unsigned} {\cf18 int} nC, {\cf17 const} IPAddress& a = IPAddress ());\par
00038 \par
00039         PeerCommunicationChannel ({\cf17 const} PeerCommunicationChannel&) = {\cf17 delete};\par
00040 \par
00041         PeerCommunicationChannel& operator = ({\cf17 const} PeerCommunicationChannel&) = {\cf17 delete};\par
00042 \par
00043         {\cf17 virtual} ~PeerCommunicationChannel ();\par
00044 \par
00045         {\cf20 // Channel data...}\par
00046         {\cf18 unsigned} {\cf18 short} listenAtPort (){\cf17  const}\par
00047 {\cf17                             }\{ {\cf19 return} (_listenAtPort); \}\par
00048         {\cf18 unsigned} {\cf18 short} simulatenousConnections (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_simultaneousConnections); \}\par
00050         {\cf17 const} IPAddress& connectedTo () const {\cf20 // IPAddress () when none...}\par
00051                             \{ {\cf19 return} (_connectedTo); \}\par
00052 \par
00053         {\cf20 // Mamanging the Status of the channel}\par
00054         {\cf18 bool} initialize ();\par
00055         {\cf18 bool} isChannelInitiated ()\par
00056                             \{ {\cf19 return} (_channelInitialized); \}\par
00057         {\cf18 bool} isChannelConnected ()\par
00058                             \{ {\cf19 return} (_channelConnected); \}\par
00059         {\cf18 bool} finalize ();\par
00060 \par
00061         {\cf20 // Managing the communication}\par
00065 {\cf20 }        {\cf18 bool} receive (std::string& str, IPAddress& from);\par
00069         {\cf18 bool} send ({\cf17 const} std::string& str, {\cf17 const} IPAddress& to);\par
00070         {\cf18 bool} send ({\cf17 const} CommunicationMessage& msg, {\cf17 const} IPAddress& to)\par
00071                             \{ {\cf19 return} (send (msg.toString (), to)); \}\par
00074         {\cf18 bool} send ({\cf17 const} std::string& str)\par
00075                             \{ {\cf19 return} (send (str, _connectedTo)); \}\par
00076         {\cf18 bool} send ({\cf17 const} CommunicationMessage& msg)\par
00077                             \{ {\cf19 return} (send (msg.toString ())); \}\par
00078 \par
00079         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00080 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00081 \par
00082         {\cf18 bool} operator ! (){\cf17  const}\par
00083 {\cf17                             }\{ {\cf19 return} (_lastError != MCHEmul::_NOERROR); \}\par
00084 \par
00085         {\cf17 protected}:\par
00086         {\cf17 const} {\cf18 unsigned} {\cf18 short} _listenAtPort; \par
00087         {\cf17 const} {\cf18 unsigned} {\cf18 short} _simultaneousConnections;\par
00088         {\cf17 const} IPAddress _connectedTo;\par
00089     \par
00090         {\cf20 // Implementation}\par
00091         RakNet::RakPeerInterface* _peer;\par
00092         {\cf17 mutable} {\cf18 bool} _channelInitialized;\par
00093         {\cf17 mutable} {\cf18 bool} _channelConnected;\par
00094         {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastError;\par
00095     \};\par
00096 \}\par
00097 \par
00098 {\cf21 #endif}\par
00099   \par
00100 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/IPAddress.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/IPAddress.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/IPAddress.hpp}
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::IPAddress}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IPAddress.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/IPAddress.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/IPAddress.hpp}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_IPADDRESS__}\par
00015 {\cf21 #define __MCHEMUL_IPADDRESS__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00022     {\cf17 class }IPAddress\par
00023     \{\par
00024         {\cf17 public}:\par
00025         IPAddress ()\par
00026             : _a (0), _b (0), _c (0), _d (0), _port (0), _error (true)\par
00027                         \{ \}\par
00028 \par
00029         IPAddress ({\cf18 unsigned} {\cf18 char} a, {\cf18 unsigned} {\cf18 char} b, {\cf18 unsigned} {\cf18 char} c, {\cf18 unsigned} {\cf18 char} d, {\cf18 unsigned} {\cf18 short} p)\par
00030             : _a (a), _b (b), _c (c), _d (d), _port (p), _error (false)\par
00031                         \{ assert (_a <= 0xff && _b <= 0xff && _c < 0xff && _port <= 0xfff); \}\par
00032 \par
00033         IPAddress ({\cf17 const} std::string& ip);\par
00034 \par
00035         IPAddress ({\cf17 const} IPAddress&) = {\cf19 default};\par
00036 \par
00037         IPAddress& operator = ({\cf17 const} IPAddress&) = {\cf19 default};\par
00038 \par
00040         {\cf18 unsigned} {\cf18 char} byte1 (){\cf17  const}\par
00041 {\cf17                         }\{ {\cf19 return} (_a); \}\par
00042         {\cf18 unsigned} {\cf18 char} byte2 (){\cf17  const}\par
00043 {\cf17                         }\{ {\cf19 return} (_b); \}\par
00044         {\cf18 unsigned} {\cf18 char} byte3 (){\cf17  const}\par
00045 {\cf17                         }\{ {\cf19 return} (_c); \}\par
00046         {\cf18 unsigned} {\cf18 char} byte4 (){\cf17  const}\par
00047 {\cf17                         }\{ {\cf19 return} (_d); \}\par
00048         {\cf18 unsigned} {\cf18 short} port (){\cf17  const}\par
00049 {\cf17                         }\{ {\cf19 return} (_port); \}\par
00050 \par
00051         std::string ipAsString (){\cf17  const}\par
00052 {\cf17                         }\{ {\cf19 return} (std::to_string (_a) + {\cf22 "."} + std::to_string (_b) + {\cf22 "."} + std::to_string (_c)); \}\par
00053         std::string asString (){\cf17  const}\par
00054 {\cf17                         }\{ {\cf19 return} (ipAsString () + {\cf22 ":"} + std::to_string (_port)); \}\par
00055 \par
00056         {\cf18 bool} error (){\cf17  const}\par
00057 {\cf17                         }\{ {\cf19 return} (_error); \}\par
00058 \par
00060         {\cf18 bool} operator ! (){\cf17  const}\par
00061 {\cf17                         }\{ {\cf19 return} (_error); \}\par
00062 \par
00063         {\cf18 bool} operator == ({\cf17 const} IPAddress& a){\cf17  const}\par
00064 {\cf17                         }\{ {\cf19 return} (_a == a._a && _b == a._b && _c == a._c && _d == a._d && _port == a._port); \}\par
00065         {\cf18 bool} operator != ({\cf17 const} IPAddress& a){\cf17  const}\par
00066 {\cf17                         }\{ {\cf19 return} (_a != a._a || _b != a._b || _c != a._c || _d != a._d || _port != a._port); \}\par
00067 \par
00068         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} IPAddress& a)\par
00069                         \{ {\cf19 return} (o << ((a._error) ? {\cf22 "Error"} : a.asString ())); \}\par
00070 \par
00071         {\cf17 private}:\par
00072         {\cf18 unsigned} {\cf18 char} _a, _b, _c, _d;\par
00073         {\cf18 unsigned} {\cf18 short} _port;\par
00074         {\cf17 mutable} {\cf18 bool} _error;\par
00075     \};\par
00076 \}\par
00077 \par
00078 {\cf21 #endif}\par
00079   \par
00080 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/Message.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/Message.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/Message.hpp}
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <COMMS/IPAddress.hpp>}\par
{\f2 #include <MessageIdentifiers.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::CommunicationMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::MessageBuilder}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Message.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/Message.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/Message.hpp}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_COMMMESSAGE__}\par
00015 {\cf21 #define __MCHEMUL_COMMMESSAGE__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <COMMS/IPAddress.hpp>}\par
00019 {\cf21 #include <MessageIdentifiers.h>}\par
00020 \par
00021 {\cf17 namespace }MCHEmul\par
00022 \{\par
00023     {\cf17 class }Computer;\par
00024 \par
00027     {\cf17 class }CommunicationMessage\par
00028     \{\par
00029         {\cf17 public}:\par
00031         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _MESSAGEID = \par
00032             DefaultMessageIDTypes::ID_USER_PACKET_ENUM + 1;\par
00033 \par
00034         CommunicationMessage ({\cf18 unsigned} {\cf18 char} t, {\cf17 const} Attributes& a)\par
00035             : _type (t), _attributes (a),\par
00036               _error (false)\par
00037                             \{ \}\par
00038 \par
00040         CommunicationMessage ({\cf17 const} CommunicationMessage&) = {\cf17 delete};\par
00041 \par
00042         CommunicationMessage& operator = ({\cf17 const} CommunicationMessage&) = {\cf17 delete};\par
00043 \par
00044         {\cf17 virtual} ~CommunicationMessage ()\par
00045                             \{ \}\par
00046 \par
00047         {\cf18 unsigned} {\cf18 char} type (){\cf17  const}\par
00048 {\cf17                             }\{ {\cf19 return} (_type); \}\par
00049 \par
00050         {\cf17 const} Attributes attributes (){\cf17  const}\par
00051 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00052 \par
00053         std::string toString () {\cf17 const};\par
00054 \par
00061         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} executeOn (Computer*, CommunicationMessage*&) = 0;\par
00062 \par
00063         {\cf17 protected}:\par
00065         {\cf18 unsigned} {\cf18 int} _type;\par
00067         Attributes _attributes;\par
00068 \par
00069         {\cf20 // Implementation}\par
00070         {\cf18 bool} _error;\par
00071     \};\par
00072 \par
00085     {\cf17 class }MessageBuilder\par
00086     \{\par
00087         {\cf17 public}:\par
00088         MessageBuilder ()\par
00089                             \{ \}\par
00090 \par
00092         MessageBuilder ({\cf17 const} MessageBuilder&) = {\cf17 delete};\par
00093 \par
00094         MessageBuilder& operator = ({\cf17 const} MessageBuilder&) = {\cf17 delete};\par
00095 \par
00096         {\cf17 virtual} ~MessageBuilder ()\par
00097                             \{ \}\par
00098 \par
00099         {\cf17 virtual} CommunicationMessage* createMessage ({\cf17 const} std::string&) = 0;\par
00100 \par
00101         {\cf17 protected}:\par
00102         {\cf20 // Implementation}\par
00104 {\cf20 }        {\cf18 bool} verifyStructure ({\cf17 const} std::string& str);\par
00106         Attributes attributesFromStr ({\cf17 const} std::string& str) {\cf17 const};\par
00107     \};\par
00108 \}\par
00109 \par
00110 {\cf21 #endif}\par
00111   \par
00112 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/StdMessages.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/StdMessages.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/StdMessages.hpp}
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <COMMS/Message.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::StandardMessageBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::GetRegisterStatusMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::GetMemoryDataMessage}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StdMessages.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/StdMessages.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/StdMessages.hpp}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_STDMESSAGES__}\par
00015 {\cf21 #define __MCHEMUL_STDMESSAGES__}\par
00016 \par
00017 {\cf21 #include <COMMS/Message.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00023     {\cf17 class }StandardMessageBuilder : {\cf17 public} MessageBuilder\par
00024     \{\par
00025         {\cf17 public}:\par
00026         StandardMessageBuilder ()\par
00027             : MessageBuilder ()\par
00028                             \{ \}\par
00029 \par
00030         {\cf17 virtual} CommunicationMessage* createMessage ({\cf17 const} std::string& str) {\cf17 override};\par
00031     \};\par
00032 \par
00034     {\cf17 class }GetRegisterStatusMessage : {\cf17 public} CommunicationMessage\par
00035     \{\par
00036         {\cf17 public}:\par
00037         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _ID = {\cf23 'A'};\par
00038 \par
00039         GetRegisterStatusMessage ({\cf17 const} Attributes& a)\par
00040             : CommunicationMessage (_ID, a)\par
00041                             \{ \}\par
00042 \par
00043         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} executeOn (Computer* c, CommunicationMessage*& ans) {\cf17 override};\par
00044     \};\par
00045 \par
00047     {\cf17 class }GetMemoryDataMessage : {\cf17 public} CommunicationMessage\par
00048     \{\par
00049         {\cf17 public}:\par
00050         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _ID = {\cf23 'B'};\par
00051 \par
00052         GetMemoryDataMessage ({\cf17 const} Attributes& a)\par
00053             : CommunicationMessage (_ID, a)\par
00054                             \{ \}\par
00055 \par
00056         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} executeOn (Computer* c, CommunicationMessage*& ans) {\cf17 override};\par
00057     \};\par
00058 \}\par
00059 \par
00060 {\cf21 #endif}\par
00061   \par
00062 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/COMMS/System.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/System.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/System.hpp}
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <COMMS/Channel.hpp>}\par
{\f2 #include <COMMS/Message.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::CommunicationSystem}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
System.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/COMMS/System.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/COMMS/System.hpp}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_COMMSSYS__}\par
00015 {\cf21 #define __MCHEMUL_COMMSSYS__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <COMMS/Channel.hpp>}\par
00019 {\cf21 #include <COMMS/Message.hpp>}\par
00020 \par
00021 {\cf17 namespace }MCHEmul\par
00022 \{\par
00023     {\cf17 class }Computer;\par
00024 \par
00025     {\cf17 class }CommunicationSystem\par
00026     \{\par
00027         {\cf17 public}:\par
00028         CommunicationSystem (PeerCommunicationChannel* cC, MessageBuilder* mB)\par
00029             : _communicationChannel (cC), _messageBuilder (mB),\par
00030               _error (false), _lastError (MCHEmul::_NOERROR)\par
00031                             \{ assert (_communicationChannel != {\cf17 nullptr} && _messageBuilder != {\cf17 nullptr}); \}\par
00032 \par
00033         CommunicationSystem ({\cf17 const} CommunicationSystem&) = {\cf17 delete};\par
00034 \par
00035         CommunicationSystem& operator = ({\cf17 const} CommunicationSystem&) = {\cf17 delete};\par
00036 \par
00037         {\cf17 virtual} ~CommunicationSystem ()\par
00038                             \{ {\cf17 delete} (_communicationChannel); {\cf17 delete} (_messageBuilder); \}\par
00039 \par
00040         {\cf20 // Managing the system...}\par
00041         {\cf17 virtual} {\cf18 bool} initialize ()\par
00042                             \{ {\cf19 return} (_communicationChannel -> initialize ()); \}\par
00044         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} processMessagesOn (Computer* c);\par
00045         {\cf17 virtual} {\cf18 bool} finalize ()\par
00046                             \{ {\cf19 return} (_communicationChannel -> finalize ()); \}\par
00047 \par
00048         {\cf18 bool} error (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_communicationChannel -> lastError ()); \}\par
00050 \par
00051         {\cf18 bool} operator ! (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (!_communicationChannel); \}\par
00053 \par
00054         {\cf17 protected}:\par
00055         MessageBuilder* _messageBuilder;\par
00056         PeerCommunicationChannel* _communicationChannel;\par
00057 \par
00058         {\cf20 // Implementation}\par
00059         {\cf18 bool} _error;\par
00060         {\cf18 unsigned} {\cf18 int} _lastError;\par
00061     \};\par
00062 \}\par
00063 \par
00064 {\cf21 #endif}\par
00065   \par
00066 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CONSOLE/Console.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CONSOLE/Console.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CONSOLE/Console.hpp}
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <EMULATORS/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Console::Console}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Console}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Console.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CONSOLE/Console.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CONSOLE/Console.hpp}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __CONSOLE_CONSOLE__}\par
00015 {\cf21 #define __CONSOLE_CONSOLE__}\par
00016 \par
00017 {\cf21 #include <EMULATORS/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }Console\par
00020 \{\par
00021     {\cf17 class }Console \par
00022     \{\par
00023         {\cf17 public}:\par
00024         Console () = {\cf17 delete};\par
00025 \par
00026         Console (Emuls::Emulator* e, MCHEmul::CommandBuilder* cB);\par
00027 \par
00028         Console ({\cf17 const} Console&) = {\cf17 delete};\par
00029 \par
00030         Console& operator = ({\cf17 const} Console&) = {\cf17 delete};\par
00031 \par
00032         {\cf17 virtual} ~Console ()\par
00033                             \{ {\cf17 delete} (_commandBuilder); \}\par
00034 \par
00035         {\cf18 void} run ();\par
00036 \par
00037         {\cf17 protected}:\par
00039         {\cf18 bool} readCommand ();\par
00040 \par
00044         {\cf17 virtual} {\cf18 bool} readChar ({\cf18 char}& chr) {\cf17 const} = 0;\par
00045 \par
00046         {\cf17 protected}:\par
00047         Emuls::Emulator* _emulator;\par
00048         MCHEmul::CommandBuilder* _commandBuilder;\par
00049 \par
00050         {\cf20 // Implementation}\par
00051         std::string _command;\par
00052     \};\par
00053 \par
00054 {\cf21 #ifdef _WIN32}\par
00056     {\cf17 class }Win32Console final : {\cf17 public} Console\par
00057     \{\par
00058         {\cf17 public}:\par
00059         Win32Console (Emuls::Emulator* e, MCHEmul::CommandBuilder* cB)\par
00060             : Console (e, cB)\par
00061                             \{ \}\par
00062 \par
00063         {\cf17 protected}:\par
00064         {\cf17 virtual} {\cf18 bool} readChar ({\cf18 char}& chr) {\cf17 const override};\par
00065     \};\par
00066 {\cf21 #endif}\par
00067 \}\par
00068 \par
00069 {\cf21 #endif}\par
00070   \par
00071 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Address.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Address.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Address.hpp}
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/UInt.hpp>}\par
{\f2 #include <CORE/UBytes.hpp>}\par
{\f2 #include <CORE/UByte.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Address}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Address.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Address.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Address.hpp}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_ADDRESS__}\par
00015 {\cf21 #define __MCHEMUL_ADDRESS__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/UInt.hpp>}\par
00019 {\cf21 #include <CORE/UBytes.hpp>}\par
00020 {\cf21 #include <CORE/UByte.hpp>}\par
00021 \par
00022 {\cf17 namespace }MCHEmul\par
00023 \{\par
00027     {\cf17 class }Address final\par
00028     \{\par
00029         {\cf17 public}:\par
00030         Address ()\par
00031             : _value (UInt ())\par
00032                             \{ \}\par
00033 \par
00035         Address ({\cf17 const} UInt& a)\par
00036             : _value (a)\par
00037                             \{ \}\par
00038 \par
00039         Address ({\cf17 const} MCHEmul::UBytes& a, {\cf18 bool} bE = {\cf17 true})\par
00040             : _value (a, bE)\par
00041                             \{ \}\par
00042 \par
00043         Address ({\cf17 const} std::vector <UByte>& a, {\cf18 bool} bE = {\cf17 true})\par
00044             : _value (a, bE)\par
00045                             \{ \}\par
00046 \par
00047         Address ({\cf17 const} Address&) = {\cf19 default};\par
00048         Address& operator = ({\cf17 const} Address&) = {\cf19 default};\par
00049 \par
00050         {\cf18 size_t} size (){\cf17  const}\par
00051 {\cf17                             }\{ {\cf19 return} (_value.size ()); \}\par
00052 \par
00053         {\cf17 const} UInt& value (){\cf17  const}\par
00054 {\cf17                             }\{ {\cf19 return} (_value);\}\par
00055         {\cf17 const} UBytes& values (){\cf17  const}\par
00056 {\cf17                             }\{ {\cf19 return} (_value.values ()); \}\par
00057         {\cf17 const} std::vector <UByte>& bytes (){\cf17  const}\par
00058 {\cf17                             }\{ {\cf19 return} (_value.bytes ()); \}\par
00059 \par
00061         {\cf18 int} distanceWith ({\cf17 const} Address& a){\cf17  const}\par
00062 {\cf17                             }\{ {\cf19 return} (({\cf18 int}) a.value ().asUnsignedInt () - ({\cf18 int}) value ().asUnsignedInt ()); \}\par
00063 \par
00065         Address next ({\cf18 size_t} n){\cf17  const}\par
00066 {\cf17                             }\{ {\cf19 return} (Address (_value + UInt::fromUnsignedInt (({\cf18 unsigned} {\cf18 int}) n))); \}       \par
00067         Address previous ({\cf18 size_t} n){\cf17  const}\par
00068 {\cf17                             }\{ {\cf19 return} (Address (_value - UInt::fromUnsignedInt (({\cf18 unsigned} {\cf18 int}) n))); \}\par
00069 \par
00070         {\cf18 bool} operator == ({\cf17 const} Address& a){\cf17  const}\par
00071 {\cf17                             }\{ {\cf19 return} (_value == a._value); \}\par
00072         {\cf18 bool} operator != ({\cf17 const} Address& a){\cf17  const}\par
00073 {\cf17                             }\{ {\cf19 return} (_value != a._value); \}\par
00074         {\cf18 bool} operator < ({\cf17 const} Address& a){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_value < a._value); \}\par
00076         {\cf18 bool} operator <= ({\cf17 const} Address& a){\cf17  const}\par
00077 {\cf17                             }\{ {\cf19 return} (_value <= a._value); \}\par
00078         {\cf18 bool} operator > ({\cf17 const} Address& a){\cf17  const}\par
00079 {\cf17                             }\{ {\cf19 return} (_value > a._value); \}\par
00080         {\cf18 bool} operator >= ({\cf17 const} Address& a){\cf17  const}\par
00081 {\cf17                             }\{ {\cf19 return} (_value >= a._value); \}\par
00082 \par
00083         Address operator + ({\cf18 size_t} n){\cf17  const}\par
00084 {\cf17                             }\{ {\cf19 return} (Address (*this).next (n)); \}\par
00085         {\cf17 friend} Address operator + ({\cf18 size_t} n, {\cf17 const} Address& a)\par
00086                             \{ {\cf19 return} (a + n); \}\par
00087         Address& operator += ({\cf18 size_t} n)\par
00088                             \{ *{\cf17 this} = *{\cf17 this} + n; {\cf19 return} (*{\cf17 this}); \}\par
00089         {\cf18 size_t} operator - ({\cf17 const} Address& a){\cf17  const}\par
00090 {\cf17                             }\{ {\cf19 return} ({\cf17 this} -> distanceWith (a)); \}\par
00091         Address operator - ({\cf18 size_t} n){\cf17  const}\par
00092 {\cf17                             }\{ {\cf19 return} (Address (*this).previous (n)); \}\par
00093         {\cf17 friend} Address operator - ({\cf18 size_t} n, {\cf17 const} Address& a)\par
00094                             \{ {\cf19 return} (a - n); \}\par
00095         Address& operator -= ({\cf18 size_t} n)\par
00096                             \{ *{\cf17 this} = *{\cf17 this} - n; {\cf19 return} (*{\cf17 this}); \}\par
00097         Address& operator -- ()\par
00098                             \{ {\cf19 return} (*{\cf17 this} -= 1); \}\par
00099 \par
00100         UByte operator [] ({\cf18 size_t} p){\cf17  const}\par
00101 {\cf17                             }\{ {\cf19 return} (_value [p]); \}\par
00102 \par
00103         std::string asString (UByte::OutputFormat oF){\cf17  const}\par
00104 {\cf17                             }\{ {\cf19 return} (_value.asString (oF, {\cf23 ' '}, 2)); \}\par
00105 \par
00106         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Address& a);\par
00107 \par
00112         {\cf17 static} Address fromStr ({\cf17 const} std::string& str);\par
00113 \par
00114         {\cf17 private}:\par
00115         UInt _value;\par
00116     \};\par
00117 \}\par
00118 \par
00119 {\cf21 #endif}\par
00120   \par
00121 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Chip.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Chip.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Chip.hpp}
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/Memory.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Chip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::NoChip}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Chips} = std::map< int, Chip * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Chip.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Chip.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Chip.hpp}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_CHIP__}\par
00015 {\cf21 #define __MCHEMUL_CHIP__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/Memory.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00022     {\cf17 class }CPU;\par
00023 \par
00027     {\cf17 class }Chip\par
00028     \{\par
00029         {\cf17 public}:\par
00030         Chip () = {\cf17 delete};\par
00031 \par
00032         Chip ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& attrs = \{ \})\par
00033             : _id ({\cf18 id}), _memory ({\cf17 nullptr}), _attributes (attrs), \par
00034               _lastError (_NOERROR) {\cf20 // Memory accessed can be null, take care...}\par
00035                             \{ \}\par
00036 \par
00037         Chip ({\cf17 const} Chip&) = {\cf17 delete};\par
00038 \par
00039         Chip& operator = ({\cf17 const} Chip&) = {\cf17 delete};\par
00040 \par
00042         {\cf17 virtual} ~Chip ()\par
00043                             \{ \} \par
00044 \par
00045         {\cf18 int} id (){\cf17  const}\par
00046 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00047 \par
00049         {\cf18 void} setMemoryRef (Memory* m)\par
00050                             \{ _memory = m; \}\par
00051         {\cf17 const} Memory* memoryRef (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_memory); \}\par
00053         Memory* memoryRef ()\par
00054                             \{ {\cf19 return} (_memory); \}\par
00055 \par
00056         {\cf17 const} Attributes& attributes (){\cf17  const}\par
00057 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00058         {\cf17 const} std::string& attribute ({\cf17 const} std::string& aN){\cf17  const}\par
00059 {\cf17                             }\{ Attributes::const_iterator i = _attributes.find (aN); \par
00060                               {\cf19 return} ((i == _attributes.end ()) ? AttributedNotDefined : (*i).second); \}\par
00061 \par
00065         {\cf17 virtual} {\cf18 bool} initialize () = 0;\par
00066 \par
00071         {\cf17 virtual} {\cf18 bool} simulate (CPU*) = 0;\par
00072 \par
00074         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00076         {\cf18 void} resetErrors ()\par
00077                             \{ _lastError = _NOERROR; \}\par
00078 \par
00079         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Chip& c);\par
00080 \par
00081         {\cf17 protected}:\par
00082         {\cf17 const} {\cf18 int} _id = -1; {\cf20 // Modified at construction level}\par
00083         Memory* _memory;\par
00084         {\cf17 const} Attributes _attributes = \{ \}; {\cf20 // Maybe modified at construction level}\par
00085 \par
00086         {\cf20 // Implementation}\par
00087         {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastError;\par
00088     \};\par
00089 \par
00090     {\cf17 using} Chips = std::map <int, Chip*>;\par
00091 \par
00093     {\cf17 class }NoChip final : {\cf17 public} Chip\par
00094     \{\par
00095         {\cf17 public}:\par
00096         NoChip ()\par
00097             : Chip (0)\par
00098                             \{ \}\par
00099 \par
00100         {\cf17 virtual} {\cf18 bool} initialize (){\cf17  override}\par
00101 {\cf17                             }\{ {\cf19 return} ({\cf17 true}); \}\par
00102 \par
00103         {\cf17 virtual} {\cf18 bool} simulate (CPU*){\cf17  override}\par
00104 {\cf17                             }\{ {\cf19 return} ({\cf17 true}); \}\par
00105     \};\par
00106 \par
00108     {\cf17 static} {\cf17 const} Chip* ChipNotValid = {\cf17 new} NoChip;\par
00109     {\cf17 static} Chip* TrashChip = {\cf17 new} NoChip;\par
00110 \}\par
00111 \par
00112 {\cf21 #endif}\par
00113   \par
00114 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Command.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Command.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Command.hpp}
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Command}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Command.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Command.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Command.hpp}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __CONSOLE_COMMANDCONSOLE__}\par
00015 {\cf21 #define __CONSOLE_COMMANDCONSOLE__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00021     {\cf17 class }Command \par
00022     \{\par
00023         {\cf17 public}:\par
00024         Command () = {\cf17 delete};\par
00025 \par
00026         Command ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& prms = \{ \})\par
00027             : _id ({\cf18 id}), _parameters (prms)\par
00028                             \{ \}\par
00029 \par
00030         Command ({\cf17 const} Command&) = {\cf19 default};\par
00031 \par
00032         Command& operator = ({\cf17 const} Command&) = {\cf19 default};\par
00033 \par
00034         {\cf17 virtual} ~Command ()\par
00035                             \{ \}\par
00036 \par
00037         {\cf18 int} id (){\cf17  const}\par
00038 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00039         {\cf17 const} Attributes& parameters (){\cf17  const}\par
00040 {\cf17                             }\{ {\cf19 return} (_parameters); \}\par
00041         {\cf18 void} setParameters ({\cf17 const} Attributes& prms)\par
00042                             \{ _parameters = prms; \}\par
00043 \par
00044         {\cf17 virtual} {\cf18 bool} canBeExecuted () {\cf17 const} = 0;\par
00045 \par
00046         {\cf17 virtual} {\cf18 bool} execute (Computer* c, {\cf17 const} Attributes& rst) = 0;\par
00047 \par
00048         {\cf17 protected}:\par
00049         {\cf18 int} _id;\par
00050         Attributes _parameters;\par
00051     \};\par
00052 \}\par
00053 \par
00054 {\cf21 #endif}\par
00055   \par
00056 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/CommandBuilder.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CommandBuilder.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CommandBuilder.hpp}
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Command.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::CommandBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::StandardCommandBuilder}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CommandBuilder.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CommandBuilder.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CommandBuilder.hpp}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __CONSOLE_COMMANDBUILDER__}\par
00015 {\cf21 #define __CONSOLE_COMMANDBUILDER__}\par
00016 \par
00017 {\cf21 #include <CORE/Command.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00022     {\cf17 class }CommandBuilder\par
00023     \{\par
00024         {\cf17 public}:\par
00025         {\cf17 virtual} ~CommandBuilder ()\par
00026                             \{ \}\par
00027 \par
00028         Command* createCommand ({\cf17 const} std::string& cmd) {\cf17 const};\par
00029 \par
00030         {\cf17 protected}:\par
00031         {\cf17 virtual} Command* createEmptyCommand ({\cf17 const} std::string& cmdName) {\cf17 const} = 0;\par
00032 \par
00033         {\cf20 // Implementation}\par
00034         std::string readCommandName ({\cf17 const} std::string& cmd) {\cf17 const};\par
00035         Attributes readCommandParameters ({\cf17 const} std::string& cmd) {\cf17 const};\par
00036     \};\par
00037 \par
00039     {\cf17 class }StandardCommandBuilder : {\cf17 public} CommandBuilder\par
00040     \{\par
00041         {\cf17 protected}:\par
00042         {\cf17 virtual} Command* createEmptyCommand ({\cf17 const} std::string& cmdName) {\cf17 const override};\par
00043     \};\par
00044 \}\par
00045 \par
00046 {\cf21 #endif}\par
00047   \par
00048 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Computer.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Computer.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Computer.hpp}
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/CPU.hpp>}\par
{\f2 #include <CORE/Chip.hpp>}\par
{\f2 #include <CORE/GraphicalChip.hpp>}\par
{\f2 #include <CORE/Memory.hpp>}\par
{\f2 #include <CORE/Register.hpp>}\par
{\f2 #include <CORE/Instruction.hpp>}\par
{\f2 #include <CORE/IO.hpp>}\par
{\f2 #include <CORE/Screen.hpp>}\par
{\f2 #include <CORE/OSIO.hpp>}\par
{\f2 #include <chrono>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Computer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Computer::Clock}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Computer.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Computer.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Computer.hpp}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHMUL_COMPUTER__}\par
00015 {\cf21 #define __MCHMUL_COMPUTER__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/CPU.hpp>}\par
00019 {\cf21 #include <CORE/Chip.hpp>}\par
00020 {\cf21 #include <CORE/GraphicalChip.hpp>}\par
00021 {\cf21 #include <CORE/Memory.hpp>}\par
00022 {\cf21 #include <CORE/Register.hpp>}\par
00023 {\cf21 #include <CORE/Instruction.hpp>}\par
00024 {\cf21 #include <CORE/IO.hpp>}\par
00025 {\cf21 #include <CORE/Screen.hpp>}\par
00026 {\cf21 #include <CORE/OSIO.hpp>}\par
00027 {\cf21 #include <chrono>}\par
00028 \par
00029 {\cf17 namespace }MCHEmul\par
00030 \{\par
00033     {\cf17 class }Computer\par
00034     \{\par
00035         {\cf17 public}:\par
00036         Computer () = {\cf17 delete};\par
00037 \par
00042         Computer (CPU* cpu, {\cf17 const} Chips& c, Memory* m, {\cf17 const} IODevices& d, {\cf18 unsigned} {\cf18 int} cs, {\cf17 const} Attributes& attrs = \{ \});\par
00043 \par
00044         Computer ({\cf17 const} Computer&) = {\cf17 delete};\par
00045 \par
00046         {\cf17 virtual} ~Computer (); \par
00047 \par
00048         Computer& operator = ({\cf17 const} Computer&) = {\cf17 delete};\par
00049 \par
00050         {\cf17 const} CPU* cpu (){\cf17  const}\par
00051 {\cf17                             }\{ {\cf19 return} (_cpu); \}\par
00052         CPU* cpu ()\par
00053                             \{ {\cf19 return} (_cpu); \}\par
00054 \par
00055         {\cf17 const} Chips& chips (){\cf17  const}\par
00056 {\cf17                             }\{ {\cf19 return} (_chips); \}\par
00057         {\cf18 bool} existsChip ({\cf18 int} {\cf18 id}){\cf17  const}\par
00058 {\cf17                             }\{ {\cf19 return} (_chips.find ({\cf18 id}) != _chips.end ()); \}\par
00059         {\cf17 const} Chip* chip ({\cf18 int} {\cf18 id}){\cf17  const}\par
00060 {\cf17                             }\{ {\cf19 return} (existsChip ({\cf18 id}) ? (*_chips.find ({\cf18 id})).second : ChipNotValid); \}\par
00061         Chip* chip ({\cf18 int} {\cf18 id})\par
00062                             \{ {\cf19 return} (existsChip ({\cf18 id}) ? (*_chips.find ({\cf18 id})).second : TrashChip); \}\par
00064         {\cf17 const} GraphicalChip* graphicalChip (){\cf17  const}\par
00065 {\cf17                             }\{ {\cf19 return} (_graphicalChip); \}\par
00066         GraphicalChip* graphicalChip ()\par
00067                             \{ {\cf19 return} (_graphicalChip); \}\par
00068 \par
00069         {\cf17 const} Memory* memory (){\cf17  const}\par
00070 {\cf17                             }\{ {\cf19 return} (_memory); \}\par
00071         Memory* memory ()\par
00072                             \{ {\cf19 return} (_memory); \}\par
00073 \par
00074         {\cf17 const} IODevices& devices (){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_devices); \}\par
00076         {\cf18 bool} existsDevice ({\cf18 int} {\cf18 id}){\cf17  const}\par
00077 {\cf17                             }\{ {\cf19 return} (_devices.find ({\cf18 id}) != _devices.end ()); \}\par
00078         {\cf17 const} IODevice* device ({\cf18 int} {\cf18 id}){\cf17  const}\par
00079 {\cf17                             }\{ {\cf19 return} (existsDevice ({\cf18 id}) ? (*_devices.find ({\cf18 id})).second : {\cf17 nullptr}); \}\par
00080         IODevice* device ({\cf18 int} {\cf18 id})\par
00081                             \{ {\cf19 return} (existsDevice ({\cf18 id}) ? (*_devices.find ({\cf18 id})).second : {\cf17 nullptr}); \}\par
00082 \par
00086         {\cf17 virtual} {\cf18 bool} connect (IOPeripheral* p, IODevice* d) = 0;\par
00087 \par
00088         {\cf17 const} Screen* screen (){\cf17  const}\par
00089 {\cf17                             }\{ {\cf19 return} (_screen); \}\par
00090         Screen* screen ()\par
00091                             \{ {\cf19 return} (_screen); \}\par
00092         {\cf17 const} InputOSSystem* inputOSSystem (){\cf17  const}\par
00093 {\cf17                             }\{ {\cf19 return} (_inputOSSystem); \}\par
00094         InputOSSystem* inputOSSytem ()\par
00095                             \{ {\cf19 return} (_inputOSSystem); \}\par
00096 \par
00097         {\cf18 unsigned} {\cf18 int} cyclesPerSecond (){\cf17  const}\par
00098 {\cf17                             }\{ {\cf19 return} (_clock.cyclesPerSecond ()); \}\par
00099 \par
00100         {\cf17 const} Attributes& attributes (){\cf17  const}\par
00101 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00102         {\cf17 const} std::string& attribute ({\cf17 const} std::string& aN){\cf17  const}\par
00103 {\cf17                             }\{ Attributes::const_iterator i = _attributes.find (aN); \par
00104                               {\cf19 return} ((i == _attributes.end ()) ? AttributedNotDefined : (*i).second); \}\par
00105 \par
00106         {\cf20 // To load data files...}\par
00107         {\cf18 bool} loadInto ({\cf17 const} std::string& fN, {\cf17 const} Address& a)\par
00108                             \{ {\cf19 return} (memory () -> loadInto (fN, a)); \}\par
00109 \par
00114         {\cf17 virtual} {\cf18 bool} initialize ();\par
00115 \par
00120         {\cf18 bool} run ();\par
00121         \par
00123         {\cf18 void} startsCycle ()\par
00124                             \{ _clock.start (_cpu -> clockCycles ()); \}\par
00126         {\cf18 bool} runComputerCycle ();\par
00129         {\cf18 bool} runIOCycle ();\par
00131         {\cf18 void} finishCycle ()\par
00132                             \{ _clock.waitFor (_cpu -> clockCycles ()); \}\par
00133 \par
00134         {\cf18 bool} exit (){\cf17  const}\par
00135 {\cf17                             }\{ {\cf19 return} (_exit); \}\par
00136         {\cf18 void} setExit ({\cf18 bool} e)\par
00137                             \{ _exit = e; \}\par
00138 \par
00139         {\cf18 unsigned} {\cf18 int} debugLevel (){\cf17  const}\par
00140 {\cf17                             }\{ {\cf19 return} (_debugLevel); \}\par
00141         {\cf18 void} setDebugLevel ({\cf18 unsigned} {\cf18 int} dL)\par
00142                             \{ _debugLevel = dL; \}\par
00143 \par
00145         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00146 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00147         {\cf18 void} resetErrors ()\par
00148                             \{ _lastError = _NOERROR; \}\par
00149 \par
00150         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Computer& c);\par
00151 \par
00152         {\cf17 protected}:\par
00155         {\cf17 class }Clock final\par
00156         \{\par
00157             {\cf17 public}:\par
00158             Clock () = {\cf17 delete};\par
00159 \par
00160             Clock ({\cf18 unsigned} {\cf18 int} cS)\par
00161                 : _cyclesPerSecond (cS),\par
00162                   _initialClockCycles (0), _iClock ()\par
00163                             \{ assert (_cyclesPerSecond > 0); \}\par
00164 \par
00165             Clock ({\cf17 const} Clock&) = {\cf19 default};\par
00166 \par
00167             Clock& operator = ({\cf17 const} Clock&) = {\cf19 default};\par
00168 \par
00169             {\cf18 unsigned} {\cf18 int} cyclesPerSecond (){\cf17  const}\par
00170 {\cf17                             }\{ {\cf19 return} (_cyclesPerSecond); \}\par
00171 \par
00172             {\cf18 void} start ({\cf18 unsigned} {\cf18 int} cC);\par
00173             {\cf18 void} waitFor ({\cf18 unsigned} {\cf18 int} cC);\par
00174 \par
00175             {\cf17 private}:\par
00176             {\cf18 unsigned} {\cf18 int} _cyclesPerSecond;\par
00177 \par
00178             {\cf20 // Implementation}\par
00179             {\cf18 unsigned} {\cf18 int} _initialClockCycles;\par
00180             std::chrono::time_point <std::chrono::steady_clock> _iClock;\par
00181         \};\par
00182             \par
00183         CPU* _cpu;\par
00184         Chips _chips; \par
00185         Memory* _memory;\par
00186         IODevices _devices;\par
00187         {\cf17 const} Attributes _attributes = \{ \}; {\cf20 // Maybe modified at construction level}\par
00188 \par
00191         {\cf18 bool} _exit;\par
00192 \par
00194         {\cf18 unsigned} {\cf18 int} _debugLevel;\par
00195 \par
00196         {\cf20 // Implementation}\par
00197         {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastError;\par
00198         Screen* _screen;\par
00199         InputOSSystem* _inputOSSystem;\par
00200         GraphicalChip* _graphicalChip;\par
00201         Clock _clock; {\cf20 // To maintain the sped of the compute...}\par
00202     \};\par
00203 \}\par
00204 \par
00205 {\cf21 #endif}\par
00206   \par
00207 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/CPU.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CPU.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CPU.hpp}
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/CPUArchitecture.hpp>}\par
{\f2 #include <CORE/Chip.hpp>}\par
{\f2 #include <CORE/Memory.hpp>}\par
{\f2 #include <CORE/Register.hpp>}\par
{\f2 #include <CORE/CPUInterrupt.hpp>}\par
{\f2 #include <CORE/ProgramCounter.hpp>}\par
{\f2 #include <CORE/StatusRegister.hpp>}\par
{\f2 #include <CORE/Instruction.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::CPU}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPU.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CPU.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CPU.hpp}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_CPU__}\par
00015 {\cf21 #define __MCHEMUL_CPU__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/CPUArchitecture.hpp>}\par
00019 {\cf21 #include <CORE/Chip.hpp>}\par
00020 {\cf21 #include <CORE/Memory.hpp>}\par
00021 {\cf21 #include <CORE/Register.hpp>}\par
00022 {\cf21 #include <CORE/CPUInterrupt.hpp>}\par
00023 {\cf21 #include <CORE/ProgramCounter.hpp>}\par
00024 {\cf21 #include <CORE/StatusRegister.hpp>}\par
00025 {\cf21 #include <CORE/Instruction.hpp>}\par
00026 \par
00027 {\cf17 namespace }MCHEmul\par
00028 \{\par
00030     {\cf17 class }CPU\par
00031     \{\par
00032         {\cf17 public}:\par
00033         CPU () = {\cf17 delete};\par
00034 \par
00035         CPU ({\cf17 const} CPUArchitecture& a, {\cf17 const} Registers& r, {\cf17 const} StatusRegister& sR, {\cf17 const} Instructions& ins)\par
00036             : _architecture (a), _registers (r), _statusRegister (sR), _instructions (ins),\par
00037               _programCounter (a.numberBytes ()), _memory (nullptr), _interrupts (),\par
00038               _lastInstruction (nullptr),\par
00039               _lastError (_NOERROR), _clockCycles (0)\par
00040                             \{ assert (_registers.size () > 0 && _instructions.size () > 0); \}\par
00041 \par
00042         CPU ({\cf17 const} CPU&) = {\cf17 delete};\par
00043 \par
00044         CPU& operator = ({\cf17 const} CPU&) = {\cf17 delete}; \par
00045 \par
00046         {\cf17 virtual} ~CPU ();\par
00047 \par
00048         {\cf17 const} CPUArchitecture& architecture (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_architecture); \}\par
00050 \par
00051         {\cf17 const} Registers& internalRegisters (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_registers); \}\par
00053         {\cf18 bool} existsInternalRegister ({\cf18 size_t} nR){\cf17  const}\par
00054 {\cf17                             }\{ {\cf19 return} (nR < _registers.size ()); \}\par
00055         {\cf17 const} Register& internalRegister ({\cf18 size_t} nR){\cf17  const}\par
00056 {\cf17                             }\{ {\cf19 return} (existsInternalRegister (nR) ? _registers [nR] : NoRegister); \}\par
00057         Register& internalRegister ({\cf18 size_t} nR)\par
00058                             \{ {\cf19 return} (existsInternalRegister (nR) ? _registers [nR] : TrashRegister); \}\par
00059         {\cf18 void} setInternalRegister ({\cf18 size_t} nR, UBytes v)\par
00060                             \{ {\cf19 if} (existsInternalRegister (nR) && internalRegister (nR).accept (v)) internalRegister (nR).set (v); \}\par
00061 \par
00062         {\cf17 const} ProgramCounter& programCounter (){\cf17  const}\par
00063 {\cf17                             }\{ {\cf19 return} (_programCounter); \}\par
00064         ProgramCounter& programCounter ()\par
00065                             \{ {\cf19 return} (_programCounter); \}\par
00066 \par
00067         {\cf17 const} StatusRegister& statusRegister (){\cf17  const}\par
00068 {\cf17                             }\{ {\cf19 return} (_statusRegister); \}\par
00069         StatusRegister& statusRegister ()\par
00070                             \{ {\cf19 return} (_statusRegister); \}\par
00071 \par
00072         {\cf18 bool} existsInstruction ({\cf18 unsigned} {\cf18 int} i){\cf17  const}\par
00073 {\cf17                             }\{ {\cf19 return} (_instructions.find (i) != _instructions.end ()); \}\par
00074         {\cf17 const} Instructions& instructions (){\cf17  const}\par
00075 {\cf17                             }\{ {\cf19 return} (_instructions); \}\par
00076         {\cf17 const} Instruction* instruction ({\cf18 unsigned} {\cf18 int} i){\cf17  const}\par
00077 {\cf17                             }\{ {\cf19 return} ((*_instructions.find (i)).second); \}\par
00078         Instruction* instruction ({\cf18 unsigned} {\cf18 int} i)\par
00079                             \{ {\cf19 return} ((*_instructions.find (i)).second); \}\par
00080 \par
00081         {\cf17 const} Instruction* lastInstruction (){\cf17  const}\par
00082 {\cf17                             }\{ {\cf19 return} (_lastInstruction); \}\par
00083 \par
00086         {\cf18 void} setMemoryRef (Memory* m)\par
00087                             \{ _memory = m; \}\par
00088         {\cf17 const} Memory* memoryRef (){\cf17  const}\par
00089 {\cf17                             }\{ {\cf19 return} (_memory); \}\par
00090         Memory* memoryRef () \par
00091                             \{ {\cf19 return} (_memory); \}\par
00092 \par
00093         {\cf18 unsigned} {\cf18 int} clockCycles (){\cf17  const}\par
00094 {\cf17                             }\{ {\cf19 return} (_clockCycles); \}\par
00095         {\cf18 void} addClockCycles ({\cf18 unsigned} {\cf18 int} cC)\par
00096                             \{ _clockCycles += cC; \}\par
00097 \par
00101         {\cf17 virtual} {\cf18 bool} initialize ();\par
00102 \par
00104         {\cf18 bool} existsInterrupt ({\cf18 int} {\cf18 id}){\cf17  const}\par
00105 {\cf17                             }\{ {\cf19 return} (_interrupts.find ({\cf18 id}) != _interrupts.end ()); \}\par
00106         {\cf17 const} CPUInterrupt* interrupt ({\cf18 int} {\cf18 id}){\cf17  const}\par
00107 {\cf17                             }\{ {\cf19 return} ((*_interrupts.find ({\cf18 id})).second); \}\par
00108         CPUInterrupt* interrupt ({\cf18 int} {\cf18 id})\par
00109                             \{ {\cf19 return} ((*_interrupts.find ({\cf18 id})).second); \}\par
00110         {\cf18 void} addInterrupt (CPUInterrupt* in);\par
00111         {\cf18 void} removeInterrrupt ({\cf18 int} {\cf18 id});\par
00112 \par
00114         {\cf18 bool} executeNextInstruction ();\par
00115 \par
00117         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00118 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00119         {\cf18 void} resetErrors ()\par
00120                             \{ _lastError = _NOERROR; \}\par
00121 \par
00122         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} CPU& c);\par
00123 \par
00124         {\cf17 protected}:\par
00125         {\cf17 const} CPUArchitecture _architecture = \par
00126             CPUArchitecture (2 , 1 ); {\cf20 // Adjusted at construction level}\par
00127         Registers _registers;\par
00128         {\cf17 const} Instructions _instructions = \{ \}; {\cf20 // Adjusted at construction level}\par
00129         ProgramCounter _programCounter;\par
00130         StatusRegister _statusRegister;\par
00131         Memory* _memory; {\cf20 // A reference...}\par
00132         CPUInterrups _interrupts;\par
00133 \par
00134         Instruction* _lastInstruction;\par
00135 \par
00136         {\cf20 // Implementation}\par
00137         {\cf18 unsigned} {\cf18 int} _lastError;\par
00138         {\cf18 unsigned} {\cf18 int} _clockCycles;\par
00139     \};\par
00140 \}\par
00141 \par
00142 {\cf21 #endif}\par
00143   \par
00144 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/CPUArchitecture.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CPUArchitecture.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CPUArchitecture.hpp}
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/Register.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::CPUArchitecture}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPUArchitecture.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CPUArchitecture.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CPUArchitecture.hpp}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_CPUARCHITECTURE__}\par
00015 {\cf21 #define __MCHEMUL_CPUARCHITECTURE__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/Register.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00023     {\cf17 class }CPUArchitecture final\par
00024     \{\par
00025         {\cf17 public}:\par
00026         CPUArchitecture () = {\cf17 delete};\par
00027 \par
00028         CPUArchitecture ({\cf18 size_t} nb , {\cf18 size_t} iL, {\cf18 bool} bE = {\cf17 true}, {\cf17 const} Attributes& attrs = \{ \});\par
00029 \par
00030         CPUArchitecture ({\cf17 const} CPUArchitecture&) = {\cf19 default};\par
00031 \par
00032         CPUArchitecture& operator = ({\cf17 const} CPUArchitecture&) = {\cf19 default};\par
00033 \par
00034         {\cf18 size_t} numberBytes (){\cf17  const}\par
00035 {\cf17                             }\{ {\cf19 return} (_numberBytes); \}\par
00036         {\cf18 size_t} numberBits (){\cf17  const}\par
00037 {\cf17                             }\{ {\cf19 return} (_numberBits); \}\par
00038         {\cf18 size_t} instructionLength (){\cf17  const}\par
00039 {\cf17                             }\{ {\cf19 return} (_instructionLength); \}\par
00040         {\cf18 bool} bigEndian (){\cf17  const}\par
00041 {\cf17                             }\{ {\cf19 return} (_bigEndian); \}\par
00042 \par
00044         Register registerLength ({\cf18 int} {\cf18 id}, {\cf17 const} std::string& n, {\cf18 size_t} nb ){\cf17  const}\par
00045 {\cf17                             }\{ {\cf19 return} ((nb > 0 && nb <= _numberBytes) \par
00046                                 ? Register ({\cf18 id}, n, UBytes (std::vector <UByte> (nb, UByte::_0))) : NoRegister); \}\par
00048         {\cf17 const} Register& longestRegisterPossible (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_longestRegisterPossible); \}\par
00050 \par
00051         {\cf17 const} Attributes& attributes (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00053         {\cf17 const} std::string& attribute ({\cf17 const} std::string& aN){\cf17  const}\par
00054 {\cf17                             }\{ Attributes::const_iterator i = _attributes.find (aN); \par
00055                               {\cf19 return} ((i == _attributes.end ()) ? AttributedNotDefined : (*i).second); \}\par
00056 \par
00057         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} CPUArchitecture& a);\par
00058 \par
00059         {\cf17 private}:\par
00060         {\cf17 const} {\cf18 size_t} _numberBytes = 0; {\cf20 // Adjusted at construction level}\par
00061         {\cf17 const} {\cf18 size_t} _numberBits = 0; {\cf20 // Calculated at construction level}\par
00062         {\cf17 const} {\cf18 size_t} _instructionLength = 0; {\cf20 // Adjusted at construction level}\par
00063         {\cf17 const} {\cf18 bool} _bigEndian = {\cf17 true}; {\cf20 // Are the most significant Ubyte (in an address) the first or the last in values?}\par
00064         {\cf17 const} Attributes _attributes = \{ \}; {\cf20 // Optionaly adjusted at construction level}\par
00065         {\cf17 const} Register _longestRegisterPossible = NoRegister; {\cf20 // Calculated at construction level}\par
00066     \};\par
00067 \}\par
00068 \par
00069 {\cf21 #endif}\par
00070   \par
00071 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/CPUInterrupt.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CPUInterrupt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CPUInterrupt.hpp}
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::CPUInterrupt}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::CPUInterrups} = std::map< int, CPUInterrupt * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPUInterrupt.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/CPUInterrupt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/CPUInterrupt.hpp}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_CPUINTERRUPT__}\par
00015 {\cf21 #define __MCHEMUL_CPUINTERRUPT__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00021     {\cf17 class }CPU;\par
00022 \par
00024     {\cf17 class }CPUInterrupt\par
00025     \{\par
00026         {\cf17 public}:\par
00027         CPUInterrupt () = {\cf17 delete};\par
00028 \par
00029         CPUInterrupt ({\cf18 int} {\cf18 id})\par
00030             : _id (id), _active (false ),\par
00031               _lastClockCyclesExecuted (0)\par
00032                             \{ \}\par
00033 \par
00034         CPUInterrupt ({\cf17 const} CPUInterrupt&) = {\cf17 delete};\par
00035 \par
00036         {\cf17 virtual} ~CPUInterrupt ()\par
00037                             \{ \}\par
00038 \par
00039         CPUInterrupt& operator = ({\cf17 const} CPUInterrupt&) = {\cf17 delete};\par
00040 \par
00041         {\cf18 int} id (){\cf17  const}\par
00042 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00043 \par
00044         {\cf18 bool} active (){\cf17  const}\par
00045 {\cf17                             }\{ {\cf19 return} (_active); \}\par
00046         {\cf18 void} setActive ({\cf18 bool} a)\par
00047                             \{ _active = a; \}\par
00048 \par
00053         {\cf18 bool} executeOver (CPU* c, {\cf18 unsigned} {\cf18 int}& nC);\par
00054 \par
00055         {\cf17 protected}:\par
00056         {\cf20 // These methods are invoked by executeOver (defined above);}\par
00058 {\cf20 }        {\cf17 virtual} {\cf18 bool} isTime (CPU* c) {\cf17 const} = 0;\par
00061         {\cf17 virtual} {\cf18 void} executeOverImpl (CPU* c, {\cf18 unsigned} {\cf18 int}& nC) = 0;\par
00062 \par
00063         {\cf17 protected}:\par
00064         {\cf18 int} _id;\par
00065         {\cf18 bool} _active;\par
00066 \par
00067         {\cf20 // Implementation}\par
00068         {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastClockCyclesExecuted;\par
00069     \};\par
00070 \par
00072     {\cf17 using} CPUInterrups = std::map <int, CPUInterrupt*>;\par
00073 \}\par
00074 \par
00075 {\cf21 #endif}\par
00076   \par
00077 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/GraphicalChip.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/GraphicalChip.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/GraphicalChip.hpp}
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Chip.hpp>}\par
{\f2 #include <CORE/ScreenMemory.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::GraphicalChip}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GraphicalChip.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/GraphicalChip.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/GraphicalChip.hpp}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_GRAPHICALCHIP__}\par
00015 {\cf21 #define __MCHEMUL_GRAPHICALCHIP__}\par
00016 \par
00017 {\cf21 #include <CORE/Chip.hpp>}\par
00018 {\cf21 #include <CORE/ScreenMemory.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00030     {\cf17 class }GraphicalChip : {\cf17 public} Chip\par
00031     \{\par
00032         {\cf17 public}:\par
00033         GraphicalChip ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& attrs = \{ \})\par
00034             : Chip ({\cf18 id}, attrs), \par
00035               _screenMemory ({\cf17 nullptr}), \par
00036               _graphicsReady ({\cf17 false})\par
00037                             \{ \}\par
00038 \par
00039         ~GraphicalChip ()\par
00040                             \{ {\cf17 delete} (_screenMemory); \}\par
00041 \par
00042         {\cf17 const} ScreenMemory* screenMemory (){\cf17  const}\par
00043 {\cf17                             }\{ {\cf19 return} (_screenMemory); \}\par
00044         ScreenMemory* screenMemory ()\par
00045                             \{ {\cf19 return} (_screenMemory); \}\par
00046 \par
00047         {\cf18 bool} graphicsReady (){\cf17  const}\par
00048 {\cf17                             }\{ {\cf19 return} (_graphicsReady); \}\par
00049         {\cf18 void} setGraphicsReady ({\cf18 bool} gR) \par
00050                             \{ _graphicsReady = gR; \}\par
00051 \par
00052         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00053 \par
00054         {\cf17 protected}:\par
00056         {\cf17 virtual} ScreenMemory* createScreenMemory () = 0;\par
00057 \par
00058         {\cf17 protected}:\par
00059         ScreenMemory* _screenMemory;\par
00060 \par
00061         {\cf20 // Implementation}\par
00062         {\cf18 bool} _graphicsReady;\par
00063     \};\par
00064 \}\par
00065 \par
00066 {\cf21 #endif}\par
00067   \par
00068 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Instruction.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Instruction.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Instruction.hpp}
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/UBytes.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Instruction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Instruction::Structure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MCHEmul::Instruction::Structure::Parameter}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _INST_FROM}(_C,  _M,  _CC,  _T,  _I,  _J)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _INST}(_C,  _M,  _CC,  _T,  _I)\~ 	{\b _INST_FROM}(_C, _M, _CC, _T, _I, {\b MCHEmul::Instruction});\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _INST_IMPL}(_I)\~ bool _I::executeImpl ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Instructions} = std::map< unsigned int, Instruction * >\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v _INST\:Instruction.hpp}
{\xe \v Instruction.hpp\:_INST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _INST( _C,  _M,  _CC,  _T,  _I)\~ 	{\b _INST_FROM}(_C, _M, _CC, _T, _I, {\b MCHEmul::Instruction});}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Idem but inheriting from basic instruction. \par
}{
Definition at line {\b 199} of file {\b Instruction.hpp}.}\par
}
{\xe \v _INST_FROM\:Instruction.hpp}
{\xe \v Instruction.hpp\:_INST_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _INST_FROM( _C,  _M,  _CC,  _T,  _I,  _J)}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 class }_I final : {\cf17 public} _J \\\par
\{ \\\par
    public: \\\par
    _I () : _J (_C, _M, _CC, _T) \{ \} \\\par
    protected: \\\par
    virtual {\cf18 bool} executeImpl () {\cf17 override}; \\\par
\};\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To simplify the way a new instruction is defined. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _C} \cell }{: Code. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _M} \cell }{: MemoryPositions occupied. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _CC} \cell }{: Clock cycles used. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _T} \cell }{: The templat to print the instruction. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _I} \cell }{: Name of the intruction. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _J} \cell }{: Name of the parent class. \cell }
{\row }
}
}{
Definition at line {\b 189} of file {\b Instruction.hpp}.}\par
}
{\xe \v _INST_IMPL\:Instruction.hpp}
{\xe \v Instruction.hpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _INST_IMPL( _I)\~ bool _I::executeImpl ()}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b Instruction.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Instruction.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Instruction.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Instruction.hpp}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_INSTRUCTION__}\par
00015 {\cf21 #define __MCHEMUL_INSTRUCTION__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/UBytes.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00022     {\cf17 class }CPU;\par
00023     {\cf17 class }Memory;\par
00024     {\cf17 class }Stack;\par
00025 \par
00027     {\cf17 class }Instruction\par
00028     \{\par
00029         {\cf17 public}:\par
00032         {\cf17 struct }Structure\par
00033         \{\par
00034             {\cf17 struct }Parameter\par
00035             \{\par
00036                 {\cf17 enum class} Type \{ _DATA = 0, _DIR, _RELJUMP, _ABSJUMP \};\par
00037 \par
00040                 {\cf17 static} std::map <unsigned char, Type> _TYPES;\par
00041 \par
00042                 Parameter () \par
00043                     : _type (Type::_DATA), _numberBytes (1)\par
00044                             \{ \}\par
00045 \par
00046                 Parameter (Type tp, {\cf18 size_t} nB)\par
00047                     : _type (tp), _numberBytes (nB)\par
00048                             \{ assert (_numberBytes > 0); \}\par
00049 \par
00050                 Parameter ({\cf17 const} Parameter&) = {\cf19 default};\par
00051 \par
00052                 Parameter& operator = ({\cf17 const} Parameter&) = {\cf19 default};\par
00053 \par
00054                 Type _type;\par
00055                 {\cf18 size_t} _numberBytes;\par
00056             \};\par
00057 \par
00058             Structure ()\par
00059                 : _error (false), _templateWithNoParameters ({\cf22 ""}), _waterMark ({\cf22 ""}), _waterMarkPlus ({\cf22 ""}), _parameters ()\par
00060                             \{ \}\par
00061 \par
00062             Structure ({\cf17 const} std::string& t, {\cf17 const} std::string& wM, {\cf17 const} std::vector <Parameter>& prms)\par
00063                 : _error (false), _templateWithNoParameters (t), _waterMark (wM), _parameters (prms)\par
00064                             \{ \}\par
00065 \par
00066             Structure ({\cf17 const} Structure&) = {\cf19 default};\par
00067 \par
00068             Structure& operator = ({\cf17 const} Structure&) = {\cf19 default};\par
00069 \par
00074             {\cf18 bool} _error; \par
00075             std::string _templateWithNoParameters;\par
00076             std::string _waterMark;\par
00077             std::string _waterMarkPlus;\par
00078             std::vector <Parameter> _parameters;\par
00079         \};\par
00080 \par
00081         Instruction () = {\cf17 delete};\par
00082 \par
00096         Instruction ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t);\par
00097 \par
00098         Instruction ({\cf17 const} Instruction&) = {\cf19 default};\par
00099 \par
00100         Instruction& operator = ({\cf17 const} Instruction&) = {\cf19 default};\par
00101 \par
00102         {\cf18 unsigned} {\cf18 int} code (){\cf17  const}\par
00103 {\cf17                             }\{ {\cf19 return} (_code); \}\par
00104         {\cf18 unsigned} {\cf18 int} memoryPositions (){\cf17  const}\par
00105 {\cf17                             }\{ {\cf19 return} (_memoryPositions); \}\par
00106         {\cf18 unsigned} {\cf18 int} clockCycles (){\cf17  const}\par
00107 {\cf17                             }\{ {\cf19 return} (_clockCycles); \}\par
00108         {\cf18 unsigned} {\cf18 int} additionalClockCycles (){\cf17  const}\par
00109 {\cf17                             }\{ {\cf19 return} (_additionalCycles); \}\par
00110         {\cf17 const} std::string iTemplate (){\cf17  const}\par
00111 {\cf17                             }\{ {\cf19 return} (_iTemplate); \}\par
00112         {\cf17 const} Structure& internalStructure (){\cf17  const}\par
00113 {\cf17                             }\{ {\cf19 return} (_iStructure); \}\par
00114 \par
00119         {\cf18 bool} matchesWith ({\cf17 const} std::string& i, std::vector <std::string>& prms);\par
00120 \par
00121         {\cf17 const} UBytes& parameters (){\cf17  const}\par
00122 {\cf17                             }\{ {\cf19 return} (_lastParameters); \}\par
00123         {\cf17 const} UBytes parameters ({\cf18 size_t} p, {\cf18 size_t} nP = 1, {\cf18 bool} bE = {\cf17 true}) {\cf17 const};\par
00124         std::string parametersAsString ({\cf18 size_t} p, {\cf18 size_t} nP = 1, {\cf18 bool} bE = {\cf17 true}) {\cf17 const}; {\cf20 // The UBytes could grouped to get a parameter...}\par
00125         std::string asString () {\cf17 const};\par
00126 \par
00129         {\cf18 bool} execute ({\cf17 const} UBytes& p, CPU* c, Memory* m, Stack* stk);\par
00130 \par
00131         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Instruction& i)\par
00132                             \{ {\cf19 return} (o << i.asString ()); \}\par
00133 \par
00134         {\cf17 protected}:\par
00136         Structure analyzeInstruction () {\cf17 const};\par
00137 \par
00140         {\cf17 virtual} {\cf18 bool} executeImpl () = 0;\par
00141 \par
00142         {\cf20 // Implementation}\par
00143         {\cf17 const} CPU* cpu (){\cf17  const}\par
00144 {\cf17                             }\{ {\cf19 return} (_cpu); \}\par
00145         CPU* cpu ()\par
00146                             \{ {\cf19 return} (_cpu); \}\par
00147         {\cf17 const} Memory* memory (){\cf17  const}\par
00148 {\cf17                             }\{ {\cf19 return} (_memory); \}\par
00149         Memory* memory () \par
00150                             \{ {\cf19 return} (_memory); \}\par
00151         {\cf17 const} Stack* stack (){\cf17  const}\par
00152 {\cf17                             }\{ {\cf19 return} (_stack); \}\par
00153         Stack* stack ()\par
00154                             \{ {\cf19 return} (_stack); \}\par
00155 \par
00156         {\cf17 protected}:\par
00157         {\cf20 // Once they assigned at construction level they couldn't be modified...}\par
00158         {\cf17 const} {\cf18 unsigned} {\cf18 int} _code = 0; \par
00159         {\cf17 const} {\cf18 unsigned} {\cf18 int} _memoryPositions = 0; \par
00160         {\cf17 const} {\cf18 unsigned} {\cf18 int} _clockCycles = 0; \par
00161         std::string _iTemplate; {\cf20 // It is modified during the construction...}\par
00162 \par
00163         {\cf20 // Implementation}\par
00164         {\cf20 // The internal structure helps us later to deal better with the instruction...}\par
00165         Structure _iStructure; \par
00166 \par
00167         {\cf18 unsigned} {\cf18 int} _additionalCycles; {\cf20 // Sometimes, when executed, }\par
00168                                         {\cf20 // an instruction could take more than expected... (@see additionalClockCylces method)}\par
00169 \par
00170         {\cf17 private}:\par
00171         MCHEmul::UBytes _lastParameters;\par
00172         MCHEmul::CPU* _cpu;\par
00173         MCHEmul::Memory* _memory;\par
00174         MCHEmul::Stack* _stack;\par
00175     \};\par
00176 \par
00177     {\cf17 using} Instructions = std::map <unsigned int, Instruction*>;\par
00178 \}\par
00179 \par
00189 {\cf21 #define _INST_FROM(_C, _M, _CC, _T, _I, _J) \\}\par
00190 {\cf21 class _I final : public _J \\}\par
00191 {\cf21 \{ \\}\par
00192 {\cf21     public: \\}\par
00193 {\cf21     _I () : _J (_C, _M, _CC, _T) \{ \} \\}\par
00194 {\cf21     protected: \\}\par
00195 {\cf21     virtual bool executeImpl () override; \\}\par
00196 {\cf21 \};}\par
00197 \par
00199 {\cf21 #define _INST(_C, _M, _CC, _T, _I) \\}\par
00200 {\cf21     _INST_FROM(_C, _M, _CC, _T, _I, MCHEmul::Instruction);}\par
00201 \par
00202 {\cf21 #define _INST_IMPL(_I) \\}\par
00203 {\cf21 bool _I::executeImpl ()}\par
00204 \par
00205 {\cf21 #endif}\par
00206   \par
00207 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/IO.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/IO.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/IO.hpp}
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Chip.hpp>}\par
{\f2 #include <CORE/IOPeripheral.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::IODevice}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::IODevices} = std::map< int, IODevice * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IO.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/IO.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/IO.hpp}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_IO__}\par
00015 {\cf21 #define __MCHEMUL_IO__}\par
00016 \par
00017 {\cf21 #include <CORE/Chip.hpp>}\par
00018 {\cf21 #include <CORE/IOPeripheral.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00030     {\cf17 class }IODevice\par
00031     \{\par
00032         {\cf17 public}:\par
00033         {\cf17 enum class} Type \{ _INPUT = 0, _OUTPUT, _INPUTOUTPUT \};\par
00034 \par
00035         IODevice () = {\cf17 delete};\par
00036 \par
00037         IODevice (Type t, {\cf18 int} {\cf18 id}, {\cf17 const} Attributes& attrs = \{ \});\par
00038 \par
00039         IODevice ({\cf17 const} IODevice&) = {\cf17 delete};\par
00040 \par
00041         IODevice& operator = ({\cf17 const} IODevice&) = {\cf17 delete};\par
00042 \par
00045         {\cf17 virtual} ~IODevice () \par
00046                             \{ \}\par
00047 \par
00048         Type type (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_type); \}\par
00050 \par
00051         {\cf18 int} id (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00053 \par
00054         {\cf17 const} Attributes& attributes (){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00056         {\cf17 const} std::string& attribute ({\cf17 const} std::string& aN){\cf17  const}\par
00057 {\cf17                             }\{ Attributes::const_iterator i = _attributes.find (aN); \par
00058                               {\cf19 return} ((i == _attributes.end ()) ? AttributedNotDefined : (*i).second); \}\par
00059 \par
00063         {\cf17 virtual} {\cf18 void} linkToChips ({\cf17 const} Chips& c)\par
00064                             \{ _chips = c; \}\par
00065         {\cf17 const} Chips& chips (){\cf17  const}\par
00066 {\cf17                             }\{ {\cf19 return} (_chips); \}\par
00067 \par
00068         {\cf20 // To manage the peripherals connected...}\par
00069         {\cf17 const} IOPeripherals& peripherals (){\cf17  const}\par
00070 {\cf17                             }\{ {\cf19 return} (_peripherals); \}\par
00071         {\cf18 bool} existsPeripheral ({\cf18 int} {\cf18 id}){\cf17  const}\par
00072 {\cf17                             }\{ {\cf19 return} (_peripherals.find ({\cf18 id}) != _peripherals.end ()); \}\par
00077         {\cf17 virtual} {\cf18 void} addPeripheral (IOPeripheral* p);\par
00079         {\cf18 void} removePeripheral ({\cf18 int} {\cf18 id});\par
00080 \par
00082         {\cf17 virtual} {\cf18 bool} initialize ();\par
00083 \par
00086         {\cf17 virtual} {\cf18 bool} simulate ();\par
00087 \par
00089         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00090 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00091 \par
00092         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} IODevice& d);\par
00093 \par
00094         {\cf17 protected}:\par
00095         {\cf17 const} Type _type; {\cf20 // Modified at constrution level}\par
00096         {\cf17 const} {\cf18 int} _id; {\cf20 // Idem}\par
00097         Chips _chips; {\cf20 // linked when computer instance is built!}\par
00098         {\cf17 const} Attributes _attributes = \{ \}; {\cf20 // Maybe modified at construction level}\par
00099         IOPeripherals _peripherals;\par
00100 \par
00101         {\cf20 // Implementation}\par
00102         {\cf17 mutable} {\cf18 unsigned} {\cf18 int} _lastError;\par
00103     \};\par
00104 \par
00106     {\cf17 using} IODevices = std::map <int, IODevice*>;\par
00107 \}\par
00108 \par
00109 {\cf21 #endif}\par
00110   \par
00111 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/IOPeripheral.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/IOPeripheral.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/IOPeripheral.hpp}
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::IOPeripheral}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::IOPeripherals} = std::map< int, IOPeripheral * >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IOPeripheral.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/IOPeripheral.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/IOPeripheral.hpp}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_IOPERIPHERAL__}\par
00015 {\cf21 #define __MCHEMUL_IOPERIPHERAL__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00021     {\cf17 class }IODevice;\par
00022 \par
00027     {\cf17 class }IOPeripheral\par
00028     \{\par
00029         {\cf17 public}:\par
00030         {\cf17 friend} IODevice;\par
00031 \par
00032         IOPeripheral () = {\cf17 delete};\par
00033 \par
00034         IOPeripheral ({\cf18 int} {\cf18 id}, {\cf17 const} Attributes& attrs = \{ \})\par
00035             : _id ({\cf18 id}), _attributes (), _device ({\cf17 nullptr}) \par
00036                             \{ \}\par
00037 \par
00038         IOPeripheral ({\cf17 const} IOPeripheral&) = {\cf17 delete};\par
00039 \par
00040         IOPeripheral& operator = ({\cf17 const} IOPeripheral&) = {\cf17 delete};\par
00041 \par
00042         {\cf17 virtual} ~IOPeripheral () \par
00043                             \{ \}\par
00044 \par
00045         {\cf18 int} id (){\cf17  const}\par
00046 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00047 \par
00048         {\cf17 const} Attributes& attributes (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00050         {\cf17 const} std::string& attribute ({\cf17 const} std::string& aN){\cf17  const}\par
00051 {\cf17                             }\{ Attributes::const_iterator i = _attributes.find (aN); \par
00052                               {\cf19 return} ((i == _attributes.end ()) ? AttributedNotDefined : (*i).second); \}\par
00053 \par
00054         {\cf17 const} IODevice* device (){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} (_device); \}\par
00056         IODevice* device ()\par
00057                             \{ {\cf19 return} (_device); \}\par
00058 \par
00061         {\cf17 virtual} {\cf18 bool} initialize () = 0;\par
00062 \par
00065         {\cf17 virtual} {\cf18 bool} simulate () = 0;\par
00066 \par
00067         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} IOPeripheral& d);\par
00068 \par
00069         {\cf17 protected}:\par
00070         {\cf17 const} {\cf18 int} _id; {\cf20 // Adjusted at construction level}\par
00071         {\cf17 const} Attributes _attributes = \{ \}; {\cf20 // Maybe modified at construction level}\par
00073 {\cf20 }        IODevice* _device;\par
00074     \};\par
00075 \par
00077     {\cf17 using} IOPeripherals = std::map <int, IOPeripheral*>;\par
00078 \}\par
00079 \par
00080 {\cf21 #endif}\par
00081   \par
00082 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/ProgramCounter.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/ProgramCounter.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/ProgramCounter.hpp}
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Register.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::ProgramCounter}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ProgramCounter.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/ProgramCounter.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/ProgramCounter.hpp}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_PROGRAMCOUNTER__}\par
00015 {\cf21 #define __MCHEMUL_PROGRAMCOUNTER__}\par
00016 \par
00017 {\cf21 #include <CORE/Register.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00023     {\cf17 class }ProgramCounter final : {\cf17 protected} Register\par
00024     \{\par
00025         {\cf17 public}:\par
00026         ProgramCounter ({\cf18 size_t} sz)\par
00027             : Register (-1 , {\cf22 "PC"}, UBytes (std::vector <UByte> (sz, UByte::_0))) \par
00028                             \{ \}\par
00029 \par
00030         ProgramCounter ({\cf17 const} ProgramCounter&) = {\cf19 default};\par
00031         ProgramCounter& operator = ({\cf17 const} ProgramCounter&) = {\cf19 default};\par
00032 \par
00033         {\cf18 void} initialize ()\par
00034                             \{ Register::initialize (); \}\par
00035 \par
00036         Address asAddress (){\cf17  const}\par
00037 {\cf17                             }\{ {\cf19 return} (Register::asAddress ({\cf17 true})); \}\par
00038         {\cf18 void} setAddress ({\cf17 const} Address& a)\par
00039                             \{ set (a.bytes ()); \}\par
00040 \par
00041         {\cf18 void} increment ({\cf18 size_t} n = 1)\par
00042                             \{ setAddress (asAddress ().next (n)); \}\par
00043         {\cf18 void} decrement ({\cf18 size_t} n = 1)\par
00044                             \{ setAddress (asAddress ().previous (n)); \}\par
00045 \par
00046         {\cf18 bool} operator == ({\cf17 const} Address& a){\cf17  const}\par
00047 {\cf17                             }\{ {\cf19 return} (asAddress () == a); \}\par
00048         {\cf18 bool} operator != ({\cf17 const} Address& a){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (asAddress () != a); \}\par
00050         {\cf18 bool} operator > ({\cf17 const} Address& a){\cf17  const}\par
00051 {\cf17                             }\{ {\cf19 return} (asAddress () > a); \}\par
00052         {\cf18 bool} operator >= ({\cf17 const} Address& a){\cf17  const}\par
00053 {\cf17                             }\{ {\cf19 return} (asAddress () >= a); \}\par
00054         {\cf18 bool} operator < ({\cf17 const} Address& a){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} (asAddress () < a); \}\par
00056         {\cf18 bool} operator <= ({\cf17 const} Address& a){\cf17  const}\par
00057 {\cf17                             }\{ {\cf19 return} (asAddress () != a); \}\par
00058 \par
00059         ProgramCounter operator + ({\cf18 size_t} n){\cf17  const}\par
00060 {\cf17                             }\{ ProgramCounter r = *{\cf17 this}; r.increment (n); {\cf19 return} (r); \}\par
00061         ProgramCounter& operator += ({\cf18 size_t} n)\par
00062                             \{ increment (n); {\cf19 return} (*{\cf17 this}); \}\par
00063         ProgramCounter operator - ({\cf18 size_t} n){\cf17  const}\par
00064 {\cf17                             }\{ ProgramCounter r = *{\cf17 this}; r.decrement (n); {\cf19 return} (r); \}\par
00065         ProgramCounter& operator -= ({\cf18 size_t} n)\par
00066                             \{ decrement (n); {\cf19 return} (*{\cf17 this}); \}\par
00067 \par
00068         std::string asString (UByte::OutputFormat oF){\cf17  const}\par
00069 {\cf17                             }\{ {\cf19 return} (asAddress ().asString (oF)); \}\par
00070 \par
00071         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} ProgramCounter& pc);\par
00072     \};\par
00073 \}\par
00074 \par
00075 {\cf21 #endif}\par
00076   \par
00077 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Register.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Register.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Register.hpp}
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <CORE/Address.hpp>}\par
{\f2 #include <CORE/UBytes.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Register}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b MCHEmul::Registers} = std::vector< Register >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Register.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Register.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Register.hpp}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_REGISTER__}\par
00015 {\cf21 #define __MCHEMUL_REGISTER__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 {\cf21 #include <CORE/Address.hpp>}\par
00019 {\cf21 #include <CORE/UBytes.hpp>}\par
00020 \par
00021 {\cf17 namespace }MCHEmul\par
00022 \{\par
00025     {\cf17 class }Register\par
00026     \{\par
00027         {\cf17 public}:\par
00028         Register () = {\cf17 delete};\par
00029 \par
00030         Register ({\cf18 int} {\cf18 id}, {\cf17 const} std::string& n, {\cf17 const} UBytes& v )\par
00031             : _id (id), _name (n), _values (v) \par
00032                             \{ \}\par
00033 \par
00034         Register ({\cf18 int} {\cf18 id}, {\cf17 const} std::string& n, {\cf17 const} std::vector <UByte>&v )\par
00035             : _id (id), _name (n), _values (v) \par
00036                             \{ \}\par
00037 \par
00038         Register ({\cf17 const} Register&) = {\cf19 default};\par
00039 \par
00040         Register& operator = ({\cf17 const} Register&) = {\cf19 default};\par
00041 \par
00043         {\cf18 void} initialize ()\par
00044                             \{ _values.to0 (); \}\par
00045 \par
00046         {\cf18 int} id (){\cf17  const}\par
00047 {\cf17                             }\{ {\cf19 return} (_id); \}\par
00048         {\cf17 const} std::string& name (){\cf17  const}\par
00049 {\cf17                             }\{ {\cf19 return} (_name); \}\par
00050         {\cf18 size_t} size (){\cf17  const}\par
00051 {\cf17                             }\{ {\cf19 return} (_values.size ()); \}\par
00052 \par
00053         {\cf17 const} UBytes& values (){\cf17  const}\par
00054 {\cf17                             }\{ {\cf19 return} (_values); \}\par
00055         {\cf17 const} std::vector <UByte>& bytes (){\cf17  const}\par
00056 {\cf17                             }\{ {\cf19 return} (_values.bytes ()); \}\par
00057 \par
00058         UInt asUInt ({\cf18 bool} bE){\cf17  const}\par
00059 {\cf17                             }\{ {\cf19 return} (UInt (_values, bE)); \}\par
00060         Address asAddress ({\cf18 bool} bE){\cf17  const}\par
00061 {\cf17                             }\{ {\cf19 return} (Address (UInt (_values, bE))); \}\par
00062 \par
00064         {\cf18 bool} accept ({\cf17 const} UBytes& v){\cf17  const}\par
00065 {\cf17                             }\{ {\cf19 return} (size () == v.size ()); \}\par
00066 \par
00068         {\cf18 void} set ({\cf17 const} std::vector <UByte>& v)\par
00069                             \{ {\cf19 if} (accept (v)) _values = v; \}\par
00070         {\cf18 void} set ({\cf17 const} UBytes& v)\par
00071                             \{ {\cf19 if} (accept (v)) _values = v; \}\par
00073         {\cf18 void} set ({\cf17 const} Register& r)\par
00074                             \{ set (r.values ()); \}\par
00075 \par
00076         {\cf18 bool} operator == ({\cf17 const} Register& r){\cf17  const}\par
00077 {\cf17                             }\{ {\cf19 return} (_values == r._values); \}\par
00078         {\cf18 bool} operator != ({\cf17 const} Register& r){\cf17  const}\par
00079 {\cf17                             }\{ {\cf19 return} (_values != r._values); \}\par
00080 \par
00081         UByte operator [] ({\cf18 size_t} p){\cf17  const}\par
00082 {\cf17                             }\{ {\cf19 return} (_values [p]); \}\par
00083 \par
00084         std::string asString (UByte::OutputFormat oF, {\cf18 char} s , {\cf18 size_t} l = 0 ){\cf17  const}\par
00085 {\cf17                             }\{ {\cf19 return} (_values.asString (oF, s, l)); \}\par
00086             \par
00087         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Register& r);\par
00088 \par
00089         {\cf17 protected}:\par
00090         {\cf17 const} {\cf18 int} _id;\par
00091         {\cf17 const} std::string _name;\par
00092         UBytes _values;\par
00093     \};\par
00094 \par
00095     {\cf17 using} Registers = std::vector <Register>;\par
00096 \par
00098     {\cf17 static} {\cf17 const} Register NoRegister = Register (0, {\cf22 "-"}, UBytes ());\par
00099 \par
00100     {\cf20 // Implementation}\par
00102 {\cf20 }    {\cf17 static} Register TrashRegister = Register (0, {\cf22 "-"}, UBytes ());\par
00103 \}\par
00104 \par
00105 {\cf21 #endif}\par
00106   \par
00107 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/ScreenMemory.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/ScreenMemory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/ScreenMemory.hpp}
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::ScreenMemory}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ScreenMemory.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/ScreenMemory.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/ScreenMemory.hpp}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_SCREENMEMORY__}\par
00015 {\cf21 #define __MCHEMUL_SCREENMEMORY__}\par
00016 \par
00017 {\cf17 namespace }MCHEmul\par
00018 \{\par
00022     {\cf17 class }ScreenMemory\par
00023     \{\par
00024         {\cf17 public}:\par
00025         ScreenMemory () = {\cf17 delete};\par
00026 \par
00027         ScreenMemory ({\cf18 size_t} c, {\cf18 size_t} r, {\cf18 unsigned} {\cf18 int}* p);\par
00028 \par
00029         ScreenMemory ({\cf17 const} ScreenMemory&) = {\cf17 delete};\par
00030 \par
00031         ScreenMemory& operator = ({\cf17 const} ScreenMemory&) = {\cf17 delete};\par
00032 \par
00033         ~ScreenMemory ()\par
00034                             \{ {\cf17 delete} (_frameData); {\cf17 delete} (_colorPalette);\}\par
00035 \par
00036         {\cf20 // Size...}\par
00037         {\cf18 size_t} columns (){\cf17  const}\par
00038 {\cf17                             }\{ {\cf19 return} (_columns); \}\par
00039         {\cf18 size_t} rows (){\cf17  const}\par
00040 {\cf17                             }\{ {\cf19 return} (_rows); \}\par
00041         {\cf17 const} {\cf18 unsigned} {\cf18 int}* frameData (){\cf17  const}\par
00042 {\cf17                             }\{ {\cf19 return} (_frameData); \}\par
00043 \par
00044         {\cf20 // Managing basically the pixels of the frame...}\par
00045         {\cf18 void} setPixel ({\cf18 size_t} x, {\cf18 size_t} y, {\cf18 unsigned} {\cf18 int} color)\par
00046                             \{ _frameData [y * _columns + x] = _colorPalette [color]; \}\par
00047         {\cf18 void} setHorizontalLine ({\cf18 size_t} x, {\cf18 size_t} y, {\cf18 size_t} nP, {\cf18 unsigned} {\cf18 int} color)\par
00048                             \{ {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < nP; setPixel (x + i++, y, color)); \}\par
00049         {\cf18 void} setVerticalLine ({\cf18 size_t} x, {\cf18 size_t} y, {\cf18 size_t} nP, {\cf18 unsigned} {\cf18 int} color)\par
00050                             \{ {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < nP; setPixel (x, y + i++, color)); \}\par
00051 \par
00052         {\cf17 private}:\par
00053         {\cf18 unsigned} {\cf18 int}* _frameData;\par
00054         {\cf18 size_t} _columns, _rows;\par
00055         {\cf18 unsigned} {\cf18 int}* _colorPalette;\par
00056     \};\par
00057 \}\par
00058 \par
00059 {\cf21 #endif}\par
00060   \par
00061 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/Stack.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Stack.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Stack.hpp}
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Memory.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::Stack}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Stack.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/Stack.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/Stack.hpp}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_STACK__}\par
00015 {\cf21 #define __MCHEMUL_STACK__}\par
00016 \par
00017 {\cf21 #include <CORE/Memory.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00021     {\cf17 class }Stack : {\cf17 public} PhisicalStorageSubset\par
00022     \{\par
00023         {\cf17 public}:\par
00029         Stack ({\cf18 int} {\cf18 id}, PhisicalStorage* ps, {\cf18 size_t} pp, {\cf17 const} Address& iA, {\cf18 size_t} s, {\cf18 bool} b = {\cf17 true}, {\cf18 bool} e = {\cf17 true})\par
00030             : PhisicalStorageSubset (id, ps, pp, iA, s), \par
00031               _position (0), _fromBack (b), _pointToEmpty (e),\par
00032               _stackOverflow (false),\par
00033               _empty (true)\par
00034                             \{ \}\par
00035 \par
00036         {\cf18 size_t} position (){\cf17  const}\par
00037 {\cf17                             }\{ {\cf19 return} (_position); \}\par
00040         {\cf18 void} setPosition ({\cf18 int} p)\par
00041                             \{ _position = p; \}\par
00042 \par
00043         {\cf17 virtual} {\cf18 void} initialize () {\cf17 override};\par
00044 \par
00045         {\cf18 void} push ({\cf17 const} UBytes& v);\par
00046         UBytes pull ({\cf18 size_t} nV);\par
00047 \par
00049         {\cf18 bool} stackOverflow (){\cf17  const}\par
00050 {\cf17                             }\{ {\cf19 return} (_stackOverflow); \}\par
00051 \par
00052         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} Stack& s);\par
00053 \par
00054         {\cf17 private}:\par
00055         {\cf18 int} _position;\par
00056         {\cf17 const} {\cf18 bool} _fromBack = {\cf17 true}; {\cf20 // Adapted at construction time}\par
00057         {\cf17 const} {\cf18 bool} _pointToEmpty = {\cf17 true}; {\cf20 // Ad\'E0ted at construction time}\par
00058 \par
00059         {\cf20 // Implementation}\par
00060         {\cf18 bool} _stackOverflow;\par
00061         {\cf18 bool} _empty;\par
00062     \};\par
00063 \}\par
00064 \par
00065 {\cf21 #endif}\par
00066   \par
00067 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/StatusRegister.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/StatusRegister.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/StatusRegister.hpp}
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Register.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::StatusRegister}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StatusRegister.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/StatusRegister.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/StatusRegister.hpp}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_STATUSREGISTER__}\par
00015 {\cf21 #define __MCHEMUL_STATUSREGISTER__}\par
00016 \par
00017 {\cf21 #include <CORE/Register.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00022     {\cf17 class }StatusRegister : {\cf17 protected} Register\par
00023     \{\par
00024         {\cf17 public}:\par
00025         {\cf17 using} BitNames = std::map <std::string, int>;\par
00026 \par
00027         StatusRegister ({\cf18 size_t} nB, {\cf17 const} BitNames& bN)\par
00028             : Register (-2 , {\cf22 "ST"}, UBytes (std::vector <UByte> (nB, UByte::_0))), \par
00029               _bitNames (bN)\par
00030                             \{\}\par
00031 \par
00032         StatusRegister ({\cf17 const} StatusRegister&) = {\cf19 default};\par
00033 \par
00034         StatusRegister& operator = ({\cf17 const} StatusRegister&) = {\cf19 default};\par
00035 \par
00036         {\cf18 void} initialize ()\par
00037                             \{ Register::initialize (); \}\par
00038 \par
00039         {\cf17 const} BitNames& bitNames (){\cf17  const}\par
00040 {\cf17                             }\{ {\cf19 return} (_bitNames); \}\par
00041         {\cf18 bool} existsBitStatus ({\cf17 const} std::string& bN){\cf17  const}\par
00042 {\cf17                             }\{ {\cf19 return} (_bitNames.find (bN) != _bitNames.end ()); \}\par
00044         {\cf18 bool} bitStatus ({\cf17 const} std::string& bN){\cf17  const}\par
00045 {\cf17                             }\{ {\cf19 return} (_values.bit ((*_bitNames.find (bN)).second)); \}\par
00046         {\cf18 void} setBitStatus ({\cf17 const} std::string& bN, {\cf18 bool} s)\par
00047                             \{ _values.setBit ((*_bitNames.find (bN)).second, s); \}\par
00048 \par
00049         {\cf17 const} UBytes& values (){\cf17  const}\par
00050 {\cf17                             }\{ {\cf19 return} (Register::values ()); \}\par
00051         {\cf17 const} std::vector <UByte>& bytes (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (Register::bytes ()); \}\par
00053 \par
00054         UBytes valuesWithout ({\cf17 const} std::vector <std::string>& bN);\par
00055         {\cf18 void} set ({\cf17 const} std::vector <UByte>& v)\par
00056                             \{ Register::set (v); \}\par
00057         {\cf18 void} set ({\cf17 const} UBytes& v)\par
00058                             \{ Register::set (v); \}\par
00059 \par
00060         std::string asString () {\cf17 const};\par
00061 \par
00062         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} StatusRegister& r)\par
00063                             \{ {\cf19 return} (o << r.asString ()); \}\par
00064 \par
00065         {\cf17 private}:\par
00066         {\cf17 const} BitNames _bitNames; \par
00067     \};\par
00068 \}\par
00069 \par
00070 {\cf21 #endif}\par
00071   \par
00072 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/UByte.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/UByte.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/UByte.hpp}
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UByte}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UByte.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/UByte.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/UByte.hpp}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_UBYTE__}\par
00015 {\cf21 #define __MCHEMUL_UBYTE__}\par
00016 \par
00017 {\cf21 #include <CORE/global.hpp>}\par
00018 \par
00019 {\cf17 namespace }MCHEmul\par
00020 \{\par
00024     {\cf17 class }UByte final\par
00025     \{\par
00026         {\cf17 public}:\par
00027         {\cf17 enum class} OutputFormat\par
00028         \{\par
00029             _DECIMAL,\par
00030             _BINARY,\par
00031             _OCTAL,\par
00032             _HEXA\par
00033         \};\par
00034 \par
00035         {\cf20 // Most common values}\par
00036         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _0       = 0x00;\par
00037         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _1       = 0x01;             {\cf20 // Used e.g in adding to get complement_2!}\par
00038         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _FF      = 0xff;\par
00039         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _0F      = 0x0f;             {\cf20 // Used to extract the LS Nibble}\par
00040         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _F0      = 0xf0;             {\cf20 // Used to extract the MS Nibble}\par
00041         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _80      = 0x80;             {\cf20 // Used to test the sign...}\par
00042         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _09      = 0x09;             {\cf20 // Used in BCD limits...}\par
00043         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _90      = 0x90;             {\cf20 // Used in BCD limits...}\par
00044         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _09N     = ~_09 + 1;         {\cf20 // Used in BCD limits...}\par
00045         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _90N     = ~_90 + 1;         {\cf20 // Used in BCD limits...}\par
00046         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _06      = 0x06;             {\cf20 // Used in BCD operations...}\par
00047         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _60      = 0x60;             {\cf20 // Used in BCD operations...}\par
00048         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _06N     = ~_06 + _1;        {\cf20 // Used in BCD operations...}\par
00049         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _60N     = ~_60 + _1;        {\cf20 // Used in BCD operations...}\par
00050 \par
00051         UByte ()\par
00052             : _value (_0)\par
00053                             \{ \}\par
00054 \par
00055         UByte ({\cf18 unsigned} {\cf18 char} v)\par
00056             : _value (v)\par
00057                             \{ \}\par
00058 \par
00059         UByte ({\cf17 const} UByte&) = {\cf19 default};\par
00060         UByte& operator = ({\cf17 const} UByte&) = {\cf19 default};\par
00061 \par
00063         {\cf17 static} {\cf18 size_t} size () {\cf20 // (static) Alol the same...}\par
00064                             \{ {\cf19 return} ({\cf17 sizeof} ({\cf18 unsigned} {\cf18 char})); \}\par
00065         {\cf17 static} {\cf18 size_t} sizeBits () {\cf20 // (static) All the same...}\par
00066                             \{ {\cf19 return} ({\cf17 sizeof} ({\cf18 unsigned} {\cf18 char}) << 3); \}\par
00067 \par
00068         {\cf18 unsigned} {\cf18 char} value (){\cf17  const}\par
00069 {\cf17                             }\{ {\cf19 return} (_value); \}\par
00070 \par
00073         {\cf18 bool} bit ({\cf18 size_t} p){\cf17  const}\par
00074 {\cf17                             }\{ {\cf19 return} ((_value & (_1 << p)) != _0); \}\par
00075         {\cf18 void} setBit ({\cf18 size_t} p, {\cf18 bool} s)\par
00076                             \{ {\cf18 unsigned} {\cf18 char} v = _1 << p; _value = _value & (~v) | (s ? v : _0); \}\par
00077 \par
00078         UByte LSNibble (){\cf17  const}\par
00079 {\cf17                             }\{ {\cf19 return} (UByte (_value & _0F)); \}\par
00080         UByte MSNibble (){\cf17  const}\par
00081 {\cf17                             }\{ {\cf19 return} (UByte (_value & _F0)); \}\par
00082 \par
00084         UByte complement (){\cf17  const}\par
00085 {\cf17                             }\{ {\cf19 return} (~_value); \}\par
00086 \par
00087         {\cf18 bool} shiftLeftC ({\cf18 bool} c = {\cf17 false} , {\cf18 size_t} p = 1);\par
00088         UByte& shiftLeft ({\cf18 size_t} p = 1)\par
00089                         \{ shiftLeftC ({\cf17 false}, p); {\cf19 return} (*{\cf17 this}); \}\par
00090         {\cf18 bool} shiftRightC ({\cf18 bool} c = {\cf17 false}, {\cf18 size_t} p = 1);\par
00091         UByte& shiftRight ({\cf18 size_t} p = 1)\par
00092                         \{ shiftRightC ({\cf17 false}, p); {\cf19 return} (*{\cf17 this}); \}\par
00093 \par
00094         {\cf18 bool} rotateLeftC ({\cf18 bool} c = {\cf17 false} , {\cf18 size_t} p = 1);\par
00095         UByte& rotateLeft ({\cf18 size_t} p = 1 );\par
00096         {\cf18 bool} rotateRightC ({\cf18 bool} c = {\cf17 false}, {\cf18 size_t} p = 1);\par
00097         UByte& rotateRight ({\cf18 size_t} p = 1);\par
00098 \par
00108         {\cf17 inline} UByte bitAdding ({\cf17 const} UByte& u, {\cf18 bool} cin, {\cf18 bool}& cout, {\cf18 bool}& o) {\cf17 const};\par
00109 \par
00110         {\cf18 bool} operator == ({\cf17 const} UByte& u){\cf17  const}\par
00111 {\cf17                             }\{ {\cf19 return} (_value == u._value); \}\par
00112         {\cf18 bool} operator != ({\cf17 const} UByte& u){\cf17  const}\par
00113 {\cf17                             }\{ {\cf19 return} (_value != u._value); \}\par
00114         {\cf18 bool} operator > ({\cf17 const} UByte& u){\cf17  const}\par
00115 {\cf17                             }\{ {\cf19 return} (_value > u._value); \}\par
00116         {\cf18 bool} operator >= ({\cf17 const} UByte& u){\cf17  const}\par
00117 {\cf17                             }\{ {\cf19 return} (_value >= u._value); \}\par
00118         {\cf18 bool} operator < ({\cf17 const} UByte& u){\cf17  const}\par
00119 {\cf17                             }\{ {\cf19 return} (_value == u._value); \}\par
00120         {\cf18 bool} operator <= ({\cf17 const} UByte& u){\cf17  const}\par
00121 {\cf17                             }\{ {\cf19 return} (_value <= u._value); \}\par
00122 \par
00123         UByte operator & ({\cf17 const} UByte& u){\cf17  const}\par
00124 {\cf17                             }\{ {\cf19 return} (_value & u._value); \}\par
00125         UByte& operator &= ({\cf17 const} UByte& u)\par
00126                             \{ *{\cf17 this} = *{\cf17 this} & u; {\cf19 return} (*{\cf17 this}); \}\par
00127         UByte operator | ({\cf17 const} UByte& u){\cf17  const}\par
00128 {\cf17                             }\{ {\cf19 return} (_value | u._value); \}\par
00129         UByte& operator |= ({\cf17 const} UByte& u)\par
00130                             \{ *{\cf17 this} = *{\cf17 this} | u; {\cf19 return} (*{\cf17 this}); \}\par
00131         UByte operator ^ ({\cf17 const} UByte& u){\cf17  const}\par
00132 {\cf17                             }\{ {\cf19 return} (_value ^ u._value); \}\par
00133         UByte& operator ^= ({\cf17 const} UByte& u)\par
00134                             \{ *{\cf17 this} = *{\cf17 this} ^ u; {\cf19 return} (*{\cf17 this}); \}\par
00135         UByte operator ~ (){\cf17  const}\par
00136 {\cf17                             }\{ {\cf19 return} (complement ()); \}\par
00137 \par
00138         {\cf18 bool} operator [] ({\cf18 size_t} p){\cf17  const}\par
00139 {\cf17                             }\{ {\cf19 return} (bit (p)); \}\par
00140         UByte& operator << ({\cf18 size_t} p)\par
00141                             \{ {\cf19 return} (shiftLeft (p)); \}\par
00142         UByte& operator >> ({\cf18 size_t} p)\par
00143                             \{ {\cf19 return} (shiftRight (p)); \}\par
00144 \par
00145         std::string asString (OutputFormat oF, {\cf18 size_t} l = 0 ) {\cf17 const};\par
00146 \par
00147         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} UByte& u)\par
00148                             \{ {\cf19 return} (o << u.asString (UByte::OutputFormat::_HEXA, 2)); \}\par
00149 \par
00150         {\cf17 private}:\par
00151         {\cf18 unsigned} {\cf18 char} _value; {\cf20 // 8 bits - length (@see static method size)}\par
00152     \};\par
00153 \par
00154     {\cf20 // This piece of the code should be inline ever!}\par
00155     {\cf20 // This is the very basic adder!}\par
00156     {\cf17 inline} UByte UByte::bitAdding ({\cf17 const} UByte& u, {\cf18 bool} cin, {\cf18 bool}& cout, {\cf18 bool}& o){\cf17  const}\par
00157 {\cf17     }\{\par
00158         {\cf18 unsigned} {\cf18 short} r = \par
00159             ({\cf18 unsigned} short) (_value + u._value + \par
00160                 (cin ? 0x01  : 0x00));\par
00161 \par
00162         {\cf20 // The carry is generated if the result is bigger than a unsigned char long!}\par
00163         cout = (r & 0xff00 ) != 0x000; \par
00164         {\cf20 // The overflow is generated when both are negative and the outcome positive...or the other way around!}\par
00165         o = (bit (7) && u.bit (7) && ((r & 0x0080) == 0x0000)) |  \par
00166                 (!bit (7) && !u.bit (7) && ((r & 0x0080) != 0x0000)); \par
00167 \par
00168         {\cf19 return} (MCHEmul::UByte (({\cf18 unsigned} {\cf18 char})  r));\par
00169     \}\par
00170 \}\par
00171 \par
00172 {\cf21 #endif}\par
00173   \par
00174 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/UBytes.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/UBytes.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/UBytes.hpp}
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/UByte.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UBytes}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UBytes.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/UBytes.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/UBytes.hpp}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00015 {\cf21 #ifndef __MCHEMUL_UBYTES__}\par
00016 {\cf21 #define __MCHEMUL_UBYTES__}\par
00017 \par
00018 {\cf21 #include <CORE/UByte.hpp>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00023     {\cf17 class }UBytes final\par
00024     \{\par
00025         {\cf17 public}:\par
00026         {\cf17 static} {\cf17 const} UBytes _E;\par
00027 \par
00028         UBytes ()\par
00029             : _values ()\par
00030                             \{ \}\par
00031 \par
00032         UBytes ({\cf17 const} std::vector <UByte>& v, {\cf18 bool} bE = {\cf17 true})\par
00033             : _values (v)\par
00034                             \{ {\cf19 if} (size () > 1 && !bE) _values = reverse ().bytes (); \}\par
00035 \par
00036         UBytes ({\cf17 const} UBytes&) = {\cf19 default};\par
00037         UBytes& operator = ({\cf17 const} UBytes&) = {\cf19 default};\par
00038 \par
00039         {\cf18 size_t} size (){\cf17  const}\par
00040 {\cf17                             }\{ {\cf19 return} (_values.size ()); \}\par
00041         {\cf18 size_t} sizeBits (){\cf17  const}\par
00042 {\cf17                             }\{ {\cf19 return} (size () * UByte::sizeBits ()); \}\par
00043 \par
00044         {\cf18 void} setMinLength ({\cf18 size_t} l, {\cf18 bool} r = {\cf17 true} );\par
00045 \par
00046         {\cf17 const} UByte& value ({\cf18 size_t} p){\cf17  const}\par
00047 {\cf17                             }\{ {\cf19 return} (_values [p]); \}\par
00048         UByte& value ({\cf18 size_t} p)\par
00049                             \{ {\cf19 return} (_values [p]); \}\par
00050 \par
00051         {\cf17 const} std::vector <UByte>& bytes (){\cf17  const}\par
00052 {\cf17                             }\{ {\cf19 return} (_values); \}\par
00053 \par
00054         UBytes LSUBytes ({\cf18 size_t} p){\cf17  const}\par
00055 {\cf17                             }\{ {\cf19 return} (UBytes ((p >= size ()) ? bytes ()\par
00056                                 : std::vector <UByte> (bytes ().begin () + (bytes ().size () - p), bytes ().end ()))); \}\par
00057         UBytes MSUBytes ({\cf18 size_t} p){\cf17  const}\par
00058 {\cf17                             }\{ {\cf19 return} (UBytes (((p >= size ()) ? bytes () \par
00059                                 : std::vector <UByte> (bytes ().begin (), bytes ().begin () + p - 1)))); \}\par
00060 \par
00063         {\cf18 bool} bit ({\cf18 size_t} p){\cf17  const }\par
00064 {\cf17                             }\{ {\cf19 return} (_values [size () - (p / UByte::sizeBits ()) - 1][p % UByte::sizeBits ()]); \}\par
00065         {\cf18 void} setBit ({\cf18 size_t} p, {\cf18 bool} s)\par
00066                             \{ _values [size () - (p / UByte::sizeBits ()) - 1].setBit (p % UByte::sizeBits (), s); \}\par
00067         \par
00068         {\cf18 void} to0 ()\par
00069                             \{ {\cf19 for} ({\cf17 auto} i : _values) i = UByte::_0; \}\par
00070         {\cf18 void} toFF ()\par
00071                             \{ {\cf19 for} ({\cf17 auto} i : _values) i = UByte::_FF; \}\par
00072 \par
00073         UBytes complement () {\cf17 const};\par
00074 \par
00075         {\cf18 bool} shiftLeftC ({\cf18 bool} c = {\cf17 false} , {\cf18 size_t} p = 1);\par
00076         UBytes& shiftLeft ({\cf18 size_t} p = 1)\par
00077                             \{ shiftLeftC ({\cf17 false}, p); {\cf19 return} (*{\cf17 this}); \}\par
00078         {\cf18 bool} shiftRightC ({\cf18 bool} c = {\cf17 false}, {\cf18 size_t} p = 1);\par
00079         UBytes& shiftRight ({\cf18 size_t} p = 1)\par
00080                             \{ shiftRightC ({\cf17 false}, p); {\cf19 return} (*{\cf17 this}); \}\par
00081         {\cf18 bool} rotateLeftC ({\cf18 bool} c = {\cf17 false}, {\cf18 size_t} p = 1);\par
00082         UBytes& rotateLeft ({\cf18 size_t} p = 1);\par
00083         {\cf18 bool} rotateRightC ({\cf18 bool} c = {\cf17 false}, {\cf18 size_t} p = 1);\par
00084         UBytes& rotateRight ({\cf18 size_t} p = 1);\par
00085 \par
00095         UBytes bitAdding ({\cf17 const} UBytes& u, {\cf18 bool} cin, {\cf18 bool}& cout, {\cf18 bool}& o) {\cf17 const};\par
00096 \par
00097         UBytes reverse () {\cf17 const};\par
00098 \par
00099         {\cf18 bool} operator == ({\cf17 const} UBytes& u) {\cf17 const};\par
00100         {\cf18 bool} operator != ({\cf17 const} UBytes& u){\cf17  const}\par
00101 {\cf17                             }\{ {\cf19 return} (!(*{\cf17 this} == u)); \}\par
00102 \par
00103         UByte operator [] ({\cf18 size_t} p){\cf17  const}\par
00104 {\cf17                             }\{ {\cf19 return} (value (p)); \}\par
00105         UByte& operator [] ({\cf18 size_t} p) \par
00106                             \{ {\cf19 return} (value (p)); \}\par
00107         UBytes& operator << ({\cf18 size_t} p)\par
00108                             \{ {\cf19 return} (shiftLeft (p)); \}\par
00109         UBytes& operator >> ({\cf18 size_t} p)\par
00110                             \{ {\cf19 return} (shiftRight (p)); \}\par
00111 \par
00112         std::string asString (UByte::OutputFormat oF, {\cf18 char} s , {\cf18 size_t} l = 0 ) {\cf17 const};\par
00113 \par
00114         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} UBytes& u)\par
00115                             \{ {\cf19 return} (o << u.asString (UByte::OutputFormat::_HEXA, {\cf23 ' '}, 2)); \}\par
00116 \par
00117         {\cf17 private}:\par
00119         std::vector <UByte> _values;\par
00120     \};\par
00121 \}\par
00122 \par
00123 {\cf21 #endif}\par
00124   \par
00125 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/CORE/UInt.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/UInt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/UInt.hpp}
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/UBytes.hpp>}\par
{\f2 #include <map>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UInt::FormatManager}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UInt::BinaryFormatManager}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UInt::PackagedBCDFormatManager}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MCHEmul::UInt::FormatManagers}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b MCHEmul}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UInt.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/CORE/UInt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/CORE/UInt.hpp}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_UINT__}\par
00015 {\cf21 #define __MCHEMUL_UINT__}\par
00016 \par
00017 {\cf21 #include <CORE/UBytes.hpp>}\par
00018 {\cf21 #include <map>}\par
00019 \par
00020 {\cf17 namespace }MCHEmul\par
00021 \{\par
00033     {\cf17 class }UInt final\par
00034     \{\par
00035         {\cf17 public}:\par
00038         {\cf17 class }FormatManager\par
00039         \{\par
00040             {\cf17 public}:\par
00041             FormatManager () = {\cf19 default};\par
00042 \par
00044             {\cf17 virtual} UInt add ({\cf17 const} UInt&, {\cf17 const} UInt&, {\cf18 bool}) {\cf17 const} = 0;\par
00046             {\cf17 virtual} UInt substract ({\cf17 const} UInt&, {\cf17 const} UInt&, {\cf18 bool}) {\cf17 const} = 0;\par
00047 \par
00048             {\cf17 virtual} {\cf18 unsigned} {\cf18 int} asUnsignedInt ({\cf17 const} UInt&) {\cf17 const} = 0;\par
00049 \par
00050             {\cf17 virtual} UInt fromUnsignedInt ({\cf18 unsigned} {\cf18 int} n) = 0;\par
00051             {\cf17 virtual} UInt fromInt ({\cf18 int} n) = 0;\par
00052         \};\par
00053 \par
00055         {\cf17 class }BinaryFormatManager final : {\cf17 public} FormatManager\par
00056         \{\par
00057             {\cf17 public}:\par
00059             {\cf17 virtual} UInt add ({\cf17 const} UInt& u1, {\cf17 const} UInt& u2, {\cf18 bool} cIn) {\cf17 const};\par
00060             {\cf17 virtual} UInt substract ({\cf17 const} UInt& u1, {\cf17 const} UInt& u2, {\cf18 bool} cIn) {\cf17 const};\par
00061 \par
00062             {\cf17 virtual} {\cf18 unsigned} {\cf18 int} asUnsignedInt ({\cf17 const} UInt& u) {\cf17 const override};\par
00063             \par
00064             {\cf17 virtual} UInt fromUnsignedInt ({\cf18 unsigned} {\cf18 int} n);\par
00065             {\cf17 virtual} UInt fromInt ({\cf18 int} n);\par
00066         \};\par
00067 \par
00069         {\cf17 class }PackagedBCDFormatManager final : {\cf17 public} FormatManager\par
00070         \{\par
00071             {\cf17 public}:\par
00072             {\cf17 virtual} UInt add ({\cf17 const} UInt& u1, {\cf17 const} UInt& u2, {\cf18 bool} cIn) {\cf17 const};\par
00073             {\cf17 virtual} UInt substract ({\cf17 const} UInt& u1, {\cf17 const} UInt& u2, {\cf18 bool} cIn) {\cf17 const};\par
00074 \par
00075             {\cf17 virtual} {\cf18 unsigned} {\cf18 int} asUnsignedInt ({\cf17 const} UInt& u) {\cf17 const override};\par
00076 \par
00077             {\cf17 virtual} UInt fromUnsignedInt ({\cf18 unsigned} {\cf18 int} n);\par
00078             {\cf17 virtual} UInt fromInt ({\cf18 int} n);\par
00079         \};\par
00080 \par
00081         {\cf20 // The different types of formats...}\par
00083 {\cf20 }        {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _BINARY = 0x00;\par
00085         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _PACKAGEDBCD = 0x01;\par
00086 \par
00089         {\cf17 class }FormatManagers final\par
00090         \{\par
00091             {\cf17 public}:\par
00093             FormatManagers ({\cf17 const} std::map <unsigned char, FormatManager*>& fM)\par
00094                 : _formatManagers (fM)\par
00095                             \{ {\cf19 if} (_instance != {\cf17 nullptr}) exit (0); \}\par
00096 \par
00097             ~FormatManagers ()\par
00098                             \{ _instance = {\cf17 nullptr}; {\cf19 for} ({\cf17 auto} i : _formatManagers) {\cf17 delete} (i.second);\}\par
00099 \par
00100             {\cf17 public}:\par
00103             std::map <unsigned char, FormatManager*> _formatManagers;\par
00104 \par
00105             {\cf17 private}:\par
00106             {\cf20 // Implementation}\par
00107             {\cf17 static} FormatManagers* _instance;           \par
00108         \};\par
00109 \par
00112         {\cf17 static} std::map <unsigned char, FormatManager*> _formatManagers;\par
00113 \par
00115         {\cf17 static} {\cf17 const} UInt _0;\par
00116         {\cf17 static} {\cf17 const} UInt _1;\par
00117 \par
00118         UInt ()\par
00119             : _values (),\par
00120               _carry (false), _overflow (false),\par
00121               _format (_BINARY)\par
00122                             \{ \}\par
00123 \par
00126         UInt ({\cf17 const} UBytes& u, {\cf18 bool} bE = {\cf17 true}, {\cf18 unsigned} {\cf18 char} f = _BINARY)\par
00127             : _values ((u.size () > 1 && !bE) ? u.reverse () : u),\par
00128               _carry (false), _overflow (false),\par
00129               _format (f)\par
00130                             \{ \}\par
00131 \par
00132         UInt ({\cf17 const} std::vector <UByte>& u, {\cf18 bool} bE = {\cf17 true}, {\cf18 unsigned} {\cf18 char} f = _BINARY)\par
00133             : _values (u, bE),\par
00134               _carry (false), _overflow (false),\par
00135               _format (f)\par
00136                             \{ \}\par
00137 \par
00138         UInt ({\cf17 const} UInt&) = {\cf19 default};\par
00139         UInt& operator = ({\cf17 const} UInt&) = {\cf19 default};\par
00140 \par
00141         {\cf18 unsigned} {\cf18 char} format (){\cf17  const}\par
00142 {\cf17                             }\{ {\cf19 return} (_format); \}\par
00143 \par
00144         {\cf18 size_t} size (){\cf17  const}\par
00145 {\cf17                             }\{ {\cf19 return} (_values.size ()); \}\par
00146         {\cf18 size_t} sizeBits (){\cf17  const}\par
00147 {\cf17                             }\{ {\cf19 return} (_values.sizeBits ()); \}\par
00148 \par
00149         {\cf18 bool} negative (){\cf17  const}\par
00150 {\cf17                             }\{ {\cf19 return} (_values [0][UByte::sizeBits () - 1]); \}\par
00151         {\cf18 bool} positive (){\cf17  const}\par
00152 {\cf17                             }\{ {\cf19 return} (!_values [0][UByte::sizeBits () - 1]); \}\par
00153 \par
00155         {\cf18 bool} carry (){\cf17  const}\par
00156 {\cf17                             }\{ {\cf19 return} (_carry); \}\par
00157         {\cf18 void} resetCarry ()\par
00158                             \{ _carry = {\cf17 false}; \}\par
00159         {\cf18 bool} overflow (){\cf17  const}\par
00160 {\cf17                             }\{ {\cf19 return} (_overflow); \}\par
00161         {\cf18 void} resetOverflow ()\par
00162                             \{ _overflow = {\cf17 false}; \}\par
00163 \par
00164         {\cf18 void} setMinLength ({\cf18 size_t} l)\par
00165                             \{ {\cf19 return} (_values.setMinLength (l, {\cf17 false} )); \}\par
00166 \par
00167         {\cf17 const} UBytes& values (){\cf17  const}\par
00168 {\cf17                             }\{ {\cf19 return} (_values); \}\par
00169         {\cf17 const} std::vector <UByte>& bytes (){\cf17  const}\par
00170 {\cf17                             }\{ {\cf19 return} (_values.bytes ()); \}\par
00171 \par
00172         UInt LSUInt ({\cf18 size_t} p){\cf17  const}\par
00173 {\cf17                             }\{ {\cf19 return} (UInt (_values.LSUBytes (p))); \}\par
00174         UInt MSUInt ({\cf18 size_t} p){\cf17  const}\par
00175 {\cf17                             }\{ {\cf19 return} (UInt (_values.MSUBytes (p))); \}\par
00176 \par
00177         UInt add ({\cf17 const} UInt& u, {\cf18 bool} iC = {\cf17 false}) {\cf17 const};\par
00178         UInt complement (){\cf17  const}\par
00179 {\cf17                             }\{ {\cf19 return} (MCHEmul::UInt (_values.complement (), {\cf17 true}, _format)); \}\par
00180         UInt complement_2 (){\cf17  const}\par
00181 {\cf17                             }\{ {\cf18 unsigned} {\cf18 char} f = _format; \par
00182                               UInt r = complement (); r._format = _BINARY; r += _1; r._format = f; {\cf19 return} (r); \}\par
00183         UInt substract ({\cf17 const} UInt& u, {\cf18 bool} iC = {\cf17 true}) {\cf17 const};\par
00184         UInt multiply ({\cf17 const} UInt& u) {\cf17 const};\par
00185 \par
00186         {\cf18 bool} operator == ({\cf17 const} UInt& u){\cf17  const}\par
00187 {\cf17                             }\{ {\cf19 return} (_values == u._values); \}\par
00188         {\cf18 bool} operator != ({\cf17 const} UInt& u){\cf17  const}\par
00189 {\cf17                             }\{ {\cf19 return} (_values != u._values); \}\par
00190 \par
00193         {\cf18 bool} operator > ({\cf17 const} UInt& u){\cf17  const}\par
00194 {\cf17                             }\{ {\cf19 return} ((*{\cf17 this} >= u) && (*{\cf17 this} != u)); \}\par
00195         {\cf18 bool} operator >= ({\cf17 const} UInt& u){\cf17  const}\par
00196 {\cf17                             }\{ {\cf19 return} ((*{\cf17 this} - u)._carry); \}\par
00197         {\cf18 bool} operator < ({\cf17 const} UInt& u){\cf17  const}\par
00198 {\cf17                             }\{ {\cf19 return} ((*{\cf17 this} <= u) && (*{\cf17 this} != u)); \}\par
00199         {\cf18 bool} operator <= ({\cf17 const} UInt& u){\cf17  const}\par
00200 {\cf17                             }\{ {\cf19 return} ((u - *{\cf17 this})._carry); \}\par
00201 \par
00202         UInt operator + ({\cf17 const} UInt& u){\cf17  const}\par
00203 {\cf17                             }\{ {\cf19 return} (add (u)); \}\par
00204         UInt& operator += ({\cf17 const} UInt& u)\par
00205                             \{ *{\cf17 this} = *{\cf17 this} + u; {\cf19 return} (*{\cf17 this}); \}\par
00206         UInt operator - (){\cf17  const}\par
00207 {\cf17                             }\{ {\cf19 return} (complement_2 ()); \}\par
00208         UInt operator - ({\cf17 const} UInt& u){\cf17  const}\par
00209 {\cf17                             }\{ {\cf19 return} (substract (u)); \}\par
00210         UInt& operator -= ({\cf17 const} UInt& u)\par
00211                             \{ *{\cf17 this} = *{\cf17 this} - u; {\cf19 return} (*{\cf17 this}); \}\par
00212         UInt operator * ({\cf17 const} UInt& u){\cf17  const}\par
00213 {\cf17                             }\{ {\cf19 return} (multiply (u)); \}\par
00214         UInt& operator *= ({\cf17 const} UInt& u)\par
00215                             \{ *{\cf17 this} = *{\cf17 this} * u; {\cf19 return} (*{\cf17 this}); \}\par
00216 \par
00217         UByte operator [] ({\cf18 size_t} p){\cf17  const}\par
00218 {\cf17                             }\{ {\cf19 return} (_values [p]); \}\par
00219         UByte& operator [] ({\cf18 size_t} p)\par
00220                             \{ {\cf19 return} (_values [p]); \}\par
00221         \par
00222         std::string asString (UByte::OutputFormat oF, {\cf18 char} s , {\cf18 size_t} l = 0 ){\cf17  const}\par
00223 {\cf17                             }\{ {\cf19 return} (_values.asString (oF, s, l)); \}\par
00224 \par
00225         {\cf18 unsigned} {\cf18 int} asUnsignedInt (){\cf17  const}\par
00226 {\cf17                             }\{ {\cf19 return} (_formaters._formatManagers [_format] -> asUnsignedInt (*{\cf17 this})); \}\par
00227         {\cf18 int} asInt (){\cf17  const}\par
00228 {\cf17                             }\{ {\cf19 return} (negative () ? -(({\cf18 int}) complement_2 ().asUnsignedInt ()) : ({\cf18 int}) asUnsignedInt ()); \}\par
00229 \par
00230         {\cf17 static} UInt fromUnsignedInt ({\cf18 unsigned} {\cf18 int} n, {\cf18 unsigned} {\cf18 char} f = _BINARY)\par
00231                             \{ {\cf19 return} (_formaters._formatManagers [f] -> fromUnsignedInt (n)); \}\par
00232         {\cf17 static} UInt fromInt ({\cf18 int} n, {\cf18 unsigned} {\cf18 char} f = _BINARY)\par
00233                             \{ {\cf19 return} (_formaters._formatManagers [f] -> fromInt (n)); \}\par
00234         {\cf17 static} UInt fromStr ({\cf17 const} std::string& s, {\cf18 unsigned} {\cf18 char} f = _BINARY);\par
00235 \par
00236         {\cf17 friend} std::ostream& operator << (std::ostream& o, {\cf17 const} UInt& u)\par
00237                             \{ {\cf19 return} (o << u.asString (UByte::OutputFormat::_HEXA, {\cf23 ' '}, 2)); \}\par
00238 \par
00239         {\cf17 private}:\par
00240         UBytes _values;\par
00242         {\cf18 unsigned} {\cf18 char} _format;\par
00243 \par
00244         {\cf20 // Implementation}\par
00245         {\cf17 mutable} {\cf18 bool} _carry;\par
00246         {\cf17 mutable} {\cf18 bool} _overflow;\par
00247         {\cf17 static} FormatManagers _formaters;\par
00248     \};\par
00249 \par
00250 \}\par
00251 \par
00252 {\cf21 #endif}\par
00253   \par
00254 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/doxy.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/doxy.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/doxy.hpp}
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
doxy.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/doxy.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/doxy.hpp}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Only for doxygen needs.}\par
00002 {\cf20 // Nobody includes it.}\par
00003 \par
00004 {\cf20 // MCHEmul Library}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/EMULATORS/C64Emulator.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/EMULATORS/C64Emulator.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/EMULATORS/C64Emulator.hpp}
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <EMULATORS/Emulator.hpp>}\par
{\f2 #include <C64/global.hpp>}\par
{\f2 #include <C64/C64.hpp>}\par
{\f2 #include <C64/IOPBuilder.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Emuls::C64Emulator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Emuls}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64Emulator.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/EMULATORS/C64Emulator.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/EMULATORS/C64Emulator.hpp}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_C64EMULATOR__}\par
00015 {\cf21 #define __MCHEMUL_C64EMULATOR__}\par
00016 \par
00017 {\cf21 #include <EMULATORS/Emulator.hpp>}\par
00018 {\cf21 #include <C64/global.hpp>}\par
00019 {\cf21 #include <C64/C64.hpp>}\par
00020 {\cf21 #include <C64/IOPBuilder.hpp>}\par
00021 \par
00022 {\cf17 namespace }Emuls\par
00023 \{\par
00024     {\cf17 class }C64Emulator : {\cf17 public} Emulator\par
00025     \{\par
00026         {\cf17 public}:\par
00028         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _PARAMNTSC;\par
00029         {\cf17 static} {\cf17 const} std::string _NTSC;\par
00030 \par
00038         C64Emulator ({\cf17 const} std::vector <std::string>& argv);\par
00039 \par
00041         {\cf18 bool} NTSCSystem (){\cf17  const}\par
00042 {\cf17                             }\{ {\cf19 return} ((_attributes.find (_NTSC) != _attributes.end ()) ? {\cf17 true} : {\cf17 false}); \}\par
00043 \par
00045         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00046 \par
00047         {\cf17 protected}:\par
00048         {\cf17 virtual} MCHEmul::Computer* createComputer (){\cf17  const override}\par
00049 {\cf17                             }\{ {\cf19 return} ({\cf17 new} C64::Commodore64 (NTSCSystem () \par
00050                                 ? C64::Commodore64::VisualSystem::_NTSC : C64::Commodore64::VisualSystem::_PAL)); \}\par
00051 \par
00052         {\cf17 virtual} MCHEmul::IOPeripheralBuilder* createPeripheralBuilder (){\cf17  const override}\par
00053 {\cf17                             }\{ {\cf19 return} ({\cf17 new} C64::IOPeripheralBuilder); \}\par
00054 \par
00056         {\cf17 virtual} {\cf18 bool} additionalRunCycle (){\cf17  override}\par
00057 {\cf17                 }\{ C64::actualizeGlobalTime ();  {\cf19 return} ({\cf17 true}); \}\par
00058     \};\par
00059 \}\par
00060 \par
00061 {\cf21 #endif}\par
00062   \par
00063 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/EMULATORS/Emulator.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/EMULATORS/Emulator.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/EMULATORS/Emulator.hpp}
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
{\f2 #include <ASSEMBLER/incs.hpp>}\par
{\f2 #include <COMMS/System.hpp>}\par
{\f2 #include <COMMS/StdMessages.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Emuls::Emulator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Emuls}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Emulator.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/EMULATORS/Emulator.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/EMULATORS/Emulator.hpp}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __MCHEMUL_EMULATOR__}\par
00015 {\cf21 #define __MCHEMUL_EMULATOR__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 {\cf21 #include <ASSEMBLER/incs.hpp>}\par
00019 {\cf21 #include <COMMS/System.hpp>}\par
00020 {\cf21 #include <COMMS/StdMessages.hpp>}\par
00021 \par
00022 {\cf17 namespace }Emuls\par
00023 \{\par
00024     {\cf17 class }Emulator \par
00025     \{\par
00026         {\cf17 public}:\par
00028         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _PARAMBYTEFILE;\par
00029         {\cf17 static} {\cf17 const} std::string _BYTEFILE;\par
00030         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _PARAMASMFILE;\par
00031         {\cf17 static} {\cf17 const} std::string _ASMFILE;\par
00032         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _PARAMLOGLEVEL;\par
00033         {\cf17 static} {\cf17 const} std::string _LOGLEVEL;\par
00034         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 char} _PARAMADDRESS;\par
00035         {\cf17 static} {\cf17 const} std::string _ADDRESS;\par
00036 \par
00037         {\cf17 using} MapOfActions = std::map <MCHEmul::Address, unsigned int>;\par
00038 \par
00049         Emulator ({\cf17 const} std::vector <std::string>& argv);\par
00050 \par
00051         {\cf17 virtual} ~Emulator ();\par
00052 \par
00053         {\cf17 const} MCHEmul::Attributes& attributes (){\cf17  const}\par
00054 {\cf17                             }\{ {\cf19 return} (_attributes); \}\par
00055 \par
00056         {\cf17 const} MCHEmul::Computer* computer (){\cf17  const}\par
00057 {\cf17                             }\{ {\cf19 return} (_computer == {\cf17 nullptr}) ? (_computer = createComputer ()) : _computer; \}\par
00058         MCHEmul::Computer* computer ()\par
00059                             \{ {\cf19 return} ((MCHEmul::Computer*) ((({\cf17 const} Emulator*) {\cf17 this}) -> computer ())); \}\par
00060 \par
00062         {\cf18 void} setCommunicationSystem (MCHEmul::CommunicationSystem* cS);\par
00063 \par
00066         std::string byteFileName (){\cf17  const}\par
00067 {\cf17                             }\{ MCHEmul::Attributes::const_iterator i; \par
00068                                 {\cf19 return} (((i = _attributes.find (_BYTEFILE)) != _attributes.end ()) ? (*i).second : {\cf22 ""}); \}\par
00069 \par
00072         std::string asmFileName (){\cf17  const}\par
00073 {\cf17                             }\{ MCHEmul::Attributes::const_iterator i; \par
00074                                 {\cf19 return} (((i = _attributes.find (_ASMFILE)) != _attributes.end ()) ? (*i).second : {\cf22 ""}); \}\par
00075 \par
00078         {\cf18 unsigned} {\cf18 int} logLevel (){\cf17  const}\par
00079 {\cf17                             }\{ MCHEmul::Attributes::const_iterator i; \par
00080                                 {\cf19 return} (({\cf18 unsigned} {\cf18 int}) std::stoi (((i = _attributes.find (_LOGLEVEL)) != _attributes.end ()) \par
00081                                     ? (*i).second : {\cf22 ""})); \}\par
00082 \par
00085         MCHEmul::Address startingAddress (){\cf17  const}\par
00086 {\cf17                             }\{ MCHEmul::Attributes::const_iterator i; \par
00087                                 {\cf19 return} (MCHEmul::Address::fromStr (((i = _attributes.find (_ADDRESS)) != _attributes.end ()) \par
00088                                     ? (*i).second : {\cf22 ""})); \}\par
00089 \par
00090         {\cf18 unsigned} {\cf18 int} debugLevel (){\cf17  const}\par
00091 {\cf17                             }\{ {\cf19 return} (_debugLevel); \}\par
00092         {\cf18 void} setDebugLevel ({\cf18 unsigned} {\cf18 int} dL)\par
00093                             \{ _debugLevel = dL; computer () -> setDebugLevel (dL); \}\par
00094 \par
00095         {\cf20 // To manage actions at address level...}\par
00097 {\cf20 }        {\cf18 void} setActions ({\cf17 const} MapOfActions& at)\par
00098                             \{ _actionsAt = at; \}\par
00100         {\cf18 void} addAction ({\cf17 const} MCHEmul::Address& at, {\cf18 unsigned} {\cf18 int} a);\par
00101         {\cf18 void} removeAction ({\cf17 const} MCHEmul::Address& at);\par
00102 \par
00103         {\cf18 bool} connectPeripheral ({\cf18 int} {\cf18 id}, {\cf17 const} MCHEmul::Attributes& prms, MCHEmul::IODevice* d)\par
00104                             \{ {\cf19 return} (computer () -> connect (peripherialBuilder () -> peripheral ({\cf18 id}, prms), d)); \}\par
00105 \par
00107         {\cf17 virtual} {\cf18 bool} initialize ();\par
00108 \par
00110         {\cf18 bool} run ();\par
00111 \par
00114         {\cf18 bool} runCycle ({\cf18 unsigned} {\cf18 int} a = 0);\par
00115 \par
00116         {\cf18 unsigned} {\cf18 int} lastError (){\cf17  const}\par
00117 {\cf17                             }\{ {\cf19 return} (_lastError); \}\par
00118         {\cf18 bool} operator ! (){\cf17  const}\par
00119 {\cf17                             }\{ {\cf19 return} (_lastError != MCHEmul::_NOERROR); \}\par
00120 \par
00121         {\cf17 protected}:\par
00122         {\cf17 const} MCHEmul::IOPeripheralBuilder* peripherialBuilder (){\cf17  const}\par
00123 {\cf17                             }\{ {\cf19 return} (_peripheralBuilder == {\cf17 nullptr}) ? \par
00124                                 (_peripheralBuilder = createPeripheralBuilder ()) : _peripheralBuilder; \}\par
00125         MCHEmul::IOPeripheralBuilder* peripherialBuilder ()\par
00126                             \{ {\cf19 return} ((MCHEmul::IOPeripheralBuilder*) ((({\cf17 const} Emulator*) {\cf17 this}) -> peripherialBuilder ())); \}\par
00127 \par
00128         {\cf20 // To be used when e.g debugging...}\par
00139 {\cf20 }        {\cf17 virtual} {\cf18 bool} executeAction ({\cf18 unsigned} {\cf18 int}& lA, {\cf18 unsigned} {\cf18 int} at, {\cf18 unsigned} {\cf18 int} a);\par
00140 \par
00143         {\cf17 virtual} {\cf18 bool} additionalRunCycle ()\par
00144                             \{ {\cf19 return} ({\cf17 true}); \}\par
00145 \par
00146         {\cf20 // Implementation}\par
00149 {\cf20 }        {\cf17 virtual} MCHEmul::Computer* createComputer () {\cf17 const} = 0;\par
00150 \par
00152         {\cf17 virtual} MCHEmul::IOPeripheralBuilder* createPeripheralBuilder () {\cf17 const} = 0;\par
00153 \par
00154         {\cf17 protected}:\par
00156         MCHEmul::Attributes _attributes;\par
00157         MCHEmul::CommunicationSystem* _communicationSystem;\par
00158         {\cf18 unsigned} {\cf18 int} _debugLevel;\par
00159         std::map <MCHEmul::Address, unsigned int> _actionsAt;\par
00160 \par
00161         {\cf20 // Implementation}\par
00162         {\cf17 mutable} MCHEmul::Computer* _computer;\par
00163         {\cf17 mutable} MCHEmul::IOPeripheralBuilder* _peripheralBuilder;\par
00164         {\cf17 mutable} {\cf18 bool} _running;\par
00165         {\cf18 unsigned} {\cf18 int} _lastError;\par
00166         {\cf18 unsigned} {\cf18 int} _lastAction;\par
00167     \};\par
00168 \}\par
00169 \par
00170 {\cf21 #endif}\par
00171   \par
00172 {\cf20 // End of the file}\par
00174 {\cf20 }{\cf21 #pragma once}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/C6500.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/C6500.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/C6500.hpp}
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::C6500}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b F6500}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C6500.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/C6500.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/C6500.hpp}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __F6500_C6500__}\par
00015 {\cf21 #define __F6500_C6500__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }F6500\par
00020 \{\par
00022     {\cf17 class }C6500 : {\cf17 public} MCHEmul::CPU\par
00023     \{\par
00024         {\cf17 public}:\par
00026         {\cf17 enum class} AddressMode\par
00027         \{\par
00028             _IMPLICIT,      {\cf20 // The instruction has no parameter at all.}\par
00029             _INMEDIATE,     {\cf20 // The parameter is a value}\par
00030             _ABSOLUTE,      {\cf20 // The parameter is an address}\par
00031             _ZEROPAGE,      {\cf20 // The parameter is an addresss to but in th first page of the memory}\par
00032             _ABSOLUTE_X,    {\cf20 // The paremeter is got from an address and the value of the register X}\par
00033             _ABSOLUTE_Y,    {\cf20 // The paremeter is got from an address and the value of the register Y}\par
00034             _RELATIVE,      {\cf20 // The parameter is a number of steps foward or backward}\par
00035             _INDIRECT,      {\cf20 // The parameter is an address where to find other}\par
00036             _ZEROPAGE_X,    {\cf20 // The paremeter is got from an address (in page 0) and the value of the register X }\par
00037             _ZEROPAGE_Y,    {\cf20 // The paremeter is got from an address (in page 0) and the value of the register Y}\par
00038             _INDIRECT_X,    {\cf20 // The parameter is got from an address that is in other, plus the register X}\par
00039             _INDIRECT_Y,    {\cf20 // The parameter is got from an address that is in other plus the register Y}\par
00040         \};\par
00041 \par
00042         C6500 ({\cf17 const} MCHEmul::CPUArchitecture& a);\par
00043 \par
00044         {\cf17 virtual} MCHEmul::Address IRQVectorAddress () {\cf17 const} = 0;\par
00045         {\cf17 virtual} MCHEmul::Address NMIVectorAddress () {\cf17 const} = 0;\par
00046         {\cf17 virtual} MCHEmul::Address ResetVectorAddress () {\cf17 const} = 0;\par
00047 \par
00048         MCHEmul::Register& accumulator ()\par
00049                             \{ {\cf19 return} (internalRegister (_ACCUMULATOR)); \}\par
00050         MCHEmul::Register& xRegister ()\par
00051                             \{ {\cf19 return} (internalRegister (_XREGISTER)); \}\par
00052         MCHEmul::Register& yRegister ()\par
00053                             \{ {\cf19 return} (internalRegister (_YREGISTER)); \}\par
00054 \par
00055         {\cf17 virtual} {\cf18 bool} initialize () {\cf17 override};\par
00056 \par
00058         {\cf17 static} {\cf17 const} {\cf18 size_t} _ACCUMULATOR = 0;\par
00059         {\cf17 static} {\cf17 const} {\cf18 size_t} _XREGISTER = 1;\par
00060         {\cf17 static} {\cf17 const} {\cf18 size_t} _YREGISTER = 2;\par
00061 \par
00062         {\cf17 private}:\par
00063         {\cf20 // Implementation}\par
00064         {\cf17 static} MCHEmul::Registers createInternalRegisters ();\par
00065         {\cf17 static} MCHEmul::StatusRegister createStatusRegister ();\par
00066         {\cf17 static} MCHEmul::Instructions createInstructions ();\par
00067     \};\par
00068 \}\par
00069 \par
00070 {\cf21 #endif}\par
00071   \par
00072 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/C6510.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/C6510.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/C6510.hpp}
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/C6500.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::C6510}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b F6500}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C6510.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/C6510.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/C6510.hpp}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __F6500_C6510__}\par
00015 {\cf21 #define __F6500_C6510__}\par
00016 \par
00017 {\cf21 #include <F6500/C6500.hpp>}\par
00018 \par
00019 {\cf17 namespace }F6500\par
00020 \{\par
00022     {\cf17 class }C6510 : {\cf17 public} C6500\par
00023     \{\par
00024         {\cf17 public}:\par
00025         C6510 ()\par
00026             : C6500 (createArchitecture ())\par
00027                             \{ \}\par
00028 \par
00029         {\cf17 virtual} MCHEmul::Address IRQVectorAddress (){\cf17  const override}\par
00030 {\cf17                             }\{ {\cf19 return} (MCHEmul::Address (\{ 0xfe, 0xff \}, {\cf17 false} )); \}\par
00031         {\cf17 virtual} MCHEmul::Address NMIVectorAddress (){\cf17  const override}\par
00032 {\cf17                             }\{ {\cf19 return} (MCHEmul::Address (\{ 0xfa, 0xff \}, {\cf17 false} )); \}\par
00033         {\cf17 virtual} MCHEmul::Address ResetVectorAddress (){\cf17  const override}\par
00034 {\cf17                             }\{ {\cf19 return} (MCHEmul::Address (\{ 0xfc, 0xff \}, {\cf17 false} )); \}\par
00035 \par
00036         {\cf17 private}:\par
00037         {\cf20 // Implementation}\par
00038         {\cf17 static} MCHEmul::CPUArchitecture createArchitecture ();\par
00039     \};\par
00040 \}\par
00041 \par
00042 {\cf21 #endif}\par
00043   \par
00044 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/Instructions.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/Instructions.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/Instructions.hpp}
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::Instruction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::ADC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::AND_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::ASL_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::BXX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::CMP_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::CPX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::CPY_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::DEC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::EOR_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::INC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::LDA_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::LDX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::LDY_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::LSR_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::ORA_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::ROL_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::ROR_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::SBC_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::STA_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::STX_General}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::STY_General}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b F6500}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x69, 2, 2, "ADC#[#1]", ADC_Inmediate, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x6d, 3, 4, "ADC[$2]", ADC_Absolute, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x65, 2, 3, "ADC[$1]", ADC_ZeroPage, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x61, 2, 6, "ADC([$1],X)", ADC_ZeroPageIndirectX, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x71, 2, 5, "ADC([$1]),Y", ADC_ZeroPageIndirectY, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x75, 2, 4, "ADC[$1],X", ADC_ZeroPageX, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x7d, 3, 4, "ADC[$2],X", ADC_AbsoluteX, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x79, 3, 4, "ADC[$2],Y", ADC_AbsoluteY, ADC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x29, 2, 2, "AND#[#1]", AND_Inmediate, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x2d, 3, 4, "AND[$2]", AND_Absolute, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x25, 2, 3, "AND[$1]", AND_ZeroPage, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x21, 2, 6, "AND([$1],X)", AND_ZeroPageIndirectX, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x31, 2, 5, "AND([$1]),Y", AND_ZeroPageIndirectY, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x35, 2, 4, "AND[$1],X", AND_ZeroPageX, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x3d, 3, 4, "AND[$2],X", AND_AbsoluteX, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x39, 3, 4, "AND[$2],Y", AND_AbsoluteY, AND_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x0e, 3, 6, "ASL[$2]", ASL_Absolute, ASL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x06, 2, 5, "ASL[$1]", ASL_ZeroPage, ASL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x0a, 1, 2, "ASL", ASL_Accumulator, ASL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x16, 2, 6, "ASL[$1],X", ASL_ZeroPageX, ASL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x1e, 3, 7, "ASL[$2],X", ASL_AbsoluteX, ASL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x90, 2, 2, "BCC[&1]", BCC, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb0, 2, 2, "BCS[&1]", BCS, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xf0, 2, 2, "BEQ[&1]", BEQ, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x2c, 3, 4, "BIT[$2]", BIT_Absolute, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x24, 2, 3, "BIT[$1]", BIT_ZeroPage, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x30, 2, 2, "BMI[&1]", BMI, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xd0, 2, 2, "BNE[&1]", BNE, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x10, 2, 2, "BPL[&1]", BPL, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x00, 1, 7, "BRK", BRK, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x50, 2, 2, "BVC[&1]", BVC, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x70, 2, 2, "BVS[&1]", BVS, BXX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x18, 1, 2, "CLC", CLC, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xd8, 1, 2, "CLD", CLD, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x58, 1, 2, "CLI", CLI, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb8, 1, 2, "CLV", CLV, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc9, 2, 2, "CMP#[#1]", CMP_Inmediate, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xcd, 3, 4, "CMP[$2]", CMP_Absolute, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc5, 2, 3, "CMP[$1]", CMP_ZeroPage, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc1, 2, 6, "CMP([$1],X)", CMP_ZeroPageIndirectX, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xd1, 2, 5, "CMP([$1]),Y", CMP_ZeroPageIndirectY, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xd5, 2, 4, "CMP[$1],X", CMP_ZeroPageX, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xdd, 3, 4, "CMP[$2],X", CMP_AbsoluteX, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xd9, 3, 4, "CMP[$2],Y", CMP_AbsoluteY, CMP_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe0, 2, 2, "CPX#[#1]", CPX_Inmediate, CPX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xec, 3, 4, "CPX[$2]", CPX_Absolute, CPX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe4, 2, 3, "CPX[$1]", CPX_ZeroPage, CPX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc0, 2, 2, "CPY#[#1]", CPY_Inmediate, CPY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xcc, 3, 4, "CPY[$2]", CPY_Absolute, CPY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc4, 2, 3, "CPY[$1]", CPY_ZeroPage, CPY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xce, 3, 6, "DEC[$2]", DEC_Absolute, DEC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc6, 2, 5, "DEC[$1]", DEC_ZeroPage, DEC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xd6, 2, 6, "DEC[$1],X", DEC_ZeroPageX, DEC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xde, 3, 7, "DEC[$2],X", DEC_AbsoluteX, DEC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xca, 1, 2, "DEX", DEX, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x88, 1, 2, "DEY", DEY, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x49, 2, 2, "EOR#[#1]", EOR_Inmediate, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x4d, 3, 4, "EOR[$2]", EOR_Absolute, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x45, 2, 3, "EOR[$1]", EOR_ZeroPage, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x41, 2, 6, "EOR([$1],X)", EOR_ZeroPageIndirectX, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x51, 2, 5, "EOR([$1]),Y", EOR_ZeroPageIndirectY, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x55, 2, 4, "EOR[$1],X", EOR_ZeroPageX, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x5d, 3, 4, "EOR[$2],X", EOR_AbsoluteX, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x59, 3, 4, "EOR[$2],Y", EOR_AbsoluteY, EOR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xee, 3, 6, "INC[$2]", INC_Absolute, INC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe6, 2, 5, "INC[$1]", INC_ZeroPage, INC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xf6, 2, 6, "INC[$1],X", INC_ZeroPageX, INC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xfe, 3, 7, "INC[$2],X", INC_AbsoluteX, INC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe8, 1, 2, "INX", INX, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xc8, 1, 2, "INY", INY, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x4c, 3, 3, "JMP[%2]", JMP_Absolute, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x6c, 3, 5, "JMP([%2])", JMP_Indirect, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x20, 3, 6, "JSR[%2]", JSR_Absolute, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa9, 2, 2, "LDA#[#1]", LDA_Inmediate, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xad, 3, 4, "LDA[$2]", LDA_Absolute, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa5, 2, 3, "LDA[$1]", LDA_ZeroPage, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa1, 2, 6, "LDA([$1],X)", LDA_ZeroPageIndirectX, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb1, 2, 5, "LDA([$1]),Y", LDA_ZeroPageIndirectY, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb5, 2, 4, "LDA[$1],X", LDA_ZeroPageX, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xbd, 3, 4, "LDA[$2],X", LDA_AbsoluteX, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb9, 3, 4, "LDA[$2],Y", LDA_AbsoluteY, LDA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa2, 2, 2, "LDX#[#1]", LDX_Inmediate, LDX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xae, 3, 4, "LDX[$2]", LDX_Absolute, LDX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa6, 2, 3, "LDX[$1]", LDX_ZeroPage, LDX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xbe, 3, 4, "LDX[$2],Y", LDX_AbsoluteY, LDX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb6, 2, 4, "LDX[$1],Y", LDX_ZeroPageY, LDX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa0, 2, 2, "LDY#[#1]", LDY_Inmediate, LDY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xac, 3, 4, "LDY[$2]", LDY_Absolute, LDY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa4, 2, 3, "LDY[$1]", LDY_ZeroPage, LDY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xb4, 2, 4, "LDY[$1],X", LDY_ZeroPageX, LDY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xbc, 3, 4, "LDY[$2],X", LDY_AbsoluteX, LDY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x4e, 3, 6, "LSR[$2]", LSR_Absolute, LSR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x46, 2, 5, "LSR[$1]", LSR_ZeroPage, LSR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x4a, 1, 2, "LSR", LSR_Accumulator, LSR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x56, 2, 6, "LSR[$1],X", LSR_ZeroPageX, LSR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x5e, 3, 7, "LSR[$2],X", LSR_AbsoluteX, LSR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xea, 1, 2, "NOP", NOP, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x09, 2, 2, "ORA#[#1]", ORA_Inmediate, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x0d, 3, 4, "ORA[$2]", ORA_Absolute, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x05, 2, 3, "ORA[$1]", ORA_ZeroPage, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x01, 2, 6, "ORA([$1],X)", ORA_ZeroPageIndirectX, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x11, 2, 5, "ORA([$1]),Y", ORA_ZeroPageIndirectY, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x15, 2, 4, "ORA[$1],X", ORA_ZeroPageX, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x1d, 3, 4, "ORA[$2],X", ORA_AbsoluteX, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x19, 3, 4, "ORA[$2],Y", ORA_AbsoluteY, ORA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x48, 1, 3, "PHA", PHA, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x08, 1, 3, "PHP", PHP, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x68, 1, 4, "PLA", PLA, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x28, 1, 4, "PLP", PLP, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x2e, 3, 6, "ROL[$2]", ROL_Absolute, ROL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x26, 2, 5, "ROL[$1]", ROL_ZeroPage, ROL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x2a, 1, 2, "ROL", ROL_Accumulator, ROL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x36, 2, 6, "ROL[$1],X", ROL_ZeroPageX, ROL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x3e, 3, 7, "ROL[$2],X", ROL_AbsoluteX, ROL_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x6e, 3, 6, "ROR[$2]", ROR_Absolute, ROR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x66, 2, 5, "ROR[$1]", ROR_ZeroPage, ROR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x6a, 1, 2, "ROR", ROR_Accumulator, ROR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x76, 2, 6, "ROR[$1],X", ROR_ZeroPageX, ROR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x7e, 3, 7, "ROR[$2],X", ROR_AbsoluteX, ROR_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x40, 1, 6, "RTI", RTI, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x60, 1, 6, "RTS", RTS, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe9, 2, 2, "SBC#[#1]", SBC_Inmediate, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xed, 3, 4, "SBC[$2]", SBC_Absolute, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe5, 2, 3, "SBC[$1]", SBC_ZeroPage, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xe1, 2, 6, "SBC([$1],X)", SBC_ZeroPageIndirectX, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xf1, 2, 5, "SBC([$1]),Y", SBC_ZeroPageIndirectY, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xf5, 2, 4, "SBC[$1],X", SBC_ZeroPageX, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xfd, 3, 4, "SBC[$2],X", SBC_AbsoluteX, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xf9, 3, 4, "SBC[$2],Y", SBC_AbsoluteY, SBC_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x38, 1, 2, "SEC", SEC, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xf8, 1, 2, "SED", SED, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x78, 1, 2, "SEI", SEI, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x8d, 3, 4, "STA[$2]", STA_Absolute, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x85, 2, 3, "STA[$1]", STA_ZeroPage, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x81, 2, 6, "STA([$1],X)", STA_ZeroPageIndirectX, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x91, 2, 6, "STA([$1]),Y", STA_ZeroPageIndirectY, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x95, 2, 4, "STA[$1],X", STA_ZeroPageX, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x9d, 3, 5, "STA[$2],X", STA_AbsoluteX, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x99, 3, 5, "STA[$2],Y", STA_AbsoluteY, STA_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x8e, 3, 4, "STX[$2]", STX_Absolute, STX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x86, 2, 3, "STX[$1]", STX_ZeroPage, STX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x96, 2, 4, "STX[$1],Y", STX_ZeroPageY, STX_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x8c, 3, 4, "STY[$2]", STY_Absolute, STY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x84, 2, 3, "STY[$1]", STY_ZeroPage, STY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x94, 2, 4, "STY[$1],X", STY_ZeroPageX, STY_General)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xaa, 1, 2, "TAX", TAX, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xa8, 1, 2, "TAY", TAY, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0xba, 1, 2, "TSX", TSX, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x8a, 1, 2, "TXA", TXA, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x9a, 1, 2, "TXS", TXS, Instruction)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F6500::_INST_FROM} (0x98, 1, 2, "TYA", TYA, Instruction)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Instructions.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/Instructions.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/Instructions.hpp}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __F6500_INSTRUCTIONS__}\par
00015 {\cf21 #define __F6500_INSTRUCTIONS__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }F6500\par
00020 \{\par
00024     {\cf17 class }Instruction : {\cf17 public} MCHEmul::Instruction\par
00025     \{\par
00026         {\cf17 public}:\par
00027         Instruction ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00028             : MCHEmul::Instruction (c, mp, cc, t)\par
00029                             \{ \}\par
00030     \par
00031         {\cf17 protected}:\par
00032         {\cf20 // To interpret the parameters of the instruction as an address }\par
00034 {\cf20 }        MCHEmul::Address address_absolute ();\par
00036         MCHEmul::Address address_zeroPage ();\par
00039         MCHEmul::Address address_absoluteX ();\par
00042         MCHEmul::Address address_absoluteY ();\par
00045         MCHEmul::Address address_zeroPageX ();\par
00048         MCHEmul::Address address_zeroPageY ();\par
00051         MCHEmul::Address address_indirectZeroPageX ();\par
00054         MCHEmul::Address address_indirectZeroPageY ();\par
00057         MCHEmul::Address address_indirect ();\par
00058 \par
00059         {\cf20 // To interpret the parameters of the instruction as a a value}\par
00061 {\cf20 }        MCHEmul::UByte value_inmediate ();\par
00062         MCHEmul::UByte value_absolute ()\par
00063                             \{ {\cf19 return} (memory () -> value (address_absolute ())); \}\par
00064         MCHEmul::UByte value_zeroPage ()\par
00065                             \{ {\cf19 return} (memory () -> value (address_zeroPage ())); \}\par
00066         MCHEmul::UByte value_absoluteX ()\par
00067                             \{ {\cf19 return} (memory () -> value (address_absoluteX ())); \}\par
00068         MCHEmul::UByte value_absoluteY ()\par
00069                             \{ {\cf19 return} (memory () -> value (address_absoluteY ())); \}\par
00071         MCHEmul::UByte value_relative ();\par
00072         MCHEmul::UByte value_zeroPageX ()\par
00073                             \{ {\cf19 return} (memory () -> value (address_zeroPageX ())); \}\par
00074         MCHEmul::UByte value_zeroPageY ()\par
00075                             \{ {\cf19 return} (memory () -> value (address_zeroPageY ())); \}\par
00076         MCHEmul::UByte value_indirectZeroPageX ()\par
00077                             \{ {\cf19 return} (memory () -> value (address_indirectZeroPageX ())); \}\par
00078         MCHEmul::UByte value_indirectZeroPageY ()\par
00079                             \{ {\cf19 return} (memory () -> value (address_indirectZeroPageY ())); \}\par
00080     \};\par
00081 \par
00082     {\cf20 // ADC}\par
00084 {\cf20 }    {\cf17 class }ADC_General : {\cf17 public} Instruction\par
00085     \{\par
00086         {\cf17 public}:\par
00087         ADC_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00088             : Instruction (c, mp, cc, t)\par
00089                             \{ \}\par
00090 \par
00091         {\cf17 protected}:\par
00092         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00093     \};\par
00094 \par
00095     _INST_FROM (0x69, 2, 2, {\cf22 "ADC#[#1]"},     ADC_Inmediate, ADC_General);\par
00096     _INST_FROM (0x6d, 3, 4, {\cf22 "ADC[$2]"},      ADC_Absolute, ADC_General);\par
00097     _INST_FROM (0x65, 2, 3, {\cf22 "ADC[$1]"},      ADC_ZeroPage, ADC_General);\par
00098     _INST_FROM (0x61, 2, 6, {\cf22 "ADC([$1],X)"},  ADC_ZeroPageIndirectX, ADC_General);\par
00099     _INST_FROM (0x71, 2, 5, {\cf22 "ADC([$1]),Y"},  ADC_ZeroPageIndirectY, ADC_General);\par
00100     _INST_FROM (0x75, 2, 4, {\cf22 "ADC[$1],X"},    ADC_ZeroPageX, ADC_General);\par
00101     _INST_FROM (0x7d, 3, 4, {\cf22 "ADC[$2],X"},    ADC_AbsoluteX, ADC_General);\par
00102     _INST_FROM (0x79, 3, 4, {\cf22 "ADC[$2],Y"},    ADC_AbsoluteY, ADC_General);\par
00103 \par
00104     {\cf20 // AND}\par
00106 {\cf20 }    {\cf17 class }AND_General : {\cf17 public} Instruction\par
00107     \{\par
00108         {\cf17 public}:\par
00109         AND_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00110             : Instruction (c, mp, cc, t)\par
00111                             \{ \}\par
00112 \par
00113         {\cf17 protected}:\par
00114         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00115     \};\par
00116 \par
00117     _INST_FROM (0x29, 2, 2, {\cf22 "AND#[#1]"},     AND_Inmediate, AND_General);\par
00118     _INST_FROM (0x2d, 3, 4, {\cf22 "AND[$2]"},      AND_Absolute, AND_General);\par
00119     _INST_FROM (0x25, 2, 3, {\cf22 "AND[$1]"},      AND_ZeroPage, AND_General);\par
00120     _INST_FROM (0x21, 2, 6, {\cf22 "AND([$1],X)"},  AND_ZeroPageIndirectX, AND_General);\par
00121     _INST_FROM (0x31, 2, 5, {\cf22 "AND([$1]),Y"},  AND_ZeroPageIndirectY, AND_General);\par
00122     _INST_FROM (0x35, 2, 4, {\cf22 "AND[$1],X"},    AND_ZeroPageX, AND_General);\par
00123     _INST_FROM (0x3d, 3, 4, {\cf22 "AND[$2],X"},    AND_AbsoluteX, AND_General);\par
00124     _INST_FROM (0x39, 3, 4, {\cf22 "AND[$2],Y"},    AND_AbsoluteY, AND_General);\par
00125 \par
00126     {\cf20 // ASL}\par
00128 {\cf20 }    {\cf17 class }ASL_General : {\cf17 public} Instruction\par
00129     \{\par
00130         {\cf17 public}:\par
00131         ASL_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00132             : Instruction (c, mp, cc, t)\par
00133                             \{ \}\par
00134 \par
00135         {\cf17 protected}:\par
00136         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00137     \};\par
00138 \par
00139     _INST_FROM (0x0e, 3, 6, {\cf22 "ASL[$2]"},  ASL_Absolute, ASL_General);\par
00140     _INST_FROM (0x06, 2, 5, {\cf22 "ASL[$1]"},      ASL_ZeroPage, ASL_General);\par
00141     _INST_FROM (0x0a, 1, 2, {\cf22 "ASL"},          ASL_Accumulator, ASL_General);\par
00142     _INST_FROM (0x16, 2, 6, {\cf22 "ASL[$1],X"},    ASL_ZeroPageX, ASL_General);\par
00143     _INST_FROM (0x1e, 3, 7, {\cf22 "ASL[$2],X"},    ASL_AbsoluteX, ASL_General);\par
00144 \par
00146     {\cf17 class }BXX_General : {\cf17 public} Instruction\par
00147     \{\par
00148         {\cf17 public}:\par
00149         BXX_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00150             : Instruction (c, mp, cc, t)\par
00151                             \{ \}\par
00152 \par
00153         {\cf17 protected}:\par
00154         {\cf18 void} executeBranch ();\par
00155     \};\par
00156 \par
00157     {\cf20 // BCC }\par
00158     _INST_FROM (0x90, 2, 2, {\cf22 "BCC[&1]"},      BCC, BXX_General);\par
00159 \par
00160     {\cf20 // BCS }\par
00161     _INST_FROM (0xb0, 2, 2, {\cf22 "BCS[&1]"},      BCS, BXX_General);\par
00162 \par
00163     {\cf20 // BEQ}\par
00164     _INST_FROM (0xf0, 2, 2, {\cf22 "BEQ[&1]"},      BEQ, BXX_General);\par
00165 \par
00166     {\cf20 // BIT}\par
00167     _INST_FROM (0x2c, 3, 4, {\cf22 "BIT[$2]"},      BIT_Absolute, Instruction);\par
00168     _INST_FROM (0x24, 2, 3, {\cf22 "BIT[$1]"},      BIT_ZeroPage, Instruction);\par
00169 \par
00170     {\cf20 // BMI}\par
00171     _INST_FROM (0x30, 2, 2, {\cf22 "BMI[&1]"},      BMI, BXX_General);\par
00172 \par
00173     {\cf20 // BNE}\par
00174     _INST_FROM (0xd0, 2, 2, {\cf22 "BNE[&1]"},      BNE, BXX_General);\par
00175 \par
00176     {\cf20 // BPL}\par
00177     _INST_FROM (0x10, 2, 2, {\cf22 "BPL[&1]"},      BPL, BXX_General);\par
00178 \par
00179     {\cf20 // BRK}\par
00180     _INST_FROM (0x00, 1, 7, {\cf22 "BRK"},          BRK, Instruction);\par
00181 \par
00182     {\cf20 // BVC}\par
00183     _INST_FROM (0x50, 2, 2, {\cf22 "BVC[&1]"},      BVC, BXX_General);\par
00184 \par
00185     {\cf20 // BVS}\par
00186     _INST_FROM (0x70, 2, 2, {\cf22 "BVS[&1]"},      BVS, BXX_General);\par
00187 \par
00188     {\cf20 // CLC}\par
00189     _INST_FROM (0x18, 1, 2, {\cf22 "CLC"},          CLC, Instruction);\par
00190 \par
00191     {\cf20 // CLD}\par
00192     _INST_FROM (0xd8, 1, 2, {\cf22 "CLD"},          CLD, Instruction);\par
00193 \par
00194     {\cf20 // CLI}\par
00195     _INST_FROM (0x58, 1, 2, {\cf22 "CLI"},          CLI, Instruction);\par
00196 \par
00197     {\cf20 // CLV}\par
00198     _INST_FROM (0xb8, 1, 2, {\cf22 "CLV"},          CLV, Instruction);\par
00199 \par
00200     {\cf20 // CMP}\par
00202 {\cf20 }    {\cf17 class }CMP_General : {\cf17 public} Instruction\par
00203     \{\par
00204         {\cf17 public}:\par
00205         CMP_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00206             : Instruction (c, mp, cc, t)\par
00207                             \{ \}\par
00208 \par
00209         {\cf17 protected}:\par
00210         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00211     \};\par
00212 \par
00213     _INST_FROM (0xc9, 2, 2, {\cf22 "CMP#[#1]"},     CMP_Inmediate, CMP_General);\par
00214     _INST_FROM (0xcd, 3, 4, {\cf22 "CMP[$2]"},  CMP_Absolute, CMP_General);\par
00215     _INST_FROM (0xc5, 2, 3, {\cf22 "CMP[$1]"},      CMP_ZeroPage, CMP_General);\par
00216     _INST_FROM (0xc1, 2, 6, {\cf22 "CMP([$1],X)"},  CMP_ZeroPageIndirectX, CMP_General);\par
00217     _INST_FROM (0xd1, 2, 5, {\cf22 "CMP([$1]),Y"},  CMP_ZeroPageIndirectY, CMP_General);\par
00218     _INST_FROM (0xd5, 2, 4, {\cf22 "CMP[$1],X"},    CMP_ZeroPageX, CMP_General);\par
00219     _INST_FROM (0xdd, 3, 4, {\cf22 "CMP[$2],X"},    CMP_AbsoluteX, CMP_General);\par
00220     _INST_FROM (0xd9, 3, 4, {\cf22 "CMP[$2],Y"},    CMP_AbsoluteY, CMP_General);\par
00221 \par
00222     {\cf20 // CPX}\par
00224 {\cf20 }    {\cf17 class }CPX_General : {\cf17 public} Instruction\par
00225     \{\par
00226         {\cf17 public}:\par
00227         CPX_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00228             : Instruction (c, mp, cc, t)\par
00229                             \{ \}\par
00230 \par
00231         {\cf17 protected}:\par
00232         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00233     \};\par
00234 \par
00235     _INST_FROM (0xe0, 2, 2, {\cf22 "CPX#[#1]"},     CPX_Inmediate, CPX_General);\par
00236     _INST_FROM (0xec, 3, 4, {\cf22 "CPX[$2]"},  CPX_Absolute, CPX_General);\par
00237     _INST_FROM (0xe4, 2, 3, {\cf22 "CPX[$1]"},      CPX_ZeroPage, CPX_General);\par
00238 \par
00239     {\cf20 // CPY}\par
00241 {\cf20 }    {\cf17 class }CPY_General : {\cf17 public} Instruction\par
00242     \{\par
00243         {\cf17 public}:\par
00244         CPY_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00245             : Instruction (c, mp, cc, t)\par
00246                             \{ \}\par
00247 \par
00248         {\cf17 protected}:\par
00249         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00250     \};\par
00251 \par
00252     _INST_FROM (0xc0, 2, 2, {\cf22 "CPY#[#1]"},     CPY_Inmediate, CPY_General);\par
00253     _INST_FROM (0xcc, 3, 4, {\cf22 "CPY[$2]"},  CPY_Absolute, CPY_General);\par
00254     _INST_FROM (0xc4, 2, 3, {\cf22 "CPY[$1]"},      CPY_ZeroPage, CPY_General);\par
00255 \par
00256     {\cf20 // DEC}\par
00258 {\cf20 }    {\cf17 class }DEC_General : {\cf17 public} Instruction\par
00259     \{\par
00260         {\cf17 public}:\par
00261         DEC_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00262             : Instruction (c, mp, cc, t)\par
00263                             \{ \}\par
00264 \par
00265         {\cf17 protected}:\par
00266         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00267     \};\par
00268 \par
00269     _INST_FROM (0xce, 3, 6, {\cf22 "DEC[$2]"},  DEC_Absolute, DEC_General);\par
00270     _INST_FROM (0xc6, 2, 5, {\cf22 "DEC[$1]"},      DEC_ZeroPage, DEC_General);\par
00271     _INST_FROM (0xd6, 2, 6, {\cf22 "DEC[$1],X"},    DEC_ZeroPageX, DEC_General);\par
00272     _INST_FROM (0xde, 3, 7, {\cf22 "DEC[$2],X"},    DEC_AbsoluteX, DEC_General);\par
00273 \par
00274     {\cf20 // DEX}\par
00275     _INST_FROM (0xca, 1, 2, {\cf22 "DEX"},          DEX, Instruction);\par
00276 \par
00277     {\cf20 // DEY}\par
00278     _INST_FROM (0x88, 1, 2, {\cf22 "DEY"},          DEY, Instruction);\par
00279 \par
00280     {\cf20 // EOR}\par
00282 {\cf20 }    {\cf17 class }EOR_General : {\cf17 public} Instruction\par
00283     \{\par
00284         {\cf17 public}:\par
00285         EOR_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00286             : Instruction (c, mp, cc, t)\par
00287                             \{ \}\par
00288 \par
00289         {\cf17 protected}:\par
00290         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00291     \};\par
00292 \par
00293     _INST_FROM (0x49, 2, 2, {\cf22 "EOR#[#1]"},     EOR_Inmediate, EOR_General);\par
00294     _INST_FROM (0x4d, 3, 4, {\cf22 "EOR[$2]"},      EOR_Absolute, EOR_General);\par
00295     _INST_FROM (0x45, 2, 3, {\cf22 "EOR[$1]"},      EOR_ZeroPage, EOR_General);\par
00296     _INST_FROM (0x41, 2, 6, {\cf22 "EOR([$1],X)"},  EOR_ZeroPageIndirectX, EOR_General);\par
00297     _INST_FROM (0x51, 2, 5, {\cf22 "EOR([$1]),Y"},  EOR_ZeroPageIndirectY, EOR_General);\par
00298     _INST_FROM (0x55, 2, 4, {\cf22 "EOR[$1],X"},    EOR_ZeroPageX, EOR_General);\par
00299     _INST_FROM (0x5d, 3, 4, {\cf22 "EOR[$2],X"},    EOR_AbsoluteX, EOR_General);\par
00300     _INST_FROM (0x59, 3, 4, {\cf22 "EOR[$2],Y"},    EOR_AbsoluteY, EOR_General);\par
00301 \par
00302     {\cf20 // INC}\par
00304 {\cf20 }    {\cf17 class }INC_General : {\cf17 public} Instruction\par
00305     \{\par
00306         {\cf17 public}:\par
00307         INC_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00308             : Instruction (c, mp, cc, t)\par
00309                             \{ \}\par
00310 \par
00311         {\cf17 protected}:\par
00312         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00313     \};\par
00314 \par
00315     _INST_FROM (0xee, 3, 6, {\cf22 "INC[$2]"},      INC_Absolute, INC_General);\par
00316     _INST_FROM (0xe6, 2, 5, {\cf22 "INC[$1]"},      INC_ZeroPage, INC_General);\par
00317     _INST_FROM (0xf6, 2, 6, {\cf22 "INC[$1],X"},    INC_ZeroPageX, INC_General);\par
00318     _INST_FROM (0xfe, 3, 7, {\cf22 "INC[$2],X"},    INC_AbsoluteX, INC_General);\par
00319 \par
00320     {\cf20 // INX}\par
00321     _INST_FROM (0xe8, 1, 2, {\cf22 "INX"},          INX, Instruction);\par
00322 \par
00323     {\cf20 // INY}\par
00324     _INST_FROM (0xc8, 1, 2, {\cf22 "INY"},          INY, Instruction);\par
00325 \par
00326     {\cf20 // JMP}\par
00327     _INST_FROM (0x4c, 3, 3, {\cf22 "JMP[%2]"},      JMP_Absolute, Instruction);\par
00328     _INST_FROM (0x6c, 3, 5, {\cf22 "JMP([%2])"},    JMP_Indirect, Instruction);\par
00329 \par
00330     {\cf20 // JSR}\par
00331     _INST_FROM (0x20, 3, 6, {\cf22 "JSR[%2]"},      JSR_Absolute, Instruction);\par
00332 \par
00333     {\cf20 // LDA}\par
00335 {\cf20 }    {\cf17 class }LDA_General : {\cf17 public} Instruction\par
00336     \{\par
00337         {\cf17 public}:\par
00338         LDA_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00339             : Instruction (c, mp, cc, t)\par
00340                             \{ \}\par
00341 \par
00342         {\cf17 protected}:\par
00343         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00344     \};\par
00345 \par
00346     _INST_FROM (0xa9, 2, 2, {\cf22 "LDA#[#1]"},     LDA_Inmediate, LDA_General);\par
00347     _INST_FROM (0xad, 3, 4, {\cf22 "LDA[$2]"},      LDA_Absolute, LDA_General);\par
00348     _INST_FROM (0xa5, 2, 3, {\cf22 "LDA[$1]"},      LDA_ZeroPage, LDA_General);\par
00349     _INST_FROM (0xa1, 2, 6, {\cf22 "LDA([$1],X)"},  LDA_ZeroPageIndirectX, LDA_General);\par
00350     _INST_FROM (0xb1, 2, 5, {\cf22 "LDA([$1]),Y"},  LDA_ZeroPageIndirectY, LDA_General);\par
00351     _INST_FROM (0xb5, 2, 4, {\cf22 "LDA[$1],X"},    LDA_ZeroPageX, LDA_General);\par
00352     _INST_FROM (0xbd, 3, 4, {\cf22 "LDA[$2],X"},    LDA_AbsoluteX, LDA_General);\par
00353     _INST_FROM (0xb9, 3, 4, {\cf22 "LDA[$2],Y"},    LDA_AbsoluteY, LDA_General);\par
00354 \par
00355     {\cf20 // LDX}\par
00357 {\cf20 }    {\cf17 class }LDX_General : {\cf17 public} Instruction\par
00358     \{\par
00359         {\cf17 public}:\par
00360         LDX_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00361             : Instruction (c, mp, cc, t)\par
00362                             \{ \}\par
00363 \par
00364         {\cf17 protected}:\par
00365         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00366     \};\par
00367 \par
00368     _INST_FROM (0xa2, 2, 2, {\cf22 "LDX#[#1]"},     LDX_Inmediate, LDX_General);\par
00369     _INST_FROM (0xae, 3, 4, {\cf22 "LDX[$2]"},      LDX_Absolute, LDX_General);\par
00370     _INST_FROM (0xa6, 2, 3, {\cf22 "LDX[$1]"},      LDX_ZeroPage, LDX_General);\par
00371     _INST_FROM (0xbe, 3, 4, {\cf22 "LDX[$2],Y"},    LDX_AbsoluteY, LDX_General);\par
00372     _INST_FROM (0xb6, 2, 4, {\cf22 "LDX[$1],Y"},    LDX_ZeroPageY, LDX_General);\par
00373 \par
00374     {\cf20 // LDY}\par
00376 {\cf20 }    {\cf17 class }LDY_General : {\cf17 public} Instruction\par
00377     \{\par
00378         {\cf17 public}:\par
00379         LDY_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00380             : Instruction (c, mp, cc, t)\par
00381                             \{ \}\par
00382 \par
00383         {\cf17 protected}:\par
00384         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00385     \};\par
00386 \par
00387     _INST_FROM (0xa0, 2, 2, {\cf22 "LDY#[#1]"},     LDY_Inmediate, LDY_General);\par
00388     _INST_FROM (0xac, 3, 4, {\cf22 "LDY[$2]"},      LDY_Absolute, LDY_General);\par
00389     _INST_FROM (0xa4, 2, 3, {\cf22 "LDY[$1]"},      LDY_ZeroPage, LDY_General);\par
00390     _INST_FROM (0xb4, 2, 4, {\cf22 "LDY[$1],X"},    LDY_ZeroPageX, LDY_General);\par
00391     _INST_FROM (0xbc, 3, 4, {\cf22 "LDY[$2],X"},    LDY_AbsoluteX, LDY_General);\par
00392 \par
00393     {\cf20 // LSR}\par
00395 {\cf20 }    {\cf17 class }LSR_General : {\cf17 public} Instruction\par
00396     \{\par
00397         {\cf17 public}:\par
00398         LSR_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00399             : Instruction (c, mp, cc, t)\par
00400                             \{ \}\par
00401 \par
00402         {\cf17 protected}:\par
00403         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00404     \};\par
00405 \par
00406     _INST_FROM (0x4e, 3, 6, {\cf22 "LSR[$2]"},      LSR_Absolute, LSR_General);\par
00407     _INST_FROM (0x46, 2, 5, {\cf22 "LSR[$1]"},      LSR_ZeroPage, LSR_General);\par
00408     _INST_FROM (0x4a, 1, 2, {\cf22 "LSR"},          LSR_Accumulator, LSR_General);\par
00409     _INST_FROM (0x56, 2, 6, {\cf22 "LSR[$1],X"},    LSR_ZeroPageX, LSR_General);\par
00410     _INST_FROM (0x5e, 3, 7, {\cf22 "LSR[$2],X"},    LSR_AbsoluteX, LSR_General);\par
00411 \par
00412     {\cf20 // NOP}\par
00413     _INST_FROM (0xea, 1, 2, {\cf22 "NOP"},          NOP, Instruction);\par
00414 \par
00415     {\cf20 // ORA}\par
00417 {\cf20 }    {\cf17 class }ORA_General : {\cf17 public} Instruction\par
00418     \{\par
00419         {\cf17 public}:\par
00420         ORA_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00421             : Instruction (c, mp, cc, t)\par
00422                             \{ \}\par
00423 \par
00424         {\cf17 protected}:\par
00425         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00426     \};\par
00427 \par
00428     _INST_FROM (0x09, 2, 2, {\cf22 "ORA#[#1]"},     ORA_Inmediate, ORA_General);\par
00429     _INST_FROM (0x0d, 3, 4, {\cf22 "ORA[$2]"},      ORA_Absolute, ORA_General);\par
00430     _INST_FROM (0x05, 2, 3, {\cf22 "ORA[$1]"},      ORA_ZeroPage, ORA_General);\par
00431     _INST_FROM (0x01, 2, 6, {\cf22 "ORA([$1],X)"},  ORA_ZeroPageIndirectX, ORA_General);\par
00432     _INST_FROM (0x11, 2, 5, {\cf22 "ORA([$1]),Y"},  ORA_ZeroPageIndirectY, ORA_General);\par
00433     _INST_FROM (0x15, 2, 4, {\cf22 "ORA[$1],X"},    ORA_ZeroPageX, ORA_General);\par
00434     _INST_FROM (0x1d, 3, 4, {\cf22 "ORA[$2],X"},    ORA_AbsoluteX, ORA_General);\par
00435     _INST_FROM (0x19, 3, 4, {\cf22 "ORA[$2],Y"},    ORA_AbsoluteY, ORA_General);\par
00436 \par
00437     {\cf20 // PHA}\par
00438     _INST_FROM (0x48, 1, 3, {\cf22 "PHA"},          PHA, Instruction);\par
00439 \par
00440     {\cf20 // PHP}\par
00441     _INST_FROM (0x08, 1, 3, {\cf22 "PHP"},          PHP, Instruction);\par
00442 \par
00443     {\cf20 // PLA}\par
00444     _INST_FROM (0x68, 1, 4, {\cf22 "PLA"},          PLA, Instruction);\par
00445 \par
00446     {\cf20 // PLP}\par
00447     _INST_FROM (0x28, 1, 4, {\cf22 "PLP"},          PLP, Instruction);\par
00448 \par
00449     {\cf20 // ROL}\par
00451 {\cf20 }    {\cf17 class }ROL_General : {\cf17 public} Instruction\par
00452     \{\par
00453         {\cf17 public}:\par
00454         ROL_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00455             : Instruction (c, mp, cc, t)\par
00456                             \{ \}\par
00457 \par
00458         {\cf17 protected}:\par
00459         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00460     \};\par
00461 \par
00462     _INST_FROM (0x2e, 3, 6, {\cf22 "ROL[$2]"},      ROL_Absolute, ROL_General);\par
00463     _INST_FROM (0x26, 2, 5, {\cf22 "ROL[$1]"},      ROL_ZeroPage, ROL_General);\par
00464     _INST_FROM (0x2a, 1, 2, {\cf22 "ROL"},          ROL_Accumulator, ROL_General);\par
00465     _INST_FROM (0x36, 2, 6, {\cf22 "ROL[$1],X"},    ROL_ZeroPageX, ROL_General);\par
00466     _INST_FROM (0x3e, 3, 7, {\cf22 "ROL[$2],X"},    ROL_AbsoluteX, ROL_General);\par
00467 \par
00468     {\cf20 // ROR}\par
00470 {\cf20 }    {\cf17 class }ROR_General : {\cf17 public} Instruction\par
00471     \{\par
00472         {\cf17 public}:\par
00473         ROR_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00474             : Instruction (c, mp, cc, t)\par
00475                             \{ \}\par
00476 \par
00477         {\cf17 protected}:\par
00478         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00479     \};\par
00480 \par
00481     _INST_FROM (0x6e, 3, 6, {\cf22 "ROR[$2]"},      ROR_Absolute, ROR_General);\par
00482     _INST_FROM (0x66, 2, 5, {\cf22 "ROR[$1]"},      ROR_ZeroPage, ROR_General);\par
00483     _INST_FROM (0x6a, 1, 2, {\cf22 "ROR"},          ROR_Accumulator, ROR_General);\par
00484     _INST_FROM (0x76, 2, 6, {\cf22 "ROR[$1],X"},    ROR_ZeroPageX, ROR_General);\par
00485     _INST_FROM (0x7e, 3, 7, {\cf22 "ROR[$2],X"},    ROR_AbsoluteX, ROR_General);\par
00486 \par
00487     {\cf20 // RTI}\par
00488     _INST_FROM (0x40, 1, 6, {\cf22 "RTI"},          RTI, Instruction);\par
00489 \par
00490     {\cf20 // RTS}\par
00491     _INST_FROM (0x60, 1, 6, {\cf22 "RTS"},          RTS, Instruction);\par
00492 \par
00493     {\cf20 // SBC}\par
00495 {\cf20 }    {\cf17 class }SBC_General : {\cf17 public} Instruction\par
00496     \{\par
00497         {\cf17 public}:\par
00498         SBC_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00499             : Instruction (c, mp, cc, t)\par
00500                             \{ \}\par
00501 \par
00502         {\cf17 protected}:\par
00503         {\cf18 bool} executeWith (MCHEmul::UByte u);\par
00504     \};\par
00505 \par
00506     _INST_FROM (0xe9, 2, 2, {\cf22 "SBC#[#1]"},     SBC_Inmediate, SBC_General);\par
00507     _INST_FROM (0xed, 3, 4, {\cf22 "SBC[$2]"},      SBC_Absolute, SBC_General);\par
00508     _INST_FROM (0xe5, 2, 3, {\cf22 "SBC[$1]"},      SBC_ZeroPage, SBC_General);\par
00509     _INST_FROM (0xe1, 2, 6, {\cf22 "SBC([$1],X)"},  SBC_ZeroPageIndirectX, SBC_General);\par
00510     _INST_FROM (0xf1, 2, 5, {\cf22 "SBC([$1]),Y"},  SBC_ZeroPageIndirectY, SBC_General);\par
00511     _INST_FROM (0xf5, 2, 4, {\cf22 "SBC[$1],X"},    SBC_ZeroPageX, SBC_General);\par
00512     _INST_FROM (0xfd, 3, 4, {\cf22 "SBC[$2],X"},    SBC_AbsoluteX, SBC_General);\par
00513     _INST_FROM (0xf9, 3, 4, {\cf22 "SBC[$2],Y"},    SBC_AbsoluteY, SBC_General);\par
00514 \par
00515     {\cf20 // SEC}\par
00516     _INST_FROM (0x38, 1, 2, {\cf22 "SEC"},          SEC, Instruction);\par
00517 \par
00518     {\cf20 // SED}\par
00519     _INST_FROM (0xf8, 1, 2, {\cf22 "SED"},          SED, Instruction);\par
00520 \par
00521     {\cf20 // SEI}\par
00522     _INST_FROM (0x78, 1, 2, {\cf22 "SEI"},          SEI, Instruction);\par
00523 \par
00524     {\cf20 // STA}\par
00526 {\cf20 }    {\cf17 class }STA_General : {\cf17 public} Instruction\par
00527     \{\par
00528         {\cf17 public}:\par
00529         STA_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00530             : Instruction (c, mp, cc, t)\par
00531                             \{ \}\par
00532 \par
00533         {\cf17 protected}:\par
00534         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00535     \};\par
00536 \par
00537     _INST_FROM (0x8d, 3, 4, {\cf22 "STA[$2]"},      STA_Absolute, STA_General);\par
00538     _INST_FROM (0x85, 2, 3, {\cf22 "STA[$1]"},      STA_ZeroPage, STA_General);\par
00539     _INST_FROM (0x81, 2, 6, {\cf22 "STA([$1],X)"},  STA_ZeroPageIndirectX, STA_General);\par
00540     _INST_FROM (0x91, 2, 6, {\cf22 "STA([$1]),Y"},  STA_ZeroPageIndirectY, STA_General);\par
00541     _INST_FROM (0x95, 2, 4, {\cf22 "STA[$1],X"},    STA_ZeroPageX, STA_General);\par
00542     _INST_FROM (0x9d, 3, 5, {\cf22 "STA[$2],X"},    STA_AbsoluteX, STA_General);\par
00543     _INST_FROM (0x99, 3, 5, {\cf22 "STA[$2],Y"},    STA_AbsoluteY, STA_General);\par
00544 \par
00545     {\cf20 // STX}\par
00547 {\cf20 }    {\cf17 class }STX_General : {\cf17 public} Instruction\par
00548     \{\par
00549         {\cf17 public}:\par
00550         STX_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00551             : Instruction (c, mp, cc, t)\par
00552                             \{ \}\par
00553 \par
00554         {\cf17 protected}:\par
00555         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00556     \};\par
00557 \par
00558     _INST_FROM (0x8e, 3, 4, {\cf22 "STX[$2]"},      STX_Absolute, STX_General);\par
00559     _INST_FROM (0x86, 2, 3, {\cf22 "STX[$1]"},      STX_ZeroPage, STX_General);\par
00560     _INST_FROM (0x96, 2, 4, {\cf22 "STX[$1],Y"},    STX_ZeroPageY, STX_General);\par
00561 \par
00562     {\cf20 // STY}\par
00564 {\cf20 }    {\cf17 class }STY_General : {\cf17 public} Instruction\par
00565     \{\par
00566         {\cf17 public}:\par
00567         STY_General ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00568             : Instruction (c, mp, cc, t)\par
00569                             \{ \}\par
00570 \par
00571         {\cf17 protected}:\par
00572         {\cf18 bool} executeOn ({\cf17 const} MCHEmul::Address& a);\par
00573     \};\par
00574 \par
00575     _INST_FROM (0x8c, 3, 4, {\cf22 "STY[$2]"},      STY_Absolute, STY_General);\par
00576     _INST_FROM (0x84, 2, 3, {\cf22 "STY[$1]"},      STY_ZeroPage, STY_General);\par
00577     _INST_FROM (0x94, 2, 4, {\cf22 "STY[$1],X"},    STY_ZeroPageX, STY_General);\par
00578 \par
00579     {\cf20 // TAX}\par
00580     _INST_FROM (0xaa, 1, 2, {\cf22 "TAX"},          TAX, Instruction);\par
00581 \par
00582     {\cf20 // TAY}\par
00583     _INST_FROM (0xa8, 1, 2, {\cf22 "TAY"},          TAY, Instruction);\par
00584 \par
00585     {\cf20 // TSX}\par
00586     _INST_FROM (0xba, 1, 2, {\cf22 "TSX"},          TSX, Instruction);\par
00587 \par
00588     {\cf20 // TXA}\par
00589     _INST_FROM (0x8a, 1, 2, {\cf22 "TXA"},          TXA, Instruction);\par
00590 \par
00591     {\cf20 // TXS}\par
00592     _INST_FROM (0x9a, 1, 2, {\cf22 "TXS"},          TXS, Instruction);\par
00593 \par
00594     {\cf20 // TYA}\par
00595     _INST_FROM (0x98, 1, 2, {\cf22 "TYA"},          TYA, Instruction);\par
00596 \}\par
00597 \par
00598 {\cf21 #endif}\par
00599   \par
00600 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/IRQInterrupt.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/IRQInterrupt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/IRQInterrupt.hpp}
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::IRQInterrupt}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b F6500}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IRQInterrupt.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/IRQInterrupt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/IRQInterrupt.hpp}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __F6500_IRQINTERRUPT__}\par
00015 {\cf21 #define __F6500_IRQINTERRUPT__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }F6500\par
00020 \{\par
00022     {\cf17 class }IRQInterrupt : {\cf17 public} MCHEmul::CPUInterrupt\par
00023     \{\par
00024         {\cf17 public}:\par
00025         {\cf17 static} {\cf17 const} {\cf18 unsigned} {\cf18 int} _ID = 0;\par
00026 \par
00027         IRQInterrupt ()\par
00028             : MCHEmul::CPUInterrupt (_ID)\par
00029                             \{ \}\par
00030 \par
00031         {\cf17 protected}:\par
00033         {\cf17 virtual} {\cf18 bool} isTime (MCHEmul::CPU* c) {\cf17 const override}; \par
00034         {\cf17 virtual} {\cf18 void} executeOverImpl (MCHEmul::CPU* c, {\cf18 unsigned} {\cf18 int}& nC) {\cf17 override};\par
00035     \};\par
00036 \}\par
00037 \par
00038 {\cf21 #endif}\par
00039   \par
00040 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/include/F6500/NMIInterrupt.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/NMIInterrupt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/NMIInterrupt.hpp}
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/incs.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b F6500::NMIInterrupt}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b F6500}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NMIInterrupt.hpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/include/F6500/NMIInterrupt.hpp}
{\xe \v C:/WorkspacesII/EMULATORS/include/F6500/NMIInterrupt.hpp}
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00003 \par
00014 {\cf21 #ifndef __F6500_NMIINTERRUPT__}\par
00015 {\cf21 #define __F6500_NMIINTERRUPT__}\par
00016 \par
00017 {\cf21 #include <CORE/incs.hpp>}\par
00018 \par
00019 {\cf17 namespace }F6500\par
00020 \{\par
00022     {\cf17 class }NMIInterrupt : {\cf17 public} MCHEmul::CPUInterrupt\par
00023     \{\par
00024         {\cf17 public}:\par
00025         {\cf17 static} {\cf17 const} {\cf18 int} _ID = 1;\par
00026 \par
00027         NMIInterrupt ()\par
00028             : MCHEmul::CPUInterrupt (_ID)\par
00029                             \{ \}\par
00030 \par
00031         {\cf17 protected}:\par
00033         {\cf17 virtual} {\cf18 bool} isTime (MCHEmul::CPU* c){\cf17  const override }\par
00034 {\cf17                             }\{{\cf19 return} ({\cf17 true}); \} \par
00035         {\cf17 virtual} {\cf18 void} executeOverImpl (MCHEmul::CPU* c, {\cf18 unsigned} {\cf18 int}& nC) {\cf17 override};\par
00036     \};\par
00037 \}\par
00038 \par
00039 {\cf21 #endif}\par
00040   \par
00041 {\cf20 // End of the file}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Compiler.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Compiler.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Compiler.cpp}
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ASSEMBLER/Compiler.hpp>}\par
{\f2 #include <algorithm>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Compiler.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Compiler.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Compiler.cpp}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <ASSEMBLER/Compiler.hpp>}\par
00002 {\cf21 #include <algorithm>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 std::ostream& MCHEmul::Assembler::operator << (std::ostream& o, {\cf17 const} MCHEmul::Assembler::ByteCodeLine& c)\par
00006 \{\par
00007     o << c._address << {\cf22 ":"};\par
00008 \par
00009     {\cf18 bool} f = {\cf17 true};\par
00010     {\cf19 for} ({\cf17 auto} i : c._bytes)\par
00011     \{\par
00012         o << ((!f) ? {\cf22 " "} : {\cf22 ""}) << i; \par
00013         f = {\cf17 false};\par
00014     \}\par
00015 \par
00016     o << ((c._instruction != {\cf17 nullptr}) ? ({\cf22 " "} + c._instruction -> iTemplate ()) : {\cf22 ""});\par
00017     o << ((c._label != {\cf22 ""}) ? {\cf22 " "} : {\cf22 ""}) << c._label;\par
00018 \par
00019     {\cf19 return} (o);\par
00020 \}\par
00021 \par
00022 {\cf20 // ---}\par
00023 std::vector <MCHEmul::UByte> MCHEmul::Assembler::ByteCode::asSetOfBytes (MCHEmul::Address& iA){\cf17  const}\par
00024 {\cf17 }\{\par
00025     {\cf19 if} (_lines.empty ())\par
00026         {\cf19 return} (std::vector <MCHEmul::UByte> ());\par
00027 \par
00028     {\cf17 auto} sort = []({\cf17 const} MCHEmul::Assembler::ByteCodeLine& l1, \par
00029         {\cf17 const} MCHEmul::Assembler::ByteCodeLine& l2) -> {\cf18 bool} \{ {\cf19 return} (l1._address < l2._address); \};\par
00030 \par
00031     MCHEmul::Assembler::ByteCode cp = *{\cf17 this};\par
00032     std::sort (cp._lines.begin (), cp._lines.end (), sort);\par
00033 \par
00034     std::vector <MCHEmul::UByte> result;\par
00035     iA = cp._lines [0]._address;\par
00036     MCHEmul::Address nA = iA; \par
00037     {\cf19 for} ({\cf17 auto} i : cp._lines)\par
00038     \{\par
00039         {\cf19 if} (i._address > nA)\par
00040         \{\par
00041             {\cf19 while} (nA != i._address)\par
00042             \{\par
00043                 result.push_back (MCHEmul::UByte::_0);\par
00044                 nA = nA + 1;\par
00045             \}\par
00046         \}\par
00047 \par
00048         {\cf19 for} ({\cf17 auto} j : i._bytes)\par
00049             result.push_back (j);\par
00050 \par
00051         nA += i._bytes.size ();\par
00052     \}\par
00053 \par
00054     {\cf19 return} (result);\par
00055 \}\par
00056 \par
00057 {\cf20 // ---}\par
00058 std::map <MCHEmul::Address, unsigned int> MCHEmul::Assembler::ByteCode::listOfActions (){\cf17  const}\par
00059 {\cf17 }\{\par
00060     std::map <MCHEmul::Address, unsigned int> result;\par
00061 \par
00062     {\cf19 for} ({\cf17 auto} i : _lines)\par
00063         {\cf19 if} (i._actionOn != 0)\par
00064             result.insert (std::map <MCHEmul::Address, unsigned int>::value_type (i._address, i._actionOn));\par
00065 \par
00066     {\cf19 return} (result);\par
00067 \}\par
00068 \par
00069 {\cf20 // ---}\par
00070 {\cf18 void} MCHEmul::Assembler::ByteCode::loadIntoMemory (MCHEmul::Memory* m)\par
00071 \{\par
00072     assert (m != {\cf17 nullptr});\par
00073 \par
00074     {\cf19 for} ({\cf17 auto} i : _lines)\par
00075         m -> set (i._address, i._bytes);\par
00076 \}\par
00077 \par
00078 {\cf20 // ---}\par
00079 MCHEmul::Assembler::ByteCode MCHEmul::Assembler::ByteCode::createFromMemory \par
00080     ({\cf17 const} MCHEmul::Address& a, {\cf18 unsigned} {\cf18 int} b, MCHEmul::Memory* m, MCHEmul::CPU* cpu)\par
00081 \{\par
00082     assert (m != {\cf17 nullptr} && cpu != {\cf17 nullptr});\par
00083 \par
00084     MCHEmul::Assembler::ByteCode result;\par
00085 \par
00086     {\cf18 unsigned} {\cf18 int} i = 0;\par
00087     {\cf19 while} (i < b)\par
00088     \{\par
00089         MCHEmul::Instructions::const_iterator pi =\par
00090             cpu -> instructions ().find (MCHEmul::UInt \par
00091                 (m -> values (a, cpu -> architecture ().instructionLength ()).bytes ()).asUnsignedInt ());\par
00092         {\cf19 if} (pi == cpu -> instructions ().end ())\par
00093             {\cf19 break}; {\cf20 // No sense to continue...the instruction doesn't exist...}\par
00094 \par
00095         {\cf17 const} MCHEmul::Instruction* inst = (*pi).second;\par
00096         result._lines.push_back (MCHEmul::Assembler::ByteCodeLine \par
00097             (a, m -> values (a, inst -> memoryPositions ()).bytes (), {\cf22 ""} , inst, 0 ));\par
00098         i += inst -> memoryPositions ();\par
00099     \}\par
00100 \par
00101     {\cf19 return} (result);\par
00102 \}\par
00103 \par
00104 {\cf20 // ---}\par
00105 MCHEmul::Assembler::ByteCode MCHEmul::Assembler::Compiler::compile ({\cf17 const} std::string& fN){\cf17  const}\par
00106 {\cf17 }\{\par
00107     MCHEmul::Assembler::ByteCode result;\par
00108 \par
00109     _errors = \{ \};\par
00110 \par
00111     {\cf20 // First of all, parse...}\par
00112     MCHEmul::Assembler::Semantic* smt = _parser.parse (fN, fN + {\cf22 ".act"});\par
00113     {\cf19 if} (!_parser)\par
00114     \{\par
00115         _errors = _parser.errors ();\par
00116         {\cf19 return} (result);\par
00117     \}\par
00118 \par
00119     {\cf20 // Then compile...}\par
00120     {\cf20 // First determines the value of the macros...}\par
00121     {\cf19 for} (MCHEmul::Assembler::Macros::const_iterator i = smt -> macros ().begin (); \par
00122             i != smt -> macros ().end (); i++) {\cf20 // Instead for (auto i : smt -> macros ()) because it makes a copy of the content}\par
00123                                                {\cf20 // and the values are not then actualized over the original list!}\par
00124     \{\par
00125         (*i).second.value (smt -> macros ()); {\cf20 // Try to calculate the value (but it wold be used)...}\par
00126         {\cf19 if} (!(*i).second)\par
00127             _errors.push_back (MCHEmul::Assembler::Error ((*i).second.error (), fN, 0, 0));\par
00128     \}\par
00129 \par
00130     {\cf20 // If there were any error calculating the value of the macros}\par
00131     {\cf20 // it would not be able to continue}\par
00132     {\cf19 if} (!(*{\cf17 this}))\par
00133         {\cf19 return} (result);\par
00134 \par
00135     {\cf20 // Then, with the macros calculated, the lines could be calculated}\par
00136     {\cf20 // Errors could happen when managing the instructions...}\par
00137     {\cf19 for} ({\cf17 auto} i : smt -> startingPoints ())\par
00138     \{\par
00139         assert ({\cf17 dynamic_cast <}MCHEmul::Assembler::StartingPointElement*{\cf17 >} (i) != {\cf17 nullptr});\par
00140 \par
00141         MCHEmul::Address spa (i -> codeBytes (smt, cpu () -> architecture ().bigEndian ()));\par
00142         {\cf19 if} (!*i)\par
00143         \{\par
00144             _errors.push_back (MCHEmul::Assembler::Error (i -> _error, fN, i -> _line, 0));\par
00145             {\cf19 continue};\par
00146         \}\par
00147 \par
00148         std::string lL = {\cf22 ""};\par
00149         {\cf19 for} (MCHEmul::Assembler::GrammaticalElement* gE = i -> _nextElement; \par
00150             gE != {\cf17 nullptr}; gE = gE -> _nextElement)\par
00151         \{\par
00152             {\cf19 switch} (gE -> _type)\par
00153             \{\par
00154                 {\cf19 case} MCHEmul::Assembler::GrammaticalElement::_LABEL:\par
00155                 \{\par
00156                     lL = {\cf17 static_cast <}MCHEmul::Assembler::LabelElement*{\cf17 >} (gE) -> _name;\par
00157                 \}\par
00158 \par
00159                 {\cf19 break};\par
00160 \par
00161                 {\cf19 case} MCHEmul::Assembler::GrammaticalElement::_BYTESINMEMORY:\par
00162                 {\cf19 case} MCHEmul::Assembler::GrammaticalElement::_INSTRUCTION:\par
00163                 \{\par
00164                     lL = {\cf22 ""};\par
00165                     std::vector <MCHEmul::UByte> b = \par
00166                         gE -> codeBytes (smt, cpu () -> architecture ().bigEndian ());\par
00167                     {\cf19 if} (!*gE)\par
00168                         _errors.push_back (MCHEmul::Assembler::Error (gE -> _error, fN, gE -> _line, 0));\par
00169                     {\cf19 else}\par
00170                         result._lines.push_back (MCHEmul::Assembler::ByteCodeLine (spa, b, lL, \par
00171                             (gE -> _type == MCHEmul::Assembler::GrammaticalElement::_INSTRUCTION) \par
00172                                 ? ({\cf17 static_cast <}MCHEmul::Assembler::InstructionElement*{\cf17 >} (gE)) -> _selectedInstruction : {\cf17 nullptr}, \par
00173                             gE -> _actionOn ));\par
00174 \par
00175                     spa += b.size (); {\cf20 // To the next...}\par
00176                 \}\par
00177 \par
00178                 {\cf19 break};\par
00179 \par
00180                 {\cf19 default}:\par
00181                     assert ({\cf17 false});\par
00182             \}\par
00183         \}\par
00184     \}\par
00185     \par
00186     {\cf17 delete} (smt);\par
00187 \par
00188     {\cf19 return} (result);\par
00189 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Error.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Error.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Error.cpp}
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ASSEMBLER/Error.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Error.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Error.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Error.cpp}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <ASSEMBLER/Error.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 std::ostream& MCHEmul::Assembler::operator << (std::ostream& o, {\cf17 const} MCHEmul::Assembler::Error& e)\par
00005 \{\par
00006     {\cf17 static} std::map <MCHEmul::Assembler::ErrorType, std::string> _ERRORTEXT =\par
00007         \{\par
00008             \{ MCHEmul::Assembler::ErrorType::_NOERROR, {\cf22 "No error"} \},\par
00009             \{ MCHEmul::Assembler::ErrorType::_MACROBADDEFINED, {\cf22 "Not valid Macro"} \},\par
00010             \{ MCHEmul::Assembler::ErrorType::_MACRONOTDEFINED, {\cf22 "Macro not defined"} \},\par
00011             \{ MCHEmul::Assembler::ErrorType::_LABELNOTVALID, {\cf22 "Not valid Label"} \},\par
00012             \{ MCHEmul::Assembler::ErrorType::_LABELNOTDEFINED, {\cf22 "Label not defined"} \},\par
00013             \{ MCHEmul::Assembler::ErrorType::_BYTESNOTVALID, {\cf22 "Bytes definition not valid"} \},\par
00014             \{ MCHEmul::Assembler::ErrorType::_STARTINGPOINTNOTVALID, {\cf22 "Not valid Starting Point"} \}, \par
00015             \{ MCHEmul::Assembler::ErrorType::_INSTRUCTIONNOTVALID, {\cf22 "Instruction definition not valid"} \},\par
00016             \{ MCHEmul::Assembler::ErrorType::_INSTRUCTIONNOTDEFINED, {\cf22 "Instruction not defined"} \},\par
00017             \{ MCHEmul::Assembler::ErrorType::_GRAMARELEMENTNOTVALID, {\cf22 "Not valid Grammatical Element"} \},\par
00018             \{ MCHEmul::Assembler::ErrorType::_STARTINGPOINTNOTDEFINED, {\cf22 "Starting Point not defined yet"} \},\par
00019             \{ MCHEmul::Assembler::ErrorType::_DUPLICATEMACRO, {\cf22 "Duplicated Macro"} \},\par
00020             \{ MCHEmul::Assembler::ErrorType::_SEMANTICERROR, {\cf22 "Semantic wrong"} \},\par
00021             \{ MCHEmul::Assembler::ErrorType::_FILEEMPTY, {\cf22 "Input file empty"} \},\par
00022             \{ MCHEmul::Assembler::ErrorType::_PARSERNOTFOUND, {\cf22 "Intruction Parser not defined"} \}\par
00023         \};\par
00024 \par
00025     {\cf19 return} (o << {\cf22 "Error: "} << _ERRORTEXT [e._type] << {\cf22 " at line "} << e._line << {\cf22 " in file "} << e._file);\par
00026 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Grammar.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Grammar.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Grammar.cpp}
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ASSEMBLER/Grammar.hpp>}\par
{\f2 #include <algorithm>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Grammar.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Grammar.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Grammar.cpp}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <ASSEMBLER/Grammar.hpp>}\par
00002 {\cf21 #include <algorithm>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 std::vector <MCHEmul::UByte> MCHEmul::Assembler::Macro::calculateValue \par
00006     ({\cf17 const} std::string& e, {\cf17 const} MCHEmul::Assembler::Macros& ms){\cf17  const}\par
00007 {\cf17 }\{\par
00008     std::vector <MCHEmul::UByte> result = \{ \}; \par
00009 \par
00010     _error = MCHEmul::Assembler::ErrorType::_NOERROR;\par
00011 \par
00012     {\cf20 // How to read:}\par
00013     {\cf20 // Check whether it exists operations between other macros to define this one...}\par
00014     {\cf20 // The checking is done in other or importance!}\par
00015     {\cf20 // If no operation symbold is found in the macro value definition, }\par
00016     {\cf20 // it is supossed that it will directly be either a label or a set of valid data... }\par
00017 \par
00018     {\cf18 size_t} r = e.find_first_of ({\cf23 '*'}); {\cf20 // To multiply values...}\par
00019     {\cf19 if} (r == std::string::npos) r = e.find_first_of ({\cf23 '+'}); {\cf20 // To add values...}\par
00020     {\cf19 if} (r == std::string::npos) r = e.find_first_of ({\cf23 '-'}); {\cf20 // To subtract values...}\par
00021     {\cf19 if} (r == std::string::npos)\par
00022     \{\par
00023         {\cf19 if} (MCHEmul::validLabel (e))\par
00024         \{\par
00025             MCHEmul::Assembler::Macros::const_iterator i = ms.find (e);\par
00026             {\cf19 if} (i != ms.end ())\par
00027             \{\par
00028                 result = (*i).second.value (ms);\par
00029                 {\cf19 if} (!(*i).second)\par
00030                 \{\par
00031                     _error = (*i).second._error;\par
00032                     result = \{ \}; {\cf20 // Just to be sure...}\par
00033                 \}\par
00034             \}\par
00035             {\cf19 else}\par
00036                 _error = MCHEmul::Assembler::ErrorType::_MACRONOTDEFINED; \par
00037         \}\par
00038         {\cf19 else}\par
00039         {\cf19 if} (MCHEmul::validBytes (e))\par
00040             result = MCHEmul::UInt::fromStr (_equivalent).bytes ();\par
00041         {\cf19 else}\par
00042             _error = MCHEmul::Assembler::ErrorType::_MACROBADDEFINED;\par
00043     \}\par
00044     {\cf19 else}\par
00045     \{\par
00046         MCHEmul::Assembler::Macro m1 ({\cf22 ""} , MCHEmul::trim (e.substr (0, r))); m1.value (ms);\par
00047         MCHEmul::Assembler::Macro m2 ({\cf22 ""}, MCHEmul::trim (e.substr (r + 1))); m2.value (ms);\par
00048         {\cf19 if} (!m1 || !m2)\par
00049             _error = MCHEmul::Assembler::ErrorType::_MACROBADDEFINED;\par
00050         {\cf19 else}\par
00051         \{\par
00052             MCHEmul::UInt u1 (m1.value (ms));\par
00053             MCHEmul::UInt u2 (m2.value (ms));\par
00054             {\cf19 if} (e [r] == {\cf23 '*'}) result = (u1 * u2).bytes ();\par
00055             {\cf19 else} {\cf19 if} (e [r] == {\cf23 '+'}) result = (u1 + u2).bytes ();\par
00056             {\cf19 else}  result = (u1 - u2).bytes ();\par
00057         \}\par
00058     \}\par
00059 \par
00060     {\cf19 return} (result);\par
00061 \}\par
00062 \par
00063 {\cf20 // ---}\par
00064 MCHEmul::Address MCHEmul::Assembler::GrammaticalElement::address ({\cf17 const} MCHEmul::Assembler::Semantic* s){\cf17  const}\par
00065 {\cf17 }\{\par
00066     assert (s != {\cf17 nullptr});\par
00067 \par
00068     {\cf18 size_t} b = 0;\par
00069     {\cf17 const} MCHEmul::Assembler::GrammaticalElement* gE = {\cf17 this} -> _previousElement;\par
00070     {\cf19 while} ({\cf17 dynamic_cast <}{\cf17 const }MCHEmul::Assembler::StartingPointElement*{\cf17 >} (gE) == {\cf17 nullptr})\par
00071     \{\par
00072         b += gE -> size (s);\par
00073         gE = gE -> _previousElement;\par
00074     \}\par
00075 \par
00076     {\cf17 const} MCHEmul::Assembler::StartingPointElement* sP = \par
00077         {\cf17 dynamic_cast <}{\cf17 const }MCHEmul::Assembler::StartingPointElement*{\cf17 >} (gE);\par
00078     assert (sP != {\cf17 nullptr}); {\cf20 // Just in case...}\par
00079 \par
00080     {\cf19 return} (sP -> address (s) + b);\par
00081 \}\par
00082 \par
00083 {\cf20 // ---}\par
00084 std::vector <MCHEmul::UByte> MCHEmul::Assembler::GrammaticalElement::bytesFromExpression \par
00085     ({\cf17 const} std::string& e, {\cf17 const} MCHEmul::Assembler::Macros& ms, {\cf18 bool}& er){\cf17  const}\par
00086 {\cf17 }\{\par
00087     std::vector <MCHEmul::UByte> result;\par
00088 \par
00089     er = {\cf17 false};\par
00090 \par
00091     {\cf19 if} (MCHEmul::validBytes (e))\par
00092     \{\par
00093         MCHEmul::UInt n = MCHEmul::UInt::fromStr (e);\par
00094         result.insert (result.end (), n.bytes ().begin (), n.bytes ().end ());\par
00095     \}\par
00096     {\cf19 else}\par
00097     \{\par
00098         MCHEmul::Assembler::Macro m ({\cf22 ""} , e);\par
00099         m.value (ms);\par
00100         {\cf19 if} (!m) {\cf20 // Error?...}\par
00101         \{\par
00102             er = {\cf17 true};\par
00103             {\cf19 return} (result);\par
00104         \}\par
00105 \par
00106         result.insert (result.end (), m.value (ms).begin (), m.value (ms).end ());\par
00107     \}\par
00108     \par
00109     {\cf19 return} (result);\par
00110 \}\par
00111 \par
00112 {\cf20 // ---}\par
00113 std::vector <MCHEmul::UByte> MCHEmul::Assembler::BytesInMemoryElement::calculateCodeBytes \par
00114     ({\cf17 const} MCHEmul::Assembler::Semantic* s, {\cf18 bool} bE){\cf17  const}\par
00115 {\cf17 }\{\par
00116     assert (s != {\cf17 nullptr});\par
00117 \par
00118     std::vector <MCHEmul::UByte> result;\par
00119 \par
00120     {\cf19 if} (!(*{\cf17 this}))\par
00121         {\cf19 return} (result); {\cf20 // Not possible when previous error...}\par
00122 \par
00123     {\cf18 bool} e = {\cf17 false};\par
00124     {\cf19 for} (std::vector <std::string>::const_iterator i = _elements.begin (); \par
00125             i != _elements.end () && !e; i++)\par
00126     \{\par
00127         std::vector <MCHEmul::UByte> n = bytesFromExpression ((*i), s -> macros (), e);\par
00128         result.insert (result.end (), n.begin (), n.end ());\par
00129     \}\par
00130 \par
00131     {\cf19 if} (e)\par
00132     \{\par
00133         _error = MCHEmul::Assembler::ErrorType::_BYTESNOTVALID;\par
00134         result = \{ \}; {\cf20 // Nothing when error...}\par
00135     \}\par
00136 \par
00137     {\cf19 return} (result);\par
00138 \}\par
00139 \par
00140 {\cf20 // ---}\par
00141 {\cf18 size_t} MCHEmul::Assembler::InstructionElement::size ({\cf17 const} Semantic* s){\cf17  const }\par
00142 {\cf17 }\{ \par
00143     {\cf18 size_t} result = 0;\par
00144 \par
00145     {\cf19 if} (!(*{\cf17 this}))\par
00146         {\cf19 return} (0); {\cf20 // With error, no size...}\par
00147 \par
00148     {\cf19 if} (_possibleInstructions.size () == 1)\par
00149         result = (*_possibleInstructions.begin ()) -> memoryPositions ();\par
00150     {\cf19 else}\par
00151     \{\par
00152         {\cf19 if} (_codeBytes.size () != 0) {\cf20 // It has already been calculated, so the size can be determine looking at this variable...}\par
00153             result = _codeBytes.size ();\par
00154         {\cf19 else}\par
00155         \{\par
00156             {\cf20 // The best way to calculate the size of an instruction is to determine its codebytes and then look at its size...}\par
00157             {\cf20 // However trying to calculate the codeBytes of a jump here could generate a dead lock.}\par
00158             \par
00159             {\cf20 // The first step to take is to determine whether there are jump instructions among the potential ones}\par
00160             {\cf18 bool} jS = {\cf17 false};\par
00161             {\cf18 unsigned} {\cf18 short} nJS = 0;\par
00162             {\cf19 for} ({\cf17 auto} i : _possibleInstructions)\par
00163             \{\par
00164                 {\cf19 for} (std::vector <MCHEmul::Instruction::Structure::Parameter>::const_iterator j = \par
00165                         i -> internalStructure ()._parameters.begin (); \par
00166                         j != i -> internalStructure ()._parameters.end () && !jS; j++)\par
00167                     jS = ((*j)._type == MCHEmul::Instruction::Structure::Parameter::Type::_RELJUMP ||\par
00168                           (*j)._type == MCHEmul::Instruction::Structure::Parameter::Type::_ABSJUMP);\par
00169 \par
00170                 {\cf19 if} (jS) nJS++;\par
00171             \}\par
00172 \par
00173             {\cf20 // If there are jump instructions among the possible ones...}\par
00174             {\cf19 if} (nJS != 0)\par
00175             \{\par
00176                 {\cf20 // ...and not all of them are jump instructions, }\par
00177                 {\cf20 // It would be impossible to determine the size of the instructions...}\par
00178                 {\cf19 if} (nJS != _possibleInstructions.size ())\par
00179                     _error = MCHEmul::Assembler::ErrorType::_GRAMARELEMENTNOTVALID;\par
00180     \par
00181                 {\cf20 // Otherwise, all of them should have the same potential size...}\par
00182                 {\cf20 // or...the calculation would be impossible again}\par
00183                 {\cf20 // However in this case the size 0 will be returned!}\par
00184                 {\cf19 else}\par
00185                 \{\par
00186                     {\cf18 bool} sC = {\cf17 false};                \par
00187                     {\cf19 for} ({\cf17 auto} i : _possibleInstructions)\par
00188                     \{\par
00189                         {\cf19 if} (sC && result != i -> memoryPositions ())\par
00190                             _error = MCHEmul::Assembler::ErrorType::_GRAMARELEMENTNOTVALID;\par
00191                         \par
00192                         sC = {\cf17 true};\par
00193                         result = i -> memoryPositions ();\par
00194                     \}\par
00195                 \}\par
00196             \}\par
00197             {\cf19 else}\par
00198             \{\par
00199                 {\cf19 for} ({\cf17 auto} i : _possibleInstructions)\par
00200                 \{\par
00201                     {\cf20 // The instruction "calculateCodeBytesForInstruction" sets the variable _error when it is wrong!}\par
00202                     {\cf20 // So it has to be deleted before calling it...}\par
00203                     _error = MCHEmul::Assembler::ErrorType::_NOERROR;\par
00204                     {\cf19 if} ((result = calculateCodeBytesForInstruction \par
00205                         (i, s ).size ()) == i -> memoryPositions ())\par
00206                         {\cf19 break}; {\cf20 // Stops when the first right size is found...}\par
00207                 \}\par
00208             \}\par
00209         \}\par
00210     \}\par
00211 \par
00212     {\cf19 return} (result);\par
00213 \}\par
00214 \par
00215 {\cf20 // ---}\par
00216 {\cf18 bool} MCHEmul::Assembler::InstructionElement::hasAnyLabelAsParameter ({\cf17 const} MCHEmul::Assembler::Semantic* s){\cf17  const}\par
00217 {\cf17 }\{\par
00218     assert (s != {\cf17 nullptr});\par
00219 \par
00220     {\cf18 bool} result = {\cf17 false};\par
00221     {\cf19 for} ({\cf18 size_t} i = 0; i < _parameters.size () && !result; i++)\par
00222         result = MCHEmul::validLabel (_parameters [i]) && \par
00223                     (s -> macros ().find (_parameters [i]) == s -> macros ().end ());\par
00224 \par
00225     {\cf19 return} (result);\par
00226 \}\par
00227 \par
00228 {\cf20 // ---}\par
00229 std::vector <size_t> MCHEmul::Assembler::InstructionElement::labelParameters ({\cf17 const} MCHEmul::Assembler::Semantic* s){\cf17  const}\par
00230 {\cf17 }\{\par
00231     std::vector <size_t> result;\par
00232 \par
00233     {\cf19 for} ({\cf18 size_t} i = 0; i < _parameters.size (); i++)\par
00234         {\cf19 if} (MCHEmul::validLabel (_parameters [i]) && \par
00235             (s -> macros ().find (_parameters [i]) == s -> macros ().end ()))\par
00236             result.push_back (i);\par
00237 \par
00238     {\cf19 return} (result);\par
00239 \}\par
00240 \par
00241 {\cf20 // ---}\par
00242 std::vector <MCHEmul::UByte> MCHEmul::Assembler::InstructionElement::calculateCodeBytes \par
00243     ({\cf17 const} MCHEmul::Assembler::Semantic* s, {\cf18 bool} bE){\cf17  const}\par
00244 {\cf17 }\{\par
00245     assert (s != {\cf17 nullptr});\par
00246 \par
00247     {\cf19 if} (!(*{\cf17 this}))\par
00248         {\cf19 return} (std::vector <MCHEmul::UByte> ()); {\cf20 // Not possible with previous error...}\par
00249 \par
00250     std::vector <MCHEmul::UByte> result;\par
00251     {\cf19 for} ({\cf18 size_t} i = 0; i < _possibleInstructions.size (); i++)\par
00252     \{\par
00253         _error = MCHEmul::Assembler::ErrorType::_NOERROR;\par
00254         result = calculateCodeBytesForInstruction (_possibleInstructions [i], s, bE);\par
00255         {\cf19 if} (!(*{\cf17 this}))\par
00256             {\cf19 continue};\par
00257         {\cf19 else}\par
00258         \{\par
00259             _selectedInstruction = _possibleInstructions [i];\par
00260             {\cf19 break};\par
00261         \}\par
00262     \}\par
00263 \par
00264     {\cf19 return} (result);\par
00265 \}\par
00266 \par
00267 {\cf20 // ---}\par
00268 std::vector <MCHEmul::UByte> MCHEmul::Assembler::InstructionElement::calculateCodeBytesForInstruction \par
00269     ({\cf17 const} MCHEmul::Instruction* inst, {\cf17 const} MCHEmul::Assembler::Semantic* s, {\cf18 bool} bE){\cf17  const}\par
00270 {\cf17 }\{\par
00271     {\cf19 if} (!(*{\cf17 this}))\par
00272         {\cf19 return} (std::vector <MCHEmul::UByte> ()); {\cf20 // Nothing possible when prervious error...}\par
00273 \par
00274     std::vector <MCHEmul::UByte> result = \par
00275         MCHEmul::UInt::fromUnsignedInt (inst -> code ()).bytes ();\par
00276     {\cf19 for} ({\cf18 size_t} i = 0; i < inst -> internalStructure ()._parameters.size (); i++)\par
00277     \{\par
00278         {\cf18 bool} e = {\cf17 false};\par
00279         std::vector <MCHEmul::UByte> bt;\par
00280         {\cf19 switch} (inst -> internalStructure ()._parameters [i]._type)\par
00281         \{\par
00282             {\cf19 case} MCHEmul::Instruction::Structure::Parameter::Type::_DATA:\par
00283             {\cf19 case} MCHEmul::Instruction::Structure::Parameter::Type::_DIR:\par
00284             \{\par
00285                 bt = MCHEmul::UBytes (bytesFromExpression (_parameters [i], s -> macros (), e), bE).bytes ();\par
00286             \}\par
00287 \par
00288             {\cf19 break};\par
00289 \par
00290             {\cf19 case} MCHEmul::Instruction::Structure::Parameter::Type::_RELJUMP:\par
00291             {\cf19 case} MCHEmul::Instruction::Structure::Parameter::Type::_ABSJUMP:\par
00292             \{\par
00293                 {\cf19 if} (MCHEmul::validLabel (_parameters [i]))\par
00294                 \{\par
00295                     std::vector <const MCHEmul::Assembler::LabelElement*> lbs = s -> labels ();\par
00296                     std::vector <const MCHEmul::Assembler::LabelElement*>::const_iterator lbsP = \par
00297                         std::find_if (lbs.begin (), lbs.end (), \par
00298                             [=]({\cf17 const} MCHEmul::Assembler::LabelElement* lb) -> {\cf18 bool} \{ return (lb -> _name == _parameters [i]); \});\par
00299                     {\cf19 if} (lbsP != lbs.end ())\par
00300                     \{\par
00301                         {\cf19 if} (inst -> internalStructure ()._parameters [i]._type == \par
00302                                 MCHEmul::Instruction::Structure::Parameter::Type::_RELJUMP)\par
00303                         \{\par
00304                             MCHEmul::Address iA = address (s) + inst -> memoryPositions ();\par
00305                             bt = MCHEmul::UInt::fromInt (iA.distanceWith ((*lbsP) -> address (s))).bytes ();\par
00306                         \}\par
00307                         {\cf19 else}\par
00308                             bt = MCHEmul::UBytes ((*lbsP) -> address (s).bytes (), bE).bytes ();\par
00309                     \}\par
00310                 \}\par
00311                 {\cf19 else}\par
00312                     bt = MCHEmul::UBytes (bytesFromExpression (_parameters [i], s -> macros (), e), bE).bytes ();\par
00313             \}\par
00314 \par
00315             {\cf19 break};\par
00316 \par
00317             {\cf19 default}:\par
00318                 assert ({\cf17 false}); {\cf20 // Just in case...}\par
00319         \}\par
00320 \par
00321         {\cf19 if} (!e)\par
00322             result.insert (result.end (), bt.begin (), bt.end ());\par
00323     \}\par
00324 \par
00325     {\cf20 // The number of bytes generated has to match with the size of the instruction...}\par
00326     {\cf20 // When an instruction has parameters with MACRO it is not possible to know its size}\par
00327     {\cf20 // before tha MACROS as calculated...}\par
00328     {\cf19 if} (result.size () != inst -> memoryPositions ())\par
00329     \{\par
00330         _error = MCHEmul::Assembler::ErrorType::_INSTRUCTIONNOTVALID;\par
00331         result = \{ \};\par
00332     \}\par
00333 \par
00334     {\cf19 return} (result);\par
00335 \}\par
00336 \par
00337 {\cf20 // ---}\par
00338 std::vector <MCHEmul::UByte> MCHEmul::Assembler::StartingPointElement::calculateCodeBytes \par
00339     ({\cf17 const} MCHEmul::Assembler::Semantic* s, {\cf18 bool} bE){\cf17  const}\par
00340 {\cf17 }\{\par
00341     assert (s != {\cf17 nullptr});\par
00342 \par
00343     std::vector <MCHEmul::UByte> result;\par
00344 \par
00345     {\cf18 bool} e = {\cf17 false};\par
00346     std::vector <MCHEmul::UByte> n = bytesFromExpression (_value, s -> macros (), e);\par
00347     {\cf19 if} (e)\par
00348         _error = MCHEmul::Assembler::ErrorType::_STARTINGPOINTNOTVALID;\par
00349     {\cf19 else}\par
00350         result.insert (result.end (), n.begin (), n.end ());\par
00351 \par
00352     {\cf19 return} (result);\par
00353 \}\par
00354 \par
00355 {\cf20 // ---}\par
00356 {\cf18 void} MCHEmul::Assembler::Semantic::addMacro ({\cf17 const} Macro& m)\par
00357 \{ \par
00358     {\cf19 if} (_macros.find (m.name ()) == _macros.end ()) \par
00359         _macros.insert (MCHEmul::Assembler::Macros::value_type (m.name (), m));\par
00360     {\cf19 else}\par
00361         _error = MCHEmul::Assembler::ErrorType::_DUPLICATEMACRO;\par
00362 \}\par
00363 \par
00364 {\cf20 // ---}\par
00365 MCHEmul::Assembler::StartingPointElement* MCHEmul::Assembler::Semantic::addNewStartingPoint ()\par
00366 \{ \par
00367     MCHEmul::Assembler::StartingPointElement* nS = {\cf17 new} StartingPointElement;\par
00368     _startingPoints.push_back (nS);\par
00369 \par
00370     _lastGrammaticalElementAdded = nS;\par
00371 \par
00372     {\cf19 return} (nS);\par
00373 \}\par
00374 \par
00375 {\cf20 // ---}\par
00376 {\cf18 void} MCHEmul::Assembler::Semantic::addGrammaticalElement (MCHEmul::Assembler::GrammaticalElement* g)\par
00377 \{\par
00378     _error = MCHEmul::Assembler::ErrorType::_NOERROR;\par
00379 \par
00380     {\cf20 // ...only valid grama elements...}\par
00381     {\cf19 if} (g == {\cf17 nullptr})\par
00382     \{\par
00383         _error = MCHEmul::Assembler::ErrorType::_GRAMARELEMENTNOTVALID;\par
00384         {\cf19 return}; \par
00385     \}\par
00386 \par
00387     {\cf20 // ...only if there is a starting points defined...}\par
00388     {\cf19 if} (_startingPoints.empty ())\par
00389     \{\par
00390         _error = MCHEmul::Assembler::ErrorType::_STARTINGPOINTNOTDEFINED;\par
00391         {\cf19 return}; {\cf20 // If there were no entry points the new grama element couldn't be added ever...}\par
00392     \}\par
00393 \par
00394     {\cf20 // ...and only then the gramatical element has no errors...}\par
00395     {\cf19 if} (!(*g))\par
00396     \{\par
00397         _error = MCHEmul::Assembler::ErrorType::_SEMANTICERROR;\par
00398         {\cf19 return};\par
00399     \}\par
00400 \par
00401     {\cf20 // Other wise is linked to the element linked to the last starting point}\par
00402     {\cf20 // That will be, BTW, the actual one...}\par
00403     MCHEmul::Assembler::GrammaticalElement* lg = _startingPoints [_startingPoints.size () - 1];\par
00404     {\cf19 while} (lg -> _nextElement != {\cf17 nullptr}) lg = lg -> _nextElement;\par
00405     lg -> _nextElement = g;\par
00406     g -> _previousElement = lg;\par
00407     {\cf20 // Now if the semantic is deleted this new elements will be also deleted as it is part of the chain}\par
00408 \par
00409     _lastGrammaticalElementAdded = g;\par
00410 \}\par
00411 \par
00412 {\cf20 // ---}\par
00413 {\cf18 void} MCHEmul::Assembler::Semantic::addFrom ({\cf17 const} MCHEmul::Assembler::Semantic* s)\par
00414 \{\par
00415     assert (s != {\cf17 nullptr});\par
00416 \par
00417     {\cf20 // Add the macros }\par
00418     {\cf20 // If repeated an error will be generated}\par
00419     {\cf19 for} ({\cf17 auto} i : s -> _macros)\par
00420         addMacro (i.second);\par
00421 \par
00422     {\cf20 // Add the starting points at the end...}\par
00423     _startingPoints.insert (_startingPoints.end (), s -> _startingPoints.begin (), s -> _startingPoints.end ());\par
00424 \par
00425     {\cf20 // The error status will be the same...}\par
00426     _error = s -> _error;\par
00427 \}\par
00428 \par
00429 {\cf20 // ---}\par
00430 {\cf18 bool} MCHEmul::Assembler::Semantic::existsLabel ({\cf17 const} std::string& l){\cf17  const}\par
00431 {\cf17 }\{\par
00432     {\cf18 bool} result = {\cf17 false};\par
00433 \par
00434     {\cf19 for} ({\cf18 size_t} i = 0; i < _startingPoints.size () && !result; i++)\par
00435     \{\par
00436         MCHEmul::Assembler::GrammaticalElement* gE = _startingPoints [i] -> _nextElement;\par
00437         {\cf19 while} (gE != {\cf17 nullptr} && !result)\par
00438         \{\par
00439             result = {\cf17 dynamic_cast <}MCHEmul::Assembler::LabelElement*{\cf17 >} (gE) != {\cf17 nullptr} && \par
00440                 {\cf17 static_cast <}MCHEmul::Assembler::LabelElement*{\cf17 >} (gE) -> _name == l;\par
00441             gE = gE -> _nextElement;\par
00442         \}\par
00443     \}\par
00444 \par
00445     {\cf19 return} (result);\par
00446 \}\par
00447 \par
00448 {\cf20 // ---}\par
00449 MCHEmul::Address MCHEmul::Assembler::Semantic::addressForLabel ({\cf17 const} std::string& l){\cf17  const}\par
00450 {\cf17 }\{\par
00451     MCHEmul::Assembler::LabelElement* lE = {\cf17 nullptr};\par
00452     {\cf19 for} ({\cf18 size_t} i = 0; i < _startingPoints.size () && lE == {\cf17 nullptr}; i++)\par
00453     \{\par
00454         {\cf19 for} (MCHEmul::Assembler::GrammaticalElement* gE = _startingPoints [i] -> _nextElement;\par
00455             gE != {\cf17 nullptr} && lE == {\cf17 nullptr}; gE = gE -> _nextElement)\par
00456         \{\par
00457             MCHEmul::Assembler::LabelElement* t = {\cf17 dynamic_cast <}MCHEmul::Assembler::LabelElement*{\cf17 >} (gE);\par
00458             {\cf19 if} (t != {\cf17 nullptr} && t -> _name == l)\par
00459                 lE = t;\par
00460         \}\par
00461     \}\par
00462 \par
00463     {\cf19 return} (lE == {\cf17 nullptr} ? MCHEmul::Address () : lE -> address ({\cf17 this}));\par
00464 \}\par
00465 \par
00466 {\cf20 // ---}\par
00467 std::vector <const MCHEmul::Assembler::LabelElement*> MCHEmul::Assembler::Semantic::labels (){\cf17  const}\par
00468 {\cf17 }\{\par
00469     std::vector <const MCHEmul::Assembler::LabelElement*> result;\par
00470 \par
00471     {\cf19 for} ({\cf17 auto} i : _startingPoints)\par
00472         {\cf19 for} (MCHEmul::Assembler::GrammaticalElement* e = i -> _nextElement; e != {\cf17 nullptr}; e = e -> _nextElement)\par
00473             {\cf19 if} ({\cf17 dynamic_cast <}MCHEmul::Assembler::LabelElement*{\cf17 >} (e) != {\cf17 nullptr})\par
00474                 result.push_back ({\cf17 static_cast <}MCHEmul::Assembler::LabelElement*{\cf17 >} (e));\par
00475 \par
00476     {\cf19 return} (result);\par
00477 \}\par
00478 \par
00479 {\cf20 // ---}\par
00480 std::map <std::string, MCHEmul::Address> MCHEmul::Assembler::Semantic::labelAddresses (){\cf17  const}\par
00481 {\cf17 }\{\par
00482     std::map <std::string, MCHEmul::Address> result;\par
00483     std::vector <const MCHEmul::Assembler::LabelElement*> l = labels ();\par
00484 \par
00485     {\cf19 for} ({\cf17 auto} i : l)\par
00486         result [i -> _name] = i -> address ({\cf17 this});\par
00487 \par
00488     {\cf19 return} (result);\par
00489 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Parser.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Parser.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Parser.cpp}
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ASSEMBLER/Parser.hpp>}\par
{\f2 #include <fstream>}\par
{\f2 #include <algorithm>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Parser.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Parser.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/ASSEMBLER/Parser.cpp}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <ASSEMBLER/Parser.hpp>}\par
00002 {\cf21 #include <fstream>}\par
00003 {\cf21 #include <algorithm>}\par
00004 \par
00005 {\cf20 // ---}\par
00006 {\cf18 void} MCHEmul::Assembler::IncludeCommandParser::parse \par
00007     (std::string& l, {\cf18 unsigned} {\cf18 int} lC, MCHEmul::Assembler::Semantic* c){\cf17  const}\par
00008 {\cf17 }\{ \par
00009     c -> addFrom (parser () -> parse \par
00010         (MCHEmul::trim (l.substr (1, l.find (parser () -> commentSymbol () ) - 1)))); \par
00011 \}\par
00012 \par
00013 {\cf20 // ---}\par
00014 {\cf18 void} MCHEmul::Assembler::MacroCommandParser::parse \par
00015     (std::string& l, {\cf18 unsigned} {\cf18 int} lC, MCHEmul::Assembler::Semantic* s){\cf17  const}\par
00016 {\cf17 }\{\par
00017     assert (s != {\cf17 nullptr});\par
00018 \par
00019     {\cf19 if} (!canParse (l))\par
00020     \{\par
00021         l = {\cf22 ""}; \par
00022         {\cf19 return}; {\cf20 // It doesn't generate error, but "forgets" the line}\par
00023     \}\par
00024 \par
00025     {\cf18 size_t} mD = l.find (_symbol);\par
00026     s -> addMacro (MCHEmul::Assembler::Macro \par
00027             (MCHEmul::trim (l.substr (0, mD)), \par
00028              MCHEmul::trim (l.substr (mD + 1, l.find (parser () -> commentSymbol () ) - (mD + 1)))));\par
00029     {\cf20 // The macro is added just if there is no other with the same value...}\par
00030     {\cf20 // Otherwise the instruction above will generate an error}\par
00031 \par
00032     l = {\cf22 ""}; {\cf20 // The line is completed...}\par
00033 \}\par
00034 \par
00035 {\cf20 // ---}\par
00036 {\cf18 void} MCHEmul::Assembler::StartingPointCommandParser::parse \par
00037     (std::string& l, {\cf18 unsigned} {\cf18 int} lC, MCHEmul::Assembler::Semantic* s){\cf17  const}\par
00038 {\cf17 }\{\par
00039     assert (s != {\cf17 nullptr});\par
00040 \par
00041     {\cf19 if} (!canParse (l))\par
00042     \{\par
00043         l = {\cf22 ""}; \par
00044         {\cf19 return}; {\cf20 // It doesn't generate error, but "forgets" the line}\par
00045     \}\par
00046 \par
00047     {\cf18 size_t} mD = l.find (_symbol);\par
00048     MCHEmul::Assembler::StartingPointElement* nE = s -> addNewStartingPoint (); {\cf20 // Starts a new entry point...}\par
00049     nE -> _id = _lastStartingPointId++; {\cf20 // Sequential...}\par
00050     nE -> _line = lC;\par
00051     nE -> _value = \par
00052         MCHEmul::trim (l.substr (mD + 1, l.find (parser () -> commentSymbol () ) - (mD + 1)));\par
00053 \par
00054     {\cf20 // Here it is not checked whether _value is or not valid}\par
00055     {\cf20 // _value could include symbols and it should be treated later like a macro...}\par
00056 \par
00057     l = {\cf22 ""}; {\cf20 // The line is completed...}\par
00058 \}\par
00059 \par
00060 {\cf20 // ---}\par
00061 {\cf18 void} MCHEmul::Assembler::LabelCommandParser::parse\par
00062     (std::string& l, {\cf18 unsigned} {\cf18 int} lC, MCHEmul::Assembler::Semantic* s){\cf17  const}\par
00063 {\cf17 }\{\par
00064     assert (s != {\cf17 nullptr});\par
00065 \par
00066     {\cf19 if} (!canParse (l))\par
00067     \{\par
00068         l = {\cf22 ""}; \par
00069         {\cf19 return}; {\cf20 // It doesn't generate error, but "forgets" the line}\par
00070     \}\par
00071 \par
00072     {\cf18 size_t} eL = l.find (_symbol);\par
00073     MCHEmul::Assembler::LabelElement* nE = {\cf17 new} MCHEmul::Assembler::LabelElement;\par
00074     nE -> _id = _lastLabelId++; {\cf20 // Sequential...}\par
00075     nE -> _line = lC;\par
00076     nE -> _name = MCHEmul::trim (MCHEmul::upper (l.substr (0, eL)));\par
00077     {\cf20 // The label has to be valid...}\par
00078     {\cf19 if} (!MCHEmul::validLabel (nE -> _name))\par
00079         nE -> _error = MCHEmul::Assembler::ErrorType::_LABELNOTVALID;\par
00080 \par
00081     {\cf20 // The line has not been read totally...}\par
00082     l = MCHEmul::trim (l.substr (eL + 1));\par
00083 \par
00084     s -> addGrammaticalElement (nE);\par
00085 \}\par
00086 \par
00087 {\cf20 // ---}\par
00088 {\cf18 void} MCHEmul::Assembler::BytesCommandParser::parse\par
00089     (std::string& l, {\cf18 unsigned} {\cf18 int} lC, MCHEmul::Assembler::Semantic* s){\cf17  const}\par
00090 {\cf17 }\{\par
00091     assert (s != {\cf17 nullptr});\par
00092 \par
00093     {\cf19 if} (!canParse (l))\par
00094     \{\par
00095         l = {\cf22 ""}; \par
00096         {\cf19 return}; {\cf20 // It doesn't generate error, but "forgets" the line}\par
00097     \}\par
00098 \par
00099     {\cf18 size_t} eL = l.find ({\cf23 ' '}); {\cf20 // The first space defines where the data starts...}\par
00100     MCHEmul::Assembler::BytesInMemoryElement* nE = {\cf17 new} MCHEmul::Assembler::BytesInMemoryElement;\par
00101     nE -> _id = _lastBytesId++; {\cf20 // Sequential...}\par
00102     nE -> _line = lC;\par
00103     nE -> _elements = MCHEmul::getElementsFrom \par
00104         (l.substr (eL + 1, l.find (parser () -> commentSymbol () ) - (eL + 1)), {\cf23 ' '});\par
00105     {\cf19 if} (nE -> _elements.empty ())\par
00106         nE -> _error = MCHEmul::Assembler::ErrorType::_BYTESNOTVALID;\par
00107 \par
00108     {\cf20 // The line is completed...}\par
00109     l = {\cf22 ""};\par
00110 \par
00111     s -> addGrammaticalElement (nE);\par
00112 \}\par
00113 \par
00114 {\cf20 // ---}\par
00115 {\cf18 bool} MCHEmul::Assembler::InstructionCommandParser::canParse ({\cf17 const} std::string& l){\cf17  const}\par
00116 {\cf17 }\{\par
00117     std::string cL = MCHEmul::trim \par
00118         (l.substr (0, l.find (parser () -> commentSymbol () )));\par
00119 \par
00120     std::vector <std::string> prms;\par
00121     {\cf19 for} ({\cf17 auto} i : cpu () -> instructions ())\par
00122         {\cf19 if} (i.second -> matchesWith (cL, prms ))\par
00123             {\cf19 return} ({\cf17 true}); \par
00125     {\cf19 return} ({\cf17 false});\par
00126 \}\par
00127 \par
00128 {\cf20 // ---}\par
00129 {\cf18 void} MCHEmul::Assembler::InstructionCommandParser::parse\par
00130     (std::string& l, {\cf18 unsigned} {\cf18 int} lC, MCHEmul::Assembler::Semantic* s){\cf17  const}\par
00131 {\cf17 }\{\par
00132     assert (s != {\cf17 nullptr});\par
00133 \par
00134     {\cf19 if} (!canParse (l))\par
00135     \{\par
00136         l = {\cf22 ""}; \par
00137         {\cf19 return}; {\cf20 // It doesn't generate error, but "forgets" the line}\par
00138     \}\par
00139 \par
00140     std::string cL = MCHEmul::trim \par
00141         (l.substr (0, l.find (parser () -> commentSymbol () )));\par
00142 \par
00143     MCHEmul::Assembler::InstructionElement* nE = {\cf17 new} MCHEmul::Assembler::InstructionElement;\par
00144     nE -> _id = _lastInstructionId; \par
00145     nE -> _line = lC;\par
00146     std::vector <std::string> prms;\par
00147     {\cf19 for} (MCHEmul::Instructions::const_iterator i = cpu () -> instructions ().begin ();\par
00148             i != cpu () -> instructions ().end (); i++)\par
00149     \{\par
00150         {\cf19 if} ((*i).second -> matchesWith (cL, prms)) {\cf20 // One option minimum will match this (as it can be parsed)}\par
00151         \{\par
00152             nE -> _possibleInstructions.push_back ((*i).second);\par
00153             nE -> _parameters = prms;\par
00154         \}\par
00155     \}\par
00156 \par
00157     {\cf20 // Just in case...}\par
00158     {\cf19 if} (nE -> _possibleInstructions.empty ())\par
00159         nE -> _error = MCHEmul::Assembler::ErrorType::_INSTRUCTIONNOTDEFINED;\par
00160 \par
00161     _lastInstructionId++;\par
00162 \par
00163     {\cf20 // More errors could happen later if e.g. the instruction is using labels...}\par
00164     {\cf20 // Or the macros used don't match the size of the instruction!}\par
00165 \par
00166     {\cf20 // The line is completed in any case...}\par
00167     l = {\cf22 ""};\par
00168 \par
00169     s -> addGrammaticalElement (nE);\par
00170 \}\par
00171 \par
00172 {\cf20 // ---}\par
00173 MCHEmul::Assembler::Parser::Parser ({\cf17 const} MCHEmul::CPU* c, {\cf17 const} MCHEmul::Assembler::CommandParsers& lP)\par
00174     : _cpu (c), _commandParsers (lP),\par
00175       _errors (), _commentSymbol ({\cf22 ' '})\par
00176 \{ \par
00177     assert (_cpu != {\cf17 nullptr});\par
00178 \par
00179     {\cf18 bool} cP = {\cf17 false};\par
00180     {\cf19 for} ({\cf17 auto} i : _commandParsers) \par
00181     \{ \par
00182         cP |= ({\cf17 dynamic_cast <}MCHEmul::Assembler::CommentCommandParser*{\cf17 >} (i) != {\cf17 nullptr});\par
00183 \par
00184         i -> setCPU (c);\par
00185         i -> setParser ({\cf17 this}); \par
00186     \}\par
00187 \par
00188     {\cf20 // The comment command parser is always mandatory...}\par
00189     {\cf19 if} (!cP)\par
00190         _commandParsers.push_back ({\cf17 new} MCHEmul::Assembler::CommentCommandParser ());\par
00191 \}\par
00192 \par
00193 {\cf20 // ---}\par
00194 {\cf18 unsigned} {\cf18 char} MCHEmul::Assembler::Parser::commentSymbol (){\cf17  const}\par
00195 {\cf17 }\{\par
00196     {\cf19 if} (_commentSymbol != {\cf23 ' '})\par
00197         {\cf19 return} (_commentSymbol);\par
00198 \par
00199     MCHEmul::Assembler::CommentCommandParser* cP = {\cf17 nullptr};\par
00200     {\cf19 for} (MCHEmul::Assembler::CommandParsers::const_iterator i = _commandParsers.begin (); \par
00201             i != _commandParsers.end () && cP == {\cf17 nullptr}; i++)\par
00202         cP = {\cf17 dynamic_cast <}MCHEmul::Assembler::CommentCommandParser*{\cf17 >} ((*i));\par
00203 \par
00204     assert (cP != {\cf17 nullptr}); {\cf20 // It shouldn't...but just in case!}\par
00205 \par
00206     {\cf19 return} (_commentSymbol = cP -> symbol ());\par
00207 \}\par
00208 \par
00209 {\cf20 // ---}\par
00210 MCHEmul::Assembler::Semantic* MCHEmul::Assembler::Parser::parse ({\cf17 const} std::string& fN, {\cf17 const} std::string& fA){\cf17  const}\par
00211 {\cf17 }\{\par
00212     MCHEmul::Assembler::Semantic* result = {\cf17 new} MCHEmul::Assembler::Semantic;\par
00213 \par
00214     _errors = \{ \};\par
00215 \par
00216     {\cf20 // If there were any error reeading the file, }\par
00217     {\cf20 // "lines" would be equal to "", and nothing else will happen!}\par
00218     std::vector <std::string> lines = readLines (fN);\par
00219     {\cf20 // The file of possible actions is also read, but it might be empty!}\par
00220     std::vector <std::string> actions = readLines (fA);\par
00221     {\cf19 if} (lines.empty ())\par
00222         _errors.push_back (MCHEmul::Assembler::Error \par
00223             (MCHEmul::Assembler::ErrorType::_FILEEMPTY, fN, 0, 0));\par
00224     actions.resize (lines.size ()); {\cf20 // Both must have the same size...}\par
00225 \par
00226     {\cf18 int} lC = 0;\par
00227     {\cf19 for} ({\cf17 auto} i : lines)\par
00228     \{\par
00229         std::string l = MCHEmul::trim (i);\par
00230         std::string aLS = MCHEmul::trim (actions [lC]);\par
00231         {\cf18 unsigned} {\cf18 int} aL = (aLS == {\cf22 ""}) ? 0 : ({\cf18 unsigned} {\cf18 int}) std::stoi (aLS);\par
00232         {\cf19 while} (l != {\cf22 ""})\par
00233         \{\par
00234             {\cf18 unsigned} {\cf18 int} col = ({\cf18 unsigned} int) i.find (l);\par
00235 \par
00236             MCHEmul::Assembler::CommandParsers::const_iterator j =\par
00237                 std::find_if (_commandParsers.begin (), _commandParsers.end (), \par
00238                     [=](MCHEmul::Assembler::CommandParser* p) -> {\cf18 bool} \{ return (p -> canParse (l)); \});\par
00239             {\cf19 if} (j != _commandParsers.end ())\par
00240             \{\par
00241                 (*j) -> parse (l, lC, result);\par
00242                 {\cf19 if} (!result)\par
00243                     _errors.push_back (MCHEmul::Assembler::Error \par
00244                         (result -> lastGrammaticalElementAdded () -> _error, fN, lC, col));\par
00245                 {\cf19 else}\par
00246                 {\cf20 // adds the action defined (if a grammatical element was created)}\par
00247                 {\cf19 if} (result -> lastGrammaticalElementAdded () != {\cf17 nullptr})\par
00248                         result -> lastGrammaticalElementAdded () -> _actionOn = aL; \par
00249             \}\par
00250             {\cf19 else}\par
00251             \{\par
00252                 l = {\cf22 ""}; {\cf20 // The line is considered as treated...}\par
00253                 _errors.push_back (MCHEmul::Assembler::Error \par
00254                     (MCHEmul::Assembler::ErrorType::_PARSERNOTFOUND, fN, lC, col));\par
00255             \}\par
00256         \}\par
00257 \par
00258         lC++;\par
00259     \}\par
00260 \par
00261     {\cf19 return} (result);\par
00262 \}\par
00263 \par
00264 {\cf20 // ---}\par
00265 std::vector <std::string> MCHEmul::Assembler::Parser::readLines ({\cf17 const} std::string& fN){\cf17  const}\par
00266 {\cf17 }\{\par
00267     std::vector <std::string> result;\par
00268 \par
00269     std::ifstream f;\par
00270     f.open (fN.c_str (), std::ios::in);\par
00271     {\cf19 if} (!f)\par
00272         {\cf19 return} (result);\par
00273 \par
00274     {\cf18 char} l [512 ];\par
00275     {\cf19 while} (!f.eof ())\par
00276         \{ f.getline (l, 512); result.push_back (std::string (l)); \}\par
00277 \par
00278     f.close ();\par
00279 \par
00280     {\cf19 return} (result);\par
00281 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/C64.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/C64.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/C64.cpp}
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/C64.hpp>}\par
{\f2 #include <C64/Memory.hpp>}\par
{\f2 #include <C64/VICII.hpp>}\par
{\f2 #include <C64/CIA1.hpp>}\par
{\f2 #include <C64/CIA2.hpp>}\par
{\f2 #include <C64/SFChip.hpp>}\par
{\f2 #include <C64/Screen.hpp>}\par
{\f2 #include <C64/OSIO.hpp>}\par
{\f2 #include <C64/UserPort.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/C64.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/C64.cpp}
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/C64.hpp>}\par
00002 {\cf21 #include <C64/Memory.hpp>}\par
00003 {\cf21 #include <C64/VICII.hpp>}\par
00004 {\cf21 #include <C64/CIA1.hpp>}\par
00005 {\cf21 #include <C64/CIA2.hpp>}\par
00006 {\cf21 #include <C64/SFChip.hpp>}\par
00007 {\cf21 #include <C64/Screen.hpp>}\par
00008 {\cf21 #include <C64/OSIO.hpp>}\par
00009 {\cf21 #include <C64/UserPort.hpp>}\par
00010 {\cf21 #include <F6500/C6510.hpp>}\par
00011 \par
00012 {\cf20 // ---}\par
00013 C64::Commodore64::Commodore64 (C64::Commodore64::VisualSystem vS)\par
00014     : MCHEmul::Computer \par
00015         (new F6500::C6510 (),\par
00016          C64::Commodore64::standardChips (vS),\par
00017          new C64::Memory (),\par
00018          C64::Commodore64::standardDevices (vS),\par
00019          vS == C64::Commodore64::VisualSystem::_PAL ? 985000 {\cf20 /* 0.986 MHz */}: 1023000 ,\par
00020          \{ \{ {\cf22 "Name"}, {\cf22 "Commodore 64"} \},\par
00021            \{ {\cf22 "Manufacturer"}, {\cf22 "Commodore Business Machines CBM"} \},\par
00022            \{ {\cf22 "Year"}, {\cf22 "1980"} \}\par
00023          \}),\par
00024       _visualSystem (vS)\par
00025 \{\par
00026     {\cf20 // Nothing else to do...}\par
00027 \}\par
00028 \par
00029 {\cf20 // ---}\par
00030 {\cf18 bool} C64::Commodore64::connect (MCHEmul::IOPeripheral* p, MCHEmul::IODevice* d)\par
00031 \{\par
00032     {\cf20 // TODO}\par
00033 \par
00034     {\cf19 return} ({\cf17 true});\par
00035 \}\par
00036 \par
00037 {\cf20 // ---}\par
00038 {\cf18 bool} C64::Commodore64::initialize ()\par
00039 \{\par
00040     {\cf18 bool} result = MCHEmul::Computer::initialize ();\par
00041     {\cf19 if} (!result)\par
00042         {\cf19 return} ({\cf17 false});\par
00043 \par
00044     {\cf20 // Both chips CIAII and VICII are link somehow (when the register 0 of the CIA2 = 0xdd00 is set e.g.)}\par
00045     {\cf17 dynamic_cast <}C64::CIA2*{\cf17 >} (chip (C64::CIA2::_ID)) -> _VICIIRef = {\cf17 dynamic_cast <}C64::VICII*{\cf17 >} (chip (C64::VICII::_ID));\par
00046 \par
00047     {\cf19 return} ({\cf17 true});\par
00048 \}\par
00049 \par
00050 {\cf20 // ---}\par
00051 MCHEmul::Chips C64::Commodore64::standardChips (C64::Commodore64::VisualSystem vS)\par
00052 \{\par
00053     MCHEmul::Chips result;\par
00054 \par
00055     {\cf20 // The Special Control Chip (invented by me!)}\par
00056     result.insert (MCHEmul::Chips::value_type (C64::SpecialFunctionsChip::_ID, (MCHEmul::Chip*) {\cf17 new} C64::SpecialFunctionsChip));\par
00057 \par
00058     {\cf20 // The CIA1 & 2}\par
00059     result.insert (MCHEmul::Chips::value_type (C64::CIA1::_ID, (MCHEmul::Chip*) {\cf17 new} C64::CIA1));\par
00060     result.insert (MCHEmul::Chips::value_type (C64::CIA2::_ID, (MCHEmul::Chip*) {\cf17 new} C64::CIA2));\par
00061 \par
00062     {\cf20 // The VicII created will depend on whether the visualization is PAL or NTSC...}\par
00063     {\cf20 // Some how it is also controlled by CIA II and Special Control Chip}\par
00064     result.insert (MCHEmul::Chips::value_type (VICII::_ID, \par
00065         (MCHEmul::Chip*) ((vS == C64::Commodore64::VisualSystem::_NTSC) \par
00066             ? (C64::VICII*) {\cf17 new} C64::VICII_NTSC : (C64::VICII*) {\cf17 new} C64::VICII_PAL)));\par
00067 \par
00068     {\cf19 return} (result);\par
00069 \}\par
00070 \par
00071 {\cf20 // ---}\par
00072 MCHEmul::IODevices C64::Commodore64::standardDevices (C64::Commodore64::VisualSystem vS)\par
00073 \{\par
00074     MCHEmul::IODevices result;\par
00075 \par
00076     result.insert (MCHEmul::IODevices::value_type (C64::Screen::_ID, \par
00077         (MCHEmul::IODevice*) ((vS == C64::Commodore64::VisualSystem::_NTSC) \par
00078             ? (C64::Screen*) {\cf17 new} C64::ScreenNTSC : (C64::Screen*) {\cf17 new} C64::ScreenPAL)));\par
00079     result.insert (MCHEmul::IODevices::value_type (C64::InputOSSystem::_ID, {\cf17 new} C64::InputOSSystem));\par
00080     result.insert (MCHEmul::IODevices::value_type (C64::UserIOPort::_ID, {\cf17 new} C64::UserIOPort));\par
00081 \par
00082     {\cf19 return} (result);\par
00083 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/CIA1.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/CIA1.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/CIA1.cpp}
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/CIA1.hpp>}\par
{\f2 #include <C64/Memory.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIA1.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/CIA1.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/CIA1.cpp}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/CIA1.hpp>}\par
00002 {\cf21 #include <C64/Memory.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} C64::CIA1::initialize ()\par
00006 \{\par
00007     assert (memoryRef () != {\cf17 nullptr});\par
00008 \par
00009     {\cf20 // Gets the memory block dedicated to the CIA1}\par
00010     {\cf19 if} (!(_CIA1Registers = \par
00011         {\cf17 dynamic_cast <}C64::CIA1Registers*{\cf17 >} (memoryRef () -> subset (C64::Memory::_CIA1_SUBSET))))\par
00012     \{\par
00013         _lastError = MCHEmul::_INIT_ERROR;\par
00014 \par
00015         {\cf19 return} ({\cf17 false});\par
00016     \}\par
00017 \par
00018     _CIA1Registers -> lookAtTimers (&_timerA, &_timerB);\par
00019 \par
00020     _CIA1Registers -> lookAtClock (&_clock);\par
00021 \par
00022     {\cf19 return} ({\cf17 true});\par
00023 \}\par
00024 \par
00025 {\cf20 // ---}\par
00026 {\cf18 bool} C64::CIA1::simulate (MCHEmul::CPU* cpu)\par
00027 \{\par
00028     _timerA.simulate (cpu);\par
00029 \par
00030     _timerB.simulate (cpu, &_timerA);\par
00031 \par
00032     _clock.simulate (cpu);\par
00033 \par
00034     {\cf19 return} ({\cf17 true});\par
00035 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/CIA1Registers.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/CIA1Registers.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/CIA1Registers.cpp}
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/CIA1Registers.hpp>}\par
{\f2 #include <C64/CIATimer.hpp>}\par
{\f2 #include <C64/CIAClock.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIA1Registers.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/CIA1Registers.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/CIA1Registers.cpp}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/CIA1Registers.hpp>}\par
00002 {\cf21 #include <C64/CIATimer.hpp>}\par
00003 {\cf21 #include <C64/CIAClock.hpp>}\par
00004 \par
00005 {\cf20 // ---}\par
00006 C64::CIA1Registers::CIA1Registers ({\cf18 int} {\cf18 id}, MCHEmul::PhisicalStorage* pS)\par
00007     : MCHEmul::PhisicalStorageSubset (id, pS, 0xdc00, MCHEmul::Address (\{ 0x00, 0xdc \}, {\cf17 false}), 0x0100),\par
00008       _timerA ({\cf17 nullptr}), _timerB ({\cf17 nullptr}),\par
00009       _lastValueRead (MCHEmul::PhisicalStorage::_DEFAULTVALUE)\par
00010       {\cf20 // At this point all internal variables will have random values...}\par
00011 \{ \par
00012     initializeInternalValues (); \par
00013 \}\par
00014 \par
00015 {\cf20 // ---}\par
00016 {\cf18 void} C64::CIA1Registers::initialize ()\par
00017 \{\par
00018     MCHEmul::PhisicalStorageSubset::initialize ();\par
00019 \par
00020     initializeInternalValues ();\par
00021 \}\par
00022 \par
00023 {\cf20 // ---}\par
00024 {\cf18 void} C64::CIA1Registers::setValue ({\cf18 size_t} p, {\cf17 const} MCHEmul::UByte& v)\par
00025 \{\par
00026     assert (_timerA != {\cf17 nullptr} && _timerB != {\cf17 nullptr} && _clock != {\cf17 nullptr});\par
00027 \par
00028     MCHEmul::PhisicalStorageSubset::setValue (p, v);\par
00029 \par
00030     {\cf18 size_t} pp = p % 0x10;\par
00031 \par
00032     {\cf19 switch} (pp)\par
00033     \{\par
00034         {\cf20 // Data Port Register A: CIAPRA}\par
00035         {\cf19 case} 0x00:\par
00036             {\cf20 // To indicate the row of the key matrix to be read (later)}\par
00037             {\cf20 // It will be affected by the communication direction (CIDDRA)}\par
00038             _keyboardRowToRead = v.value () & _dataPortADir;\par
00039 \par
00040         {\cf20 // Data Port Register B: CIAPRB}\par
00041         {\cf19 case} 0x01:\par
00042             {\cf20 // No special meaning when set (but very important when read!)}\par
00043             {\cf19 break};\par
00044 \par
00045         {\cf20 // Data Direction Register A: CIDDRA}\par
00046         {\cf19 case} 0x02:\par
00047             _dataPortADir = v.value ();\par
00048             {\cf19 break};\par
00049 \par
00050         {\cf20 // Data Direction Register B: CIDDRB}\par
00051         {\cf19 case} 0x03:\par
00052             _dataPortBDir = v.value ();\par
00053             {\cf19 break};\par
00054 \par
00055         {\cf20 // LSB of the Latch A: TIMALO}\par
00056         {\cf19 case} 0x04:\par
00057             _timerA -> setInitialValue (_timerA -> initialValue () & 0x00ff | ({\cf18 unsigned} {\cf18 short}) v.value ());\par
00058             {\cf19 break};\par
00059 \par
00060         {\cf20 // MSB of the Latch A: TIMAHI}\par
00061         {\cf19 case} 0x05:\par
00062             _timerA -> setInitialValue (_timerA -> initialValue () & 0xff00 | ({\cf18 unsigned} {\cf18 short}) (v.value () << 8));\par
00063             {\cf19 break};\par
00064 \par
00065         {\cf20 // LSB of the Latch B: TIMBLO}\par
00066         {\cf19 case} 0x06:\par
00067             _timerB -> setInitialValue (_timerB -> initialValue () & 0x00ff | ({\cf18 unsigned} {\cf18 short}) v.value ());\par
00068             {\cf19 break};\par
00069 \par
00070         {\cf20 // MSB of the Latch B: TIMBHI}\par
00071         {\cf19 case} 0x07:\par
00072             _timerB -> setInitialValue (_timerB -> initialValue () & 0xff00 | ({\cf18 unsigned} {\cf18 short}) (v.value () << 8));\par
00073             {\cf19 break};\par
00074 \par
00075         {\cf20 // Time of Day Clock Tenths of Seconds: TO2TEN}\par
00076         {\cf20 // Bits 0-3: BCD Digits. Bits 4-7: Unused.}\par
00077         {\cf19 case} 0x08:\par
00078             \{\par
00079                 {\cf18 int} ts = MCHEmul::UInt (\{ MCHEmul::PhisicalStorageSubset::readValue (0x08) \}, \par
00080                     {\cf17 true} , {\cf17 true} ).asInt (); {\cf20 // A BCD value to int...}\par
00081                 {\cf19 if} (MCHEmul::PhisicalStorageSubset::readValue (0x0f).bit (7)) _clock -> setAlarmTenthSeconds (({\cf18 unsigned} {\cf18 char}) ts); \par
00082                 {\cf19 else} _clock -> setTenthSeconds (({\cf18 unsigned} {\cf18 char}) ts);\par
00083             \}\par
00084 \par
00085             {\cf19 break};\par
00086 \par
00087         {\cf20 // Time of Day Clock Seconds: TO2SEC}\par
00088         {\cf20 // Bits 0-3: Second BCD Digit. Bits 4-6: First BCD Digit. Bit 7: Unused.}\par
00089         {\cf19 case} 0x09:\par
00090             \{\par
00091                 {\cf18 int} s = MCHEmul::UInt (\{ MCHEmul::PhisicalStorageSubset::readValue (0x08) \}, \par
00092                     {\cf17 true} , {\cf17 true} ).asInt (); {\cf20 // A BCD value to int...}\par
00093                 {\cf19 if} (MCHEmul::PhisicalStorageSubset::readValue (0x0f).bit (7)) _clock -> setSeconds (({\cf18 unsigned} {\cf18 char}) s); \par
00094                 {\cf19 else} _clock -> setSeconds (({\cf18 unsigned} {\cf18 char}) s);\par
00095             \}\par
00096 \par
00097             {\cf19 break};\par
00098 \par
00099         {\cf20 // Time of Day Clock Minutes: TO2MIN}\par
00100         {\cf20 // Bits 0-3: Second BCD Digit. Bits 4-6: First BCD Digit. Bit 7: Unused.}\par
00101         {\cf19 case} 0x0b:\par
00102             \{\par
00103                 {\cf18 int} m = MCHEmul::UInt (\{ MCHEmul::PhisicalStorageSubset::readValue (0x08) \}, \par
00104                     {\cf17 true} , {\cf17 true} ).asInt (); {\cf20 // A BCD value to int...}\par
00105                 {\cf19 if} (MCHEmul::PhisicalStorageSubset::readValue (0x0f).bit (7)) _clock -> setAlarmMinutes (({\cf18 unsigned} {\cf18 char}) m); \par
00106                 {\cf19 else} _clock -> setMinutes (({\cf18 unsigned} {\cf18 char}) m);\par
00107             \}\par
00108 \par
00109             {\cf19 break};\par
00110 \par
00111         {\cf20 // Time of Day Clock Hours: TO2HRS}\par
00112         {\cf20 // Bits 0-3: Second BCD Digit. Bit 4: First BCD Digit. Bits 5-6: Unused. Bit 7: AM/PM Flag (PM = 1)}\par
00113         {\cf19 case} 0x0a:\par
00114             \{\par
00115                 {\cf18 int} h = MCHEmul::UInt (\{ MCHEmul::PhisicalStorageSubset::readValue (0x08) \}, \par
00116                     {\cf17 true} , {\cf17 true} ).asInt (); {\cf20 // A BCD value to int...}\par
00117                 {\cf19 if} (MCHEmul::PhisicalStorageSubset::readValue (0x0f).bit (7)) _clock -> setAlarmHours (({\cf18 unsigned} {\cf18 char}) h); \par
00118                 {\cf19 else} _clock -> setHours (({\cf18 unsigned} {\cf18 char}) h);\par
00119             \}\par
00120 \par
00121             {\cf19 break};\par
00122 \par
00123         {\cf20 // Serial Data Port CI2SDR}\par
00124         {\cf19 case} 0x0c:\par
00125             {\cf19 break};\par
00126 \par
00127         {\cf20 // Interrupt Control Register: CI2ICR}\par
00128         {\cf20 // Depending on the bit 7 the behaviour is different: 1 = bits with 1 are set, 0 = bits with 1 are cleared... }\par
00129         {\cf19 case} 0x0d:\par
00130             {\cf19 if} (v.bit (0)) _timerA -> setIRQEnabled (v.bit (7));\par
00131             {\cf19 if} (v.bit (1)) _timerB -> setIRQEnabled (v.bit (7));\par
00132             {\cf19 if} (v.bit (2)) _clock -> setIRQEnabled (v.bit (7));\par
00133             {\cf20 // TODO: To manage the serial port...}\par
00134             {\cf19 break};\par
00135 \par
00136         {\cf20 // Control Register A: CI2CRA}\par
00137         {\cf19 case} 0x0e:\par
00138             _timerA -> setEnabled (v.bit (0));\par
00139             {\cf20 // TODO: Sending signals to serial port...(bits 1, 2 & 6)}\par
00140             _timerA -> setRunMode (v.bit (3) ? CIATimer::RunMode::_ONETIME : CIATimer::RunMode::_RESTART);\par
00141             {\cf19 if} (v.bit (4)) _timerA -> reset ();\par
00142             _timerA -> setCountMode (v.bit (5)\par
00143                 ? C64::CIATimer::CountMode::_PROCESSORCYCLES: C64::CIATimer::CountMode::_SIGNALSONCNTLINE);\par
00144             {\cf20 // TODO: Pending to control based on 60Hz or 50 Hz...(bit 7)}\par
00145             {\cf19 break};\par
00146 \par
00147         {\cf20 // Control Register B: CI2CRB}\par
00148         {\cf19 case} 0x0f:\par
00149             _timerB -> setEnabled (v.bit (0));\par
00150             {\cf20 // TODO: Sending signals to serial port B...(bits 1, 2 & 6)}\par
00151             _timerB -> setRunMode (v.bit (3) ? CIATimer::RunMode::_ONETIME : CIATimer::RunMode::_RESTART);\par
00152             {\cf19 if} (v.bit (4)) _timerB -> reset ();\par
00153             {\cf20 // bits 5 & 6 indicates the mode...}\par
00154             _timerB -> setCountMode ((C64::CIATimer::CountMode) ((v.value () >> 4) & 0x03));\par
00155             {\cf20 // _PROCESSORCYCLES = 0, _SIGNALSONCNTLINE = 1,...}\par
00156             {\cf19 break};\par
00157             \par
00158         {\cf19 default}:\par
00159             {\cf19 break};\par
00160     \}\par
00161 \}\par
00162 \par
00163 {\cf20 // ---}\par
00164 {\cf17 const} MCHEmul::UByte& C64::CIA1Registers::readValue ({\cf18 size_t} p){\cf17  const}\par
00165 {\cf17 }\{\par
00166     assert (_timerA != {\cf17 nullptr} && _timerB != {\cf17 nullptr} && _clock != {\cf17 nullptr});\par
00167 \par
00168     MCHEmul::UByte result = MCHEmul::PhisicalStorage::_DEFAULTVALUE;\par
00169 \par
00170     {\cf18 size_t} pp = p % 0x10;\par
00171 \par
00172     {\cf19 switch} (pp)\par
00173     \{\par
00174         {\cf19 case} 0x00:\par
00175             result = MCHEmul::UByte (_joystick2Status);\par
00176             {\cf19 break};\par
00177 \par
00178         {\cf19 case} 0x01:\par
00179             \{\par
00180                 {\cf20 // Identify the row to read...}\par
00181                 {\cf20 // Take into account that the row is identified writting 0 in its bit (so it is necessary to inverse it first)}\par
00182                 {\cf18 unsigned} {\cf18 char} bRV = ~_keyboardRowToRead;\par
00183                 {\cf18 size_t} c = 0; {\cf19 while} ((bRV >>= 1) != 0) c++;\par
00184                 {\cf20 // If more than 1 row will be possible, the greatest one will be choosen...}\par
00185                 {\cf20 // The columns (from keyboard or joystick 1) connected will have its bits to 0!...}\par
00186                 result = _keyboardStatusMatrix [c] & ~_dataPortBDir;\par
00187             \}\par
00188             \par
00189             {\cf19 break};\par
00190 \par
00191         {\cf20 // When reading no special behaviour...but when setting!}\par
00192         {\cf19 case} 0x02:\par
00193         {\cf19 case} 0x03:\par
00194             result = MCHEmul::PhisicalStorageSubset::readValue (p);\par
00195             {\cf19 break};\par
00196 \par
00197         {\cf19 case} 0x04:\par
00198             result = MCHEmul::UByte (({\cf18 unsigned} {\cf18 char}) (_timerA -> currentValue () & 0x00ff));\par
00199             {\cf19 break};\par
00200 \par
00201         {\cf19 case} 0x05:\par
00202             result = MCHEmul::UByte (({\cf18 unsigned} {\cf18 char}) ((_timerA -> currentValue () & 0xff00) >> 8));\par
00203             {\cf19 break};\par
00204 \par
00205         {\cf19 case} 0x06:\par
00206             result = MCHEmul::UByte (({\cf18 unsigned} {\cf18 char}) (_timerB -> currentValue () & 0x00ff));\par
00207             {\cf19 break};\par
00208 \par
00209         {\cf19 case} 0x07:\par
00210             result = MCHEmul::UByte (({\cf18 unsigned} {\cf18 char}) ((_timerB -> currentValue () & 0xff00) >> 8));\par
00211             {\cf19 break};\par
00212 \par
00213         {\cf19 case} 0x08:\par
00214             {\cf20 // Only 1 digit from 0 to 9 (4 bits). Rest unused.}\par
00215             result = MCHEmul::UInt::fromUnsignedInt (_clock -> tenthsSecond (), MCHEmul::UInt::_PACKAGEDBCD).bytes ()[0];\par
00216             {\cf19 break};\par
00217 \par
00218         {\cf19 case} 0x09:\par
00219             {\cf20 // 2 digits. 1\'BA: from 0 to 9 (4 bits), 2\'BA: from 0 to 6 (3 bits). Bit 7 unused}\par
00220             result = MCHEmul::UInt::fromUnsignedInt (_clock -> seconds (), MCHEmul::UInt::_PACKAGEDBCD).bytes ()[0];\par
00221             {\cf19 break};\par
00222 \par
00223         {\cf19 case} 0x0a:\par
00224             {\cf20 // 2 digits. 1\'BA: from 0 to 9 (4 bits), 2\'BA: from 0 to 6 (3 bits). Bit 7 unused}\par
00225             result = MCHEmul::UInt::fromUnsignedInt (_clock -> minutes (), MCHEmul::UInt::_PACKAGEDBCD).bytes ()[0];\par
00226             {\cf19 break};\par
00227 \par
00228         {\cf19 case} 0x0b:\par
00229             \{\par
00230                 {\cf20 // 2 digits. 1\'BA: from 0 to 9 (4 bits), 2\'BA: either 0 or 1 (1 bit). Bits 5,6 unused. Bit 7 AM/PM flag (PM = 1)}\par
00231                 {\cf18 unsigned} {\cf18 int} h = ({\cf18 unsigned} int) _clock -> hours ();\par
00232                 {\cf18 bool} pm = h > 12 || (h == 12 && _clock -> minutes () > 0);\par
00233                 {\cf19 if} (pm && h > 12) h -= 12; {\cf20 // The value 12 is kept...}\par
00234                 result = MCHEmul::UInt::fromUnsignedInt (h, MCHEmul::UInt::_PACKAGEDBCD).bytes ()[0];\par
00235                 result.setBit (7, pm);\par
00236             \}\par
00237 \par
00238             {\cf19 break};\par
00239 \par
00240         {\cf19 case} 0x0c:\par
00241             {\cf20 // TODO: }\par
00242             {\cf20 // To simulate the Serial Port.}\par
00243             {\cf20 // The directions of the information has to be taken into account}\par
00244             {\cf20 // When the serial port is configurated for input, the data is read in the pint 5 when the pin 4 (CNT) let you know}\par
00245             {\cf20 // the info is ready for reading (this is connected with the timer).}\par
00246             {\cf19 break};\par
00247 \par
00248         {\cf19 case} 0x0d:\par
00249             \{\par
00250                 {\cf18 bool} IA = _timerA -> IRQRequested (); {\cf20 // It is set back to false after reading...}\par
00251                 {\cf18 bool} IB = _timerB -> IRQRequested (); {\cf20 // Same...}\par
00252                 {\cf18 bool} IC = _clock -> IRQRequested (); {\cf20 // Same...}\par
00253                 result = MCHEmul::UByte::_0;\par
00254                 result.setBit (7, IA || IB || IC); {\cf20 // IRQ?}\par
00255                 result.setBit (0, IA); {\cf20 // in Timer A?}\par
00256                 result.setBit (1, IB); {\cf20 // in Timer B?}\par
00257                 result.setBit (2, IC); {\cf20 // in Clock?}\par
00258                 {\cf20 // TODO: To manage the serial port...}\par
00259             \}\par
00260 \par
00261             {\cf19 break};\par
00262 \par
00263         {\cf19 case} 0x0e:\par
00264         {\cf19 case} 0x0f:\par
00265             result = MCHEmul::PhisicalStorageSubset::readValue (p);\par
00266             {\cf19 break};\par
00267             \par
00268         {\cf19 default}:\par
00269             {\cf19 break};\par
00270     \}\par
00271 \par
00272     {\cf19 return} (_lastValueRead = result);\par
00273 \}\par
00274 \par
00275 {\cf20 // ---}\par
00276 {\cf18 void} C64::CIA1Registers::initializeInternalValues ()\par
00277 \{\par
00278     {\cf20 // At this point the timers and the clock might not be set yet...}\par
00279     {\cf19 if} (_timerA == {\cf17 nullptr} || _timerB == {\cf17 nullptr} || _clock == {\cf17 nullptr})\par
00280         {\cf19 return};\par
00281 \par
00282     {\cf20 // Data Port A all input...}\par
00283     setValue (0x02, MCHEmul::UByte::_FF); \par
00284     {\cf20 // Data Port B all output...}\par
00285     setValue (0x03, MCHEmul::UByte::_0);\par
00286     {\cf20 // Just to be able to read well the keyboard...}\par
00287 \par
00288     setValue (0x00, MCHEmul::UByte::_0); {\cf20 // Row 0 of the keyboard to be read}\par
00289     setValue (0x01, MCHEmul::UByte::_0);\par
00290     setValue (0x04, MCHEmul::UByte::_0); {\cf20 // No timer A active}\par
00291     setValue (0x05, MCHEmul::UByte::_0);\par
00292     setValue (0x06, MCHEmul::UByte::_0); {\cf20 // No timer B active}\par
00293     setValue (0x07, MCHEmul::UByte::_0);\par
00294     setValue (0x08, MCHEmul::UByte::_0); \par
00295     setValue (0x09, MCHEmul::UByte::_0); \par
00296     setValue (0x0a, MCHEmul::UByte::_0); \par
00297     setValue (0x0b, MCHEmul::UByte::_0); \par
00298     setValue (0x0c, MCHEmul::UByte::_0); \par
00299     setValue (0x0d, MCHEmul::UByte::_0); {\cf20 // No interupts allowed from the early beginning...so stopped!}\par
00300     setValue (0x0e, MCHEmul::UByte::_0); {\cf20 // No value in timer A}\par
00301     setValue (0x0f, MCHEmul::UByte::_0); {\cf20 // No value in timer B}\par
00302 \par
00303     _joystick2Status = 0xff; {\cf20 // No switches clicked, no fire buttons pressed...}\par
00304     {\cf19 for} ({\cf18 size_t} i = 0; i < 8; _keyboardStatusMatrix [i++] = MCHEmul::UByte::_FF); {\cf20 // No keys pressed...}\par
00305 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/CIA2.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/CIA2.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/CIA2.cpp}
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/CIA2.hpp>}\par
{\f2 #include <C64/Memory.hpp>}\par
{\f2 #include <C64/VICII.hpp>}\par
{\f2 #include <F6500/NMIInterrupt.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIA2.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/CIA2.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/CIA2.cpp}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/CIA2.hpp>}\par
00002 {\cf21 #include <C64/Memory.hpp>}\par
00003 {\cf21 #include <C64/VICII.hpp>}\par
00004 {\cf21 #include <F6500/NMIInterrupt.hpp>}\par
00005 \par
00006 {\cf20 // ---}\par
00007 {\cf18 bool} C64::CIA2::initialize ()\par
00008 \{\par
00009     assert (memoryRef () != {\cf17 nullptr});\par
00010 \par
00011     {\cf20 // Gets the memory block dedicated to the CIA2}\par
00012     {\cf19 if} (!(_CIA2Registers = \par
00013         {\cf17 dynamic_cast <}C64::CIA2Registers*{\cf17 >} (memoryRef () -> subset (C64::Memory::_CIA2_SUBSET))))\par
00014     \{\par
00015         _lastError = MCHEmul::_INIT_ERROR;\par
00016 \par
00017         {\cf19 return} ({\cf17 false});\par
00018     \}\par
00019 \par
00020     _CIA2Registers -> lookAtTimers (&_timerA, &_timerB);\par
00021 \par
00022     _CIA2Registers -> lookAtClock (&_clock);\par
00023 \par
00024     {\cf19 return} ({\cf17 true});\par
00025 \}\par
00026 \par
00027 {\cf20 // ---}\par
00028 {\cf18 bool} C64::CIA2::simulate (MCHEmul::CPU* cpu)\par
00029 \{\par
00030     _VICIIRef -> setBank (_CIA2Registers -> VICIIBank ());\par
00031 \par
00032     _timerA.simulate (cpu);\par
00033 \par
00034     _timerB.simulate (cpu, &_timerA);\par
00035 \par
00036     _clock.simulate (cpu);\par
00037 \par
00038     _lastClockCycles = cpu -> clockCycles ();\par
00039 \par
00040     {\cf19 return} ({\cf17 true});\par
00041 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/CIA2Registers.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/CIA2Registers.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/CIA2Registers.cpp}
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/CIA2Registers.hpp>}\par
{\f2 #include <C64/CIATimer.hpp>}\par
{\f2 #include <C64/CIAClock.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIA2Registers.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/CIA2Registers.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/CIA2Registers.cpp}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/CIA2Registers.hpp>}\par
00002 {\cf21 #include <C64/CIATimer.hpp>}\par
00003 {\cf21 #include <C64/CIAClock.hpp>}\par
00004 \par
00005 {\cf20 // ---}\par
00006 C64::CIA2Registers::CIA2Registers ({\cf18 int} {\cf18 id}, MCHEmul::PhisicalStorage* pS)\par
00007     : MCHEmul::PhisicalStorageSubset (id, pS, 0xdc00, MCHEmul::Address (\{ 0x00, 0xdc \}, {\cf17 false}), 0x0100),\par
00008       _timerA ({\cf17 nullptr}), _timerB ({\cf17 nullptr}),\par
00009       _lastValueRead (MCHEmul::PhisicalStorage::_DEFAULTVALUE)\par
00010       {\cf20 // At this point all internal variables will have random values...}\par
00011 \{ \par
00012     initializeInternalValues (); \par
00013 \}\par
00014 \par
00015 {\cf20 // ---}\par
00016 {\cf18 void} C64::CIA2Registers::initialize ()\par
00017 \{\par
00018     MCHEmul::PhisicalStorageSubset::initialize ();\par
00019 \par
00020     initializeInternalValues ();\par
00021 \}\par
00022 \par
00023 {\cf20 // ---}\par
00024 {\cf18 void} C64::CIA2Registers::setValue ({\cf18 size_t} p, {\cf17 const} MCHEmul::UByte& v)\par
00025 \{\par
00026     assert (_timerA != {\cf17 nullptr} && _timerB != {\cf17 nullptr} && _clock != {\cf17 nullptr});\par
00027 \par
00028     MCHEmul::PhisicalStorageSubset::setValue (p, v);\par
00029 \par
00030     {\cf18 size_t} pp = p % 0x10;\par
00031 \par
00032     {\cf19 switch} (pp)\par
00033     \{\par
00034         {\cf20 // Data Port Register A: CI2PRA}\par
00035         {\cf20 // The three first bites control VICIIB active bank}\par
00036         {\cf19 case} 0x00:\par
00037             _VICBank = 0x03 - (v.value () & 0x03); {\cf20 // From 0 to 3...}\par
00038             {\cf19 break};\par
00039 \par
00040         {\cf20 // Data Port Register B: CIAPRB}\par
00041         {\cf19 case} 0x01:\par
00042             {\cf20 // No special meaning when set (but very important when read!)}\par
00043             {\cf19 break};\par
00044 \par
00045         {\cf20 // Data Direction Register A: CIDDRA}\par
00046         {\cf19 case} 0x02:\par
00047             {\cf19 break};\par
00048 \par
00049         {\cf20 // Data Direction Register B: CIDDRB}\par
00050         {\cf19 case} 0x03:\par
00051             {\cf19 break};\par
00052 \par
00053         {\cf20 // LSB of the Latch A: TIMALO}\par
00054         {\cf19 case} 0x04:\par
00055             _timerA -> setInitialValue (_timerA -> initialValue () & 0x00ff | ({\cf18 unsigned} {\cf18 short}) v.value ());\par
00056             {\cf19 break};\par
00057 \par
00058         {\cf20 // MSB of the Latch A: TIMAHI}\par
00059         {\cf19 case} 0x05:\par
00060             _timerA -> setInitialValue (_timerA -> initialValue () & 0xff00 | ({\cf18 unsigned} {\cf18 short}) (v.value () << 8));\par
00061             {\cf19 break};\par
00062 \par
00063         {\cf20 // LSB of the Latch B: TIMBLO}\par
00064         {\cf19 case} 0x06:\par
00065             _timerB -> setInitialValue (_timerB -> initialValue () & 0x00ff | ({\cf18 unsigned} {\cf18 short}) v.value ());\par
00066             {\cf19 break};\par
00067 \par
00068         {\cf20 // MSB of the Latch B: TIMBHI}\par
00069         {\cf19 case} 0x07:\par
00070             _timerB -> setInitialValue (_timerB -> initialValue () & 0xff00 | ({\cf18 unsigned} {\cf18 short}) (v.value () << 8));\par
00071             {\cf19 break};\par
00072 \par
00073         {\cf20 // Time of Day Clock Tenths of Seconds: TO2TEN}\par
00074         {\cf20 // Bits 0-3: BCD Digits. Bits 4-7: Unused.}\par
00075         {\cf19 case} 0x08:\par
00076             \{\par
00077                 {\cf18 int} ts = MCHEmul::UInt (\{ MCHEmul::PhisicalStorageSubset::readValue (0x08) \}, \par
00078                     {\cf17 true} , {\cf17 true} ).asInt (); {\cf20 // A BCD value to int...}\par
00079                 {\cf19 if} (MCHEmul::PhisicalStorageSubset::readValue (0x0f).bit (7)) _clock -> setAlarmTenthSeconds (({\cf18 unsigned} {\cf18 char}) ts); \par
00080                 {\cf19 else} _clock -> setTenthSeconds (({\cf18 unsigned} {\cf18 char}) ts);\par
00081             \}\par
00082 \par
00083             {\cf19 break};\par
00084 \par
00085         {\cf20 // Time of Day Clock Seconds: TO2SEC}\par
00086         {\cf20 // Bits 0-3: Second BCD Digit. Bits 4-6: First BCD Digit. Bit 7: Unused.}\par
00087         {\cf19 case} 0x09:\par
00088             \{\par
00089                 {\cf18 int} s = MCHEmul::UInt (\{ MCHEmul::PhisicalStorageSubset::readValue (0x08) \}, \par
00090                     {\cf17 true} , {\cf17 true} ).asInt (); {\cf20 // A BCD value to int...}\par
00091                 {\cf19 if} (MCHEmul::PhisicalStorageSubset::readValue (0x0f).bit (7)) _clock -> setSeconds (({\cf18 unsigned} {\cf18 char}) s); \par
00092                 {\cf19 else} _clock -> setSeconds (({\cf18 unsigned} {\cf18 char}) s);\par
00093             \}\par
00094 \par
00095             {\cf19 break};\par
00096 \par
00097         {\cf20 // Time of Day Clock Minutes: TO2MIN}\par
00098         {\cf20 // Bits 0-3: Second BCD Digit. Bits 4-6: First BCD Digit. Bit 7: Unused.}\par
00099         {\cf19 case} 0x0b:\par
00100             \{\par
00101                 {\cf18 int} m = MCHEmul::UInt (\{ MCHEmul::PhisicalStorageSubset::readValue (0x08) \}, \par
00102                     {\cf17 true} , {\cf17 true} ).asInt (); {\cf20 // A BCD value to int...}\par
00103                 {\cf19 if} (MCHEmul::PhisicalStorageSubset::readValue (0x0f).bit (7)) _clock -> setAlarmMinutes (({\cf18 unsigned} {\cf18 char}) m); \par
00104                 {\cf19 else} _clock -> setMinutes (({\cf18 unsigned} {\cf18 char}) m);\par
00105             \}\par
00106 \par
00107             {\cf19 break};\par
00108 \par
00109         {\cf20 // Time of Day Clock Hours: TO2HRS}\par
00110         {\cf20 // Bits 0-3: Second BCD Digit. Bit 4: First BCD Digit. Bits 5-6: Unused. Bit 7: AM/PM Flag (PM = 1)}\par
00111         {\cf19 case} 0x0a:\par
00112             \{\par
00113                 {\cf18 int} h = MCHEmul::UInt (\{ MCHEmul::PhisicalStorageSubset::readValue (0x08) \}, \par
00114                     {\cf17 true} , {\cf17 true} ).asInt (); {\cf20 // A BCD value to int...}\par
00115                 {\cf19 if} (MCHEmul::PhisicalStorageSubset::readValue (0x0f).bit (7)) _clock -> setAlarmHours (({\cf18 unsigned} {\cf18 char}) h); \par
00116                 {\cf19 else} _clock -> setHours (({\cf18 unsigned} {\cf18 char}) h);\par
00117             \}\par
00118 \par
00119             {\cf19 break};\par
00120 \par
00121         {\cf20 // Serial Data Port CI2SDR}\par
00122         {\cf19 case} 0x0c:\par
00123             {\cf19 break};\par
00124 \par
00125         {\cf20 // Interrupt Control Register: CI2ICR}\par
00126         {\cf20 // Depending on the bit 7 the behaviour is different: 1 = bits with 1 are set, 0 = bits with 1 are cleared... }\par
00127         {\cf19 case} 0x0d:\par
00128             {\cf19 if} (v.bit (0)) _timerA -> setIRQEnabled (v.bit (7));\par
00129             {\cf19 if} (v.bit (1)) _timerB -> setIRQEnabled (v.bit (7));\par
00130             {\cf19 if} (v.bit (2)) _clock -> setIRQEnabled (v.bit (7));\par
00131             {\cf20 // TODO: To manage the serial port...}\par
00132             {\cf19 break};\par
00133 \par
00134         {\cf20 // Control Register A: CI2CRA}\par
00135         {\cf19 case} 0x0e:\par
00136             _timerA -> setEnabled (v.bit (0));\par
00137             {\cf20 // TODO: Sending signals to serial port...(bits 1, 2 & 6)}\par
00138             _timerA -> setRunMode (v.bit (3) ? CIATimer::RunMode::_ONETIME : CIATimer::RunMode::_RESTART);\par
00139             {\cf19 if} (v.bit (4)) _timerA -> reset ();\par
00140             _timerA -> setCountMode (v.bit (5)\par
00141                 ? C64::CIATimer::CountMode::_PROCESSORCYCLES: C64::CIATimer::CountMode::_SIGNALSONCNTLINE);\par
00142             {\cf20 // TODO: Pending to control based on 60Hz or 50 Hz...(bit 7)}\par
00143             {\cf19 break};\par
00144 \par
00145         {\cf20 // Control Register B: CI2CRB}\par
00146         {\cf19 case} 0x0f:\par
00147             _timerB -> setEnabled (v.bit (0));\par
00148             {\cf20 // TODO: Sending signals to serial port B...(bits 1, 2 & 6)}\par
00149             _timerB -> setRunMode (v.bit (3) ? CIATimer::RunMode::_ONETIME : CIATimer::RunMode::_RESTART);\par
00150             {\cf19 if} (v.bit (4)) _timerB -> reset ();\par
00151             {\cf20 // bits 5 & 6 indicates the mode...}\par
00152             _timerB -> setCountMode ((C64::CIATimer::CountMode) ((v.value () >> 4) & 0x03));\par
00153             {\cf20 // _PROCESSORCYCLES = 0, _SIGNALSONCNTLINE = 1,...}\par
00154             {\cf19 break};\par
00155             \par
00156         {\cf19 default}:\par
00157             {\cf19 break};\par
00158     \}\par
00159 \}\par
00160 \par
00161 {\cf20 // ---}\par
00162 {\cf17 const} MCHEmul::UByte& C64::CIA2Registers::readValue ({\cf18 size_t} p){\cf17  const}\par
00163 {\cf17 }\{\par
00164     assert (_timerA != {\cf17 nullptr} && _timerB != {\cf17 nullptr} && _clock != {\cf17 nullptr});\par
00165 \par
00166     MCHEmul::UByte result = MCHEmul::PhisicalStorage::_DEFAULTVALUE;\par
00167 \par
00168     {\cf18 size_t} pp = p % 0x10;\par
00169 \par
00170     {\cf19 switch} (pp)\par
00171     \{\par
00172         {\cf20 // When reading no special behaviour...but when setting!}\par
00173         {\cf19 case} 0x00:\par
00174         {\cf19 case} 0x01:\par
00175         {\cf19 case} 0x02:\par
00176         {\cf19 case} 0x03:\par
00177             result = MCHEmul::PhisicalStorageSubset::readValue (p);\par
00178             {\cf19 break};\par
00179 \par
00180         {\cf19 case} 0x04:\par
00181             result = MCHEmul::UByte (({\cf18 unsigned} {\cf18 char}) (_timerA -> currentValue () & 0x00ff));\par
00182             {\cf19 break};\par
00183 \par
00184         {\cf19 case} 0x05:\par
00185             result = MCHEmul::UByte (({\cf18 unsigned} {\cf18 char}) ((_timerA -> currentValue () & 0xff00) >> 8));\par
00186             {\cf19 break};\par
00187 \par
00188         {\cf19 case} 0x06:\par
00189             result = MCHEmul::UByte (({\cf18 unsigned} {\cf18 char}) (_timerB -> currentValue () & 0x00ff));\par
00190             {\cf19 break};\par
00191 \par
00192         {\cf19 case} 0x07:\par
00193             result = MCHEmul::UByte (({\cf18 unsigned} {\cf18 char}) ((_timerB -> currentValue () & 0xff00) >> 8));\par
00194             {\cf19 break};\par
00195 \par
00196         {\cf19 case} 0x08:\par
00197             {\cf20 // Only 1 digit from 0 to 9 (4 bits). Rest unused.}\par
00198             result = MCHEmul::UInt::fromUnsignedInt (_clock -> tenthsSecond (), MCHEmul::UInt::_PACKAGEDBCD).bytes ()[0];\par
00199             {\cf19 break};\par
00200 \par
00201         {\cf19 case} 0x09:\par
00202             {\cf20 // 2 digits. 1\'BA: from 0 to 9 (4 bits), 2\'BA: from 0 to 6 (3 bits). Bit 7 unused}\par
00203             result = MCHEmul::UInt::fromUnsignedInt (_clock -> seconds (), MCHEmul::UInt::_PACKAGEDBCD).bytes ()[0];\par
00204             {\cf19 break};\par
00205 \par
00206         {\cf19 case} 0x0a:\par
00207             {\cf20 // 2 digits. 1\'BA: from 0 to 9 (4 bits), 2\'BA: from 0 to 6 (3 bits). Bit 7 unused}\par
00208             result = MCHEmul::UInt::fromUnsignedInt (_clock -> minutes (), MCHEmul::UInt::_PACKAGEDBCD).bytes ()[0];\par
00209             {\cf19 break};\par
00210 \par
00211         {\cf19 case} 0x0b:\par
00212             \{\par
00213                 {\cf20 // 2 digits. 1\'BA: from 0 to 9 (4 bits), 2\'BA: either 0 or 1 (1 bit). Bits 5,6 unused. Bit 7 AM/PM flag (PM = 1)}\par
00214                 {\cf18 unsigned} {\cf18 int} h = ({\cf18 unsigned} int) _clock -> hours ();\par
00215                 {\cf18 bool} pm = h > 12 || (h == 12 && _clock -> minutes () > 0);\par
00216                 {\cf19 if} (pm && h > 12) h -= 12; {\cf20 // The value 12 is kept...}\par
00217                 result = MCHEmul::UInt::fromUnsignedInt (h, MCHEmul::UInt::_PACKAGEDBCD).bytes ()[0];\par
00218                 result.setBit (7, pm);\par
00219             \}\par
00220 \par
00221             {\cf19 break};\par
00222 \par
00223         {\cf19 case} 0x0c:\par
00224             {\cf20 // TODO: }\par
00225             {\cf20 // To simulate the Serial Port.}\par
00226             {\cf20 // The directions of the information has to be taken into account}\par
00227             {\cf20 // When the serial port is configurated for input, the data is read in the pint 5 when the pin 4 (CNT) let you know}\par
00228             {\cf20 // the info is ready for reading (this is connected with the timer).}\par
00229             {\cf19 break};\par
00230 \par
00231         {\cf19 case} 0x0d:\par
00232             \{\par
00233                 {\cf18 bool} IA = _timerA -> IRQRequested (); {\cf20 // It is set back to false after reading...}\par
00234                 {\cf18 bool} IB = _timerB -> IRQRequested (); {\cf20 // Same...}\par
00235                 {\cf18 bool} IC = _clock -> IRQRequested (); {\cf20 // Same...}\par
00236                 result = MCHEmul::UByte::_0;\par
00237                 result.setBit (7, IA || IB || IC); {\cf20 // IRQ?}\par
00238                 result.setBit (0, IA); {\cf20 // in Timer A?}\par
00239                 result.setBit (1, IB); {\cf20 // in Timer B?}\par
00240                 result.setBit (2, IC); {\cf20 // in Clock?}\par
00241                 {\cf20 // TODO: To manage the serial port...}\par
00242             \}\par
00243 \par
00244             {\cf19 break};\par
00245 \par
00246         {\cf19 case} 0x0e:\par
00247         {\cf19 case} 0x0f:\par
00248             result = MCHEmul::PhisicalStorageSubset::readValue (p);\par
00249             {\cf19 break};\par
00250             \par
00251         {\cf19 default}:\par
00252             {\cf19 break};\par
00253     \}\par
00254 \par
00255     {\cf19 return} (_lastValueRead = result);\par
00256 \}\par
00257 \par
00258 {\cf20 // ---}\par
00259 {\cf18 void} C64::CIA2Registers::initializeInternalValues ()\par
00260 \{\par
00261     {\cf20 // At this point the timers and the clock might not be set yet...}\par
00262     {\cf19 if} (_timerA == {\cf17 nullptr} || _timerB == {\cf17 nullptr} || _clock == {\cf17 nullptr})\par
00263         {\cf19 return};\par
00264 \par
00265     {\cf20 // The internal variables are initialized through the data in memory...}\par
00266 \par
00267     setValue (0x00, 0x03); {\cf20 // To set the bank 0...}\par
00268 \par
00269     setValue (0x01, MCHEmul::UByte::_0);\par
00270     setValue (0x02, MCHEmul::UByte::_0);\par
00271     setValue (0x03, MCHEmul::UByte::_0);\par
00272     setValue (0x04, MCHEmul::UByte::_0); {\cf20 // No timer A active}\par
00273     setValue (0x05, MCHEmul::UByte::_0);\par
00274     setValue (0x06, MCHEmul::UByte::_0); {\cf20 // No timer B active}\par
00275     setValue (0x07, MCHEmul::UByte::_0);\par
00276     setValue (0x08, MCHEmul::UByte::_0); \par
00277     setValue (0x09, MCHEmul::UByte::_0); \par
00278     setValue (0x0a, MCHEmul::UByte::_0); \par
00279     setValue (0x0b, MCHEmul::UByte::_0); \par
00280     setValue (0x0c, MCHEmul::UByte::_0); \par
00281     setValue (0x0d, MCHEmul::UByte::_0); {\cf20 // No interupts allowed from the early beginning...so stopped!}\par
00282     setValue (0x0e, MCHEmul::UByte::_0); {\cf20 // No value in timer A}\par
00283     setValue (0x0f, MCHEmul::UByte::_0); {\cf20 // No value in timer B}\par
00284 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/CIAClock.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/CIAClock.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/CIAClock.cpp}
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/CIAClock.hpp>}\par
{\f2 #include <F6500/NMIInterrupt.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIAClock.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/CIAClock.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/CIAClock.cpp}
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/CIAClock.hpp>}\par
00002 {\cf21 #include <F6500/NMIInterrupt.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 void} C64::CIAClock::initialize ()\par
00006 \{\par
00007     _IRQEnabled = {\cf17 false};\par
00008 \par
00009     _time = C64::Time ();\par
00010 \par
00011     {\cf20 // The implementation values...}\par
00012     _lastClockCycles = 0;\par
00013     _hours = _minutes = _seconds = _tenthsSecond = 0x00;\par
00014     _minutesL = _secondsL = _tenthsSecondL = 0x00;\par
00015     _timeLatched = {\cf17 false};\par
00016 \par
00017     _stopped = {\cf17 false};\par
00018 \par
00019     _reachesAlarm = {\cf17 false};\par
00020     _IRQRequested = {\cf17 false};\par
00021 \}\par
00022 \par
00023 {\cf20 // ---}\par
00024 {\cf18 void} C64::CIAClock::simulate (MCHEmul::CPU* cpu)\par
00025 \{\par
00026     assert (cpu != {\cf17 nullptr}); \par
00027 \par
00028     {\cf19 if} (_stopped)\par
00029         {\cf19 return};\par
00030 \par
00031     _reachesAlarm = {\cf17 false};\par
00032 \par
00033     actualizeTime ();\par
00034 \par
00035     {\cf20 // The alamr is controlled versus the values latched}\par
00036     {\cf20 // because the actualization of the official ones might be in progress...}\par
00037     {\cf19 if} (_hours == _alarmHours && _minutesL == _alarmMinutes && _secondsL == _alarmSeconds &&\par
00038         _tenthsSecondL >= _alarmTenthsSecond)\par
00039     \{\par
00040         {\cf19 if} (_IRQEnabled)\par
00041             cpu -> interrupt (F6500::NMIInterrupt::_ID) -> setActive (_IRQRequested = {\cf17 true});\par
00042         \par
00043         _reachesAlarm = {\cf17 true};\par
00044     \}\par
00045 \par
00046     _lastClockCycles = cpu -> clockCycles ();\par
00047 \}\par
00048 \par
00049 {\cf20 // ---}\par
00050 {\cf18 void} C64::CIAClock::actualizeTime () \par
00051 \{\par
00052     _time += C64::_TENTHSSECONDPAST; {\cf20 // Actualize the timer...}\par
00053     {\cf19 if} (_time.time_since_epoch ().count () >= 864000 )\par
00054         _time = C64::Time ();\par
00055 \par
00056     {\cf20 // Now it is time to convert it into days, hours,...}\par
00057     {\cf17 auto} tds = _time.time_since_epoch ().count (); {\cf20 // In tenths of seconds...}\par
00058     _hours = ({\cf18 unsigned} char) (tds / 36000); tds -= ({\cf18 unsigned} long) _hours * 36000; {\cf20 // tenths of second per hour = 60 * 60 * 10}\par
00059     _minutes = ({\cf18 unsigned} char) (tds / 600); tds -= ({\cf18 unsigned} long) _minutes * 600; {\cf20 // tenths of second per minute = 60 * 10}\par
00060     _seconds = ({\cf18 unsigned} char) (tds / 10); tds -= ({\cf18 unsigned} long) _seconds * 10; {\cf20 // tenths of second per second = 10;}\par
00061     _tenthsSecond = ({\cf18 unsigned} char) tds; {\cf20 // What remains are the tenths of second...}\par
00062 \par
00063     {\cf19 if} (!_timeLatched)\par
00064         \{ _minutesL = _minutes; _secondsL = _seconds; _tenthsSecondL = _tenthsSecond; \}\par
00065 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/CIATimer.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/CIATimer.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/CIATimer.cpp}
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/CIATimer.hpp>}\par
{\f2 #include <F6500/NMIInterrupt.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIATimer.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/CIATimer.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/CIATimer.cpp}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/CIATimer.hpp>}\par
00002 {\cf21 #include <F6500/NMIInterrupt.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 void} C64::CIATimer::initialize ()\par
00006 \{\par
00007     _runMode = RunMode::_RESTART;\par
00008     _countMode = CountMode::_PROCESSORCYCLES;\par
00009 \par
00010     _enabled = {\cf17 false};\par
00011     _IRQEnabled = {\cf17 false};\par
00012 \par
00013     _initialValue = 0x0000;\par
00014     _time = C64::Time ();\par
00015 \par
00016     {\cf20 // The implementation values...}\par
00017     _currentValue = 0x0000;\par
00018     _lastClockCycles = 0;\par
00019 \par
00020     _reaches0 = {\cf17 false};\par
00021     _IRQRequested = {\cf17 false};\par
00022 \}\par
00023 \par
00024 {\cf20 // ---}\par
00025 {\cf18 void} C64::CIATimer::simulate (MCHEmul::CPU* cpu, C64::CIATimer* t)\par
00026 \{\par
00027     assert (cpu != {\cf17 nullptr});\par
00028 \par
00029     {\cf19 if} (!_enabled)\par
00030         {\cf19 return};\par
00031 \par
00032     {\cf19 if} (countDown (cpu, t))\par
00033     \{\par
00034         {\cf19 if} (_IRQEnabled)\par
00035             cpu -> interrupt (F6500::NMIInterrupt::_ID) -> setActive (_IRQRequested = {\cf17 true});\par
00036         \par
00037         {\cf19 switch} (_runMode)\par
00038         \{\par
00039             {\cf19 case} C64::CIATimer::RunMode::_RESTART:\par
00040                 _currentValue = _initialValue;\par
00041                 {\cf19 break};\par
00042 \par
00043             {\cf19 case} C64::CIATimer::RunMode::_ONETIME:\par
00044                 _enabled = {\cf17 false};\par
00045                 {\cf19 break};\par
00046 \par
00047             {\cf19 default}:\par
00048                 {\cf19 break};\par
00049         \}\par
00050 \par
00051         _reaches0 = {\cf17 true};\par
00052     \}\par
00053 \par
00054     _lastClockCycles = cpu -> clockCycles ();\par
00055 \}\par
00056 \par
00057 {\cf20 // ---}\par
00058 {\cf18 bool} C64::CIATimer::countDown (MCHEmul::CPU* cpu, C64::CIATimer* t)\par
00059 \{\par
00060     _reaches0 = {\cf17 false};\par
00061 \par
00062     {\cf18 bool} result = {\cf17 false};\par
00063     {\cf19 switch} (_countMode)\par
00064     \{\par
00065         {\cf19 case} C64::CIATimer::CountMode::_PROCESSORCYCLES:\par
00066             \{\par
00067                 {\cf18 unsigned} {\cf18 int} c = cpu -> clockCycles () - _lastClockCycles;\par
00068                 result = ((_currentValue -= (c > ({\cf18 unsigned} int) _currentValue) ? _currentValue : ({\cf18 unsigned} short) c) == 0x0000);\par
00069             \}\par
00070 \par
00071             {\cf19 break};\par
00072 \par
00073         {\cf19 case} C64::CIATimer::CountMode::_SIGNALSONCNTLINE:\par
00074             {\cf20 // TODO: Linked to the serial port...}\par
00075             {\cf19 break};\par
00076 \par
00077         {\cf19 case} C64::CIATimer::CountMode::_TIMERCOUNTSDOWNTO0:\par
00078             {\cf19 if} (t != {\cf17 nullptr} && t -> reaches0 ())\par
00079                 result = (--_currentValue == 0x00);\par
00080             {\cf19 break};\par
00081 \par
00082         {\cf19 case} C64::CIATimer::CountMode::_0ONCNTPULSES:\par
00083             {\cf20 // TODO: Linked to the serial port...}\par
00084             {\cf19 break};\par
00085 \par
00086         {\cf19 default}:\par
00087             {\cf19 break};\par
00088     \}\par
00089 \par
00090     {\cf19 return} (result);\par
00091 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/ColorMemory.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/ColorMemory.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/ColorMemory.cpp}
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/ColorMemory.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ColorMemory.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/ColorMemory.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/ColorMemory.cpp}
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/ColorMemory.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/global.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/global.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/global.cpp}
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/global.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
global.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/global.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/global.cpp}
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/global.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 {\cf18 void} C64::actualizeGlobalTime ()\par
00005 \{\par
00006     C64::Time n = std::chrono::time_point_cast <C64::Duration> (std::chrono::steady_clock::now ());\par
00007     C64::_TENTHSSECONDPAST = C64::_NOW - n;\par
00008     C64::_NOW = n;\par
00009 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/global.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/global.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/global.cpp}
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/global.hpp>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <cctype>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
global.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/global.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/global.cpp}
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/global.hpp>}\par
00002 {\cf21 #include <algorithm>}\par
00003 {\cf21 #include <cctype>}\par
00004 \par
00005 {\cf20 // ---}\par
00006 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} MCHEmul::Attributes& attrs)\par
00007 \{ \par
00008     {\cf18 bool} f = {\cf17 true};\par
00009     {\cf19 for} ({\cf17 auto} i : attrs)\par
00010     \{\par
00011         {\cf19 if} (!f)\par
00012             o << std::endl;\par
00013         o << i.first << {\cf22 ":"} << i.second;\par
00014 \par
00015         f = {\cf17 false};\par
00016     \}\par
00017 \par
00018     {\cf19 return} (o);\par
00019 \}\par
00020 \par
00021 {\cf20 // ---}\par
00022 std::string MCHEmul::ltrim ({\cf17 const} std::string& s)\par
00023 \{\par
00024     std::string r = s; \par
00025     r.erase (r.begin (), std::find_if (r.begin (), r.end (), \par
00026         []({\cf18 unsigned} {\cf18 char} ch) -> {\cf18 bool} \{ return (!std::isspace (ch)); \})); \par
00027 \par
00028     {\cf19 return} (r); \par
00029 \}\par
00030 \par
00031 {\cf20 // ---}\par
00032 std::string MCHEmul::rtrim ({\cf17 const} std::string& s)\par
00033 \{\par
00034     std::string r = s; \par
00035     r.erase (std::find_if (r.rbegin (), r.rend (), \par
00036         []({\cf18 unsigned} {\cf18 char} ch) -> {\cf18 bool} \{ return (!std::isspace (ch)); \}).base (), r.end ()); \par
00037 \par
00038     {\cf19 return} (r); \par
00039 \}\par
00040 \par
00041 {\cf20 // ---}\par
00042 std::string MCHEmul::trim ({\cf17 const} std::string& s)\par
00043 \{ \par
00044     {\cf19 return} (MCHEmul::rtrim (MCHEmul::ltrim (s)));\par
00045 \}\par
00046 \par
00047 {\cf20 // ---}\par
00048 std::string MCHEmul::upper ({\cf17 const} std::string& s)\par
00049 \{ \par
00050     std::string r = s; \par
00051     {\cf19 for} ({\cf17 auto}& i : r) \par
00052         i = std::toupper (i); \par
00053     \par
00054     {\cf19 return} (r);\par
00055 \}\par
00056 \par
00057 {\cf20 // ---}\par
00058 std::string MCHEmul::lower ({\cf17 const} std::string& s)\par
00059 \{\par
00060     std::string r = s; \par
00061     {\cf19 for} ({\cf17 auto}& i : r) \par
00062         i = std::tolower (i); \par
00063     \par
00064     {\cf19 return} (r);\par
00065 \}\par
00066 \par
00067 {\cf20 // ---}\par
00068 std::string MCHEmul::noSpaces ({\cf17 const} std::string& s)\par
00069 \{ \par
00070     std::string r = s; \par
00071     r.erase (std::remove_if (r.begin (), r.end (), \par
00072         []({\cf18 unsigned} {\cf18 char} ch) -> {\cf18 bool} \{ return (std::isspace (ch)); \}), r.end ());\par
00073     \par
00074     {\cf19 return} (r);\par
00075 \}\par
00076 \par
00077 {\cf20 // ---}\par
00078 std::string MCHEmul::onlyAlphanumeric ({\cf17 const} std::string& s)\par
00079 \{\par
00080     std::string r = s; \par
00081     r.erase (std::remove_if (r.begin (), r.end (), \par
00082         []({\cf18 unsigned} {\cf18 char} ch) -> {\cf18 bool} \{ return (!std::isalnum (ch)); \}), r.end ());\par
00083     \par
00084     {\cf19 return} (r);\par
00085 \}\par
00086 \par
00087 {\cf20 // ---}\par
00088 std::string MCHEmul::noneOf ({\cf17 const} std::string& s, {\cf17 const} std::string& chrs)\par
00089 \{\par
00090     std::string r = s; \par
00091     r.erase (std::remove_if (r.begin (), r.end (), \par
00092         [=]({\cf18 unsigned} {\cf18 char} chr) -> {\cf18 bool} \{ return (chrs.find (chr) != std::string::npos); \}), r.end ());\par
00093     \par
00094     {\cf19 return} (r);\par
00095 \}\par
00096 \par
00097 {\cf20 // ---}\par
00098 std::string MCHEmul::removeAllFrom ({\cf17 const} std::string& s, std::vector <std::string>& strs)\par
00099 \{\par
00100     std::string result = s;\par
00101 \par
00102     {\cf18 size_t} pos;\par
00103     {\cf19 for} ({\cf17 auto} i : strs)\par
00104         {\cf19 if} ((pos = result.find (i)) != std::string::npos)\par
00105             result.erase (pos, i.length ());\par
00106 \par
00107     {\cf19 return} (result);\par
00108 \}\par
00109 \par
00110 {\cf20 // ---}\par
00111 std::vector <std::string> MCHEmul::getElementsFrom ({\cf17 const} std::string& txt, {\cf18 unsigned} {\cf18 char} ch, {\cf18 size_t} nE)\par
00112 \{\par
00113     std::vector <std::string> result;\par
00114 \par
00115     {\cf18 size_t} i = 0;\par
00116     std::string cpTxt = txt;\par
00117     {\cf19 while} (cpTxt != std::string ({\cf22 ""}) && i < nE)\par
00118     \{\par
00119         std::string prt = cpTxt;\par
00120         {\cf18 size_t} pC = cpTxt.find_first_of (ch);\par
00121         prt = cpTxt.substr (0, pC); \par
00122         cpTxt = (pC == std::numeric_limits <size_t>::max ()) ? {\cf22 ""} : cpTxt.substr (pC + 1);\par
00123         result.push_back (MCHEmul::trim (prt));\par
00124     \}\par
00125 \par
00126     {\cf20 // Adjust the size...}\par
00127     {\cf19 if} (result.size () < nE && nE != std::numeric_limits <size_t>::max ()) \par
00128         {\cf19 for} ({\cf18 size_t} i = result.size (); i < nE; result.push_back (std::string ({\cf22 ""})), i++);\par
00129     {\cf19 if} (result.size () > nE && nE != std::numeric_limits <size_t>::max ())\par
00130         {\cf19 for} ({\cf18 size_t} i = result.size (); i > nE; result.pop_back (), i++);\par
00131 \par
00132     {\cf19 return} (result);\par
00133 \}\par
00134 \par
00135 {\cf20 // ---}\par
00136 {\cf18 bool} MCHEmul::validLabel ({\cf17 const} std::string& s)\par
00137 \{\par
00138     {\cf19 return} (s.length () >= 1 && \par
00139             std::find_if (s.begin (), s.end (), \par
00140                 []({\cf18 unsigned} ch) -> {\cf18 bool} \{ return (!std::isalnum (ch)); \}) == s.end () &&\par
00141             !std::isdigit (s [0]));\par
00142 \}\par
00143 \par
00144 {\cf20 // ---}\par
00145 {\cf18 bool} MCHEmul::validBytesOctal ({\cf17 const} std::string& s)\par
00146 \{ \par
00147     {\cf17 static} {\cf17 const} std::string oS ({\cf22 "01234567"});\par
00148 \par
00149     {\cf19 return} (s.length () >= 1 && \par
00150             std::find_if (s.begin (), s.end (), \par
00151             []({\cf18 unsigned} ch) -> {\cf18 bool} \{ return (oS.find (ch) == std::string::npos); \}) == s.end () &&\par
00152             s [0] == {\cf23 '0'}); \par
00153 \}\par
00154 \par
00155 {\cf20 // ---}\par
00156 {\cf18 bool} MCHEmul::validBytesHexadecimal ({\cf17 const} std::string& s) \par
00157 \{ \par
00158     {\cf17 static} {\cf17 const} std::string oS ({\cf22 "0123456789ABCDEFabcdef"});\par
00159 \par
00160     {\cf19 return} (s.length () > 1 && \par
00161             std::find_if (++s.begin (), s.end (), \par
00162             []({\cf18 unsigned} ch) -> {\cf18 bool} \{ return (oS.find (ch) == std::string::npos); \}) == s.end () &&\par
00163             s [0] == {\cf23 '$'}); \par
00164 \}\par
00165 \par
00166 {\cf20 // ---}\par
00167 {\cf18 bool} MCHEmul::validBytesDecimal ({\cf17 const} std::string& s) \par
00168 \{ \par
00169     {\cf17 static} {\cf17 const} std::string oS ({\cf22 "0123456789"});\par
00170 \par
00171     {\cf19 return} (s.length () >= 1 && \par
00172             std::find_if (s.begin (), s.end (), \par
00173             []({\cf18 unsigned} ch) -> {\cf18 bool} \{ return (oS.find (ch) == std::string::npos); \}) == s.end () &&\par
00174             s [0] != {\cf23 '0'} ); \par
00175 \}\par
00176 \par
00177 {\cf20 // ---}\par
00178 {\cf18 bool} MCHEmul::validBytes ({\cf17 const} std::string& s)\par
00179 \{ \par
00180     {\cf19 return} (MCHEmul::validBytesOctal (s) || \par
00181             MCHEmul::validBytesHexadecimal (s) ||\par
00182             MCHEmul::validBytesDecimal (s));\par
00183 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/IOPBuilder.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/IOPBuilder.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/IOPBuilder.cpp}
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/IOPBuilder.hpp>}\par
{\f2 #include <C64/UserPeripherals.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IOPBuilder.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/IOPBuilder.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/IOPBuilder.cpp}
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/IOPBuilder.hpp>}\par
00002 {\cf21 #include <C64/UserPeripherals.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 MCHEmul::IOPeripheral* C64::IOPeripheralBuilder::createPeripheral ({\cf18 int} {\cf18 id}, {\cf17 const} MCHEmul::Attributes& prms){\cf17  const}\par
00006 {\cf17 }\{\par
00007     MCHEmul::IOPeripheral* result = {\cf17 nullptr};\par
00008 \par
00009     {\cf19 if} ({\cf18 id} == C64::UserIONoPeripheral::_ID)\par
00010         result = {\cf17 new} C64::UserIONoPeripheral;\par
00011 \par
00012     {\cf20 // Take care, it could be null...}\par
00013     {\cf19 return} (result);\par
00014 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/IOPBuilder.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/IOPBuilder.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/IOPBuilder.cpp}
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/IOPBuilder.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IOPBuilder.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/IOPBuilder.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/IOPBuilder.cpp}
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/IOPBuilder.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 MCHEmul::IOPeripheral* MCHEmul::IOPeripheralBuilder::peripheral ({\cf18 int} {\cf18 id}, {\cf17 const} MCHEmul::Attributes& prms){\cf17  const}\par
00005 {\cf17 }\{\par
00006     MCHEmul::IOPeripherals::const_iterator i = _peripherals.find ({\cf18 id});\par
00007     {\cf19 if} (i != _peripherals.end ())\par
00008         {\cf19 return} ((*i).second);\par
00009 \par
00010     MCHEmul::IOPeripheral* result = createPeripheral ({\cf18 id}, prms);\par
00011     assert (result != {\cf17 nullptr});\par
00012 \par
00013     _peripherals.insert (MCHEmul::IOPeripherals::value_type ({\cf18 id}, result));\par
00014 \par
00015     {\cf19 return} (result);\par
00016 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/Memory.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/Memory.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/Memory.cpp}
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/Memory.hpp>}\par
{\f2 #include <C64/ColorMemory.hpp>}\par
{\f2 #include <C64/VICIIRegisters.hpp>}\par
{\f2 #include <C64/CIA1Registers.hpp>}\par
{\f2 #include <C64/CIA2Registers.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Memory.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/Memory.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/Memory.cpp}
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/Memory.hpp>}\par
00002 {\cf21 #include <C64/ColorMemory.hpp>}\par
00003 {\cf21 #include <C64/VICIIRegisters.hpp>}\par
00004 {\cf21 #include <C64/CIA1Registers.hpp>}\par
00005 {\cf21 #include <C64/CIA2Registers.hpp>}\par
00006 \par
00007 {\cf20 // ---}\par
00008 C64::Memory::Memory ()\par
00009     : MCHEmul::Memory (C64::Memory::standardMemoryContent ())\par
00010 \{\par
00011     {\cf20 // In the content...}\par
00012     {\cf19 if} (lastError () != MCHEmul::_NOERROR)\par
00013         {\cf19 return};\par
00014 \par
00015     {\cf18 bool} ok = {\cf17 true};\par
00016     ok &= subset (_BASICROM_SUBSET) -> loadInto ({\cf22 "./basic.901226-01.bin"});\par
00017     subset (_BASICROM_SUBSET) -> fixDefaultValues (); {\cf20 // Fix the values for further initializations...}\par
00018     ok &= subset (_CHARROM_SUBSET) -> loadInto ({\cf22 "./characters.901225-01.bin"});\par
00019     subset (_CHARROM_SUBSET) -> fixDefaultValues ();\par
00020     ok &= subset (_BANK0CHARROM_SUBSET) -> loadInto ({\cf22 "./characters.901225-01.bin"});\par
00021     subset (_BANK0CHARROM_SUBSET) -> fixDefaultValues ();\par
00022     ok &= subset (_BANK2CHARROM_SUBSET) -> loadInto ({\cf22 "./characters.901225-01.bin"});\par
00023     subset (_BANK2CHARROM_SUBSET) -> fixDefaultValues ();\par
00024     ok &= subset (_KERNELROM_SUBSET) -> loadInto ({\cf22 "./kernal.901227-03.bin"});\par
00025     subset (_KERNELROM_SUBSET) -> fixDefaultValues ();\par
00026 \par
00027     {\cf19 if} (!ok)\par
00028         _lastError = MCHEmul::_INIT_ERROR;\par
00029 \}\par
00030 \par
00031 {\cf20 // ---}\par
00032 {\cf18 bool} C64::Memory::initialize ()\par
00033 \{\par
00034     {\cf18 bool} result = MCHEmul::Memory::initialize ();\par
00035     {\cf19 if} (!result)\par
00036         {\cf19 return} ({\cf17 false});\par
00037 \par
00038     {\cf20 // The active view has to be initially the CPU vire...}\par
00039     setCPUView ();\par
00040 \par
00041     {\cf20 // Very basic values as the memory starts...}\par
00042     {\cf20 // The address 0 controls Chip I/O Data Direction Register: D6510}\par
00043     subset (_PAGEZERO_SUBSET)   -> set (MCHEmul::Address (\{ 0x00, 0x00 \}, {\cf17 false}), MCHEmul::UByte (0x2f));\par
00044     {\cf20 // Not all Subsets are active for reading activities...}\par
00045     {\cf20 // The address 1 keeps that info, about how the 6510 reads the different zones of the memory...}\par
00046     subset (_PAGEZERO_SUBSET)   -> set (MCHEmul::Address (\{ 0x01, 0x00 \}, {\cf17 false}), MCHEmul::UByte (0x07));\par
00047 \par
00048     {\cf19 return} ({\cf17 true});\par
00049 \}\par
00050 \par
00051 {\cf20 // ---}\par
00052 MCHEmul::Memory::Content C64::Memory::standardMemoryContent ()\par
00053 \{\par
00056     {\cf20 // Phisical storages}\par
00057     MCHEmul::PhisicalStorage* RAM = \par
00058         {\cf17 new} MCHEmul::PhisicalStorage (_RAM, MCHEmul::PhisicalStorage::Type::_RAM, 0x10000);             {\cf20 // 64k}\par
00059     MCHEmul::PhisicalStorage* BASICROM = \par
00060         {\cf17 new} MCHEmul::PhisicalStorage (_BASICROM, MCHEmul::PhisicalStorage::Type::_ROM, 0x2000);         {\cf20 // 8k}\par
00061     MCHEmul::PhisicalStorage* CHARROM = \par
00062         {\cf17 new} MCHEmul::PhisicalStorage (_CHARROM, MCHEmul::PhisicalStorage::Type::_ROM, 0x1000);          {\cf20 // 4k}\par
00063     MCHEmul::PhisicalStorage* KERNELROM = \par
00064         {\cf17 new} MCHEmul::PhisicalStorage (_KERNELROM, MCHEmul::PhisicalStorage::Type::_ROM, 0x2000);        {\cf20 // 8k}\par
00065 \par
00066     {\cf20 // The map of phisical storages, used later...}\par
00067     MCHEmul::PhisicalStorages storages (\par
00068         \{\par
00069             \{ _RAM, RAM \},\par
00070             \{ _BASICROM, BASICROM \},\par
00071             \{ _CHARROM, CHARROM \},\par
00072             \{ _KERNELROM, KERNELROM \}\par
00073         \});\par
00074 \par
00075     {\cf20 // Subsets}\par
00076     {\cf20 // ...Over the RAM and ROM as the CPU sees it}\par
00077     {\cf20 // Page 0}\par
00078     MCHEmul::PhisicalStorageSubset* PageZero = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00079         (_PAGEZERO_SUBSET, RAM, 0x0000, MCHEmul::Address (\{ 0x00, 0x00 \}, {\cf17 false}), 0x0100);\par
00080     {\cf20 // Stack}\par
00081     MCHEmul::Stack*  Stack = {\cf17 new} MCHEmul::Stack \par
00082         (_STACK_SUBSET, RAM, 0x0100, MCHEmul::Address (\{ 0x01, 0x01 \}, {\cf17 false}), 0x0100);\par
00083     {\cf20 // Pure RAM. A piece used by BASIC (40k)}\par
00084     MCHEmul::PhisicalStorageSubset* RAM0 = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00085         (_RAM0_SUBSET, RAM, 0x0200, MCHEmul::Address (\{ 0x00, 0x02 \}, {\cf17 false}), 0x9e00);                  {\cf20 // 40k pure (a bit used by BASIC)}\par
00086     {\cf20 // Where the basic is can be either ROM o RAM (depends on bits in position 1 of the page 0) }\par
00087     MCHEmul::PhisicalStorageSubset* BasicROM = {\cf17 new} MCHEmul::PhisicalStorageSubset\par
00088         (_BASICROM_SUBSET, BASICROM, 0x0000, MCHEmul::Address (\{ 0x00, 0xa0 \}, {\cf17 false}), 0x2000); \par
00089     MCHEmul::PhisicalStorageSubset* BasicRAM = {\cf17 new} MCHEmul::PhisicalStorageSubset\par
00090         (_BASICRAM_SUBSET, RAM, 0x0a000, MCHEmul::Address (\{ 0x00, 0xa0 \}, {\cf17 false}), 0x2000);             {\cf20 // 8k (over BasicROM)}\par
00091     {\cf20 //  Pure RAM (4k)}\par
00092     MCHEmul::PhisicalStorageSubset* RAM1 = {\cf17 new} MCHEmul::PhisicalStorageSubset\par
00093         (_RAM1_SUBSET, RAM, 0x0c000, MCHEmul::Address (\{ 0x00, 0xc0 \}, {\cf17 false}), 0x1000);                 {\cf20 // 4k}\par
00094     {\cf20 // Where the CharROM is defined we have also the access to the chips (VIC, SID,...)}\par
00095     MCHEmul::PhisicalStorageSubset* CharROM = {\cf17 new} MCHEmul::PhisicalStorageSubset\par
00096         (_CHARROM_SUBSET, CHARROM, 0x0000, MCHEmul::Address (\{ 0x00, 0xd0 \}, {\cf17 false}), 0x1000);\par
00097     MCHEmul::PhisicalStorageSubset* VICIIRegisters = {\cf17 new} C64::VICIIRegisters (_VICREGS_SUBSET, RAM);\par
00098     MCHEmul::PhisicalStorageSubset* SIDRegisters = {\cf17 new} MCHEmul::PhisicalStorageSubset\par
00099         (_SIDREGS_SUBSET, RAM, 0xd400, MCHEmul::Address (\{ 0x00, 0xd4 \}, {\cf17 false}), 0x0400);\par
00100     MCHEmul::PhisicalStorageSubset* ColorRAM = {\cf17 new} C64::ColorRAMMemory (_COLOR_SUBSET, RAM);\par
00101     MCHEmul::PhisicalStorageSubset* CIA1 = {\cf17 new} C64::CIA1Registers (_CIA1_SUBSET, RAM);\par
00102     MCHEmul::PhisicalStorageSubset* CIA2 = {\cf17 new} C64::CIA2Registers (_CIA2_SUBSET, RAM);\par
00103     MCHEmul::PhisicalStorageSubset* IO1 = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00104         (_IO1_SUBSET, RAM, 0xde00, MCHEmul::Address (\{ 0x00, 0xde \}, {\cf17 false}), 0x0100); \par
00105     MCHEmul::PhisicalStorageSubset* IO2 = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00106         (_IO2_SUBSET, RAM, 0xdf00, MCHEmul::Address (\{ 0x00, 0xdf \}, {\cf17 false}), 0x0100); \par
00107     {\cf20 // Where the kernel is defined can be eiher RAM or ROM (}\par
00108     MCHEmul::PhisicalStorageSubset* KernelROM = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00109         (_KERNELROM_SUBSET, KERNELROM, 0x0000, MCHEmul::Address (\{ 0x00, 0xe0 \}, {\cf17 false}), 0x2000);\par
00110     MCHEmul::PhisicalStorageSubset* KernelRAM = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00111         (_KERNELRAM_SUBSET, RAM, 0xe000, MCHEmul::Address (\{ 0x00, 0xe0 \}, {\cf17 false}), 0x2000);             {\cf20 // 8k (over KernelROM)}\par
00112 \par
00113     {\cf20 // A map with the subsets swwn from the CPU perspective}\par
00114     MCHEmul::PhisicalStorageSubsets cpusubsets (\par
00115         \{\par
00116             \{ _PAGEZERO_SUBSET,     PageZero \}, \par
00117             \{ _STACK_SUBSET,        Stack \}, \par
00118             \{ _RAM0_SUBSET,         RAM0 \}, \par
00119             \{ _BASICROM_SUBSET,     BasicROM \}, \par
00120             \{ _BASICRAM_SUBSET,     BasicRAM \}, \par
00121             \{ _RAM1_SUBSET,         RAM1 \}, \par
00122             \{ _CHARROM_SUBSET,      CharROM \}, \par
00123             \{ _VICREGS_SUBSET,      VICIIRegisters \}, \par
00124             \{ _SIDREGS_SUBSET,      SIDRegisters \}, \par
00125             \{ _COLOR_SUBSET,        ColorRAM \}, \par
00126             \{ _CIA1_SUBSET,         CIA1 \}, \par
00127             \{ _CIA2_SUBSET,         CIA2 \}, \par
00128             \{ _IO1_SUBSET,          IO1\}, \par
00129             \{ _IO2_SUBSET,          IO2\}, \par
00130             \{ _KERNELROM_SUBSET,    KernelROM \}, \par
00131             \{ _KERNELRAM_SUBSET,    KernelRAM \}\par
00132         \});\par
00133 \par
00134     {\cf20 // And same like the VICII chips sees it...}\par
00135     {\cf20 // Bank 0}\par
00136     MCHEmul::PhisicalStorageSubset* Bank0RAM0 = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00137         (_BANK0RAM0_SUBSET, RAM, 0x0000, MCHEmul::Address (\{ 0x00, 0x00 \}, {\cf17 false}), 0x1000);\par
00138     MCHEmul::PhisicalStorageSubset* Bank0CharROM = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00139         (_BANK0CHARROM_SUBSET, CHARROM, 0x0000, MCHEmul::Address (\{ 0x00, 0x10 \}, {\cf17 false}), 0x1000);\par
00140     MCHEmul::PhisicalStorageSubset* Bank0RAM1 = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00141         (_BANK0RAM1_SUBSET, RAM, 0x2000, MCHEmul::Address (\{ 0x00, 0x20 \}, {\cf17 false}), 0x2000);\par
00142     {\cf20 // Bank 1}\par
00143     MCHEmul::PhisicalStorageSubset* Bank1RAM = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00144         (_BANK1RAM_SUBSET, RAM, 0x4000, MCHEmul::Address (\{ 0x00, 0x40 \}, {\cf17 false}), 0x4000);\par
00145     {\cf20 // Bank 2}\par
00146     MCHEmul::PhisicalStorageSubset* Bank2RAM0 = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00147         (_BANK2RAM0_SUBSET, RAM, 0x8000, MCHEmul::Address (\{ 0x00, 0x80 \}, {\cf17 false}), 0x1000);\par
00148     MCHEmul::PhisicalStorageSubset* Bank2CharROM = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00149         (_BANK2CHARROM_SUBSET, CHARROM, 0x0000, MCHEmul::Address (\{ 0x00, 0x90 \}, {\cf17 false}), 0x1000);\par
00150     MCHEmul::PhisicalStorageSubset* Bank2RAM1 = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00151         (_BANK2RAM1_SUBSET, RAM, 0xa000, MCHEmul::Address (\{ 0x00, 0xa0 \}, {\cf17 false}), 0x2000);\par
00152     {\cf20 // Bank 3}\par
00153     MCHEmul::PhisicalStorageSubset* Bank3RAM = {\cf17 new} MCHEmul::PhisicalStorageSubset \par
00154         (_BANK3RAM_SUBSET, RAM, 0xc000, MCHEmul::Address (\{ 0x00, 0xc0 \}, {\cf17 false}), 0x4000);\par
00155 \par
00156     {\cf20 // The map with the subsets from the VICII perspective}\par
00157     MCHEmul::PhisicalStorageSubsets vicIIsubsets (\par
00158         \{\par
00159             \{ _BANK0RAM0_SUBSET,    Bank0RAM0 \},\par
00160             \{ _BANK0CHARROM_SUBSET, Bank0CharROM\},\par
00161             \{ _BANK0RAM1_SUBSET,    Bank0RAM1 \},\par
00162             \{ _BANK1RAM_SUBSET,     Bank1RAM \},\par
00163             \{ _BANK2RAM0_SUBSET,    Bank2RAM0 \},\par
00164             \{ _BANK2CHARROM_SUBSET, Bank2CharROM\},\par
00165             \{ _BANK2RAM1_SUBSET,    Bank2RAM1 \},\par
00166             \{ _BANK3RAM_SUBSET,     Bank3RAM \}\par
00167         \});\par
00168 \par
00169     {\cf20 // A map with all the subsets possible...}\par
00170     MCHEmul::PhisicalStorageSubsets allsubsets (\par
00171         \{\par
00172             \{ _PAGEZERO_SUBSET,     PageZero \}, \par
00173             \{ _STACK_SUBSET,        Stack \}, \par
00174             \{ _RAM0_SUBSET,         RAM0 \}, \par
00175             \{ _BASICROM_SUBSET,     BasicROM \}, \par
00176             \{ _BASICRAM_SUBSET,     BasicRAM \}, \par
00177             \{ _RAM1_SUBSET,         RAM1 \}, \par
00178             \{ _CHARROM_SUBSET,      CharROM \}, \par
00179             \{ _VICREGS_SUBSET,      VICIIRegisters \}, \par
00180             \{ _SIDREGS_SUBSET,      SIDRegisters \}, \par
00181             \{ _COLOR_SUBSET,        ColorRAM \}, \par
00182             \{ _CIA1_SUBSET,         CIA1 \}, \par
00183             \{ _CIA2_SUBSET,         CIA2 \}, \par
00184             \{ _IO1_SUBSET,          IO1\}, \par
00185             \{ _IO2_SUBSET,          IO2\}, \par
00186             \{ _KERNELROM_SUBSET,    KernelROM \}, \par
00187             \{ _KERNELRAM_SUBSET,    KernelRAM \},\par
00188             \{ _BANK0RAM0_SUBSET,    Bank0RAM0 \},\par
00189             \{ _BANK0CHARROM_SUBSET, Bank0CharROM\},\par
00190             \{ _BANK0RAM1_SUBSET,    Bank0RAM1 \},\par
00191             \{ _BANK1RAM_SUBSET,     Bank1RAM \},\par
00192             \{ _BANK2RAM0_SUBSET,    Bank2RAM0 \},\par
00193             \{ _BANK2CHARROM_SUBSET, Bank2CharROM\},\par
00194             \{ _BANK2RAM1_SUBSET,    Bank2RAM1 \},\par
00195             \{ _BANK3RAM_SUBSET,     Bank3RAM \}\par
00196         \});\par
00197 \par
00198     {\cf20 // Then the views...}\par
00199     {\cf20 // From the CPU side...}\par
00200     MCHEmul::MemoryView* CPUView = {\cf17 new} MCHEmul::MemoryView (_CPU_VIEW, cpusubsets);\par
00201     {\cf20 // ...and from the VICII}\par
00202     MCHEmul::MemoryView* VICIIView = {\cf17 new} MCHEmul::MemoryView (_VICII_VIEW, vicIIsubsets);\par
00203 \par
00204     {\cf20 // ...and finally the memory that is the result...}\par
00205     MCHEmul::Memory::Content result;\par
00206     result._phisicalStorages = storages;\par
00207     result._subsets = allsubsets;\par
00208     result._views = MCHEmul::MemoryViews (\par
00209         \{\par
00210             \{ _CPU_VIEW, CPUView \},\par
00211             \{ _VICII_VIEW, VICIIView \}\par
00212         \});\par
00213 \par
00214     {\cf19 return} (result);\par
00215 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/Memory.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Memory.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Memory.cpp}
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Memory.hpp>}\par
{\f2 #include <fstream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Memory.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Memory.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Memory.cpp}
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/Memory.hpp>}\par
00002 {\cf21 #include <fstream>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 MCHEmul::UByte MCHEmul::PhisicalStorage::_DEFAULTVALUE (MCHEmul::UByte::_0);\par
00006 \par
00007 {\cf20 // ---}\par
00008 std::vector <MCHEmul::UByte> MCHEmul::PhisicalStorage::bytes ({\cf18 size_t} pB, {\cf18 size_t} nB){\cf17  const}\par
00009 {\cf17 }\{\par
00010     std::vector <MCHEmul::UByte> result;\par
00011     {\cf19 for} ({\cf18 size_t} i = 0; i < nB; i++)\par
00012         result.push_back (value (pB + i));\par
00013     {\cf19 return} (result);\par
00014 \}\par
00015 \par
00016 {\cf20 // ---}\par
00017 MCHEmul::PhisicalStorageSubset::PhisicalStorageSubset \par
00018         ({\cf18 int} {\cf18 id}, MCHEmul::PhisicalStorage* pS, {\cf18 size_t} pp, {\cf17 const} MCHEmul::Address& a, {\cf18 size_t} s)\par
00019     : _id (id), _phisicalStorage (pS), _initialPhisicalPosition (pp), _initialAddress (a), _size (s),\par
00020       _active (true), {\cf20 // By default all are active}\par
00021       _activeForReading (true), {\cf20 // It can be switched off}\par
00022       _defaultData (_size, MCHEmul::UByte::_0) {\cf20 // The default data is initially = _0;}\par
00023 \{ \par
00024     assert (_phisicalStorage != {\cf17 nullptr});\par
00025     assert (_size > 0);\par
00026 \par
00027     {\cf20 // The size defined for a phisical storage subset can not exceed the boundaries of the full phisical storage behind.}\par
00028     {\cf20 // If it happens then the whole phisical storage behind is considered!}\par
00029     {\cf19 if} (_phisicalStorage -> size () < (_initialPhisicalPosition + _size))\par
00030     \{\par
00031         _initialPhisicalPosition = 0;\par
00032         _size = _phisicalStorage -> size ();\par
00033 \par
00034         _defaultData = std::vector <MCHEmul::UByte> (_size, MCHEmul::UByte::_0);\par
00035     \}\par
00036 \}\par
00037 \par
00038 {\cf20 // ---}\par
00039 {\cf18 bool} MCHEmul::PhisicalStorageSubset::load ({\cf17 const} std::string& fN, {\cf18 size_t} sA, {\cf18 bool} bE)\par
00040 \{\par
00041     std::ifstream file (fN, std::ios::binary);\par
00042     {\cf19 if} (!file)\par
00043         {\cf19 return} ({\cf17 false});\par
00044 \par
00045     file.seekg (0, std::ios::end);\par
00046     std::streamoff lF = file.tellg ();\par
00047     {\cf19 if} (lF > (std::streamoff) std::numeric_limits <size_t>::max () ||\par
00048         lF < (std::streamoff) sA || (lF - (std::streamoff) sA) > (std::streamoff) size ())\par
00049         {\cf19 return} ({\cf17 false}); {\cf20 // either bad format or too long for this memory...}\par
00050 \par
00051     {\cf18 size_t} lFA = (size_t) lF;\par
00052     {\cf18 char}* aDT = {\cf17 new} {\cf18 char} [sA];\par
00053     file.seekg (0, std::ios::beg);\par
00054     file.read (aDT, (std::streamsize) sA); {\cf20 // Reads the address where to load the info}\par
00055     {\cf18 char}* fDT = {\cf17 new} {\cf18 char} [lFA - sA];\par
00056     file.read (fDT, (std::streamsize) (lFA - sA)); {\cf20 // Reads the info itself}\par
00057 \par
00058     file.close ();\par
00059 \par
00060     std::vector <MCHEmul::UByte> aV;\par
00061     {\cf19 for} ({\cf18 size_t} i = 0; i < (size_t) (sA / MCHEmul::UByte::size  ()); i += MCHEmul::UByte::size ())\par
00062         aV.push_back ((MCHEmul::UByte) (*(aDT + i)));\par
00063     std::vector <MCHEmul::UByte> fV;\par
00064     {\cf19 for} ({\cf18 size_t} i = 0; i < (size_t) ((lFA - sA) / MCHEmul::UByte::size ()); i += MCHEmul::UByte::size ())\par
00065         fV.push_back ((MCHEmul::UByte) (*(fDT + i)));\par
00066 \par
00067     {\cf17 delete} [] aDT;\par
00068     {\cf17 delete} [] fDT;\par
00069 \par
00070     {\cf18 int} dt;\par
00071     MCHEmul::Address adr (aV, bE);\par
00072     {\cf19 if} (!isIn (adr, dt))\par
00073         {\cf19 return} ({\cf17 false});\par
00074     \par
00075     set (adr, fV, {\cf17 true});\par
00076 \par
00077     {\cf19 return} ({\cf17 true});\par
00078 \}\par
00079 \par
00080 {\cf20 // ---}\par
00081 std::vector <MCHEmul::UByte> MCHEmul::PhisicalStorageSubset::bytes ({\cf17 const} MCHEmul::Address& a, {\cf18 size_t} nB){\cf17  const}\par
00082 {\cf17 }\{\par
00083     std::vector <MCHEmul::UByte> result;\par
00084     \par
00085     {\cf18 int} dt;\par
00086     {\cf19 if} (_active && _activeForReading &&\par
00087         nB < _size && (a >= _initialAddress && (dt = _initialAddress.distanceWith (a)) <= ({\cf18 int}) (_size - nB))) \par
00088         {\cf19 for} ({\cf18 size_t} i = 0; i < nB; i++)\par
00089             result.push_back (readValue (dt + i)); \par
00090     \par
00091     {\cf19 return} (result);\par
00092 \}\par
00093 \par
00094 {\cf20 // ---}\par
00095 {\cf18 void} MCHEmul::PhisicalStorageSubset::set ({\cf17 const} MCHEmul::Address& a, {\cf17 const} std::vector <MCHEmul::UByte>& v, {\cf18 bool} f)\par
00096 \{\par
00097     std::vector <MCHEmul::UByte> result;\par
00098     \par
00099     {\cf18 int} dt; \par
00100     {\cf19 if} (_active && _phisicalStorage -> canBeWriten (f) &&\par
00101         v.size () < _size && (a >= _initialAddress && (dt = _initialAddress.distanceWith (a)) <= ({\cf18 int}) (_size - v.size ())))\par
00102         {\cf19 for} ({\cf18 size_t} i = 0; i < v.size (); i++)\par
00103             setValue (dt + i, v [i]);\par
00104 \}\par
00105 \par
00106 {\cf20 // ---}\par
00107 {\cf18 bool} MCHEmul::PhisicalStorage::loadInto ({\cf17 const} std::string& fN, {\cf18 size_t} pB)\par
00108 \{\par
00109     std::ifstream file (fN, std::ios::binary);\par
00110     {\cf19 if} (!file)\par
00111         {\cf19 return} ({\cf17 false});\par
00112 \par
00113     file.seekg (0, std::ios::end);\par
00114     std::streamoff lF = file.tellg ();\par
00115     {\cf19 if} (pB > size () || lF > (std::streamoff) (size () - pB))\par
00116         {\cf19 return} ({\cf17 false}); {\cf20 // too long for this memory...}\par
00117 \par
00118     {\cf18 size_t} lFA = (size_t) lF;\par
00119     {\cf18 char}* fDT = {\cf17 new} {\cf18 char} [lFA];\par
00120     file.seekg (0, std::ios::beg);\par
00121     file.read (fDT, (std::streamsize) lFA); {\cf20 // Reads the info itself}\par
00122 \par
00123     file.close ();\par
00124 \par
00125     std::vector <MCHEmul::UByte> fV;\par
00126     {\cf19 for} ({\cf18 size_t} i = 0; i < (size_t) (lFA / MCHEmul::UByte::size ()); i += MCHEmul::UByte::size ())\par
00127         fV.push_back ((MCHEmul::UByte) (*(fDT + i)));\par
00128 \par
00129     {\cf17 delete} [] fDT;\par
00130     \par
00131     set (pB, fV);\par
00132 \par
00133     {\cf19 return} ({\cf17 true});\par
00134 \}\par
00135 \par
00136 {\cf20 // ---}\par
00137 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} MCHEmul::PhisicalStorageSubset& ps)\par
00138 \{\par
00139     {\cf19 if} (!ps.active ())\par
00140         {\cf19 return} (o);\par
00141 \par
00142     o << {\cf22 "---"} << std::endl;\par
00143     o << {\cf22 "Memory Subset Data"} << std::endl;\par
00144     o << {\cf22 "("} << ps.id () << {\cf22 "),"} << ps.initialAddress () << {\cf22 ","} << ps.size ();\par
00145     o << {\cf22 "Read "} << (ps.activeForReading () ? {\cf22 "allowed"} : {\cf22 "not allowed"});\par
00146 \par
00147     {\cf19 if} (ps.size () != 0)\par
00148     \{\par
00149         {\cf18 size_t} bS = 0x10;\par
00150         {\cf19 for} ({\cf18 size_t} i = 0; i <= (size_t) (ps.size () / bS); i++)\par
00151         \{\par
00152             {\cf19 if} ((i * bS) < ps.size ())\par
00153                 o << std::endl;\par
00154             \par
00155             {\cf19 for} ({\cf18 size_t} j = 0; j < bS && ((i * bS) + j) < ps.size (); j++)\par
00156                 o << ((j != 0) ? {\cf22 " "} : {\cf22 ""}) << ps.value (ps.initialAddress () + (i * bS) + j);\par
00157         \}\par
00158     \}\par
00159         \par
00160     {\cf19 return} (o);\par
00161 \}\par
00162 \par
00163 {\cf20 // ---}\par
00164 {\cf18 bool} MCHEmul::MemoryView::isIn ({\cf17 const} MCHEmul::Address& a, {\cf18 int}& dt){\cf17  const}\par
00165 {\cf17 }\{ \par
00166     {\cf18 bool} result = {\cf17 false};\par
00167     {\cf19 for} (MCHEmul::PhisicalStorageSubsets::const_iterator i = _subsets.begin ();\par
00168             i != _subsets.end () && !result; i++)\par
00169         result = (*i).second -> isIn (a, dt); {\cf20 // Only one is enought...}\par
00170 \par
00171     {\cf19 return} (result);\par
00172 \}\par
00173 \par
00174 {\cf20 // ---}\par
00175 {\cf18 void} MCHEmul::MemoryView::set ({\cf17 const} MCHEmul::Address& a, {\cf17 const} MCHEmul::UByte& d, {\cf18 bool} f)\par
00176 \{\par
00177     {\cf18 int} dt = 0;\par
00178     {\cf18 bool} w = {\cf17 false};\par
00179     {\cf19 for} (MCHEmul::PhisicalStorageSubsets::const_iterator i = _subsets.begin (); \par
00180             i != _subsets.end () && !w; i++)\par
00181         {\cf19 if} (w = ((*i).second -> canBeWriten (f) && (*i).second -> isIn (a, dt))) {\cf20 // The first one when it is possible...}\par
00182             (*i).second -> setValue (dt, d); {\cf20 // Access directly to the low level method to speed up access...}\par
00183                                              {\cf20 // and to avoid "isIn" to be executed twice}\par
00184 \}\par
00185 \par
00186 {\cf20 // ---}\par
00187 {\cf17 const} MCHEmul::UByte& MCHEmul::MemoryView::value ({\cf17 const} MCHEmul::Address& a){\cf17  const}\par
00188 {\cf17 }\{\par
00189     {\cf18 int} dt = 0;\par
00190     {\cf19 for} ({\cf17 auto} i : _subsets)\par
00191         {\cf19 if} (i.second -> activeForReading () && i.second -> isIn (a, dt))\par
00192             {\cf19 return} (i.second -> readValue (dt)); {\cf20 // Access directly to the low level method to speed up the access...}\par
00193                                                  {\cf20 // and to avoid "isIn" to be executed twice!}\par
00194 \par
00195     {\cf19 return} (MCHEmul::PhisicalStorage::_DEFAULTVALUE);\par
00196 \}\par
00197 \par
00198 {\cf20 // ---}\par
00199 std::vector <MCHEmul::UByte> MCHEmul::MemoryView::bytes ({\cf17 const} MCHEmul::Address& a, {\cf18 size_t} nB){\cf17  const}\par
00200 {\cf17 }\{\par
00201     std::vector <MCHEmul::UByte> result;\par
00202     \par
00203     {\cf18 int} dt = 0;\par
00204     {\cf18 bool} r = {\cf17 false};\par
00205     {\cf19 for} (MCHEmul::PhisicalStorageSubsets::const_iterator i = _subsets.begin ();\par
00206             i != _subsets.end () && !r; i++)\par
00207     \{\par
00208         {\cf19 if} (r = ((*i).second -> active () && (*i).second -> activeForReading () && \par
00209             (a >= (*i).second -> initialAddress () && \par
00210             (dt = (*i).second -> initialAddress ().distanceWith (a)) <= ({\cf18 int}) ((*i).second -> size () - nB))))\par
00211             {\cf19 for} ({\cf18 size_t} j = 0; j < nB; j++)\par
00212                 result.push_back ((*i).second -> readValue (dt + j));\par
00213     \}\par
00214 \par
00215     {\cf19 return} (result);\par
00216 \}\par
00217 \par
00218 {\cf20 // ---}\par
00219 {\cf18 void} MCHEmul::MemoryView::set ({\cf17 const} MCHEmul::Address& a, {\cf17 const} std::vector <MCHEmul::UByte>& v, {\cf18 bool} f)\par
00220 \{ \par
00221     {\cf18 int} dt = 0;\par
00222     {\cf18 bool} w = {\cf17 false};\par
00223     {\cf19 for} (MCHEmul::PhisicalStorageSubsets::const_iterator i = _subsets.begin ();\par
00224             i != _subsets.end () && !w; i++)\par
00225     \{\par
00226         {\cf19 if} (w = ((*i).second -> active () && (*i).second -> canBeWriten (f) && \par
00227             (a >= (*i).second -> initialAddress () && \par
00228                 (dt = (*i).second -> initialAddress ().distanceWith (a)) <= ({\cf18 int}) ((*i).second -> size () - v.size ()))))\par
00229             {\cf19 for} ({\cf18 size_t} j = 0; j < v.size (); j++)\par
00230                 (*i).second -> setValue (dt + j, v [j]);\par
00231     \}\par
00232 \}\par
00233 \par
00234 {\cf20 // ---}\par
00235 {\cf18 bool} MCHEmul::MemoryView::loadInto ({\cf17 const} std::string& fN, {\cf17 const} MCHEmul::Address& a)\par
00236 \{\par
00237     {\cf18 int} dt = 0;\par
00238     MCHEmul::PhisicalStorageSubset* ss = {\cf17 nullptr};\par
00239     {\cf19 for} (MCHEmul::PhisicalStorageSubsets::const_iterator i = _subsets.begin (); \par
00240             i != _subsets.end () && ss == {\cf17 nullptr}; i++)\par
00241         ss = (*i).second -> isIn (a, dt) ? (*i).second : {\cf17 nullptr};\par
00242 \par
00243     {\cf19 return} ((ss == {\cf17 nullptr}) ? ss -> loadInto (fN, a) : {\cf17 false});\par
00244 \}\par
00245 \par
00246 {\cf20 // ---}\par
00247 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} MCHEmul::MemoryView& mv)\par
00248 \{\par
00249     o << {\cf22 "---"} << std::endl;\par
00250     o << {\cf22 "Memory View Data"};\par
00251 \par
00252     {\cf19 for} ({\cf17 auto} i : mv.subsets ())\par
00253         o << std::endl << i.second; \par
00254         \par
00255     {\cf19 return} (o);\par
00256 \}\par
00257 \par
00258 {\cf20 // ---}\par
00259 {\cf18 bool} MCHEmul::Memory::Content::verifyCoherence (){\cf17  const}\par
00260 {\cf17 }\{\par
00261     _error = _phisicalStorages.empty () || _subsets.empty () || _views.empty ();\par
00262 \par
00263     {\cf19 for} ({\cf17 auto} i :_subsets)\par
00264         _error |= _phisicalStorages.find (i.second -> phisicalStorage () -> {\cf18 id} ()) == _phisicalStorages.end ();\par
00265     \par
00266     {\cf19 for} ({\cf17 auto} i : _views)\par
00267     \{\par
00268         {\cf19 for} ({\cf17 auto} j : i.second -> subsets ())\par
00269         \{\par
00270             _error |= _subsets.find (j.second -> id ()) == _subsets.end ();\par
00271             _error |= _phisicalStorages.find (j.second -> phisicalStorage () -> {\cf18 id} ()) == _phisicalStorages.end ();\par
00272         \}\par
00273     \}\par
00274 \par
00275     {\cf19 return} (_error);\par
00276 \}\par
00277 \par
00278 {\cf20 // ---}\par
00279 {\cf18 bool} MCHEmul::Memory::Content::initialize ()\par
00280 \{ \par
00281     {\cf19 if} (_error) \par
00282         {\cf19 return} ({\cf17 false}); \par
00283 \par
00284     {\cf19 for} ({\cf17 auto} i : _subsets)\par
00285         i.second -> initialize ();\par
00286 \par
00287     {\cf19 return} ({\cf17 true}); \par
00288 \}\par
00289 \par
00290 {\cf20 // ---}\par
00291 MCHEmul::Memory::Memory ({\cf17 const} Content& cnt)\par
00292     : _content (), \par
00293       _activeView (nullptr),\par
00294       _stack (nullptr), \par
00295       _cpuView (nullptr), \par
00296       _lastError (MCHEmul::_NOERROR)\par
00297 \{\par
00298     {\cf20 // It has to be verified...}\par
00299     cnt.verifyCoherence ();\par
00300 \par
00301     {\cf19 if} (cnt.error ())\par
00302         _lastError = MCHEmul::_INIT_ERROR;\par
00303     {\cf19 else}\par
00304     \{\par
00305         _content = cnt;\par
00306 \par
00307         {\cf20 // Just to have one by default...}\par
00308         _activeView = _content.firstView ();\par
00309     \}\par
00310 \}\par
00311 \par
00312 {\cf20 // ---}\par
00313 MCHEmul::Memory::~Memory ()\par
00314 \{ \par
00315     {\cf19 for} ({\cf17 auto} i : _content._phisicalStorages) \par
00316         {\cf17 delete} (i.second); \par
00317 \par
00318     {\cf19 for} ({\cf17 auto} i : _content._subsets) \par
00319         {\cf17 delete} (i.second); \par
00320 \par
00321     {\cf19 for} ({\cf17 auto} i : _content._views) \par
00322         {\cf17 delete} (i.second); \par
00323 \}\par
00324 \par
00325 {\cf20 // ---}\par
00326 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} MCHEmul::Memory& m)\par
00327 \{\par
00328     o << {\cf22 "---"} << std::endl;\par
00329     o << {\cf22 "Memory Data"} << std::endl;\par
00330     {\cf19 if} (m.lastError () != MCHEmul::_NOERROR) o << {\cf22 "Error"};\par
00331     {\cf19 else} *m.activeView (); {\cf20 // Only the active view is prited out is there is no errors...}\par
00332         \par
00333     {\cf19 return} (o);\par
00334 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/OSIO.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/OSIO.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/OSIO.cpp}
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/OSIO.hpp>}\par
{\f2 #include <C64/CIA1.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OSIO.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/OSIO.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/OSIO.cpp}
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/OSIO.hpp>}\par
00002 {\cf21 #include <C64/CIA1.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf17 const} std::map <SDL_Scancode, C64::InputOSSystem::KeyMPos> C64::InputOSSystem::_C64KEYS\par
00006     (\par
00007         \{\par
00009             \{ SDL_SCANCODE_A, std::make_pair (1,2) \},\par
00010             \{ SDL_SCANCODE_B, std::make_pair (3,4) \},\par
00011             \{ SDL_SCANCODE_C, std::make_pair (2,4) \},\par
00012             \{ SDL_SCANCODE_D, std::make_pair (2,2) \},\par
00013             \{ SDL_SCANCODE_E, std::make_pair (1,6) \},\par
00014             \{ SDL_SCANCODE_F, std::make_pair (2,5) \},\par
00015             \{ SDL_SCANCODE_G, std::make_pair (3,2) \},\par
00016             \{ SDL_SCANCODE_H, std::make_pair (3,5) \},\par
00017             \{ SDL_SCANCODE_I, std::make_pair (4,1) \},\par
00018             \{ SDL_SCANCODE_J, std::make_pair (4,2) \},\par
00019             \{ SDL_SCANCODE_K, std::make_pair (4,5) \},\par
00020             \{ SDL_SCANCODE_L, std::make_pair (5,2) \},\par
00021             \{ SDL_SCANCODE_M, std::make_pair (4,4) \},\par
00022             \{ SDL_SCANCODE_N, std::make_pair (4,7) \},\par
00023             \{ SDL_SCANCODE_O, std::make_pair (4,6) \},\par
00024             \{ SDL_SCANCODE_P, std::make_pair (5,1) \},\par
00025             \{ SDL_SCANCODE_Q, std::make_pair (7,6) \},\par
00026             \{ SDL_SCANCODE_R, std::make_pair (2,1) \},\par
00027             \{ SDL_SCANCODE_S, std::make_pair (1,5) \},\par
00028             \{ SDL_SCANCODE_T, std::make_pair (2,6) \},\par
00029             \{ SDL_SCANCODE_U, std::make_pair (3,6) \},\par
00030             \{ SDL_SCANCODE_V, std::make_pair (3,7) \},\par
00031             \{ SDL_SCANCODE_W, std::make_pair (1,1) \},\par
00032             \{ SDL_SCANCODE_X, std::make_pair (2,7) \},\par
00033             \{ SDL_SCANCODE_Y, std::make_pair (3,1) \},\par
00034             \{ SDL_SCANCODE_Z, std::make_pair (1,4) \},\par
00035             {\cf20 /* keymap numbers */}\par
00036             \{ SDL_SCANCODE_1, std::make_pair (7,0) \},\par
00037             \{ SDL_SCANCODE_2, std::make_pair (7,3) \},\par
00038             \{ SDL_SCANCODE_3, std::make_pair (1,0) \},\par
00039             \{ SDL_SCANCODE_4, std::make_pair (1,3) \},\par
00040             \{ SDL_SCANCODE_5, std::make_pair (2,0) \},\par
00041             \{ SDL_SCANCODE_6, std::make_pair (2,3) \},\par
00042             \{ SDL_SCANCODE_7, std::make_pair (3,0) \},\par
00043             \{ SDL_SCANCODE_8, std::make_pair (3,3) \},\par
00044             \{ SDL_SCANCODE_9, std::make_pair (4,0) \},\par
00045             \{ SDL_SCANCODE_0, std::make_pair (4,3) \},\par
00046             {\cf20 /* keymap function keys */}\par
00047             \{ SDL_SCANCODE_F1, std::make_pair (0,4) \},\par
00048             \{ SDL_SCANCODE_F3, std::make_pair (0,4) \},\par
00049             \{ SDL_SCANCODE_F5, std::make_pair (0,4) \},\par
00050             \{ SDL_SCANCODE_F7, std::make_pair (0,4) \},\par
00051             {\cf20 /* keymap: other */}\par
00052             \{ SDL_SCANCODE_RETURN, std::make_pair (0,1) \},\par
00053             \{ SDL_SCANCODE_SPACE, std::make_pair (7,4) \},\par
00054             \{ SDL_SCANCODE_LSHIFT, std::make_pair (1,7) \},\par
00055             \{ SDL_SCANCODE_RSHIFT, std::make_pair (6,4) \},\par
00056             \{ SDL_SCANCODE_COMMA, std::make_pair (5,7) \},\par
00057             \{ SDL_SCANCODE_PERIOD, std::make_pair (5,4) \},\par
00058             \{ SDL_SCANCODE_SLASH, std::make_pair (6,7) \},\par
00059             \{ SDL_SCANCODE_SEMICOLON, std::make_pair (6,2) \},\par
00060             \{ SDL_SCANCODE_EQUALS, std::make_pair (6,5) \},\par
00061             \{ SDL_SCANCODE_BACKSPACE, std::make_pair (0,0) \},\par
00062             \{ SDL_SCANCODE_MINUS, std::make_pair (5,3) \},\par
00063             {\cf20 /* keymap: these are mapped to other keys */}\par
00064             \{ SDL_SCANCODE_BACKSLASH, std::make_pair (5,5) \}, {\cf20 // : }\par
00065             \{ SDL_SCANCODE_LEFTBRACKET, std::make_pair (5,0) \}, {\cf20 // +}\par
00066             \{ SDL_SCANCODE_RIGHTBRACKET, std::make_pair (6,1) \}, {\cf20 // *}\par
00067             \{ SDL_SCANCODE_APOSTROPHE, std::make_pair (5,6) \}, {\cf20 // @}\par
00068             \{ SDL_SCANCODE_LGUI, std::make_pair (7,5) \} {\cf20 // commodore key}\par
00069         \}\par
00070     );\par
00071 \par
00072 {\cf20 // ---}\par
00073 {\cf18 void} C64::InputOSSystem::linkToChips ({\cf17 const} MCHEmul::Chips& c)\par
00074 \{\par
00075     {\cf19 for} ({\cf17 auto} i : c)\par
00076         {\cf19 if} ((_cia1 = {\cf17 dynamic_cast <}C64::CIA1*{\cf17 >} (i.second)) != {\cf17 nullptr})\par
00077             {\cf19 break};\par
00078 \par
00079     {\cf20 // Can't be null after this method...}\par
00080     assert (_cia1 != {\cf17 nullptr});\par
00081 \}\par
00082 \par
00083 {\cf20 // ---}\par
00084 {\cf18 void} C64::InputOSSystem::whenKeyPressed (SDL_Scancode k)\par
00085 \{\par
00086     std::map <SDL_Scancode, C64::InputOSSystem::KeyMPos>::const_iterator i = _C64KEYS.find (k);\par
00087     {\cf19 if} (i != _C64KEYS.end ())\par
00088         _cia1 -> setKeyboardStatusMatrix ((*i).second.first, (*i).second.second, {\cf17 false} );\par
00089 \}\par
00090 \par
00091 {\cf20 // ---}\par
00092 {\cf18 void} C64::InputOSSystem::whenKeyReleased (SDL_Scancode k)\par
00093 \{\par
00094     std::map <SDL_Scancode, C64::InputOSSystem::KeyMPos>::const_iterator i = _C64KEYS.find (k);\par
00095     {\cf19 if} (i != _C64KEYS.end ())\par
00096         _cia1 -> setKeyboardStatusMatrix ((*i).second.first, (*i).second.second, {\cf17 true} );\par
00097 \}\par
00098 \par
00099 {\cf20 // ---}\par
00100 {\cf18 void} C64::InputOSSystem::whenJoystickMoved ({\cf17 const} MCHEmul::InputOSSystem::SDL_JoyAxisEvents& js)\par
00101 \{\par
00102     {\cf18 unsigned} {\cf18 char} dr [2] = \{ 0, 0 \}; \par
00103     {\cf19 for} ({\cf17 auto} i : js)\par
00104     \{\par
00105         {\cf20 // Only events for two joysticks (1 & 2) are allowed...}\par
00106         {\cf19 if} (i.which != 0 && i.which != 1)\par
00107             {\cf19 break};\par
00108 \par
00109         dr [i.which] |= (i.axis == 0 ) \par
00110             ? ((i.value > 0) ? 8  : ((i.value < 0) ? 4  : 0))\par
00111             : ((i.axis == 1 ) \par
00112                 ? ((i.value > 0) ? 2  : ((i.value < 0) ? 1  : 0))\par
00113                 : 0 ); \par
00114     \}\par
00115 \par
00116     {\cf20 // The events on the joystick 1 are set on the same place than the keyboard...}\par
00117     {\cf19 for} ({\cf18 size_t} i = 0; i < 8; i++)\par
00118         _cia1 -> setKeyboardStatusMatrix (i, _cia1 -> keyboardStatusMatrix (i) | (0xff  - dr [0]));\par
00119 \par
00120     {\cf20 // The movement of the joystick 2...}\par
00121     {\cf20 // it is simplier!}\par
00122     _cia1 -> setJoystick2Status (_cia1 -> joystick2Status () | (0xff  - dr [1]));\par
00123 \}\par
00124 \par
00125 {\cf20 // ---}\par
00126 {\cf18 void} C64::InputOSSystem::whenJoystickButtonPressed (SDL_JoyButtonEvent jb)\par
00127 \{\par
00128     {\cf20 // Only two joysticks are allowed...}\par
00129     {\cf19 if} (jb.which == 0)\par
00130         {\cf20 // The events on the joystick 1 are set on the same place than the keyboard...}\par
00131         {\cf19 for} ({\cf18 size_t} i = 0; i < 8; i++)\par
00132             _cia1 -> setKeyboardStatusMatrix (i, _cia1 -> keyboardStatusMatrix (i) | \par
00133                 (0xff  - 0x10 ));\par
00134     {\cf19 else}\par
00135     {\cf19 if} (jb.which == 1)\par
00136         _cia1 -> setJoystick2Status (_cia1 -> joystick2Status () | (0xff  - 0x10 ));\par
00137 \}\par
00138 \par
00139 {\cf20 // ---}\par
00140 {\cf18 void} C64::InputOSSystem::whenJoystickButtonReleased (SDL_JoyButtonEvent jb)\par
00141 \{\par
00142     {\cf20 // Only two joysticks are allowed...}\par
00143     {\cf19 if} (jb.which == 0)\par
00144         {\cf20 // The events on the joystick 1 are set on the same place than the keyboard...}\par
00145         {\cf19 for} ({\cf18 size_t} i = 0; i < 8; i++)\par
00146             _cia1 -> setKeyboardStatusMatrix (i, _cia1 -> keyboardStatusMatrix (i) & \par
00147                 (0xff  - 0x10 ));\par
00148     {\cf19 else}\par
00149     {\cf19 if} (jb.which == 1)\par
00150         _cia1 -> setJoystick2Status (_cia1 -> joystick2Status () & (0xff  - 0x10 ));\par
00151 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/OSIO.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/OSIO.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/OSIO.cpp}
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/OSIO.hpp>}\par
{\f2 #include <SDL.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OSIO.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/OSIO.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/OSIO.cpp}
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/OSIO.hpp>}\par
00002 {\cf21 #include <SDL.h>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} MCHEmul::InputOSSystem::initialize ()\par
00006 \{ \par
00007     _quitRequested = {\cf17 false}; \par
00008     \par
00009     {\cf19 return} ({\cf17 true}); \par
00010 \}\par
00011 \par
00012 {\cf20 // ---}\par
00013 {\cf18 bool} MCHEmul::InputOSSystem::simulate ()\par
00014 \{\par
00015     {\cf19 if} (!MCHEmul::IODevice::simulate ())\par
00016         {\cf19 return} ({\cf17 false});\par
00017 \par
00018     SDL_Event event;\par
00019 \par
00020     MCHEmul::InputOSSystem::SDL_JoyAxisEvents js;\par
00021 \par
00022     {\cf19 while} (SDL_PollEvent (&event))\par
00023     \{\par
00024         {\cf19 switch} (event.type)\par
00025         \{\par
00026             {\cf19 case} SDL_KEYDOWN:\par
00027                 whenKeyPressed (event.key.keysym.scancode);\par
00028                 {\cf19 break};\par
00029 \par
00030             {\cf19 case} SDL_KEYUP:\par
00031                 whenKeyReleased (event.key.keysym.scancode);\par
00032                 {\cf19 break};\par
00033 \par
00034             {\cf19 case} SDL_JOYAXISMOTION:\par
00035                 js.push_back (event.jaxis);\par
00036                 {\cf19 break};\par
00037 \par
00038             {\cf19 case} SDL_JOYBUTTONDOWN:\par
00039                 whenJoystickButtonPressed (event.jbutton);\par
00040                 {\cf19 break};\par
00041             \par
00042             {\cf19 case} SDL_JOYBUTTONUP:\par
00043                 whenJoystickButtonReleased (event.jbutton);\par
00044                 {\cf19 break};\par
00045 \par
00046             {\cf19 case} SDL_QUIT:\par
00047                 _quitRequested = {\cf17 true};\par
00048                 {\cf19 break};\par
00049 \par
00050             {\cf19 default}:\par
00051                 {\cf19 break};\par
00052         \}\par
00053     \}\par
00054 \par
00055     {\cf19 if} (!js.empty ())\par
00056         whenJoystickMoved (js);\par
00057 \par
00058     {\cf19 return} ({\cf17 true});\par
00059 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/Screen.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/Screen.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/Screen.cpp}
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/Screen.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Screen.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/Screen.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/Screen.cpp}
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/Screen.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 C64::Screen::Screen ({\cf18 double} hz, {\cf18 int} x, {\cf18 int} y, {\cf17 const} MCHEmul::Attributes& attrs)\par
00005     : MCHEmul::Screen ({\cf22 "C64"}, _ID, x, y, 2, hz, attrs)\par
00006 \{ \par
00007     {\cf20 // Nothing else to do}\par
00008 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/Screen.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Screen.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Screen.cpp}
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Screen.hpp>}\par
{\f2 #include <CORE/GraphicalChip.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Screen.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Screen.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Screen.cpp}
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/Screen.hpp>}\par
00002 {\cf21 #include <CORE/GraphicalChip.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 MCHEmul::Screen::Screen ({\cf17 const} std::string& n, {\cf18 int} {\cf18 id}, \par
00006         {\cf18 unsigned} {\cf18 int} sc, {\cf18 unsigned} {\cf18 int} sr, {\cf18 unsigned} {\cf18 int} vF, {\cf18 double} hz,\par
00007         {\cf17 const} Attributes& attrs)\par
00008     : MCHEmul::IODevice (MCHEmul::IODevice::Type::_OUTPUT, id, attrs),\par
00009       _screenName (n), \par
00010       _screenColumns (sc), _screenRows (sr), _visibilityFactor (vF), \par
00011       _hertzs (hz),\par
00012       _window (nullptr), _renderer (nullptr), _texture (nullptr), _graphicalChip (nullptr),\par
00013       _refreshRate (0)\par
00014 \{\par
00015     assert (_hertzs > 0);\par
00016 \par
00017     _window = SDL_CreateWindow (\par
00018         _screenName.c_str (),\par
00019         SDL_WINDOWPOS_UNDEFINED,\par
00020         SDL_WINDOWPOS_UNDEFINED,\par
00021         _screenColumns * _visibilityFactor, \par
00022         {\cf20 // Maybe one point in certain condition can be represented as 2 and it would need more space...}\par
00023         _screenRows * _visibilityFactor,\par
00024         SDL_WINDOW_OPENGL\par
00025     );\par
00026 \par
00027     _renderer = SDL_CreateRenderer (_window, -1, SDL_RENDERER_ACCELERATED);\par
00028     _texture  = SDL_CreateTexture   \par
00029         (_renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, _screenColumns, _screenRows);\par
00030 \par
00031     _refreshRate = 1 / _hertzs;\par
00032 \}\par
00033 \par
00034 {\cf20 // ---}\par
00035 MCHEmul::Screen::~Screen ()\par
00036 \{\par
00037     SDL_DestroyRenderer (_renderer);\par
00038     SDL_DestroyTexture (_texture);\par
00039 \}\par
00040 \par
00041 {\cf20 // ---}\par
00042 {\cf18 void} MCHEmul::Screen::linkToChips ({\cf17 const} MCHEmul::Chips& c)\par
00043 \{\par
00044     {\cf19 for} ({\cf17 auto} i : c)\par
00045         {\cf19 if} ((_graphicalChip = {\cf17 dynamic_cast <}MCHEmul::GraphicalChip*{\cf17 >} (i.second)) != {\cf17 nullptr})\par
00046             {\cf19 break};\par
00047 \par
00048     {\cf20 // It is mandatory!...}\par
00049     assert (_graphicalChip != {\cf17 nullptr});\par
00050 \}\par
00051 \par
00052 {\cf20 // ---}\par
00053 {\cf18 bool} MCHEmul::Screen::simulate ()\par
00054 \{\par
00055     {\cf19 if} (!MCHEmul::IODevice::simulate ())\par
00056         {\cf19 return} ({\cf17 false});\par
00057 \par
00058     {\cf19 if} (_graphicalChip -> graphicsReady ())\par
00059     \{\par
00060         SDL_UpdateTexture (_texture, {\cf17 nullptr}, \par
00061             _graphicalChip -> screenMemory () -> frameData (), \par
00062             ({\cf18 int}) _graphicalChip -> screenMemory () -> columns () * {\cf17 sizeof} ({\cf18 unsigned} {\cf18 int})); {\cf20 // The link with the chip...}\par
00063         SDL_RenderClear (_renderer);\par
00064         SDL_RenderCopy (_renderer, _texture, {\cf17 nullptr}, {\cf17 nullptr});\par
00065         SDL_RenderPresent (_renderer);\par
00066 \par
00067         _graphicalChip -> setGraphicsReady ({\cf17 false});\par
00068     \}\par
00069 \par
00070     {\cf19 return} ({\cf17 true});\par
00071 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/SFChip.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/SFChip.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/SFChip.cpp}
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/SFChip.hpp>}\par
{\f2 #include <C64/Memory.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SFChip.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/SFChip.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/SFChip.cpp}
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/SFChip.hpp>}\par
00002 {\cf21 #include <C64/Memory.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} C64::SpecialFunctionsChip::initialize ()\par
00006 \{\par
00007     _BasicROM       = memoryRef () -> subset (C64::Memory::_BASICROM_SUBSET);\par
00008     _BasicRAM       = memoryRef () -> subset (C64::Memory::_BASICRAM_SUBSET);\par
00009     _KernelROM      = memoryRef () -> subset (C64::Memory::_KERNELROM_SUBSET);\par
00010     _KernelRAM      = memoryRef () -> subset (C64::Memory::_KERNELRAM_SUBSET);\par
00011     _CharROM        = memoryRef () -> subset (C64::Memory::_CHARROM_SUBSET);\par
00012     _VICIIRegisters = memoryRef () -> subset (C64::Memory::_VICREGS_SUBSET);\par
00013     _SIDRegisters   = memoryRef () -> subset (C64::Memory::_SIDREGS_SUBSET);\par
00014     _ColorRAM       = memoryRef () -> subset (C64::Memory::_COLOR_SUBSET);\par
00015     _CIA1Registers  = memoryRef () -> subset (C64::Memory::_CIA1_SUBSET);\par
00016     _CIA2registers  = memoryRef () -> subset (C64::Memory::_CIA2_SUBSET);\par
00017     _IO1Registers   = memoryRef () -> subset (C64::Memory::_IO1_SUBSET);\par
00018     _IO2registers   = memoryRef () -> subset (C64::Memory::_IO2_SUBSET);\par
00019 \par
00020     {\cf19 return} ({\cf17 true});\par
00021 \}\par
00022 \par
00023 {\cf20 // ---}\par
00024 {\cf18 bool} C64::SpecialFunctionsChip::simulate (MCHEmul::CPU* cpu)\par
00025 \{\par
00026     MCHEmul::UByte val0 = memoryRef () -> value (MCHEmul::Address (\{ 0x01, 0x00 \}, {\cf17 false}));\par
00027 \par
00028     {\cf20 // Active or desactive the BASIC ROM....}\par
00029     _BasicROM       -> setActiveForReading (val0.bit (0));\par
00030     _BasicRAM       -> setActiveForReading (!val0.bit (0));\par
00031 \par
00032     {\cf20 // Active or desactive the KENEL ROM...}\par
00033     _KernelROM      -> setActiveForReading (val0.bit (1));\par
00034     _KernelRAM      -> setActiveForReading (!val0.bit (1));\par
00035 \par
00036     {\cf20 // Usually the CHAR ROM is only seen from VIC II, }\par
00037     {\cf20 // because CPU access to the Chip Registers instead}\par
00038     {\cf20 // But it could be accessed. Take really care when doing so!}\par
00039     _CharROM        -> setActiveForReading (!val0.bit (2));\par
00040     _VICIIRegisters -> setActiveForReading (val0.bit (2));\par
00041     _SIDRegisters   -> setActiveForReading (val0.bit (2));\par
00042     _ColorRAM       -> setActiveForReading (val0.bit (2));\par
00043     _CIA1Registers  -> setActiveForReading (val0.bit (2));\par
00044     _CIA2registers  -> setActiveForReading (val0.bit (2));\par
00045     _IO1Registers   -> setActiveForReading (val0.bit (2));\par
00046     _IO2registers   -> setActiveForReading (val0.bit (2));\par
00047 \par
00048     {\cf19 return} ({\cf17 true});\par
00049 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/UserPeripherals.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/UserPeripherals.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/UserPeripherals.cpp}
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/UserPeripherals.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UserPeripherals.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/UserPeripherals.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/UserPeripherals.cpp}
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/UserPeripherals.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 {\cf18 bool} C64::UserIONoPeripheral::initialize ()\par
00005 \{ \par
00006     {\cf20 // TODO}\par
00007 \par
00008     {\cf19 return} ({\cf17 true}); \par
00009 \}\par
00010 \par
00011 {\cf20 // ---}\par
00012 {\cf18 bool} C64::UserIONoPeripheral::simulate ()\par
00013 \{ \par
00014     {\cf20 // TODO}\par
00015 \par
00016     {\cf19 return} ({\cf17 true}); \par
00017 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/UserPort.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/UserPort.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/UserPort.cpp}
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/UserPort.hpp>}\par
{\f2 #include <C64/UserPeripherals.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UserPort.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/UserPort.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/UserPort.cpp}
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/UserPort.hpp>}\par
00002 {\cf21 #include <C64/UserPeripherals.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 C64::UserIOPort::UserIOPort ()\par
00006     : MCHEmul::IODevice (MCHEmul::IODevice::Type::_INPUTOUTPUT, _ID,\par
00007         \{ \par
00008         \})\par
00009 \{ \par
00010     {\cf20 // Nothing else to do}\par
00011 \}\par
00012 \par
00013 {\cf20 // ---}\par
00014 {\cf18 void} C64::UserIOPort::addPeripheral (MCHEmul::IOPeripheral* p)\par
00015 \{\par
00016     {\cf19 if} ({\cf17 dynamic_cast <}C64::UserIOPeripheral*{\cf17 >} (p) == {\cf17 nullptr})\par
00017         {\cf19 return};\par
00018 \par
00019     MCHEmul::IODevice::addPeripheral (p);\par
00020 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/VICII.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/VICII.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/VICII.cpp}
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/VICII.hpp>}\par
{\f2 #include <C64/C64.hpp>}\par
{\f2 #include <C64/Memory.hpp>}\par
{\f2 #include <F6500/incs.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VICII.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/VICII.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/VICII.cpp}
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/VICII.hpp>}\par
00002 {\cf21 #include <C64/C64.hpp>}\par
00003 {\cf21 #include <C64/Memory.hpp>}\par
00004 {\cf21 #include <F6500/incs.hpp>}\par
00005 \par
00006 {\cf20 // ---}\par
00007 {\cf17 const} MCHEmul::Address C64::VICII::_COLORMEMORY (\{ 0x00, 0xd8 \}, {\cf17 false});\par
00008 {\cf17 const} C64::VICII::RasterData C64::VICII_NTSC::_VRASTERDATA (27, 41, 51, 250, 12, 26, 262, 4, 4);\par
00009 {\cf17 const} C64::VICII::RasterData C64::VICII_NTSC::_HRASTERDATA (412, 488, 24, 343, 388, 411, 512, 7, 9);\par
00010 {\cf17 const} C64::VICII::RasterData C64::VICII_PAL::_VRASTERDATA (0, 16, 51, 250, 299, 311, 312, 4, 4);\par
00011 {\cf17 const} C64::VICII::RasterData C64::VICII_PAL::_HRASTERDATA (404, 480, 24, 343, 380, 403, 504, 7, 9);\par
00012 \par
00013 {\cf20 // ---}\par
00014 C64::VICII::RasterData::RasterData (\par
00015     {\cf18 unsigned} {\cf18 short} fp,\par
00016     {\cf18 unsigned} {\cf18 short} fvp,\par
00017     {\cf18 unsigned} {\cf18 short} fdp,\par
00018     {\cf18 unsigned} {\cf18 short} ldp,\par
00019     {\cf18 unsigned} {\cf18 short} lvp,\par
00020     {\cf18 unsigned} {\cf18 short} lp,\par
00021     {\cf18 unsigned} {\cf18 short} mp,\par
00022     {\cf18 unsigned} {\cf18 short} pr1,\par
00023     {\cf18 unsigned} {\cf18 short} pr2\par
00024                       )\par
00025                 : _firstPosition (fp), _firstVisiblePosition (fvp), _firstDisplayPosition (fdp), \par
00026                   _lastDisplayPosition (ldp), _lastVisiblePosition (lvp), _lastPosition (lp),\par
00027                   _originalFirstDisplayPosition (fdp), _originalLastDisplayPosition (ldp),\par
00028                   _maxPositions (mp),\par
00029                   _positionsToReduce1 (pr1), _positionsToReduce2 (pr2),\par
00030                   _currentPosition (fp),\par
00031                   _displayZoneReducted (false)\par
00032 \{\par
00033     _firstPosition_0                = toBase0 (_firstPosition);\par
00034     _firstVisiblePosition_0         = toBase0 (_firstVisiblePosition);\par
00035     _firstDisplayPosition_0         = toBase0 (_firstDisplayPosition);\par
00036     _originalFirstDisplayPosition_0 = toBase0 (_firstDisplayPosition);\par
00037     _lastDisplayPosition_0          = toBase0 (_lastDisplayPosition);\par
00038     _originalLastDisplayPosition_0  = toBase0 (_lastDisplayPosition);\par
00039     _lastVisiblePosition_0          = toBase0 (_lastVisiblePosition);\par
00040     _lastPosition_0                 = toBase0 (_lastPosition);\par
00041 \par
00042     _currentPosition_0              = toBase0 (_currentPosition_0);\par
00043 \par
00044     assert (_lastPosition_0 == (_maxPositions - 1));\par
00045 \}\par
00046 \par
00047 {\cf20 // ---}\par
00048 {\cf18 void} C64::VICII::RasterData::reduceDisplayZone ({\cf18 bool} s)\par
00049 \{\par
00050     {\cf19 if} (_displayZoneReducted == s)\par
00051         {\cf19 return}; {\cf20 // If nothing changes, nothing to do...}\par
00052 \par
00053     {\cf19 if} (_displayZoneReducted = s)\par
00054     \{\par
00055         _firstDisplayPosition   += _positionsToReduce1;\par
00056         _firstDisplayPosition_0 += _positionsToReduce1;\par
00057         _lastDisplayPosition    -= _positionsToReduce2;\par
00058         _lastDisplayPosition_0  -= _positionsToReduce2;\par
00059     \}\par
00060     {\cf19 else}\par
00061     \{\par
00062         _firstDisplayPosition   -= _positionsToReduce1;\par
00063         _firstDisplayPosition_0 -= _positionsToReduce1;\par
00064         _lastDisplayPosition    += _positionsToReduce2;\par
00065         _lastDisplayPosition_0  += _positionsToReduce2;\par
00066     \}\par
00067 \}\par
00068 \par
00069 {\cf20 // ---}\par
00070 {\cf18 bool} C64::VICII::RasterData::add ({\cf18 unsigned} {\cf18 short} i)\par
00071 \{\par
00072     {\cf18 bool} result = {\cf17 false};\par
00073 \par
00074     {\cf18 int} cP = (int) _currentPosition_0;\par
00075     cP += i; {\cf20 // Can move to the next (o nexts) lines...}\par
00076     {\cf19 if} (result = (cP >= ({\cf18 int}) _maxPositions))\par
00077         {\cf19 while} (cP >= ({\cf18 int}) _maxPositions)\par
00078             cP -= ({\cf18 int}) _maxPositions;\par
00079 \par
00080     cP += (int) _firstPosition;\par
00081     {\cf19 if} (cP >= ({\cf18 int}) _maxPositions)\par
00082         cP -= ({\cf18 int}) _maxPositions;\par
00083 \par
00084     _currentPosition = ({\cf18 unsigned} short) cP;\par
00085     _currentPosition_0 = toBase0 (_currentPosition);\par
00086 \par
00087     {\cf19 return} (result);\par
00088 \}\par
00089 \par
00090 {\cf20 // ---}\par
00091 C64::VICII::VICII ({\cf17 const} C64::VICII::RasterData& vd, {\cf17 const} C64::VICII::RasterData& hd, \par
00092         {\cf17 const} MCHEmul::Attributes& attrs)\par
00093     : MCHEmul::GraphicalChip (_ID, attrs),\par
00094       _VICIIRegisters (nullptr), \par
00095       _raster (vd, hd),\par
00096       _lastCPUCycles (0),\par
00097       _format (nullptr),\par
00098       _graphicsCharCodeData (MCHEmul::UBytes::_E), \par
00099       _graphicsCharData (MCHEmul::UBytes::_E), \par
00100       _graphicsBitmapData (MCHEmul::UBytes::_E),\par
00101       _graphicsColorData (MCHEmul::UBytes::_E),\par
00102       _isNewRasterLine (false),\par
00103       _lastVBlankEntered (false)\par
00104 \{\par
00105     _format = SDL_AllocFormat (SDL_PIXELFORMAT_ARGB8888);\par
00106 \}\par
00107 \par
00108 {\cf20 // ---}\par
00109 C64::VICII::~VICII ()\par
00110 \{\par
00111     SDL_FreeFormat (_format);\par
00112 \}\par
00113 \par
00114 {\cf20 // ---}\par
00115 {\cf18 bool} C64::VICII::initialize ()\par
00116 \{\par
00117     assert (memoryRef () != {\cf17 nullptr});\par
00118 \par
00119     {\cf19 if} (!MCHEmul::GraphicalChip::initialize ())\par
00120         {\cf19 return} ({\cf17 false});\par
00121 \par
00122     {\cf20 // Gets the memory block dedicated to the VICII}\par
00123     {\cf19 if} (!(_VICIIRegisters = \par
00124         {\cf17 dynamic_cast <}C64::VICIIRegisters*{\cf17 >} (memoryRef () -> subset (C64::Memory::_VICREGS_SUBSET))))\par
00125     \{\par
00126         _lastError = MCHEmul::_INIT_ERROR;\par
00127 \par
00128         {\cf19 return} ({\cf17 false});\par
00129     \}\par
00130 \par
00131     _raster.initialize ();\par
00132 \par
00133     _lastCPUCycles = 0;\par
00134 \par
00135     _graphicsCharCodeData = MCHEmul::UBytes::_E; \par
00136     _graphicsCharData = MCHEmul::UBytes::_E;\par
00137     _graphicsBitmapData = MCHEmul::UBytes::_E;\par
00138     _graphicsColorData = MCHEmul::UBytes::_E;\par
00139 \par
00140     _isNewRasterLine = {\cf17 true}; {\cf20 // The first...}\par
00141 \par
00142     _lastVBlankEntered = {\cf17 false};\par
00143 \par
00144     {\cf19 return} ({\cf17 true});\par
00145 \}\par
00146 \par
00147 {\cf20 // ---}\par
00148 {\cf18 bool} C64::VICII::simulate (MCHEmul::CPU* cpu)\par
00149 \{\par
00150     {\cf20 // Notice that the bad line detection routine takes into account }\par
00151     {\cf20 // the value of the YSCROLL register as the graphics information to be shown }\par
00152     {\cf20 // is loaded at the beginning of every bad line...}\par
00153     {\cf17 auto} isBadRasterLine = [=]() -> {\cf18 bool}\par
00154         \{ {\cf19 return} (!_VICIIRegisters -> videoResetActive () && _raster.isInPotentialBadLine () && \par
00155             ((_raster.currentLine () - 0x03) & 0x07 ) == _VICIIRegisters -> verticalScrollPosition ()); \};\par
00156 \par
00157     {\cf19 if} (_VICIIRegisters -> vicIItoGenerateIRQ ())\par
00158         cpu -> interrupt (F6500::IRQInterrupt::_ID) -> setActive ({\cf17 true});\par
00159 \par
00160     {\cf20 // Rduce the visible zone if any... The info is passed to the raster!}\par
00161     _raster.reduceDisplayZone\par
00162         (!_VICIIRegisters -> textDisplay25RowsActive (), !_VICIIRegisters -> textDisplay40ColumnsActive ());\par
00163 \par
00164     {\cf19 for} ({\cf18 size_t} i = (cpu -> clockCycles  () - _lastCPUCycles); i > 0 ; i--)\par
00165     \{\par
00166         {\cf19 if} (_isNewRasterLine)\par
00167         \{\par
00168             {\cf19 if} (isBadRasterLine () )\par
00169             \{\par
00170                 {\cf20 // This is not exactly what VICII does, but it could be a good aproximation...}\par
00171                 {\cf20 // Not all graphic info is read actually at th beginning of a bad line, only video and color matrix...}\par
00172                 {\cf20 // The rest of the info is read in further cycles depending on the type of graphic mode}\par
00173                 readGraphicsInfo ();\par
00174 \par
00175                 cpu -> addClockCycles (_CPUCYCLESWHENREADGRAPHS); {\cf20 // The cost of reading in terms of cycles...}\par
00176                                                                   {\cf20 // This will slow down for a while later the cpu, }\par
00177                                                                   {\cf20 // that is what actually should happen!}\par
00178             \}\par
00179 \par
00180             {\cf19 if} (_VICIIRegisters -> rasterIRQActive () && \par
00181                 _raster.currentLine () == _VICIIRegisters -> IRQRasterLineAt ())\par
00182             \{\par
00183                 _VICIIRegisters -> setRasterAtLine ({\cf17 true});\par
00184 \par
00185                 cpu -> interrupt (F6500::IRQInterrupt::_ID) -> setActive ({\cf17 true});\par
00186             \}\par
00187 \par
00188             _isNewRasterLine = {\cf17 false};\par
00189         \}\par
00190 \par
00191         {\cf19 if} (_raster.isInVisibleZone ())\par
00192         \{\par
00193             {\cf20 // READ: Important variables}\par
00194             {\cf20 // Where is the raster in the visible part of the screen? (starting from 0)}\par
00195             {\cf18 unsigned} {\cf18 short} rv, cv; _raster.currentVisiblePosition (cv, rv);\par
00196             {\cf20 // Which is the horizontal closest block of 8 pixels (from left to the right)?}\par
00197             {\cf20 // Take into account that the step - size of the raster is always 8 pixels per cycle..}\par
00198             {\cf20 // It always starts at 0...}\par
00199             {\cf18 unsigned} {\cf18 short} cav = (cv >> 3) << 3;\par
00200 \par
00201             {\cf20 // Draws the border...}\par
00202             screenMemory () -> setHorizontalLine (({\cf18 size_t}) cav, ({\cf18 size_t}) rv,\par
00203                 (cav + 8) > _raster.visibleColumns () ? (_raster.visibleColumns () - cav) : 8, _VICIIRegisters -> borderColor ());\par
00204 \par
00205             {\cf19 if} (_raster.isInDisplayZone () && {\cf20 // In the display...}\par
00206                 rv >= _raster.vData ().firstScreenPosition () && {\cf20 // It has to be within the visible lines...}\par
00207                 rv <= _raster.vData ().lastScreenPosition ( ) &&\par
00208                 !_VICIIRegisters -> videoResetActive ()) {\cf20 // ...and obviously with the video not reset!}\par
00209             \{\par
00210                 {\cf20 // Draws the back ground, taken ito account }\par
00211                 {\cf20 // The additional border that could exist...}\par
00212                 {\cf18 unsigned} {\cf18 short} fpxl = 0; {\cf20 // First pixels from the cav to be drawn...}\par
00213                 {\cf18 unsigned} {\cf18 short} lbk = 8;  {\cf20 // Number of pixels to be drawn...}\par
00214                 {\cf20 // With the screen? }\par
00215                 {\cf19 if} (cav <= _raster.hData ().lastScreenPosition ())\par
00216                 \{\par
00217                     {\cf19 if} (_raster.hData ().firstScreenPosition () > cav)\par
00218                         \{ fpxl += (_raster.hData ().firstScreenPosition () - cav); lbk = 8 - fpxl; \}\par
00219                     {\cf19 if} ((cav + 8) > _raster.hData ().lastScreenPosition ())\par
00220                         \{ lbk = _raster.hData ().lastScreenPosition () - cav + 1; \}\par
00221                     screenMemory () -> setHorizontalLine (({\cf18 size_t}) (cav + fpxl), ({\cf18 size_t}) rv, lbk, _VICIIRegisters -> backgroundColor ());\par
00222                 \}\par
00223 \par
00224                 {\cf20 // Draw the graphics, and the sprites...}\par
00225                 C64::VICII::DrawContext dC\par
00226                     = \{ \par
00227                         _raster.hData ().firstScreenPosition ({\cf17 true}),        {\cf20 // The original...}\par
00228                         _raster.hData ().firstScreenPosition (),            {\cf20 // And the real one}\par
00229                         _raster.hData ().lastScreenPosition ({\cf17 true}),         {\cf20 // The original...}\par
00230                         _raster.hData ().lastScreenPosition (),             {\cf20 // And the real one}\par
00231                         _VICIIRegisters -> horizontalScrollPosition (),     {\cf20 // From 0 - 7 }\par
00232                         cv, cav,                                            {\cf20 // Where the horizontal raster is (also adjusted)}\par
00233                         _raster.vData ().firstScreenPosition ({\cf17 true}),        {\cf20 // The original...}\par
00234                         _raster.vData ().firstScreenPosition (),            {\cf20 // And the real one}\par
00235                         _raster.vData ().lastScreenPosition ({\cf17 true}),         {\cf20 // The original...}\par
00236                         _raster.vData ().lastScreenPosition (),             {\cf20 // And the real one}\par
00237                         _VICIIRegisters -> verticalScrollPosition (),       {\cf20 // From 0 - 7 (taken into account in bad lines)}\par
00238                         rv                                                  {\cf20 // Where the vertical raster is...}\par
00239                       \};\par
00240 \par
00241                 drawGraphics (dC);\par
00242                 drawSprites (dC);\par
00243             \}\par
00244         \}\par
00245 \par
00246         {\cf20 // 1 cycle = 8 horizontal columns = 8 pixels...}\par
00247         _isNewRasterLine = _raster.moveCycles (1); \par
00248 \par
00249         {\cf19 if} (_raster.isInLastVBlank ())\par
00250         \{\par
00251             {\cf19 if} (!_lastVBlankEntered)\par
00252                 setGraphicsReady (_lastVBlankEntered = {\cf17 true}); {\cf20 // The limit of the visible screen has been reached!}\par
00253                                                               {\cf20 // so it is time to actualize the graphics...}\par
00254         \}\par
00255         {\cf19 else}\par
00256             _lastVBlankEntered = {\cf17 false};\par
00257     \}\par
00258 \par
00259     {\cf20 // It might have been incremented after reading graphics...}\par
00260     _lastCPUCycles = cpu -> clockCycles (); \par
00261 \par
00262     {\cf20 // To store back the info in the VIC Registers...}\par
00263     _VICIIRegisters -> setCurrentRasterLine (_raster.currentLine ()); \par
00264 \par
00265     {\cf18 unsigned} {\cf18 short} x1, y1, x2, y2;\par
00266     _raster.screenPositions (x1, y1, x2, y2);\par
00267     screenMemory () -> setHorizontalLine (x1 - 1, y1 - 1, x2 - x1 + 3, 1);\par
00268     screenMemory () -> setHorizontalLine (x1 - 1, y2 + 1, x2 - x1 + 3, 1);\par
00269     screenMemory () -> setVerticalLine (x1 - 1, y1 - 1, y2 - y1 + 3, 1);\par
00270     screenMemory () -> setVerticalLine (x2 + 1, y1 - 1, y2 - y1 + 3, 1);\par
00271 \par
00272     {\cf19 return} ({\cf17 true});\par
00273 \}\par
00274 \par
00275 {\cf20 // ---}\par
00276 {\cf18 void} C64::VICII::readGraphicsInfo ()\par
00277 \{\par
00278     {\cf18 unsigned} {\cf18 short} graphLine = _raster.currentLine () - _raster._FIRSTBADLINE;\par
00279     {\cf18 unsigned} {\cf18 short} chrLine = graphLine >> 3;\par
00280 \par
00281     {\cf17 dynamic_cast <}C64::Memory*{\cf17 >} (memoryRef ()) -> setVICIIView ();\par
00282 \par
00283     _graphicsCharCodeData   = readCharCodeDataAt (chrLine);\par
00284     _graphicsCharData       = readCharDataFor (_graphicsCharCodeData);\par
00285     _graphicsBitmapData     = readBitmapDataAt (graphLine);\par
00286     _graphicsColorData      = readColorDataAt (chrLine);\par
00287 \par
00288     {\cf17 dynamic_cast <}C64::Memory*{\cf17 >} (memoryRef ()) -> setCPUView ();\par
00289 \}\par
00290 \par
00291 {\cf20 // ---}\par
00292 {\cf18 void} C64::VICII::drawGraphics ({\cf17 const} C64::VICII::DrawContext& dC)\par
00293 \{\par
00294     {\cf20 // If no graphic has been loaded, it is not needed to continue...}\par
00295     {\cf19 if} (_graphicsColorData.size () == 0)\par
00296         {\cf19 return}; {\cf20 // It could happen at the first lines of the screen when the vertical SCROLL is active...}\par
00297 \par
00298     {\cf20 // The graphical column being involved...}\par
00299     {\cf20 // The SCROLLX has been applied to the calculus, so it can be negative!}\par
00300     {\cf20 // -7 - _GRAPHMAXBITMAPCOLUMNS}\par
00301     {\cf18 int} cb = (dC._RCA - dC._ICD) - dC._SC; \par
00302 \par
00303     {\cf20 // The graphical line being involved...}\par
00304     {\cf20 // The SCROLLY is included in the calculus!}\par
00305     {\cf20 // The graphical data is loaded only in a bad line but "aligned" with the value of the SCROLLY}\par
00306     {\cf20 // So, at this point, the line being rastered could still have graphical data from the previous block of 8 rastered lines...}\par
00307     {\cf20 // 0 - _GRAPHMAXBITMAPROWS}\par
00308     {\cf18 size_t} r = ((dC._RR - dC._IRS) % 8); \par
00309     r = (r >= dC._SR) ? (r - dC._SR) : (8 + r - dC._SR);\par
00310 \par
00311     {\cf19 switch} (_VICIIRegisters -> graphicModeActive ())\par
00312     \{\par
00313         {\cf19 case} C64::VICIIRegisters::GraphicMode::_CHARMODE:\par
00314             drawMonoColorBytes (cb, r, _graphicsCharData , _graphicsColorData, dC);\par
00315             {\cf19 break};\par
00316 \par
00317         {\cf19 case} C64::VICIIRegisters::GraphicMode::_MULTICOLORCHARMODE:\par
00318             drawMonoColorBytes (cb, r, _graphicsCharData, _graphicsColorData, dC);\par
00319             {\cf19 break};\par
00320     \par
00321         {\cf19 case} C64::VICIIRegisters::GraphicMode::_BITMAPMODE:\par
00322             drawMonoColorBytes (cb, r, _graphicsBitmapData , _graphicsColorData, dC);\par
00323 \par
00324         {\cf19 case} C64::VICIIRegisters::GraphicMode::_MULTICOLORBITMAPMODE:\par
00325             drawMonoColorBytes (cb, r, _graphicsBitmapData, _graphicsColorData, dC);\par
00326             {\cf19 break};\par
00327 \par
00328         {\cf19 default}:\par
00329             {\cf20 // Not graphic mode supported, yet...}\par
00330             {\cf19 break};\par
00331     \}\par
00332 \}\par
00333 \par
00334 {\cf20 // ---}\par
00335 {\cf18 void} C64::VICII::drawSprites ({\cf17 const} C64::VICII::DrawContext& dC)\par
00336 \{\par
00337     {\cf20 // TODO}\par
00338 \}\par
00339 \par
00340 {\cf20 // ---}\par
00341 MCHEmul::ScreenMemory* C64::VICII::createScreenMemory ()\par
00342 \{\par
00343     {\cf18 unsigned} {\cf18 int}* cP = {\cf17 new} {\cf18 unsigned} {\cf18 int} [16];\par
00344     cP [0]  = SDL_MapRGB (_format, 0x00, 0x00, 0x00);\par
00345     cP [1]  = SDL_MapRGB (_format, 0xff, 0xff, 0xff);\par
00346     cP [2]  = SDL_MapRGB (_format, 0xab, 0x31, 0x26);\par
00347     cP [3]  = SDL_MapRGB (_format, 0x66, 0xda, 0xff);\par
00348     cP [4]  = SDL_MapRGB (_format, 0xbb, 0x3f, 0xb8);\par
00349     cP [5]  = SDL_MapRGB (_format, 0x55, 0xce, 0x58);\par
00350     cP [6]  = SDL_MapRGB (_format, 0x1d, 0x0e, 0x97);\par
00351     cP [7]  = SDL_MapRGB (_format, 0xea, 0xf5, 0x7c);\par
00352     cP [8]  = SDL_MapRGB (_format, 0xb9, 0x74, 0x18);\par
00353     cP [9]  = SDL_MapRGB (_format, 0x78, 0x53, 0x00);\par
00354     cP [10] = SDL_MapRGB (_format, 0xdd, 0x93, 0x87);\par
00355     cP [11] = SDL_MapRGB (_format, 0x5b, 0x5b, 0x5b);\par
00356     cP [12] = SDL_MapRGB (_format, 0x8b, 0x8b, 0x8b);\par
00357     cP [13] = SDL_MapRGB (_format, 0xb0, 0xf4, 0xac);\par
00358     cP [14] = SDL_MapRGB (_format, 0xaa, 0x9d, 0xef);\par
00359     cP [15] = SDL_MapRGB (_format, 0xb8, 0xb8, 0xb8);\par
00360 \par
00361     {\cf19 return} ({\cf17 new} MCHEmul::ScreenMemory (_raster.visibleColumns (), _raster.visibleLines (), cP));\par
00362 \}\par
00363 \par
00364 {\cf20 // ---}\par
00365 MCHEmul::UBytes C64::VICII::readCharDataFor ({\cf17 const} MCHEmul::UBytes& chrs){\cf17  const}\par
00366 {\cf17 }\{\par
00367     std::vector <MCHEmul::UByte> dt;\par
00368 \par
00369     {\cf19 for} ({\cf17 auto} i : chrs.bytes ())\par
00370     \{\par
00371         std::vector <MCHEmul::UByte> chrDt = memoryRef () -> bytes \par
00372             (_VICIIRegisters -> charDataMemory ()  + ({\cf18 size_t}) (i.value () << 3), 8);\par
00373         dt.insert (dt.end (), chrDt.begin (), chrDt.end ());\par
00374     \}\par
00375 \par
00376     {\cf19 return} (MCHEmul::UBytes (dt));\par
00377 \}\par
00378 \par
00379 {\cf20 // ---}\par
00380 MCHEmul::UBytes C64::VICII::readBitmapDataAt ({\cf18 unsigned} {\cf18 short} l){\cf17  const}\par
00381 {\cf17 }\{\par
00382     std::vector <MCHEmul::UByte> dt;\par
00383 \par
00384     {\cf18 unsigned} {\cf18 short} cL = l * _GRAPHMAXCHARCOLUMNS;\par
00385     {\cf19 for} ({\cf18 unsigned} {\cf18 short} i = 0; i < _GRAPHMAXCHARCOLUMNS; i++)\par
00386     \{\par
00387         std::vector <MCHEmul::UByte> btDt = \par
00388             memoryRef () -> bytes (_VICIIRegisters -> bitmapMemory () + ({\cf18 size_t}) (cL + (i << 3)), 8);\par
00389         dt.insert (dt.end (), btDt.begin (), btDt.end ());\par
00390     \}\par
00391 \par
00392     {\cf19 return} (MCHEmul::UBytes (dt));\par
00393 \}\par
00394 \par
00395 {\cf20 // ---}\par
00396 MCHEmul::UBytes C64::VICII::readSpriteDataAt ({\cf18 unsigned} {\cf18 short} l){\cf17  const}\par
00397 {\cf17 }\{\par
00398     {\cf20 // TODO}\par
00399 \par
00400     {\cf19 return} (MCHEmul::UBytes::_E);\par
00401 \}\par
00402 \par
00403 {\cf20 // ---}\par
00404 {\cf18 void} C64::VICII::drawMonoColorBytes ({\cf18 int} cb, {\cf18 size_t} r, \par
00405     {\cf17 const} MCHEmul::UBytes& bt, {\cf17 const} MCHEmul::UBytes& clr, {\cf17 const} C64::VICII::DrawContext& dC)\par
00406 \{\par
00407     {\cf19 for} ({\cf18 int} i = 0; i < 8 ; i++)\par
00408     \{\par
00409         {\cf19 if} ((cb + i) < 0)\par
00410             {\cf19 continue};\par
00411 \par
00412         {\cf18 size_t} iBy = (size_t) ((cb + i) >> 3 );\par
00413         {\cf18 size_t} iBt = 7 - (size_t) ((cb + i) % 8); \par
00414         {\cf18 unsigned} {\cf18 short} pos = dC._RCA + i;\par
00415         {\cf19 if} (pos <= dC._LCS && bt [(iBy << 3) + r].bit (iBt))\par
00416             screenMemory () -> setPixel (({\cf18 size_t}) pos, ({\cf18 size_t}) dC._RR, \par
00417                 ({\cf18 unsigned} {\cf18 int}) (clr [iBy].value () & 0x0f ));\par
00418     \}\par
00419 \}\par
00420 \par
00421 {\cf20 // ---}\par
00422 {\cf18 void} C64::VICII::drawMultiColorBytes ({\cf18 int} cb, {\cf18 size_t} r, \par
00423     {\cf17 const} MCHEmul::UBytes& bt, {\cf17 const} MCHEmul::UBytes& clr, {\cf17 const} C64::VICII::DrawContext& dC)\par
00424 \{\par
00425     {\cf19 for} ({\cf18 unsigned} {\cf18 short} i = 0 ; i < 8; i += 2)\par
00426     \{\par
00427         {\cf19 if} ((cb + i) < 0)\par
00428             {\cf19 continue};\par
00429 \par
00430         {\cf18 size_t} iBy = (size_t) ((cb + i) >> 3); \par
00431         {\cf18 size_t} iBt = 7 - (size_t) ((cb + i) % 8);\par
00432         {\cf18 unsigned} {\cf18 char} cs = (bt [(iBy << 3) + r].value () >> i) & 0x03; {\cf20 // 0, 1, 2 or 3...}\par
00433         {\cf18 unsigned} {\cf18 int} fc = ({\cf18 unsigned} int) ((cs == 3) \par
00434             ? clr [iBy].value () : _VICIIRegisters -> backgroundColor (cs)) & 0x0f ;\par
00435         {\cf18 unsigned} {\cf18 short} pos = dC._RCA + i;\par
00436         {\cf19 if} (pos <= dC._LCS) screenMemory () -> setPixel (({\cf18 size_t}) pos, ({\cf18 size_t}) dC._RR, fc);\par
00437         {\cf19 if} ((pos + 1) <= dC._LCS) screenMemory () -> setPixel (({\cf18 size_t}) (pos + 1), ({\cf18 size_t}) dC._RR, fc);\par
00438     \}\par
00439 \}\par
00440 \par
00441 {\cf20 // ---}\par
00442 C64::VICII_NTSC::VICII_NTSC ()\par
00443     : C64::VICII (\par
00444          _VRASTERDATA, _HRASTERDATA,\par
00445          \{ \{ {\cf22 "Name"}, {\cf22 "VIC-II (NTSC) Video Chip Interface II"} \},\par
00446            \{ {\cf22 "Code"}, {\cf22 "6567/8562/8564"} \},\par
00447            \{ {\cf22 "Manufacturer"}, {\cf22 "MOS Technology INC/Commodore Semiconductor Group (CBM)"}\},\par
00448            \{ {\cf22 "Year"}, {\cf22 "1980"} \} \})\par
00449 \{\par
00450     {\cf20 // Nothing else to do...}\par
00451 \}\par
00452 \par
00453 {\cf20 // ---}\par
00454 C64::VICII_PAL::VICII_PAL ()\par
00455     : C64::VICII (\par
00456          _VRASTERDATA, _HRASTERDATA,\par
00457          \{ \{ {\cf22 "Name"}, {\cf22 "VIC-II (PAL) Video Chip Interface II"} \},\par
00458            \{ {\cf22 "Code"}, {\cf22 "6569/8565/8566"} \},\par
00459            \{ {\cf22 "Manufacturer"}, {\cf22 "MOS Technology INC/Commodore Semiconductor Group (CBM)"}\},\par
00460            \{ {\cf22 "Year"}, {\cf22 "1980"} \} \})\par
00461 \{\par
00462     {\cf20 // Nothing else to do...}\par
00463 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/C64/VICIIRegisters.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/VICIIRegisters.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/VICIIRegisters.cpp}
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <C64/VICIIRegisters.hpp>}\par
{\f2 #include <C64/C64.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VICIIRegisters.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/C64/VICIIRegisters.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/C64/VICIIRegisters.cpp}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <C64/VICIIRegisters.hpp>}\par
00002 {\cf21 #include <C64/C64.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 void} C64::VICIIRegisters::initialize ()\par
00006 \{\par
00007     MCHEmul::PhisicalStorageSubset::initialize ();\par
00008 \par
00009     initializeInternalValues ();\par
00010 \}\par
00011 \par
00012 {\cf20 // ---}\par
00013 {\cf18 void} C64::VICIIRegisters::setValue ({\cf18 size_t} p, {\cf17 const} MCHEmul::UByte& v)\par
00014 \{\par
00015     MCHEmul::PhisicalStorageSubset::setValue (p, v);\par
00016 \par
00017     {\cf18 size_t} pp = p % 0x40;\par
00018 \par
00019     {\cf19 switch} (pp)\par
00020     \{\par
00021         {\cf20 // SPnX: Sprite n Horizontal Position}\par
00022         {\cf19 case} 0x0:\par
00023         {\cf19 case} 0x2:\par
00024         {\cf19 case} 0x4:\par
00025         {\cf19 case} 0x6:\par
00026         {\cf19 case} 0x8:\par
00027         {\cf19 case} 0xa:\par
00028         {\cf19 case} 0xc:\par
00029         {\cf19 case} 0xe:\par
00030             _spriteXCoord [pp >> 1] = (({\cf18 unsigned} short) v.value ()) | (_spriteXCoord [pp >> 1] & 0x0100);\par
00031             {\cf19 break};\par
00032 \par
00033         {\cf20 // SPnY: Sprite n Vertical Position }\par
00034         {\cf19 case} 0x1:\par
00035         {\cf19 case} 0x3:\par
00036         {\cf19 case} 0x5:\par
00037         {\cf19 case} 0x7:\par
00038         {\cf19 case} 0x9:\par
00039         {\cf19 case} 0xb:\par
00040         {\cf19 case} 0xd:\par
00041         {\cf19 case} 0xf:\par
00042             _spriteYCoord [pp >> 1] = v.value ();\par
00043             {\cf19 break};\par
00044 \par
00045         {\cf20 // MSIGX: Most significant bits of sprites Horizontal Positions}\par
00046         {\cf19 case} 0x10:\par
00047             {\cf19 for} ({\cf18 size_t} i = 0; i < 8; i++)\par
00048                 _spriteXCoord [i] = (_spriteXCoord [i] & 0x00ff) | (v.bit (i) ? 0x0100 : 0x0000); \par
00049             {\cf19 break};\par
00050 \par
00051         {\cf20 // SCROLY: Vertical Fine Scrolling and Control Register}\par
00052         {\cf19 case} 0x11:\par
00053             _verticalScrollPosition = v.value () & 0x07; {\cf20 // 3 LSBits}\par
00054             _textDisplay25RowsActive = v.bit (3);\par
00055             _screenSameColorBorderActive = v.bit (4);\par
00056             _graphicBitModeActive = v.bit (5);\par
00057             _graphicExtendedColorTextModeActive = v.bit (6);\par
00058             _IRQRasterLineAt = (_IRQRasterLineAt & 0x00ff) | (v.bit (7) ? 0x0100 : 0x0000); {\cf20 // The MSB of the raster position}\par
00059             setGraphicModeActive ();\par
00060             {\cf19 break};\par
00061 \par
00062         {\cf20 // RASTER: Write to compare with raster IRQ}\par
00063         {\cf19 case} 0x12:\par
00064             _IRQRasterLineAt = ({\cf18 unsigned} short) v.value () | (_IRQRasterLineAt & 0x0100);\par
00065             {\cf19 break};\par
00066 \par
00067         {\cf20 // LPENX/LPENY: Light Pen Horizontal/Vertical Positions (it must be multiplied by 2 after read)}\par
00068         {\cf19 case} 0x13:\par
00069         {\cf19 case} 0x14:\par
00071             {\cf19 break};\par
00072 \par
00073         {\cf20 // SPENA: Sprite enable register}\par
00074         {\cf19 case} 0x15:\par
00075             {\cf19 for} ({\cf18 size_t} i = 0; i < 7; i++)\par
00076                 _spriteEnabled [i] = v.bit (i);\par
00077             {\cf19 break};\par
00078         \par
00079         {\cf20 // SCROLX: Horizontal Fine Scrolling and Control Register}\par
00080         {\cf19 case} 0x16:\par
00081             _horizontalScrollPosition = v.value () & 0x07; {\cf20 // 3 LSBits}\par
00082             _textDisplay40ColumnsActive = v.bit (3);\par
00083             _graphicMulticolorTextModeActive = v.bit (4);\par
00084             _videoResetActive = v.bit (5);\par
00086             setGraphicModeActive ();\par
00087             {\cf19 break};\par
00088 \par
00089         {\cf20 // YXPAND Sprite Vertical Expansion Register}\par
00090         {\cf19 case} 0x17:\par
00091             {\cf19 for} ({\cf18 size_t} i = 0; i < 7; i++)\par
00092                 _spriteDoubleHeight [i] = v.bit (i);\par
00093             {\cf19 break};\par
00094     \par
00095         {\cf20 // VMCSB: VICII Chip Memory Control Register}\par
00096         {\cf19 case} 0x18:\par
00097             {\cf20 /* bits ----xxx- */}\par
00098             _charDataMemory = MCHEmul::Address (MCHEmul::UInt::fromUnsignedInt \par
00099                 ((({\cf18 unsigned} {\cf18 int}) (v.value () & 0x0e)) << 10 ));\par
00100             {\cf20 /* bits xxxx---- */}\par
00101             _screenMemory = MCHEmul::Address (MCHEmul::UInt::fromUnsignedInt \par
00102                 ((({\cf18 unsigned} {\cf18 int}) (v.value () & 0xf0)) << 6 ));\par
00103             {\cf20 /* bit ----x--- (also used above) */}\par
00104             _bitmapMemory = MCHEmul::Address (MCHEmul::UInt::fromUnsignedInt \par
00105                 ((({\cf18 unsigned} {\cf18 int}) (v.value () & 0x08)) << 10 ));\par
00107             {\cf19 break};\par
00108 \par
00109         {\cf20 // VICIRQ: VIC Interrrupt Flag Register}\par
00110         {\cf19 case} 0x19:\par
00112             {\cf19 break};\par
00113     \par
00114         {\cf20 // IRQMSK: IRQ Mask Register}\par
00115         {\cf19 case} 0x1a:\par
00116             _rasterIRQActive = v.bit (0);\par
00117             _spriteCollisionWithDataIRQActive = v.bit (1);\par
00118             _spriteCollisionsIRQActive = v.bit (2);\par
00119             _lightPenIRQActive = v.bit (3);\par
00121             {\cf19 break};\par
00122     \par
00123         {\cf20 // SPBGPR: Sprite to Foreground Display Priority Register}\par
00124         {\cf19 case} 0x1b:\par
00125             {\cf19 for} ({\cf18 size_t} i = 0; i < 8; i++)\par
00126                 _spriteToForegroundPriority [i] = v.bit (i);\par
00127             {\cf19 break};\par
00128 \par
00129         {\cf20 // SPMC: Sprite Multicolor Registers}\par
00130         {\cf19 case} 0x1c:\par
00131             {\cf19 for} ({\cf18 size_t} i = 0; i < 8; i++)\par
00132                 _spriteMulticolor [i] = v.bit (i);\par
00133             {\cf19 break};\par
00134     \par
00135         {\cf20 // XXPAND: Sprite Horizontal Expansion Register}\par
00136         {\cf19 case} 0x1d:\par
00137             {\cf19 for} ({\cf18 size_t} i = 0; i < 8; i++)\par
00138                 _spriteDoubleWidth [i] = v.bit (i);\par
00139             {\cf19 break};\par
00140     \par
00141         {\cf20 // SPSPCL: Sprite to Sprite Collision Register}\par
00142         {\cf19 case} 0x1e:\par
00143             {\cf20 /* Only makes sense when reading. */}\par
00144             {\cf19 break};\par
00145         \par
00146         {\cf20 // EXTCOLOR: Border Color Register}\par
00147         {\cf19 case} 0x20:\par
00148             _borderColor = v.value ();\par
00149             {\cf19 break};\par
00150     \par
00151         {\cf20 // BGCOL0, BGCOL1, BGCOL2, BGCOL3 : Background Color Registers}\par
00152         {\cf19 case} 0x21:\par
00153         {\cf19 case} 0x22:\par
00154         {\cf19 case} 0x23:\par
00155         {\cf19 case} 0x24:\par
00156             _backgroundColor [pp - 0x21] = v.value ();\par
00157             {\cf19 break};\par
00158 \par
00159         {\cf20 // SPMCOL0, SPMCOL1: Sprite Multicolor Registers}\par
00160         {\cf19 case} 0x25:\par
00161         {\cf19 case} 0x26:\par
00162             _spriteSharedColor [pp - 0x25] = v.value ();\par
00163             {\cf19 break};\par
00164 \par
00165         {\cf20 // SPnCOL: Sprite Color Registers}\par
00166         {\cf19 case} 0x27:\par
00167         {\cf19 case} 0x28:\par
00168         {\cf19 case} 0x29:\par
00169         {\cf19 case} 0x2a:\par
00170         {\cf19 case} 0x2b:\par
00171         {\cf19 case} 0x2c:\par
00172         {\cf19 case} 0x2d:\par
00173         {\cf19 case} 0x2e:\par
00174             _spriteColor [pp - 0x27] = v.value ();\par
00175             {\cf19 break};\par
00176     \par
00177         {\cf20 // Not connected}\par
00178         {\cf20 // Ignored when writing...}\par
00179         {\cf19 case} 0x2f:\par
00180         {\cf19 case} 0x30:\par
00181         {\cf19 case} 0x31:\par
00182         {\cf19 case} 0x32:\par
00183         {\cf19 case} 0x33:\par
00184         {\cf19 case} 0x34:\par
00185         {\cf19 case} 0x35:\par
00186         {\cf19 case} 0x36:\par
00187         {\cf19 case} 0x37:\par
00188         {\cf19 case} 0x38:\par
00189         {\cf19 case} 0x39:\par
00190         {\cf19 case} 0x3a:\par
00191         {\cf19 case} 0x3b:\par
00192         {\cf19 case} 0x3c:\par
00193         {\cf19 case} 0x3d:\par
00194         {\cf19 case} 0x3e:\par
00195         {\cf19 case} 0x3f:\par
00196         {\cf19 default}:\par
00197             {\cf19 break};\par
00198     \}\par
00199 \}       \par
00200 \par
00201 {\cf20 // ---}\par
00202 {\cf17 const} MCHEmul::UByte& C64::VICIIRegisters::readValue ({\cf18 size_t} p){\cf17  const}\par
00203 {\cf17 }\{\par
00204     MCHEmul::UByte result = MCHEmul::PhisicalStorage::_DEFAULTVALUE;\par
00205 \par
00206     {\cf18 size_t} pp = p % 0x40;\par
00207 \par
00208     {\cf19 switch} (pp)\par
00209     \{\par
00210         {\cf20 // The value is read as it is...}\par
00211         {\cf19 case} 0x0:\par
00212         {\cf19 case} 0x1:\par
00213         {\cf19 case} 0x2:\par
00214         {\cf19 case} 0x3:\par
00215         {\cf19 case} 0x4:\par
00216         {\cf19 case} 0x5:\par
00217         {\cf19 case} 0x6:\par
00218         {\cf19 case} 0x7:\par
00219         {\cf19 case} 0x8:\par
00220         {\cf19 case} 0x9:\par
00221         {\cf19 case} 0xa:\par
00222         {\cf19 case} 0xb:\par
00223         {\cf19 case} 0xc:\par
00224         {\cf19 case} 0xd:\par
00225         {\cf19 case} 0xe:\par
00226         {\cf19 case} 0xf:\par
00227         {\cf19 case} 0x10:\par
00228         {\cf19 case} 0x15:\par
00229         {\cf19 case} 0x17:\par
00230         {\cf19 case} 0x18:\par
00231         {\cf19 case} 0x1b:\par
00232         {\cf19 case} 0x1c:\par
00233         {\cf19 case} 0x1d:\par
00234             result = MCHEmul::PhisicalStorageSubset::readValue (pp);\par
00235             {\cf19 break};\par
00236 \par
00237         {\cf20 // SCROLY: Vertical Fine Scrolling and Control Register}\par
00238         {\cf20 // Just to consider that when reading the raster MSB bit shows where the raster is now}\par
00239         {\cf19 case} 0x11:\par
00240             result = MCHEmul::UByte \par
00241                 ((MCHEmul::PhisicalStorageSubset::readValue (pp).value () & 0x7f) | \par
00242                  ((_currentRasterLine & 0xff00) != 0) ? 0x80 : 0x00);\par
00243             {\cf19 break};\par
00244 \par
00245         {\cf20 // RASTER: When reading get the current raster postion (except the MSB that is in the previous)}\par
00246         {\cf19 case} 0x12:\par
00247             result = MCHEmul::UByte (({\cf18 unsigned} {\cf18 char}) _currentRasterLine & 0x00ff);\par
00248             {\cf19 break};\par
00249 \par
00250         {\cf20 // LPENX: Light Pen Horizontal Position}\par
00251         {\cf19 case} 0x13:\par
00252             result = MCHEmul::UByte (({\cf18 unsigned} {\cf18 char}) _currentLightPenHorizontalPosition);\par
00253             {\cf19 break};\par
00254 \par
00255         {\cf20 // LPENY: Light Pen Vertical Position}\par
00256         {\cf19 case} 0x14:\par
00257             result = MCHEmul::UByte (({\cf18 unsigned} {\cf18 char}) _currentLightPenVerticalPosition);\par
00258             {\cf19 break};\par
00259         \par
00260         {\cf20 // SCROLX: Horizontal Fine Scrolling and Control Register}\par
00261         {\cf19 case} 0x16:\par
00262             result = MCHEmul::UByte (MCHEmul::PhisicalStorageSubset::readValue (pp).value () & 0x3f | 0xd0); \par
00263             {\cf19 break};\par
00264 \par
00265         {\cf20 // VICIRQ: VIC Interrrupt Flag Register}\par
00266         {\cf19 case} 0x19:\par
00267             result = MCHEmul::UByte::_1; \par
00268             result.setBit (0, _rasterAtIRQLine);\par
00269             result.setBit (1, _spritesCollisionWithDataHappened);\par
00270             result.setBit (2, _spritesCollisionHappened);\par
00271             result.setBit (3, _lightPenOnScreenHappened);\par
00273             result.setBit (7, _vicIItoGenerateIRQ);\par
00274             {\cf19 break};\par
00275     \par
00276         {\cf20 // IRQMSK: IRQ Mask Register}\par
00277         {\cf19 case} 0x1a:\par
00278             result = MCHEmul::UByte::_1; \par
00279             result.setBit (0, _rasterIRQActive);\par
00280             result.setBit (1, _spriteCollisionWithDataIRQActive);\par
00281             result.setBit (2, _spriteCollisionsIRQActive);\par
00282             result.setBit (3, _lightPenIRQActive);\par
00284             {\cf19 break};\par
00285     \par
00286         {\cf20 // SPSPCL: Sprite - Sprite Collision Register}\par
00287         {\cf19 case} 0x1e:\par
00288             result = MCHEmul::UByte::_0;\par
00289             {\cf19 for} ({\cf18 size_t} i = 0; i < 8; i++)\par
00290                 result.setBit (i, _spriteCollisionHappened [i]);\par
00291             _spriteCollisionHappened = std::vector <bool> (8, {\cf17 false}); {\cf20 // false back when reading...}\par
00292             {\cf19 break};\par
00293 \par
00294         {\cf20 // SPBGCL: Sprite - Data Collision Register}\par
00295         {\cf19 case} 0x1f:\par
00296             result = MCHEmul::UByte::_0;\par
00297             {\cf19 for} ({\cf18 size_t} i = 0; i < 8; i++)\par
00298                 result.setBit (i, _spriteCollisionWithDataHappened [i]);\par
00299             _spriteCollisionWithDataHappened = std::vector <bool> (8, {\cf17 false}); {\cf20 // false back when reading...}\par
00300             {\cf19 break};\par
00301 \par
00302         {\cf19 case} 0x20:\par
00303         {\cf19 case} 0x21:\par
00304         {\cf19 case} 0x22:\par
00305         {\cf19 case} 0x23:\par
00306         {\cf19 case} 0x24:\par
00307         {\cf19 case} 0x25:\par
00308         {\cf19 case} 0x26:\par
00309         {\cf19 case} 0x27:\par
00310         {\cf19 case} 0x28:\par
00311         {\cf19 case} 0x29:\par
00312         {\cf19 case} 0x2a:\par
00313         {\cf19 case} 0x2b:\par
00314         {\cf19 case} 0x2c:\par
00315         {\cf19 case} 0x2d:\par
00316         {\cf19 case} 0x2e:\par
00318             result = MCHEmul::UByte (MCHEmul::PhisicalStorageSubset::readValue (pp).value () & 0x0f | 0xf0);\par
00319             {\cf19 break};\par
00320     \par
00321         {\cf20 // Not connected}\par
00322         {\cf19 case} 0x2f:\par
00323         {\cf19 case} 0x30:\par
00324         {\cf19 case} 0x31:\par
00325         {\cf19 case} 0x32:\par
00326         {\cf19 case} 0x33:\par
00327         {\cf19 case} 0x34:\par
00328         {\cf19 case} 0x35:\par
00329         {\cf19 case} 0x36:\par
00330         {\cf19 case} 0x37:\par
00331         {\cf19 case} 0x38:\par
00332         {\cf19 case} 0x39:\par
00333         {\cf19 case} 0x3a:\par
00334         {\cf19 case} 0x3b:\par
00335         {\cf19 case} 0x3c:\par
00336         {\cf19 case} 0x3d:\par
00337         {\cf19 case} 0x3e:\par
00338         {\cf19 case} 0x3f:\par
00339         {\cf19 default}:\par
00340             result = MCHEmul::UByte::_FF;\par
00341             {\cf19 break};\par
00342     \}\par
00343 \par
00344     {\cf19 return} (_lastValueRead = result);\par
00345 \}\par
00346 \par
00347 {\cf20 // ---}\par
00348 {\cf18 void} C64::VICIIRegisters::initializeInternalValues ()\par
00349 \{\par
00350     {\cf20 // The internal variables are initialized direcly throught the data in the register...}\par
00351 \par
00352     {\cf20 // _spriteXCoord = std::vector <unsigned short> (8, 0x0000);}\par
00353     setValue (0x00, MCHEmul::UByte::_0);\par
00354     setValue (0x02, MCHEmul::UByte::_0);\par
00355     setValue (0x04, MCHEmul::UByte::_0);\par
00356     setValue (0x06, MCHEmul::UByte::_0);\par
00357     setValue (0x08, MCHEmul::UByte::_0);\par
00358     setValue (0x0a, MCHEmul::UByte::_0);\par
00359     setValue (0x0c, MCHEmul::UByte::_0);\par
00360     setValue (0x0e, MCHEmul::UByte::_0);\par
00361     {\cf20 // _spriteYCoord = std::vector <unsigned short> (8, 0x0000);}\par
00362     setValue (0x01, MCHEmul::UByte::_0);\par
00363     setValue (0x03, MCHEmul::UByte::_0);\par
00364     setValue (0x05, MCHEmul::UByte::_0);\par
00365     setValue (0x07, MCHEmul::UByte::_0);\par
00366     setValue (0x09, MCHEmul::UByte::_0);\par
00367     setValue (0x0b, MCHEmul::UByte::_0);\par
00368     setValue (0x0d, MCHEmul::UByte::_0);\par
00369     setValue (0x0f, MCHEmul::UByte::_0);\par
00370     \par
00371     {\cf20 // MSIGX: Most significant bits of sprites Horizontal Positions}\par
00372     setValue (0x10, MCHEmul::UByte::_0);\par
00373 \par
00374     {\cf20 // _verticalScrollPosition = 0x0000;}\par
00375     {\cf20 // _textDisplay25RowsActive = true;}\par
00376     {\cf20 // _screenSameColorBorderActive = false;}\par
00377     {\cf20 // _graphicBitModeActive = false;}\par
00378     {\cf20 // _graphicExtendedColorTextModeActive = false;}\par
00379     {\cf20 // _IRQRasterLineAt = 0x00;}\par
00380     setValue (0x11, MCHEmul::UByte (0x08));\par
00381 \par
00382     {\cf20 // _IRQRasterLineAt = 0x00;}\par
00383     setValue (0x12, MCHEmul::UByte::_0);\par
00384 \par
00385     {\cf20 // _spriteEnabled = std::vector <bool> (8, false);}\par
00386     setValue (0x15, MCHEmul::UByte::_0);\par
00387         \par
00388     {\cf20 // _horizontalScrollPosition = 0x0000;}\par
00389     {\cf20 // _textDisplay40ColumnsActive = true;}\par
00390     {\cf20 // _graphicMulticolorTextModeActive = false;}\par
00391     {\cf20 // _videoResetActive = false;}\par
00392     setValue (0x16, MCHEmul::UByte (0x08));\par
00393 \par
00394     {\cf20 // _spriteDoubleHeight = std::vector <bool> (8, false);}\par
00395     setValue (0x17, MCHEmul::UByte::_0);\par
00396     \par
00397     {\cf20 // _charDataMemory  = MCHEmul::Address (\{ 0x00, 0x10 \}, false);}\par
00398     {\cf20 // _screenMemory    = MCHEmul::Address (\{ 0x00, 0x04 \}, false); }\par
00399     {\cf20 // _bitmapMemory    = MCHEmul::Address (\{ 0x00, 0x00 \}, false);}\par
00400     setValue (0x18, MCHEmul::UByte (0x14));\par
00401 \par
00402     {\cf20 // _rasterIRQActive = false;}\par
00403     {\cf20 // _spriteCollisionWithDataIRQActive = false;}\par
00404     {\cf20 // _spriteCollisionsIRQActive = false;}\par
00405     {\cf20 // _lightPenIRQActive = false;}\par
00406     setValue (0x1a, MCHEmul::UByte::_0);\par
00407     \par
00408     {\cf20 // _spriteToForegroundPriority = std::vector <bool> (8, false);}\par
00409     setValue (0x1b, MCHEmul::UByte::_0);\par
00410 \par
00411     {\cf20 //_spriteMulticolor = std::vector <bool> (8, false);}\par
00412     setValue (0x1c, MCHEmul::UByte::_0);\par
00413     \par
00414     {\cf20 // _spriteDoubleWidth = std::vector <bool> (8, false);}\par
00415     setValue (0x1c, MCHEmul::UByte::_0);\par
00416         \par
00417     {\cf20 // _borderColor = 0x0000;}\par
00418     setValue (0x20, MCHEmul::UByte::_0);\par
00419     \par
00420     {\cf20 // _backgroundColor = std::vector <unsigned short> (4, 0x0000);}\par
00421     setValue (0x21, MCHEmul::UByte::_0);\par
00422     setValue (0x22, MCHEmul::UByte::_0);\par
00423     setValue (0x23, MCHEmul::UByte::_0);\par
00424     setValue (0x24, MCHEmul::UByte::_0);\par
00425 \par
00426     {\cf20 // _spriteSharedColor = std::vector <unsigned short> (2, 0x0000);}\par
00427     setValue (0x25, MCHEmul::UByte::_0);\par
00428     setValue (0x26, MCHEmul::UByte::_0);\par
00429 \par
00430     {\cf20 // _spriteColor = std::vector <unsigned short> (8, 0x0000);}\par
00431     setValue (0x27, MCHEmul::UByte::_0);\par
00432     setValue (0x28, MCHEmul::UByte::_0);\par
00433     setValue (0x29, MCHEmul::UByte::_0);\par
00434     setValue (0x2a, MCHEmul::UByte::_0);\par
00435     setValue (0x2b, MCHEmul::UByte::_0);\par
00436     setValue (0x2c, MCHEmul::UByte::_0);\par
00437     setValue (0x2d, MCHEmul::UByte::_0);\par
00438     setValue (0x2e, MCHEmul::UByte::_0);\par
00439 \par
00440     {\cf20 // Managed direclty by the VICII Chip...}\par
00441     _currentRasterLine = 0x0000;\par
00442     _currentLightPenHorizontalPosition = 0x0000;\par
00443     _currentLightPenVerticalPosition = 0x0000;\par
00444     _rasterAtIRQLine = {\cf17 false};\par
00445     _spritesCollisionWithDataHappened = {\cf17 false};\par
00446     _spriteCollisionWithDataHappened = std::vector <bool> (8, {\cf17 false}), \par
00447     _spritesCollisionHappened = {\cf17 false};\par
00448     _spriteCollisionHappened = std::vector <bool> (8, {\cf17 false});\par
00449     _lightPenOnScreenHappened = {\cf17 false};\par
00450     _vicIItoGenerateIRQ = {\cf17 false};\par
00451 \par
00452     {\cf20 // This variable will be set from CIAII simulation method...}\par
00453     _bank = 0;\par
00454 \}\par
00455 \par
00456 {\cf20 // ---}\par
00457 {\cf18 void} C64::VICIIRegisters::setGraphicModeActive ()\par
00458 \{\par
00459     _graphicModeActive = C64::VICIIRegisters::GraphicMode::_ILLEGALMODE;\par
00460 \par
00461     {\cf19 if} (!graphicExtendedColorTextModeActive () && !graphicBitModeActive () && !graphicMulticolorTextModeActive ())\par
00462         _graphicModeActive = C64::VICIIRegisters::GraphicMode::_CHARMODE;\par
00463     {\cf19 else} {\cf19 if} (!graphicExtendedColorTextModeActive () && !graphicBitModeActive () && graphicMulticolorTextModeActive ())\par
00464         _graphicModeActive = C64::VICIIRegisters::GraphicMode::_MULTICOLORCHARMODE;\par
00465     {\cf19 else} {\cf19 if} (!graphicExtendedColorTextModeActive () && graphicBitModeActive () && !graphicMulticolorTextModeActive ())\par
00466         _graphicModeActive = C64::VICIIRegisters::GraphicMode::_BITMAPMODE;\par
00467     {\cf19 else} {\cf19 if} (!graphicExtendedColorTextModeActive () && graphicBitModeActive () && graphicMulticolorTextModeActive ())\par
00468         _graphicModeActive = C64::VICIIRegisters::GraphicMode::_MULTICOLORBITMAPMODE;\par
00469     {\cf19 else} {\cf19 if} (graphicExtendedColorTextModeActive () && !graphicBitModeActive () && !graphicMulticolorTextModeActive ())\par
00470         _graphicModeActive = C64::VICIIRegisters::GraphicMode::_EXTENDEDBACKGROUNDMODE;\par
00471 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/COMMS/Channel.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/COMMS/Channel.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/COMMS/Channel.cpp}
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <COMMS/Channel.hpp>}\par
{\f2 #include <MessageIdentifiers.h>}\par
{\f2 #include <BitStream.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Channel.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/COMMS/Channel.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/COMMS/Channel.cpp}
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <COMMS/Channel.hpp>}\par
00002 {\cf21 #include <MessageIdentifiers.h>}\par
00003 {\cf21 #include <BitStream.h>}\par
00004 \par
00005 {\cf20 // ---}\par
00006 MCHEmul::PeerCommunicationChannel::PeerCommunicationChannel ({\cf18 unsigned} {\cf18 short} p, {\cf18 unsigned} {\cf18 int} nC, {\cf17 const} MCHEmul::IPAddress& to)\par
00007     : _listenAtPort (p), _simultaneousConnections (nC), _connectedTo (to),\par
00008       _peer (nullptr),\par
00009       _channelInitialized (false), _channelConnected (false),\par
00010       _lastError (MCHEmul::_NOERROR)\par
00011 \{\par
00012     {\cf19 if} ((_peer = RakNet::RakPeerInterface::GetInstance ()) == {\cf17 nullptr})\par
00013         _lastError = MCHEmul::_COMMSINTNOTCREATED_ERROR;\par
00014 \}\par
00015 \par
00016 {\cf20 // ---}\par
00017 MCHEmul::PeerCommunicationChannel::~PeerCommunicationChannel ()\par
00018 \{\par
00019     RakNet::RakPeerInterface::DestroyInstance (_peer);\par
00020 \}\par
00021     \par
00022 {\cf20 // ---}\par
00023 {\cf18 bool} MCHEmul::PeerCommunicationChannel::initialize ()\par
00024 \{\par
00025     {\cf19 if} (_lastError != MCHEmul::_NOERROR)\par
00026         {\cf19 return} ({\cf17 false});\par
00027 \par
00028     {\cf19 if} (!_channelInitialized)\par
00029     \{\par
00030         RakNet::SocketDescriptor sd (_listenAtPort, 0);\par
00031         {\cf19 if} (_peer -> Startup (_simultaneousConnections, &sd, 1) != RakNet::StartupResult::RAKNET_STARTED)\par
00032         \{\par
00033             _lastError = MCHEmul::_COMMSNOTOPENED_ERROR;\par
00034 \par
00035             {\cf19 return} ({\cf17 false});\par
00036         \}\par
00037 \par
00038         _channelInitialized = {\cf17 true};\par
00039     \}\par
00040 \par
00041     {\cf19 if} (!_channelConnected && _connectedTo != MCHEmul::IPAddress ())\par
00042     \{\par
00043         {\cf19 if} (_peer -> Connect (_connectedTo.ipAsString ().c_str (), _connectedTo.port (), {\cf17 nullptr}, 0) \par
00044                 != RakNet::ConnectionAttemptResult::CONNECTION_ATTEMPT_STARTED)\par
00045         \{\par
00046             _lastError = MCHEmul::_COMMSNOTOPENED_ERROR;\par
00047 \par
00048             {\cf19 return} ({\cf17 false});\par
00049         \}\par
00050     \}\par
00051 \par
00052     {\cf19 return} ({\cf17 true});\par
00053 \}\par
00054 \par
00055 {\cf20 // ---}\par
00056 {\cf18 bool} MCHEmul::PeerCommunicationChannel::finalize ()\par
00057 \{\par
00058     _peer -> CloseConnection (_peer -> GetMyGUID (), {\cf17 true}); {\cf20 // Informing about the disconnection...}\par
00059 \par
00060     _channelConnected = {\cf17 false};\par
00061     _channelInitialized = {\cf17 false};\par
00062 \par
00063     {\cf19 return} ({\cf17 true});\par
00064 \}\par
00065 \par
00066 {\cf20 // ---}\par
00067 {\cf18 bool} MCHEmul::PeerCommunicationChannel::receive (std::string& str, MCHEmul::IPAddress& from)\par
00068 \{\par
00069     {\cf18 bool} result = {\cf17 true}; {\cf20 // By default the result will be true...}\par
00070  \par
00071     RakNet::Packet* packet = {\cf17 nullptr};\par
00072     {\cf19 while} (packet = _peer -> Receive ())\par
00073     \{\par
00074         {\cf20 // The sender address is always kept...}\par
00075         {\cf18 char} chr [100];\par
00076         packet -> systemAddress.ToString_Old ({\cf17 true}, chr);\par
00077         from = MCHEmul::IPAddress (chr);\par
00078 \par
00079         {\cf20 // The first char has the id of the mesaage...}\par
00080         {\cf19 switch} (packet -> data [0]) \par
00081         \{\par
00082             {\cf20 // Usually client messages:}\par
00083             {\cf19 case} ID_DISCONNECTION_NOTIFICATION:                         {\cf20 // Connection lost normally.}\par
00084             {\cf19 case} ID_ALREADY_CONNECTED:                                  {\cf20 // Connection not posible because the system is already in.}\par
00085             {\cf19 case} ID_INCOMPATIBLE_PROTOCOL_VERSION:                      {\cf20 // The communication protocol is different than the one the server expects.}\par
00086             {\cf19 case} ID_REMOTE_DISCONNECTION_NOTIFICATION:                  {\cf20 // Other client has been disconnected.}\par
00087             {\cf19 case} ID_REMOTE_CONNECTION_LOST:                             {\cf20 // Clients of another client disconnecting forcefully.}\par
00088             {\cf19 case} ID_REMOTE_NEW_INCOMING_CONNECTION:                     {\cf20 // Clients of another client connecting}\par
00089             {\cf19 case} ID_CONNECTION_BANNED:                                  {\cf20 // Banned from this server}\par
00090             {\cf19 case} ID_CONNECTION_ATTEMPT_FAILED:                          {\cf20 // Not posssible to reach the server. IP is right?}\par
00091             {\cf19 case} ID_NO_FREE_INCOMING_CONNECTIONS:                       {\cf20 // Server is full. }\par
00092             {\cf19 case} ID_INVALID_PASSWORD:                               \par
00093             {\cf19 case} ID_CONNECTION_LOST:                                    {\cf20 // Couldn't deliver a reliable packet (Server was terminated)}\par
00094                 _channelConnected = {\cf17 false};\par
00095                 {\cf19 break};\par
00096 \par
00097             {\cf19 case} DefaultMessageIDTypes::ID_CONNECTION_REQUEST_ACCEPTED: {\cf20 // The server has accepted the connection}\par
00098                 _channelConnected = {\cf17 true}; {\cf20 // Noww the communication is possible...}\par
00099                 {\cf19 break};\par
00100 \par
00101             {\cf20 // Usually server messages:}\par
00102             {\cf19 case} ID_NEW_INCOMING_CONNECTION:                            {\cf20 // Client is requested connection}\par
00103             {\cf19 case} ID_CONNECTED_PING:                                     {\cf20 // A Client is trying to ping}\par
00104             {\cf19 case} ID_UNCONNECTED_PING:                                   {\cf20 // A non client is trying to ping}\par
00105                 {\cf19 break};\par
00106 \par
00107             {\cf20 // Our important message...}\par
00108             {\cf19 case} MCHEmul::CommunicationMessage::_MESSAGEID: \par
00109                 \{\par
00110                     RakNet::RakString rs;\par
00111                     RakNet::BitStream bsIn (packet -> data, packet -> length, {\cf17 false});\par
00112                     bsIn.IgnoreBytes ({\cf17 sizeof} (RakNet::MessageID));\par
00113                     {\cf19 if} (!(result = bsIn.Read (rs)))\par
00114                         _lastError = MCHEmul::_CHANNELREADERROR_ERROR;\par
00115                     {\cf19 else}\par
00116                         str += rs.C_String (); {\cf20 // The string to be returned is then set...}\par
00117                                                {\cf20 // The string can be splitted in many!}\par
00118                 \}\par
00119 \par
00120                 {\cf19 break};\par
00121     \par
00122             {\cf20 // No other messages are managed...}\par
00123             {\cf19 default}:\par
00124                 result = {\cf17 false};\par
00125         \}\par
00126     \}\par
00127 \par
00128     {\cf19 return} (result);\par
00129 \}\par
00130 \par
00131 {\cf20 // ---}\par
00132 {\cf18 bool} MCHEmul::PeerCommunicationChannel::send ({\cf17 const} std::string& str, {\cf17 const} MCHEmul::IPAddress& to)\par
00133 \{\par
00134     {\cf19 if} (!*{\cf17 this})\par
00135         {\cf19 return} ({\cf17 false});\par
00136 \par
00137     {\cf19 if} (!_channelInitialized)\par
00138     \{\par
00139         _lastError = MCHEmul::_COMMSNOTOPENED_ERROR;\par
00140 \par
00141         {\cf19 return} ({\cf17 false});\par
00142     \}\par
00143 \par
00144     RakNet::BitStream bsOut;\par
00145     bsOut.Write ((RakNet::MessageID) MCHEmul::CommunicationMessage::_MESSAGEID);\par
00146     bsOut.Write (str.c_str ());\par
00147     RakNet::SystemAddress sA (to.ipAsString ().c_str (), to.port ());\par
00148     {\cf19 if} (_peer -> Send (&bsOut, IMMEDIATE_PRIORITY, RELIABLE_ORDERED, 0, sA, {\cf17 false}) == 0)\par
00149     \{\par
00150         _lastError = MCHEmul::_CHANNELWRITEERROR_ERROR;\par
00151 \par
00152         {\cf19 return} ({\cf17 false});\par
00153     \}\par
00154 \par
00155     {\cf19 return} ({\cf17 true});\par
00156 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/COMMS/IPAddress.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/COMMS/IPAddress.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/COMMS/IPAddress.cpp}
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <COMMS/IPAddress.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IPAddress.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/COMMS/IPAddress.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/COMMS/IPAddress.cpp}
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <COMMS/IPAddress.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 MCHEmul::IPAddress::IPAddress ({\cf17 const} std::string& ip)\par
00005     : _a (0x00), _b (0x00), _c (0x00), _d (0x00), _port (0x0000), _error (false)\par
00006 \{\par
00007     std::vector <std::string> t = MCHEmul::getElementsFrom (ip, {\cf23 '.'});\par
00008     {\cf19 if} (t.size () == 4)\par
00009     \{\par
00010         _a = ({\cf18 unsigned} char) std::stoi (MCHEmul::trim (t [0]));\par
00011         _b = ({\cf18 unsigned} char) std::stoi (MCHEmul::trim (t [1]));\par
00012         _c = ({\cf18 unsigned} char) std::stoi (MCHEmul::trim (t [2]));\par
00013 \par
00014         {\cf18 size_t} pp = 0;\par
00015         {\cf19 if} ((pp = t [3].find ({\cf23 ':'})) != std::string::npos)\par
00016         \{\par
00017             _d = std::stoi (MCHEmul::trim (t [3].substr (0, pp)));\par
00018             _port = std::stoi (MCHEmul::trim (t [3].substr (pp + 1)));\par
00019         \}\par
00020         {\cf19 else}\par
00021             _d = ({\cf18 unsigned} char) std::stoi (MCHEmul::trim (t [3]));\par
00022     \}\par
00023     {\cf19 else}\par
00024         _error = {\cf17 true};\par
00025 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/COMMS/Message.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/COMMS/Message.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/COMMS/Message.cpp}
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <COMMS/Message.hpp>}\par
{\f2 #include <CORE/Computer.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Message.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/COMMS/Message.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/COMMS/Message.cpp}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <COMMS/Message.hpp>}\par
00002 {\cf21 #include <CORE/Computer.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 std::string MCHEmul::CommunicationMessage::toString (){\cf17  const}\par
00006 {\cf17 }\{\par
00007     std::string result;\par
00008 \par
00009     result += MCHEmul::CommunicationMessage::_MESSAGEID;\par
00010     result += _type;\par
00011 \par
00012     {\cf18 bool} f = {\cf17 true};\par
00013     result += _type;\par
00014     {\cf19 for} ({\cf17 auto} i : _attributes)\par
00015     \{\par
00016         result += ((f) ? {\cf22 ""} : {\cf22 ","}) + i.first + {\cf22 "="} + i.second;\par
00017 \par
00018         f = {\cf17 false};\par
00019     \}\par
00020 \par
00021     {\cf19 return} (result);\par
00022 \}\par
00023 \par
00024 {\cf20 // ---}\par
00025 MCHEmul::Attributes MCHEmul::MessageBuilder::attributesFromStr ({\cf17 const} std::string& str){\cf17  const}\par
00026 {\cf17 }\{\par
00027     MCHEmul::Attributes result;\par
00028 \par
00029     std::vector <std::string> attrs = \par
00030         MCHEmul::getElementsFrom (str.substr (1) , {\cf23 ','});\par
00031     {\cf19 for} ({\cf17 auto} i : attrs)\par
00032     \{\par
00033         std::vector <std::string> attr = MCHEmul::getElementsFrom (i, {\cf23 '='});\par
00034         std::string n, v;\par
00035         {\cf19 if} ((attr.size () == ({\cf18 size_t}) 2) && {\cf20 // Only 2 elements!}\par
00036             ((n = MCHEmul::onlyAlphanumeric (attr [0])) == attr [0]) && {\cf20 // Name & Value have to be alphanumeric...}\par
00037             ((v = MCHEmul::onlyAlphanumeric (attr [1])) == attr [1]))\par
00038             result [n] = v;\par
00039     \}\par
00040 \par
00041     {\cf19 return} (result);\par
00042 \}\par
00043 \par
00044 {\cf20 // ---}\par
00045 {\cf18 bool} MCHEmul::MessageBuilder::verifyStructure ({\cf17 const} std::string& str)\par
00046 \{\par
00047     {\cf19 if} (str == {\cf22 ""})\par
00048         {\cf19 return} ({\cf17 false});\par
00049 \par
00050     {\cf18 bool} result = {\cf17 true};\par
00051     std::vector <std::string> attrs = \par
00052         MCHEmul::getElementsFrom (str.substr (1) , {\cf23 ','});\par
00053     {\cf19 for} (std::vector <std::string>::const_iterator i = attrs.begin (); i != attrs.end () && result; i++)\par
00054     \{\par
00055         std::vector <std::string> attr = MCHEmul::getElementsFrom ((*i), {\cf23 '='});\par
00056         result = (attr.size () == (size_t) 2) && {\cf20 // Only 2 elements!}\par
00057             (MCHEmul::onlyAlphanumeric (attr [0]) == attr [0]) && {\cf20 // Name & Value have to be alphanumeric...}\par
00058             (MCHEmul::onlyAlphanumeric (attr [1]) == attr [1]);\par
00059     \}\par
00060 \par
00061     {\cf19 return} (result);\par
00062 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/COMMS/StdMessages.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/COMMS/StdMessages.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/COMMS/StdMessages.cpp}
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <COMMS/StdMessages.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StdMessages.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/COMMS/StdMessages.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/COMMS/StdMessages.cpp}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <COMMS/StdMessages.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 MCHEmul::CommunicationMessage* MCHEmul::StandardMessageBuilder::createMessage ({\cf17 const} std::string& str)\par
00005 \{\par
00006     {\cf19 if} (!verifyStructure (str))\par
00007         {\cf19 return} ({\cf17 nullptr}); {\cf20 // No message possible...}\par
00008 \par
00009     {\cf20 // The position 0 es the on indicating theer is a MCHEmul message}\par
00010     MCHEmul::CommunicationMessage* result = {\cf17 nullptr};\par
00011     MCHEmul::Attributes attrs = attributesFromStr (str.substr (2)); \par
00012     {\cf19 switch} (str [1])\par
00013     \{\par
00014         {\cf19 case} MCHEmul::GetRegisterStatusMessage::_ID:\par
00015             result = {\cf17 new} MCHEmul::GetRegisterStatusMessage (attrs);\par
00016             {\cf19 break};\par
00017 \par
00018         {\cf19 case} MCHEmul::GetMemoryDataMessage::_ID:\par
00019             result = {\cf17 new} MCHEmul::GetMemoryDataMessage (attrs);\par
00020             {\cf19 break};\par
00021 \par
00022         {\cf19 default}:\par
00023             assert ({\cf17 false});\par
00024     \}\par
00025 \par
00026     {\cf19 return} (result);\par
00027 \}\par
00028 \par
00029 {\cf20 // ---}\par
00030 {\cf18 unsigned} {\cf18 int} MCHEmul::GetRegisterStatusMessage::executeOn (MCHEmul::Computer* c, MCHEmul::CommunicationMessage*& ans)\par
00031 \{\par
00032     {\cf20 // TODO}\par
00033 \par
00034     {\cf19 return} (0);\par
00035 \}\par
00036 \par
00037 {\cf20 // ---}\par
00038 {\cf18 unsigned} {\cf18 int} MCHEmul::GetMemoryDataMessage::executeOn (MCHEmul::Computer*, MCHEmul::CommunicationMessage*& ans)\par
00039 \{\par
00040     {\cf20 // TODO}\par
00041 \par
00042     {\cf19 return} (0);\par
00043 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/COMMS/System.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/COMMS/System.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/COMMS/System.cpp}
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <COMMS/System.hpp>}\par
{\f2 #include <COMMS/IPAddress.hpp>}\par
{\f2 #include <CORE/Computer.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
System.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/COMMS/System.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/COMMS/System.cpp}
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <COMMS/System.hpp>}\par
00002 {\cf21 #include <COMMS/IPAddress.hpp>}\par
00003 {\cf21 #include <CORE/Computer.hpp>}\par
00004 \par
00005 {\cf20 // ---}\par
00006 {\cf18 unsigned} {\cf18 int} MCHEmul::CommunicationSystem::processMessagesOn (MCHEmul::Computer* c)\par
00007 \{\par
00008     assert (c != {\cf17 nullptr});\par
00009 \par
00010     {\cf19 if} (!*{\cf17 this})\par
00011         {\cf19 return} (0);\par
00012 \par
00013     std::string str;\par
00014     MCHEmul::IPAddress addr;\par
00015     {\cf18 bool} rS;\par
00016     \par
00017     {\cf19 if} (!(rS = _communicationChannel -> receive (str, addr)))\par
00018         {\cf19 return} (0);\par
00019     {\cf19 if} (str == {\cf22 ""})\par
00020         {\cf19 return} (0);\par
00021 \par
00022     MCHEmul::CommunicationMessage* msg = _messageBuilder -> createMessage (str);\par
00023     {\cf19 if} (msg == {\cf17 nullptr})\par
00024         {\cf19 return} (0);\par
00025 \par
00026     {\cf18 unsigned} {\cf18 int} result = 0;\par
00027     MCHEmul::CommunicationMessage* answ = {\cf17 nullptr};\par
00028     {\cf19 if} ((result = msg -> executeOn (c, answ)) == 0  && answ != {\cf17 nullptr})\par
00029         result = _communicationChannel -> send (answ -> toString (), addr);\par
00030 \par
00031     {\cf17 delete} (answ);\par
00032     {\cf17 delete} (msg);\par
00033 \par
00034     {\cf19 return} (result);\par
00035 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CONSOLE/Console.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CONSOLE/Console.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CONSOLE/Console.cpp}
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CONSOLE/Console.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Console.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CONSOLE/Console.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CONSOLE/Console.cpp}
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CONSOLE/Console.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 Console::Console::Console (Emuls::Emulator* e, MCHEmul::CommandBuilder* cB)\par
00005     : _emulator (e), \par
00006       _commandBuilder (cB),\par
00007       _command ({\cf22 ""})\par
00008 \{ \par
00009     assert (_emulator != {\cf17 nullptr} && _commandBuilder != {\cf17 nullptr}); \par
00010 \}\par
00011 \par
00012 {\cf20 // ----}\par
00013 {\cf18 void} Console::Console::run ()\par
00014 \{\par
00015     {\cf18 bool} exit = {\cf17 false};\par
00016 \par
00017     std::cout << {\cf22 "?:"};\par
00018     {\cf19 while} (!exit)\par
00019     \{\par
00020         {\cf20 // Any command ready?}\par
00021         {\cf19 if} (readCommand ())\par
00022         \{\par
00023             std::cout << std::endl;\par
00024             _command = MCHEmul::upper (MCHEmul::trim (_command));\par
00025             {\cf19 if} (exit = (_command == {\cf22 "QUIT"})) {\cf19 break}; {\cf20 // The very common command to any interpreter...}\par
00026             {\cf19 else}\par
00027             \{\par
00028                 MCHEmul::Attributes prms;\par
00029                 MCHEmul::Command* cmd = _commandBuilder -> createCommand (_command);\par
00030                 {\cf19 if} (cmd != {\cf17 nullptr}  && cmd -> canBeExecuted () )\par
00031                 \{\par
00032                     MCHEmul::Attributes rst; {\cf20 // The results...}\par
00033                     {\cf19 if} (!cmd -> execute (_emulator -> computer (), rst)) {\cf20 // error?}\par
00034                     \{\par
00035                     \}\par
00036                     {\cf19 else}\par
00037                     \{\par
00038                     \}\par
00039                 \}\par
00040                 {\cf19 else}\par
00041                 \{\par
00042                 \}\par
00043 \par
00044                 {\cf17 delete} (cmd);\par
00045             \}\par
00046 \par
00047             {\cf20 // Starts back!}\par
00048             _command = {\cf22 ""};\par
00049             std::cout << std::endl << {\cf22 "?:"};\par
00050         \}\par
00051 \par
00052         exit = !_emulator -> runCycle ();\par
00053     \}\par
00054 \}\par
00055 \par
00056 {\cf20 // ---}\par
00057 {\cf18 bool} Console::Console::readCommand ()\par
00058 \{\par
00059     {\cf18 bool} result = {\cf17 false};\par
00060 \par
00061     {\cf18 char} chr;\par
00062     {\cf19 if} (readChar (chr))\par
00063     \{\par
00064         {\cf19 if} (chr == 0x0d ) result = {\cf17 true}; \par
00065         {\cf19 else}\par
00066         \{\par
00067             std::cout << chr;\par
00068 \par
00069             _command += chr;\par
00070         \}\par
00071     \}\par
00072 \par
00073     {\cf19 return} (result);\par
00074 \}\par
00075 \par
00076 {\cf21 #ifdef _WIN32}\par
00077 {\cf21 #include <conio.h>}\par
00078 {\cf20 // ---}\par
00079 {\cf18 bool} Console::Win32Console::readChar ({\cf18 char}& chr){\cf17  const }\par
00080 {\cf17 }\{ \par
00081     {\cf18 bool} result = {\cf17 false};\par
00082     {\cf19 if} (result = (_kbhit () != 0))\par
00083         chr = {\cf17 static_cast <}{\cf18 char}{\cf17 >} (_getch ());\par
00084     {\cf19 return} (result); \par
00085 \}\par
00086 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/Address.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Address.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Address.cpp}
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Address.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Address.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Address.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Address.cpp}
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/Address.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} MCHEmul::Address& a)\par
00005 \{ \par
00006     {\cf19 return} (o << {\cf22 "$"} << a.asString (UByte::OutputFormat::_HEXA)); \par
00007 \}\par
00008 \par
00009 {\cf20 // ---}\par
00010 MCHEmul::Address MCHEmul::Address::fromStr ({\cf17 const} std::string& str)\par
00011 \{\par
00012     {\cf19 return} (MCHEmul::Address (MCHEmul::UInt::fromStr (str)));\par
00013 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/Chip.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Chip.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Chip.cpp}
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Chip.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Chip.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Chip.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Chip.cpp}
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/Chip.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} MCHEmul::Chip& c)\par
00005 \{\par
00006     o << {\cf22 "---"} << std::endl;\par
00007     o << {\cf22 "Chip Info"} << std::endl;\par
00008     o << c._id << std::endl;\par
00009     o << c._attributes;\par
00010     {\cf19 if} (c.memoryRef () != {\cf17 nullptr})\par
00011         o << std::endl << (*c._memory);\par
00012 \par
00013     {\cf19 return} (o);\par
00014 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/CommandBuilder.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/CommandBuilder.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/CommandBuilder.cpp}
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/CommandBuilder.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ENDLOOP}\~ \{ prms =""; break; \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ENDLOOP\:CommandBuilder.cpp}
{\xe \v CommandBuilder.cpp\:ENDLOOP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ENDLOOP\~ \{ prms =""; break; \}}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CommandBuilder.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/CommandBuilder.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/CommandBuilder.cpp}
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/CommandBuilder.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 MCHEmul::Command* MCHEmul::CommandBuilder::createCommand ({\cf17 const} std::string& cmd){\cf17  const}\par
00005 {\cf17 }\{\par
00006     std::string CMD = MCHEmul::upper (MCHEmul::trim (cmd));\par
00007 \par
00008     MCHEmul::Command* result = {\cf17 nullptr};\par
00009     {\cf19 if} ((result = createEmptyCommand (readCommandName (CMD))) != {\cf17 nullptr})\par
00010         result -> setParameters (readCommandParameters (CMD)); {\cf20 // if there is instruction set the prms!}\par
00011     {\cf19 return} (result);\par
00012 \}\par
00013 \par
00014 {\cf20 // ---}\par
00015 std::string MCHEmul::CommandBuilder::readCommandName ({\cf17 const} std::string& cmd){\cf17  const}\par
00016 {\cf17 }\{\par
00017     std::string result = cmd;\par
00018 \par
00019     std::size_t p;\par
00020     {\cf19 if} ((p = cmd.find_first_of ({\cf23 ' '})) != std::string::npos)\par
00021         result = result.substr (0, p);\par
00022 \par
00023     {\cf19 return} (result);\par
00024 \}\par
00025 \par
00026 {\cf20 // ---}\par
00027 MCHEmul::Attributes MCHEmul::CommandBuilder::readCommandParameters ({\cf17 const} std::string& cmd){\cf17  const}\par
00028 {\cf17 }\{\par
00029     MCHEmul::Attributes result;\par
00030 \par
00031 {\cf21 #define ENDLOOP \{ prms =""}; break; \}\par
00032 \par
00033     std::string prms = cmd;\par
00034     {\cf18 size_t} iP = prms.find_first_of ({\cf23 ' '}); {\cf20 // Take off the first word!}\par
00035     {\cf19 if} (iP == std::string::npos || iP >= (cmd.length () - 1)) {\cf20 // Are there other things after?...they could be parameters}\par
00036         {\cf19 return} (result); {\cf20 // There is nothing...so no parameters!}\par
00037     {\cf19 else}\par
00038         {\cf19 if} ((prms = MCHEmul::trim (prms.substr (iP))) == {\cf22 ""})\par
00039             {\cf19 return} (result); {\cf20 // But what is after are only spaces...}\par
00040 \par
00041     {\cf20 // Now it is time to investigate what is left!}\par
00042     {\cf19 while} (prms != {\cf22 ""})\par
00043     \{\par
00044         {\cf20 // The equal symbol defines (almost always) a parameter...}\par
00045         iP = prms.find_first_of ({\cf23 '='});\par
00046         {\cf20 // but when there is none, it could be considerered as a simple parameter with the value YES}\par
00047         {\cf19 if} (iP == std::string::npos)\par
00048         \{\par
00049             {\cf20 // The name of that parameter lasts until the following space!}\par
00050             iP = prms.find_first_of ({\cf23 ' '});\par
00051             std::string fName = MCHEmul::upper (prms.substr (0, iP));\par
00052             prms = MCHEmul::trim (prms.substr (iP + 1));\par
00053             result.insert (MCHEmul::Attributes::value_type (fName, {\cf22 "YES"}));\par
00054 \par
00055             {\cf19 break};\par
00056         \}\par
00057 \par
00058         {\cf20 // There is and equal symbol, but there is nothing else after...}\par
00059         {\cf20 // so there is an error, and the anaylisis has to end!}\par
00060         {\cf19 if} (iP == (prms.length () - 1))\par
00061             ENDLOOP;\par
00062 \par
00063         {\cf20 // There is an equal symbol, and there is something after...}\par
00064         {\cf20 // What is before that is the name of the field...}\par
00065         std::string fName = MCHEmul::upper (MCHEmul::trim (prms.substr (0, iP)));\par
00066         {\cf20 // What is after the equal symbol contains (potentially) the value of that field...}\par
00067         prms = MCHEmul::trim (prms.substr (iP + 1));\par
00068         {\cf20 // If that starts with quotes, the content has to be taken as it is up to the following quote!}\par
00069         {\cf19 if} (prms [0] = {\cf23 '"'})\par
00070         \{\par
00071             iP = prms.find_first_of ({\cf23 '"'});\par
00072             {\cf19 if} (iP == std::string::npos) {\cf20 // There must be a quote at the end, otherwise it will be an error!}\par
00073                 ENDLOOP;\par
00074 \par
00075             result.insert (MCHEmul::Attributes::value_type (fName, prms.substr (1, iP - 1)));\par
00076             prms = prms.substr (iP + 1);\par
00077         \}\par
00078         {\cf19 else}\par
00079         \{\par
00080             iP = prms.find_first_of ({\cf23 ' '});\par
00081             result.insert (MCHEmul::Attributes::value_type (fName, prms.substr (1, iP)));\par
00082             prms = prms.substr (iP + 1);\par
00083         \}\par
00084     \}\par
00085 \par
00086     {\cf19 return} (result);\par
00087 \}\par
00088 \par
00089 {\cf20 // ---}\par
00090 MCHEmul::Command* MCHEmul::StandardCommandBuilder::createEmptyCommand ({\cf17 const} std::string& cmdName){\cf17  const}\par
00091 {\cf17 }\{\par
00092     {\cf19 return} ({\cf17 nullptr});\par
00093 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/Computer.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Computer.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Computer.cpp}
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Computer.hpp>}\par
{\f2 #include <thread>}\par
{\f2 #include <sstream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Computer.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Computer.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Computer.cpp}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/Computer.hpp>}\par
00002 {\cf21 #include <thread>}\par
00003 {\cf21 #include <sstream>}\par
00004 \par
00005 {\cf20 // ---}\par
00006 MCHEmul::Computer::Computer (MCHEmul::CPU* cpu, {\cf17 const} MCHEmul::Chips& c, \par
00007         MCHEmul::Memory* m, {\cf17 const} MCHEmul::IODevices& d, {\cf18 unsigned} {\cf18 int} cs, {\cf17 const} MCHEmul::Attributes& attrs)\par
00008     : _cpu (cpu), _chips (c), _memory (m), _devices (d), _clock (cs), _attributes (attrs),\par
00009       _exit (false), _debugLevel (MCHEmul::_DEBUGNOTHING),\par
00010       _lastError (MCHEmul::_NOERROR),\par
00011       _screen (nullptr), _inputOSSystem (nullptr), _graphicalChip (nullptr)\par
00012 \{ \par
00013     assert (_cpu != {\cf17 nullptr});\par
00014     assert (_memory != {\cf17 nullptr} && _memory -> stack () != {\cf17 nullptr});\par
00015 \par
00016     _cpu -> setMemoryRef (_memory);\par
00017 \par
00018     {\cf19 for} ({\cf17 auto} i : _chips)\par
00019     \{\par
00020         {\cf19 if} (_graphicalChip == {\cf17 nullptr})\par
00021             _graphicalChip = {\cf17 dynamic_cast <}MCHEmul::GraphicalChip*{\cf17 >} (i.second);\par
00022 \par
00023         i.second -> setMemoryRef (_memory);\par
00024     \}\par
00025 \par
00026     {\cf20 // To define a graphical chip is mandatory...}\par
00027     assert (_graphicalChip != {\cf17 nullptr});\par
00028 \par
00029     {\cf19 for} ({\cf17 auto} i : _devices)\par
00030     \{\par
00031         {\cf19 if} (_screen == {\cf17 nullptr}) \par
00032             _screen = {\cf17 dynamic_cast <}MCHEmul::Screen*{\cf17 >} (i.second);\par
00033         {\cf19 if} (_inputOSSystem == {\cf17 nullptr}) \par
00034             _inputOSSystem = {\cf17 dynamic_cast <}MCHEmul::InputOSSystem*{\cf17 >} (i.second);\par
00035 \par
00036         {\cf20 // In general...}\par
00037         i.second -> linkToChips (_chips);\par
00038     \}\par
00039 \par
00040     {\cf20 // These are mandatory...}\par
00041     assert (_screen != {\cf17 nullptr} && _inputOSSystem != {\cf17 nullptr});\par
00042 \}\par
00043 \par
00044 {\cf20 // ---}\par
00045 MCHEmul::Computer::~Computer ()\par
00046 \{ \par
00047     {\cf17 delete} (_cpu); \par
00048 \par
00049     {\cf17 delete} (_memory);\par
00050 \par
00051     {\cf19 for} ({\cf17 auto} i : _chips)\par
00052         {\cf17 delete} (i.second);\par
00053 \par
00054     {\cf19 for} ({\cf17 auto} i : _devices)\par
00055         {\cf17 delete} (i.second);\par
00056 \}\par
00057 \par
00058 {\cf20 // ---}\par
00059 {\cf18 bool} MCHEmul::Computer::initialize ()\par
00060 \{\par
00061     {\cf19 if} (_screen == {\cf17 nullptr} || _inputOSSystem == {\cf17 nullptr} ||\par
00062         _graphicalChip == {\cf17 nullptr})\par
00063     \{\par
00064         _lastError = MCHEmul::_INIT_ERROR;\par
00065 \par
00066         {\cf19 return} ({\cf17 false});\par
00067     \}\par
00068 \par
00069     {\cf19 if} (!_cpu -> initialize ())\par
00070     \{\par
00071         _lastError = MCHEmul::_INIT_ERROR;\par
00072 \par
00073         {\cf19 return} ({\cf17 false});\par
00074     \}\par
00075 \par
00076     {\cf18 bool} resultChips = {\cf17 true};\par
00077     {\cf19 for} ({\cf17 auto} i : chips ())\par
00078         resultChips &= i.second -> initialize ();\par
00079     {\cf19 if} (!resultChips)\par
00080     \{\par
00081         _lastError = MCHEmul::_INIT_ERROR;\par
00082 \par
00083         {\cf19 return} ({\cf17 false});\par
00084     \}\par
00085 \par
00086     {\cf18 bool} resultIO = {\cf17 true};\par
00087     {\cf19 for} ({\cf17 auto} i : devices ())\par
00088         resultIO &= i.second -> initialize ();\par
00089     {\cf19 if} (!resultIO)\par
00090     \{\par
00091         _lastError = MCHEmul::_INIT_ERROR;\par
00092 \par
00093         {\cf19 return} ({\cf17 false});\par
00094     \}\par
00095 \par
00096     {\cf19 if} (!_memory -> initialize ())\par
00097     \{\par
00098         _lastError = MCHEmul::_INIT_ERROR;\par
00099 \par
00100         {\cf19 return} ({\cf17 false});\par
00101     \}\par
00102 \par
00103     {\cf19 return} ({\cf17 true});\par
00104 \}\par
00105 \par
00106 {\cf20 // ---}\par
00107 {\cf18 bool} MCHEmul::Computer::run ()\par
00108 \{\par
00109     {\cf20 // It has to be initialized before...}\par
00110 \par
00111     _exit = {\cf17 false};\par
00112     _lastError = MCHEmul::_NOERROR;\par
00113 \par
00114     {\cf18 bool} ok = {\cf17 true};\par
00115     {\cf19 while} (ok && !_exit)\par
00116     \{\par
00117         startsCycle ();\par
00118 \par
00119         ok &= runComputerCycle ();\par
00120         ok &= runIOCycle ();\par
00121         \par
00122         finishCycle ();\par
00123     \}\par
00124 \par
00125     {\cf19 return} (_lastError != MCHEmul::_NOERROR);\par
00126 \}\par
00127 \par
00128 {\cf20 // ---}\par
00129 {\cf18 bool} MCHEmul::Computer::runComputerCycle ()\par
00130 \{\par
00131     {\cf19 if} (!_cpu -> executeNextInstruction ())\par
00132     \{\par
00133         _exit = {\cf17 true};\par
00134 \par
00135         _lastError = MCHEmul::_CPU_ERROR;\par
00136 \par
00137         {\cf19 if} (_debugLevel >= MCHEmul::_DEBUGERRORS)\par
00138             std::cout << {\cf22 "Error executing instruction"} << std::endl;\par
00139 \par
00140         {\cf19 return} ({\cf17 false}); {\cf20 // Error...}\par
00141     \}\par
00142 \par
00143     {\cf19 if} (_debugLevel >= MCHEmul::_DEBUGALL)\par
00144     \{\par
00145         std::stringstream ss;\par
00146         ss << {\cf22 "->"} << *_cpu -> lastInstruction (); {\cf20 // To control the size printed out!}\par
00147         std::cout  \par
00148             << ss.str () << MCHEmul::_TABS.substr (0, 2  - ({\cf18 size_t}) (ss.str ().length () / 8))\par
00149             << _cpu -> programCounter () << {\cf23 '\\t'} \par
00150             << _cpu -> statusRegister ();\par
00151         {\cf19 for} ({\cf17 auto} i : _cpu -> internalRegisters ())\par
00152             std::cout << {\cf23 '\\t'} << i;\par
00153         std::cout << std::endl;\par
00154     \}\par
00155 \par
00156     {\cf19 for} ({\cf17 auto} i : _chips)\par
00157     \{\par
00158         {\cf19 if} (!i.second -> simulate (_cpu))\par
00159         \{\par
00160             _exit = {\cf17 true};\par
00161 \par
00162             _lastError = MCHEmul::_CHIP_ERROR;\par
00163 \par
00164             {\cf19 if} (_debugLevel >= MCHEmul::_DEBUGERRORS)\par
00165                 std::cout << {\cf22 "Error simulating chip: "} << std::endl << i.second << std::endl;\par
00166 \par
00167             {\cf19 return} ({\cf17 false}); {\cf20 // Error...}\par
00168         \}\par
00169     \}\par
00170 \par
00171     {\cf19 return} ({\cf17 true});\par
00172 \}\par
00173 \par
00174 {\cf20 // ---}\par
00175 {\cf18 bool} MCHEmul::Computer::runIOCycle ()\par
00176 \{\par
00177     {\cf19 for} ({\cf17 auto} i : _devices)\par
00178     \{\par
00179         {\cf19 if} (!i.second -> simulate ())\par
00180         \{\par
00181             _exit = {\cf17 true};\par
00182 \par
00183             _lastError = MCHEmul::_DEVICE_ERROR;\par
00184 \par
00185             {\cf19 if} (_debugLevel >= MCHEmul::_DEBUGERRORS)\par
00186                 std::cout << {\cf22 "Error in IO device:"} << std::endl << i.second << std::endl;\par
00187 \par
00188             {\cf19 return} ({\cf17 false}); {\cf20 // Error...}\par
00189         \}\par
00190     \}\par
00191 \par
00192     _exit = _inputOSSystem -> quitRequested ();\par
00193 \par
00194     {\cf19 return} ({\cf17 true});\par
00195 \}\par
00196 \par
00197 {\cf20 // ---}\par
00198 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} MCHEmul::Computer& c)\par
00199 \{\par
00200     o << {\cf22 "---"} << std::endl;\par
00201     o << {\cf22 "Computer Info"} << std::endl;\par
00202     o << *c.cpu () << std::endl;\par
00203     {\cf19 for} ({\cf17 auto} i : c.chips ())\par
00204         o << *i.second << std::endl;\par
00205     o << *c.memory () << std::endl;\par
00206     {\cf19 for} ({\cf17 auto} i : c.devices ())\par
00207         o << *i.second << std::endl;\par
00208     o << c.attributes ();\par
00209     {\cf19 return} (o);\par
00210 \}\par
00211 \par
00212 {\cf20 // ---}\par
00213 {\cf18 void} MCHEmul::Computer::Clock::start ({\cf18 unsigned} {\cf18 int} cC)\par
00214 \{\par
00215     _initialClockCycles = cC;\par
00216     _iClock = std::chrono::steady_clock ().now ();\par
00217 \}\par
00218 \par
00219 {\cf20 // ---}\par
00220 {\cf18 void} MCHEmul::Computer::Clock::waitFor ({\cf18 unsigned} {\cf18 int} cC)\par
00221 \{\par
00222     {\cf17 static} {\cf17 const} {\cf18 long} {\cf18 long} nanosc = ({\cf18 long} long) 1.0e9;\par
00223 \par
00224     {\cf18 long} {\cf18 long} elapsed = std::chrono::duration_cast <std::chrono::nanoseconds> (std::chrono::steady_clock::now () - _iClock).count ();\par
00225     {\cf18 long} {\cf18 long} tElapsed = ({\cf18 long} long) (({\cf18 double}) (cC - _initialClockCycles) / ({\cf18 double}) _cyclesPerSecond * (double) nanosc);\par
00226     {\cf19 if} (tElapsed > elapsed)\par
00227         std::this_thread::sleep_for (std::chrono::nanoseconds (tElapsed - elapsed));\par
00228 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/CPU.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/CPU.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/CPU.cpp}
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/CPU.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPU.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/CPU.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/CPU.cpp}
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/CPU.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 MCHEmul::CPU::~CPU ()\par
00005 \{\par
00006     {\cf19 for} ({\cf17 auto} i : _instructions)\par
00007         {\cf17 delete} (i.second);\par
00008 \par
00009     {\cf19 for} ({\cf17 auto} i : _interrupts)\par
00010         {\cf17 delete} (i.second);\par
00011 \}\par
00012 \par
00013 {\cf20 // ---}\par
00014 {\cf18 bool} MCHEmul::CPU::initialize ()\par
00015 \{\par
00016     {\cf19 for} ({\cf17 auto} i : _registers)\par
00017         i.initialize ();\par
00018 \par
00019     _statusRegister.initialize ();\par
00020 \par
00021     _programCounter.initialize (); \par
00022 \par
00023     _lastInstruction = {\cf17 nullptr};\par
00024 \par
00025     _clockCycles = 0;\par
00026 \par
00027     {\cf19 return} ({\cf17 true});\par
00028 \}\par
00029 \par
00030 {\cf20 // ---}\par
00031 {\cf18 void} MCHEmul::CPU::addInterrupt (MCHEmul::CPUInterrupt* in)\par
00032 \{\par
00033     assert (in != {\cf17 nullptr});\par
00034 \par
00035     {\cf19 if} (_interrupts.find (in -> id ()) != _interrupts.end ())\par
00036         {\cf19 return}; {\cf20 // Only one with the the same id...}\par
00037 \par
00038     _interrupts.insert (MCHEmul::CPUInterrups::value_type (in -> {\cf18 id} (), in));\par
00039 \}\par
00040 \par
00041 {\cf20 // ---}\par
00042 {\cf18 void} MCHEmul::CPU::removeInterrrupt ({\cf18 int} {\cf18 id})\par
00043 \{\par
00044     MCHEmul::CPUInterrups::const_iterator i;\par
00045     {\cf19 if} ((i = _interrupts.find ({\cf18 id})) == _interrupts.end ())\par
00046         {\cf19 return};\par
00047 \par
00048     _interrupts.erase (i);\par
00049 \}\par
00050 \par
00051 {\cf20 // ---}\par
00052 {\cf18 bool} MCHEmul::CPU::executeNextInstruction ()\par
00053 \{\par
00054     memoryRef () -> setCPUView (); {\cf20 // Always...}\par
00055 \par
00056     {\cf18 unsigned} {\cf18 int} nC = 0;\par
00057     {\cf19 for} ({\cf17 auto} i : _interrupts)\par
00058     \{\par
00059         i.second -> executeOver ({\cf17 this}, nC);\par
00060         _clockCycles += nC;\par
00061     \}\par
00062 \par
00063     MCHEmul::Instructions::const_iterator i = \par
00064         _instructions.find (\par
00065             MCHEmul::UInt (\par
00066                 _memory -> values (\par
00067                     programCounter ().asAddress (), architecture ().instructionLength ()), \par
00068                 architecture ().bigEndian ()).asUnsignedInt ());\par
00069 \par
00070     {\cf19 if} (i == _instructions.end ())\par
00071         {\cf19 return} ({\cf17 false});\par
00072 \par
00073     {\cf18 bool} result = {\cf17 false};\par
00074 \par
00075     MCHEmul::Instruction* inst = (*i).second;\par
00076 \par
00077     {\cf20 // Gets the data that the instruction occupies}\par
00078     MCHEmul::UBytes dt = _memory -> values (programCounter ().asAddress (), inst -> memoryPositions ());\par
00079     {\cf20 // Move the "Program Counter" to the next instruction...}\par
00080     {\cf20 // This is done before executing the instruction because the intruction itself could}\par
00081     {\cf20 // modify the value of the "Program Counter"}\par
00082     _programCounter += (size_t) inst -> memoryPositions ();\par
00083     {\cf20 // Then executes the instruction}\par
00084     result = inst -> execute (dt, {\cf17 this}, _memory, _memory -> stack ());\par
00085 \par
00086     {\cf20 // And also, take into account what it costs in terms of cycles...}\par
00087     _clockCycles += inst -> clockCycles () + inst -> additionalClockCycles ();\par
00088 \par
00089     _lastInstruction = inst;\par
00090 \par
00091     {\cf19 return} (result);\par
00092 \}\par
00093 \par
00094 {\cf20 // ---}\par
00095 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} MCHEmul::CPU& c)\par
00096 \{\par
00097     o << {\cf22 "---"} << std::endl;\par
00098     o << {\cf22 "CPU Info"} << std::endl;\par
00099     o << c.architecture () << std::endl;\par
00100     {\cf19 for} ({\cf17 auto} i : c.internalRegisters ())\par
00101         o << i << std::endl;\par
00102     o << c.programCounter () << std::endl;\par
00103     o << c.statusRegister () << std::endl;\par
00104     o << c.clockCycles () << {\cf22 " clock cycles"};\par
00105 \par
00106     {\cf19 return} (o);\par
00107 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/CPUArchitecture.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/CPUArchitecture.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/CPUArchitecture.cpp}
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/CPUArchitecture.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPUArchitecture.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/CPUArchitecture.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/CPUArchitecture.cpp}
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/CPUArchitecture.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 MCHEmul::CPUArchitecture::CPUArchitecture ({\cf18 size_t} nb, {\cf18 size_t} iL, {\cf18 bool} bE, {\cf17 const} Attributes& attrs)\par
00005     : _numberBytes (nb), _instructionLength (iL), _numberBits ((size_t) (nb << 3)), _bigEndian (bE), _attributes (attrs), \par
00006       _longestRegisterPossible (0, {\cf22 "-"}, MCHEmul::UBytes (std::vector <MCHEmul::UByte> (nb, MCHEmul::UByte::_0))) {\cf20 // The id is an imagination...}\par
00007 \{ \par
00008     assert (_numberBytes > 0 && \par
00009             _numberBytes <= MCHEmul::_MAXBYTESMANAGED && {\cf20 // The maximum byte length supported}\par
00010             (_numberBits >> 3) == _numberBytes &&  {\cf20 // To b sure everything matches}\par
00011             _instructionLength <= _numberBytes); \par
00012 \}\par
00013 \par
00014 {\cf20 // ---}\par
00015 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} MCHEmul::CPUArchitecture& a)\par
00016 \{\par
00017     o << {\cf22 "---"} << std::endl;\par
00018     o << {\cf22 "CPU Architecture Info"} << std::endl;\par
00019     o << a.numberBytes () << {\cf22 " bytes"} << std::endl;\par
00020     o << a.numberBits () << {\cf22 " bits"} << std::endl;\par
00021     o << a.instructionLength () << {\cf22 " bytes per instruction"} << std::endl;\par
00022     o << (a.bigEndian () ? {\cf22 "big endian"} : {\cf22 "little endian"}) << std::endl;\par
00023     o << a.attributes ();\par
00024 \par
00025     {\cf19 return} (o);\par
00026 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/CPUInterrupt.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/CPUInterrupt.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/CPUInterrupt.cpp}
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/CPUInterrupt.hpp>}\par
{\f2 #include <CORE/CPU.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPUInterrupt.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/CPUInterrupt.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/CPUInterrupt.cpp}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/CPUInterrupt.hpp>}\par
00002 {\cf21 #include <CORE/CPU.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} MCHEmul::CPUInterrupt::executeOver (MCHEmul::CPU* c, {\cf18 unsigned} {\cf18 int}& nC)\par
00006 \{\par
00007     assert (c != {\cf17 nullptr});\par
00008 \par
00009     {\cf18 bool} result = {\cf17 false};\par
00010 \par
00011     {\cf19 if} (active () && isTime (c))\par
00012     \{\par
00013         _lastClockCyclesExecuted = c -> clockCycles ();\par
00014 \par
00015         executeOverImpl (c, nC);\par
00016 \par
00017         result = {\cf17 true};\par
00018     \}\par
00019 \par
00020     {\cf19 return} (result);\par
00021 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/GraphicalChip.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/GraphicalChip.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/GraphicalChip.cpp}
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/GraphicalChip.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GraphicalChip.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/GraphicalChip.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/GraphicalChip.cpp}
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/GraphicalChip.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 {\cf18 bool} MCHEmul::GraphicalChip::initialize ()\par
00005 \{\par
00006     _screenMemory = createScreenMemory ();\par
00007 \par
00008     _graphicsReady = {\cf17 false};\par
00009 \par
00010     {\cf19 return} (_screenMemory != {\cf17 nullptr});\par
00011 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/Instruction.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Instruction.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Instruction.cpp}
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Instruction.hpp>}\par
{\f2 #include <CORE/CPU.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Instruction.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Instruction.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Instruction.cpp}
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/Instruction.hpp>}\par
00002 {\cf21 #include <CORE/CPU.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf17 static} std::map <unsigned char, MCHEmul::Instruction::Structure::Parameter::Type> _TYPES\par
00006     (\{ \par
00007         \{{\cf23 '#'}, MCHEmul::Instruction::Structure::Parameter::Type::_DATA\},\par
00008         \{{\cf23 '$'}, MCHEmul::Instruction::Structure::Parameter::Type::_DIR\},\par
00009         \{{\cf23 '&'}, MCHEmul::Instruction::Structure::Parameter::Type::_RELJUMP\}, \par
00010         \{{\cf23 '%'}, MCHEmul::Instruction::Structure::Parameter::Type::_ABSJUMP\} \par
00011     \});\par
00012 \par
00013 {\cf20 // ---}\par
00014 MCHEmul::Instruction::Instruction ({\cf18 unsigned} {\cf18 int} c, {\cf18 unsigned} {\cf18 int} mp, {\cf18 unsigned} {\cf18 int} cc, {\cf17 const} std::string& t)\par
00015     : _code (c), _memoryPositions (mp), _clockCycles (cc), \par
00016       _iTemplate (MCHEmul::noSpaces (MCHEmul::upper (t))),\par
00017       _iStructure (), {\cf20 // Assigned later...}\par
00018       _lastParameters (), _cpu (nullptr), _memory (nullptr), _stack (nullptr)\par
00019 \{ \par
00020     assert (_memoryPositions > 0 && _clockCycles > 0); \par
00021     assert (_iTemplate != {\cf22 ""}); \par
00022 \par
00023     {\cf20 // The template if stored in uppercase and with no spaces...}\par
00024 \par
00025     _iStructure = analyzeInstruction ();\par
00026     {\cf19 if} (_iStructure._error)\par
00027         _iTemplate = _iStructure._templateWithNoParameters;\par
00028 \}\par
00029 \par
00030 {\cf20 // ---}\par
00031 {\cf18 bool} MCHEmul::Instruction::matchesWith ({\cf17 const} std::string& i, std::vector <std::string>& prms)\par
00032 \{\par
00033     {\cf19 if} (_iStructure._error)\par
00034         {\cf19 return} ({\cf17 false});\par
00035 \par
00036     std::string inst = _iStructure._templateWithNoParameters;\par
00037 \par
00038     std::string iL = MCHEmul::upper (MCHEmul::noSpaces (i));\par
00039 \par
00040     std::string pW = {\cf22 ""};\par
00041 \par
00042     {\cf20 // The one received can't be shorter than the template never}\par
00043     {\cf19 if} (iL.length () < inst.length ())\par
00044         {\cf19 return} ({\cf17 false}); {\cf20 // if it is, we are speaking about another opcode...}\par
00045 \par
00046     {\cf20 // If they don't start by the same symbol, thre woldn't be any possibility for them to match}\par
00047     {\cf19 if} (iL [0] != inst [0])\par
00048         {\cf19 return} ({\cf17 false});\par
00049 \par
00050     {\cf20 // It is time to review whether }\par
00051     {\cf20 // the structure of the received instruction could match with this...}\par
00052     prms = \{ \};\par
00053     {\cf18 bool} result = {\cf17 true};\par
00054     {\cf18 size_t} ctIL = 0;\par
00055     {\cf19 for} ({\cf18 size_t} ctInst = 0; \par
00056             ctInst < inst.length () && ctIL < iL.length () && result; ctInst++, ctIL++)\par
00057     \{\par
00058         {\cf20 // When the character in the received intruction }\par
00059         {\cf20 // doesn't match with the equivalent one in the template}\par
00060         {\cf20 // the system tries to find the next match, assuming that evrything}\par
00061         {\cf20 // In between should be a parameter...}\par
00062         {\cf20 // THis is something also checfed later!}\par
00063         {\cf19 if} (iL [ctIL] != inst [ctInst])\par
00064         \{\par
00065             {\cf18 size_t} iPP = ctIL;\par
00066             {\cf19 while} (iL [ctIL] != inst [ctInst] && ctIL < iL.length ()) ctIL++;\par
00067             {\cf19 if} (result = (ctIL != iL.length ()))\par
00068             \{\par
00069                 prms.push_back (iL.substr (iPP, ctIL - iPP));\par
00070 \par
00071                 pW += {\cf23 '?'};\par
00072                 pW += iL [ctIL];\par
00073             \}\par
00074         \}\par
00075         {\cf19 else}\par
00076             pW += iL [ctIL];\par
00077     \}\par
00078 \par
00079     {\cf20 // If the global aspect doesn't match}\par
00080     {\cf20 // It is not worth to continue...}\par
00081     {\cf19 if} (!result)\par
00082         {\cf19 return} ({\cf17 false});\par
00083 \par
00084     {\cf20 // If the instruction recevived hasn't been compared until its end,}\par
00085     {\cf20 // It could mean there is parameters still pending to add...}\par
00086     {\cf20 // That potential parameter should be a valid label or numbr!}\par
00087     {\cf19 if} (ctIL != iL.length ())\par
00088     \{\par
00089         std::string lP = iL.substr (ctIL);\par
00090         {\cf19 if} (MCHEmul::validLabel (lP) || MCHEmul::validBytes (lP))\par
00091         \{\par
00092             prms.push_back (lP);\par
00093             pW += {\cf23 '?'};\par
00094         \}\par
00095         {\cf19 else} {\cf20 // In other case, it is not something that matches!}\par
00096             {\cf19 return} ({\cf17 false});\par
00097     \}\par
00098 \par
00099     {\cf20 // The number of extracted parameters has to match the number of the ones defined...}\par
00100     {\cf20 // ...and also the watermark!}\par
00101     {\cf19 return} (_iStructure._waterMark == MCHEmul::onlyAlphanumeric (MCHEmul::removeAllFrom (iL, prms))  &&\par
00102             _iStructure._waterMarkPlus == pW && \par
00103             prms.size () == _iStructure._parameters.size () );\par
00104 \}\par
00105 \par
00106 {\cf20 // ---}\par
00107 {\cf17 const} MCHEmul::UBytes MCHEmul::Instruction::parameters ({\cf18 size_t} p, {\cf18 size_t} nP, {\cf18 bool} bE){\cf17  const}\par
00108 {\cf17 }\{\par
00109     {\cf19 if} ((p + nP - 1) >= _lastParameters.size ())\par
00110         {\cf19 return} (MCHEmul::UBytes::_E);\par
00111 \par
00112     std::vector <MCHEmul::UByte> ub;\par
00113     {\cf19 for} ({\cf18 size_t} i = 0; i < nP; ub.push_back (_lastParameters [p + i++]));\par
00114     {\cf19 return} (MCHEmul::UBytes (ub, bE));\par
00115 \}\par
00116 \par
00117 {\cf20 // ---}\par
00118 std::string MCHEmul::Instruction::parametersAsString ({\cf18 size_t} p, {\cf18 size_t} nP, {\cf18 bool} bE){\cf17  const}\par
00119 {\cf17 }\{ \par
00120     MCHEmul::UBytes ub = parameters (p, nP, bE);\par
00121 \par
00122     std::string result = {\cf22 ""};\par
00123     {\cf19 for} ({\cf18 size_t} i = 0; i < ub.size (); i++)\par
00124         result += ((i == 0) ? {\cf22 "$"} : {\cf22 ""}) + ub [i].asString (MCHEmul::UByte::OutputFormat::_HEXA, 2);\par
00125     {\cf19 return} (result);\par
00126 \}\par
00127 \par
00128 {\cf20 // ---}\par
00129 std::string MCHEmul::Instruction::asString (){\cf17  const}\par
00130 {\cf17 }\{\par
00131     {\cf19 if} (_cpu == {\cf17 nullptr} || _memory == {\cf17 nullptr} || _stack == {\cf17 nullptr})\par
00132         {\cf19 return} ({\cf22 ""}); {\cf20 // If the transaction has not been executed...}\par
00133 \par
00134     {\cf19 if} (internalStructure ()._error)\par
00135         {\cf19 return} (_iTemplate); {\cf20 // Nothing else is possible...}\par
00136 \par
00137     std::string t = _iTemplate;\par
00138 \par
00139     std::string toPrint = {\cf22 ""};\par
00140 \par
00141     {\cf18 size_t} nPrm = _cpu -> architecture ().instructionLength ();\par
00142     {\cf18 size_t} lP = 0;\par
00143     {\cf18 bool} end = {\cf17 false};\par
00144     {\cf19 while} (!end)\par
00145     \{\par
00146         {\cf18 size_t} iPP = t.find ({\cf23 '['}, lP);\par
00147         {\cf19 if} (iPP != std::string::npos)\par
00148         \{\par
00149             {\cf20 // As the template has been already analyzed}\par
00150             {\cf20 // After "[" there will be always a "]"...}\par
00151             {\cf20 // No error is now possible!}\par
00152             {\cf18 size_t} fPP = t.find ({\cf23 ']'}, iPP + 1);\par
00153 \par
00154             std::string prm = t.substr (iPP + 1, fPP - iPP);\par
00155             {\cf18 size_t} bPrm = std::atoi (prm.substr (1).c_str ());\par
00156             std::map <unsigned char, Structure::Parameter::Type>::const_iterator iPrm = _TYPES.find (prm [0]);\par
00157             {\cf18 bool} bE = (iPrm != _TYPES.end ()) \par
00158                 ? (((*iPrm).second == Structure::Parameter::Type::_DIR ||\par
00159                     (*iPrm).second == Structure::Parameter::Type::_ABSJUMP) \par
00160                         ? _cpu -> architecture ().bigEndian () : {\cf17 true})\par
00161                 : {\cf17 true};\par
00162 \par
00163             toPrint += t.substr (lP, iPP - lP) + parametersAsString (nPrm, bPrm, bE);\par
00164 \par
00165             nPrm += bPrm;\par
00166             lP = fPP + 1;\par
00167         \}\par
00168         {\cf19 else}\par
00169         \{\par
00170             toPrint += t.substr (lP);\par
00171 \par
00172             end = {\cf17 true};\par
00173         \}\par
00174     \}\par
00175 \par
00176     {\cf19 return} (toPrint);\par
00177 \}\par
00178 \par
00179 {\cf18 bool} MCHEmul::Instruction::execute ({\cf17 const} MCHEmul::UBytes& p, MCHEmul::CPU* c, MCHEmul::Memory* m, MCHEmul::Stack* stk)\par
00180 \{\par
00181     assert (p.size () == _memoryPositions);\par
00182     assert (c != {\cf17 nullptr} && m != {\cf17 nullptr});\par
00183 \par
00184     _lastParameters = p;\par
00185     _cpu = c;\par
00186     _memory = m;\par
00187     _stack = stk;\par
00188 \par
00189     _additionalCycles = 0; {\cf20 // executeImpl could add additional cycles...}\par
00190 \par
00191     {\cf19 return} (executeImpl ());\par
00192 \}\par
00193 \par
00194 {\cf20 // ---}\par
00195 MCHEmul::Instruction::Structure MCHEmul::Instruction::analyzeInstruction (){\cf17  const}\par
00196 {\cf17 }\{\par
00197     MCHEmul::Instruction::Structure result;\par
00198 \par
00199     std::string inst = iTemplate ();\par
00200     std::string wmak = inst;\par
00201 \par
00202     {\cf18 size_t} iP = inst.find ({\cf23 '['});\par
00203     {\cf19 while} (iP != std::string::npos)\par
00204     \{\par
00205         {\cf18 size_t} fP = inst.find ({\cf23 ']'}, iP + 1);\par
00206         {\cf19 if} (fP != std::string::npos)\par
00207         \{\par
00208             std::string pr = inst.substr (iP + 1, fP - iP - 1);\par
00209             {\cf19 if} (pr != {\cf22 ""} && pr.length () >= 2  &&\par
00210                 (_TYPES.find (pr [0]) != _TYPES.end ()))\par
00211             \{\par
00212                 result._parameters.push_back \par
00213                     (Structure::Parameter ((*_TYPES.find (pr [0])).second, std::stoi (pr.substr (1))));\par
00214                 \par
00215                 inst = inst.substr (0, iP) + inst.substr (fP + 1);\par
00216                 wmak = wmak.substr (0, iP) + {\cf22 "?"}  + wmak.substr (fP + 1);\par
00217             \}\par
00218             {\cf19 else}\par
00219             \{\par
00220                 {\cf20 // There is mistake in the definition of the parameter}\par
00221                 inst = {\cf22 "?"};\par
00222                 result._error = {\cf17 true};\par
00223             \}\par
00224         \}\par
00225         {\cf19 else}\par
00226         \{\par
00227             {\cf20 // There is a mistake in the definition of the instruction...}\par
00228             {\cf20 // Nothing should coninue...}\par
00229             inst = {\cf22 "-"};\par
00230             result._error = {\cf17 true};\par
00231         \}\par
00232 \par
00233         iP = inst.find ({\cf23 '['});\par
00234     \}\par
00235 \par
00236     result._templateWithNoParameters = inst;\par
00237     result._waterMark = MCHEmul::onlyAlphanumeric (inst);\par
00238     result._waterMarkPlus = wmak;\par
00239 \par
00240     {\cf19 return} (result);\par
00241 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/IO.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/IO.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/IO.cpp}
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/IO.hpp>}\par
{\f2 #include <CORE/global.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IO.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/IO.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/IO.cpp}
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/IO.hpp>}\par
00002 {\cf21 #include <CORE/global.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 MCHEmul::IODevice::IODevice (MCHEmul::IODevice::Type t, {\cf18 int} {\cf18 id}, {\cf17 const} MCHEmul::Attributes& attrs)\par
00006     : _type (t), \par
00007       _id (id), \par
00008       _chips (), \par
00009       _attributes (),\par
00010       _peripherals (),\par
00011       _lastError (MCHEmul::_NOERROR)\par
00012 \{\par
00013     {\cf20 // Nothing else to do}\par
00014 \}\par
00015 \par
00016 {\cf20 // ---      }\par
00017 {\cf18 void} MCHEmul::IODevice::addPeripheral (MCHEmul::IOPeripheral* p)\par
00018 \{\par
00019     {\cf19 if} (p == {\cf17 nullptr})\par
00020         {\cf19 return};\par
00021 \par
00022     MCHEmul::IOPeripherals::const_iterator i = _peripherals.find (p -> {\cf18 id} ());\par
00023     {\cf19 if} (i == _peripherals.end ())\par
00024     \{\par
00025         _peripherals.insert (MCHEmul::IOPeripherals::value_type (p -> {\cf18 id} (), p));\par
00026 \par
00027         p -> _device = {\cf17 this}; {\cf20 // link it...}\par
00028     \}\par
00029 \}\par
00030 \par
00031 {\cf20 // ---}\par
00032 {\cf18 void} MCHEmul::IODevice::removePeripheral ({\cf18 int} {\cf18 id})\par
00033 \{\par
00034     MCHEmul::IOPeripherals::const_iterator i = _peripherals.find ({\cf18 id});\par
00035     {\cf19 if} (i != _peripherals.end ())\par
00036     \{\par
00037         (*i).second -> _device = {\cf17 nullptr};\par
00038 \par
00039         _peripherals.erase (i); {\cf20 // unlink it...}\par
00040     \}\par
00041 \}\par
00042 \par
00043 {\cf20 // ---}\par
00044 {\cf18 bool} MCHEmul::IODevice::initialize ()\par
00045 \{\par
00046     {\cf18 bool} result = {\cf17 true};\par
00047     {\cf19 for} ({\cf17 auto} i : _peripherals)\par
00048         result &= i.second -> initialize ();\par
00049 \par
00050     {\cf19 if} (!result)\par
00051         _lastError = MCHEmul::_INIT_ERROR;\par
00052 \par
00053     {\cf19 return} (result);\par
00054 \}\par
00055 \par
00056 {\cf20 // ---}\par
00057 {\cf18 bool} MCHEmul::IODevice::simulate ()\par
00058 \{\par
00059     {\cf18 bool} result = {\cf17 true};\par
00060     {\cf19 for} ({\cf17 auto} i : _peripherals)\par
00061         result &= i.second -> simulate ();\par
00062 \par
00063     {\cf19 if} (!result)\par
00064         _lastError = MCHEmul::_DEVICE_ERROR;\par
00065 \par
00066     {\cf19 return} (result);\par
00067 \}\par
00068 \par
00069 {\cf20 // ---}\par
00070 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} MCHEmul::IODevice& d)\par
00071 \{\par
00072     o << {\cf22 "---"} << std::endl;\par
00073     o << {\cf22 "Device Info"} << std::endl;\par
00074     o << d._id << std::endl;\par
00075     o << d._attributes;\par
00076 \par
00077     {\cf18 bool} f = {\cf17 true};\par
00078     {\cf19 for} ({\cf17 auto} i : d._peripherals)\par
00079     \{\par
00080         {\cf19 if} (f) o << std::endl;\par
00081         o << i.second;\par
00082 \par
00083         f = {\cf17 false};\par
00084     \}\par
00085 \par
00086     {\cf19 return} (o);\par
00087 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/IOPeripheral.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/IOPeripheral.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/IOPeripheral.cpp}
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/IOPeripheral.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IOPeripheral.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/IOPeripheral.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/IOPeripheral.cpp}
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/IOPeripheral.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} MCHEmul::IOPeripheral& d)\par
00005 \{\par
00006     o << {\cf22 "---"} << std::endl;\par
00007     o << {\cf22 "Peripheral Info"} << std::endl;\par
00008     o << d._id << std::endl;\par
00009     o << d._attributes;\par
00010 \par
00011     {\cf19 return} (o);\par
00012 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/ProgramCounter.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/ProgramCounter.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/ProgramCounter.cpp}
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/ProgramCounter.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ProgramCounter.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/ProgramCounter.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/ProgramCounter.cpp}
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/ProgramCounter.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} MCHEmul::ProgramCounter& pc)\par
00005 \{\par
00006     {\cf19 return} (o << pc._name << {\cf22 ":$"} << pc.asString (MCHEmul::UByte::OutputFormat::_HEXA));\par
00007 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/Register.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Register.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Register.cpp}
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Register.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Register.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Register.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Register.cpp}
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/Register.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} Register& r)\par
00005 \{ \par
00006     {\cf19 return} (o << r._name << {\cf22 "("} << r._id << {\cf22 "):$"} << r.asString (UByte::OutputFormat::_HEXA, {\cf23 ' '}, 2)); \par
00007 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/ScreenMemory.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/ScreenMemory.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/ScreenMemory.cpp}
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/ScreenMemory.hpp>}\par
{\f2 #include <assert.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ScreenMemory.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/ScreenMemory.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/ScreenMemory.cpp}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/ScreenMemory.hpp>}\par
00002 {\cf21 #include <assert.h>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 MCHEmul::ScreenMemory::ScreenMemory ({\cf18 size_t} c, {\cf18 size_t} r, {\cf18 unsigned} {\cf18 int}* p)\par
00006     : _frameData (nullptr),\par
00007       _columns (c), _rows (r), _colorPalette (p)\par
00008 \{ \par
00009     assert (_columns > 0 && _rows > 0);\par
00010     assert (_colorPalette != {\cf17 nullptr});\par
00011                             \par
00012     _frameData = {\cf17 new} {\cf18 unsigned} {\cf18 int} [_rows * _columns]; \par
00013 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/Stack.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Stack.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Stack.cpp}
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/Stack.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Stack.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/Stack.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/Stack.cpp}
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/Stack.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 {\cf18 void} MCHEmul::Stack::initialize ()\par
00005 \{ \par
00006     MCHEmul::PhisicalStorageSubset::initialize ();\par
00007 \par
00008     _position = _fromBack ? (int) (size () - 1) : 0; \par
00009     _stackOverflow = {\cf17 false}; \par
00010     _empty = {\cf17 true}; {\cf20 // No elements so far at the beginning...}\par
00011 \}\par
00012 \par
00013 {\cf20 // ---}\par
00014 {\cf18 void} MCHEmul::Stack::push ({\cf17 const} MCHEmul::UBytes& v)\par
00015 \{\par
00016     {\cf19 if} (_stackOverflow)\par
00017         {\cf19 return};\par
00018 \par
00019     _stackOverflow = {\cf17 false};\par
00020 \par
00021     {\cf19 for} (std::vector <MCHEmul::UByte>::const_iterator i = v.bytes ().begin (); \par
00022             i != v.bytes ().end () && !_stackOverflow; i++)\par
00023     \{\par
00024         {\cf20 // When the stack is filled from the highest address down to 0...}\par
00025         {\cf19 if} (_fromBack)\par
00026         \{\par
00027             {\cf20 // Filling from highest down to 0, but}\par
00028             {\cf20 // The stack pointer points to an empty position? }\par
00029             {\cf19 if} (_pointToEmpty)\par
00030             \{\par
00031                 {\cf20 // In that case, }\par
00032                 {\cf20 // If would be only possible to insert a new byte when that pointer is >= 0 (never less than 1)}\par
00033                 {\cf19 if} (!(_stackOverflow = (_position < 0)))\par
00034                 \{\par
00035                     set (initialAddress () + ({\cf18 size_t}) _position, (*i));\par
00036 \par
00037                     _position--; {\cf20 // After that it could be negative and no other insertion will allowed later!}\par
00038                 \}\par
00039             \}\par
00040             {\cf19 else}\par
00041             \{\par
00042                 {\cf20 // The pointer doesn't move after this first insertion!}\par
00043                 {\cf19 if} (_empty)\par
00044                     set (initialAddress () + ({\cf18 size_t}) _position, (*i)); {\cf20 // And not move the pointer...}\par
00045                 {\cf19 else}\par
00046                 \{\par
00047                     {\cf19 if} (!(_stackOverflow = (_position < 1)))\par
00048                     \{\par
00049                         _position--; {\cf20 // After that the position can become 0 not allowing insertions later!}\par
00050 \par
00051                         set (initialAddress () + ({\cf18 size_t}) _position, (*i));\par
00052                     \}\par
00053                 \}\par
00054             \}\par
00055         \}\par
00056         {\cf20 // When the stack is filled from the position 0 to the highest possible...}\par
00057         {\cf19 else}\par
00058         \{\par
00059             {\cf19 if} (_pointToEmpty)\par
00060             \{\par
00061                 {\cf19 if} (!(_stackOverflow = (({\cf18 size_t}) _position >= size ())))\par
00062                 \{\par
00063                     set (initialAddress () + ({\cf18 size_t}) _position, (*i));\par
00064 \par
00065                     _position++;\par
00066                 \}\par
00067             \}\par
00068             {\cf19 else}\par
00069             \{\par
00070                 {\cf19 if} (_empty)\par
00071                     set (initialAddress () + ({\cf18 size_t}) _position, (*i)); \par
00072                 {\cf19 else}\par
00073                 \{\par
00074                     {\cf19 if} (!(_stackOverflow = (({\cf18 size_t}) _position >= (size () - 1))))\par
00075                     \{\par
00076                         _position++;\par
00077 \par
00078                         set (initialAddress () + ({\cf18 size_t}) _position, (*i));\par
00079                     \}\par
00080                 \}\par
00081             \}\par
00082         \}\par
00083 \par
00084         _empty = {\cf17 false};\par
00085     \}\par
00086 \}\par
00087 \par
00088 {\cf20 // ---}\par
00089 MCHEmul::UBytes MCHEmul::Stack::pull ({\cf18 size_t} nV)\par
00090 \{\par
00091     {\cf19 if} (_stackOverflow || _empty)\par
00092         {\cf19 return} (MCHEmul::UBytes::_E); {\cf20 // nothing can be pull when error || empty!}\par
00093 \par
00094     std::vector <MCHEmul::UByte> dt = \{ \};\par
00095 \par
00096     _stackOverflow = {\cf17 false};\par
00097 \par
00098     {\cf19 for} ({\cf18 size_t} i = 0; i < nV && !_stackOverflow; i++)\par
00099     \{\par
00100         {\cf19 if} (_fromBack)\par
00101         \{\par
00102             {\cf19 if} (_pointToEmpty)\par
00103             \{\par
00104                 {\cf19 if} (!(_stackOverflow = (({\cf18 size_t}) _position >= size ())))\par
00105                 \{\par
00106                     _position++;\par
00107 \par
00108                     dt.push_back (value (initialAddress () + ({\cf18 size_t}) _position));\par
00109                 \}\par
00110             \}\par
00111             {\cf19 else}\par
00112             \{\par
00113                 {\cf19 if} (!(_stackOverflow = (({\cf18 size_t})_position >= (size () - 1))))\par
00114                 \{\par
00115                     dt.push_back (value (initialAddress () + ({\cf18 size_t}) _position));\par
00116 \par
00117                     _position++;\par
00118                 \}\par
00119             \}\par
00120         \}\par
00121         {\cf19 else}\par
00122         \{\par
00123             {\cf19 if} (_pointToEmpty)\par
00124             \{\par
00125                 {\cf19 if} (!(_stackOverflow = (_position < 0)))\par
00126                 \{\par
00127                     _position--;\par
00128 \par
00129                     dt.push_back (value (initialAddress () + ({\cf18 size_t}) _position));\par
00130                 \}\par
00131             \}\par
00132             {\cf19 else}\par
00133             \{\par
00134                 {\cf19 if} (!(_stackOverflow = (_position < 1)))\par
00135                 \{\par
00136                     dt.push_back (value (initialAddress () + ({\cf18 size_t}) _position));\par
00137 \par
00138                     _position--;\par
00139                 \}\par
00140             \}\par
00141         \}\par
00142     \}\par
00143 \par
00144     {\cf19 return} (MCHEmul::UBytes (dt));\par
00145 \}\par
00146 \par
00147 {\cf20 // ---}\par
00148 std::ostream& MCHEmul::operator << (std::ostream& o, {\cf17 const} MCHEmul::Stack& s)\par
00149 \{\par
00150     o << (*(static_cast <const MCHEmul::PhisicalStorageSubset*> (&s))) << std::endl;\par
00151     o << (s._fromBack ? {\cf22 "Back"} : {\cf22 "Front"}) << {\cf22 ","} << (s._pointToEmpty ? {\cf22 "Pointing empty"} : {\cf22 "Pointing last"}) << std::endl;\par
00152     o << (s._stackOverflow ? {\cf22 "Overflow"} : {\cf22 "No Overflow"}) << std::endl;\par
00153     o << (s._empty ? {\cf22 "Empty"} : {\cf22 "With data"}) << std::endl;\par
00154     o << {\cf22 "->"} << s.position ();\par
00155 \par
00156     {\cf19 return} (o);\par
00157 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/STACK.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/STACK.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/STACK.cpp}
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::PHA)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::PHP)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::PLA)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::PLP)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::TSX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::TXS)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:STACK.cpp}
{\xe \v STACK.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::PHA )}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b STACK.cpp}.}\par
}
{\xe \v _INST_IMPL\:STACK.cpp}
{\xe \v STACK.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::PHP )}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b STACK.cpp}.}\par
}
{\xe \v _INST_IMPL\:STACK.cpp}
{\xe \v STACK.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::PLA )}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 byte long.\par
}{
Definition at line {\b 25} of file {\b STACK.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_f6500_2_stack_8cpp_aa94d52e5c593cf633098e3af41e0e24f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:STACK.cpp}
{\xe \v STACK.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::PLP )}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 byte long.\par
}{
Definition at line {\b 40} of file {\b STACK.cpp}.}\par
}
{\xe \v _INST_IMPL\:STACK.cpp}
{\xe \v STACK.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::TSX )}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b STACK.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_f6500_2_stack_8cpp_a70cdfa78090424116610b37d5756c853_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:STACK.cpp}
{\xe \v STACK.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::TXS )}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b STACK.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
STACK.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/STACK.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/STACK.cpp}
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 _INST_IMPL (F6500::PHA)\par
00006 \{\par
00007     assert (parameters ().size () == 1);\par
00008 \par
00009     stack () -> push (cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR).values ()); {\cf20 // 1 byte long...}\par
00010 \par
00011     {\cf19 return} ({\cf17 true});\par
00012 \}\par
00013 \par
00014 {\cf20 // ---}\par
00015 _INST_IMPL (F6500::PHP)\par
00016 \{\par
00017     assert (parameters ().size () == 1);\par
00018 \par
00019     stack () -> push (cpu () -> statusRegister ().values ()); {\cf20 // 1 byte long...}\par
00020 \par
00021     {\cf19 return} ({\cf17 true});\par
00022 \}\par
00023 \par
00024 {\cf20 // ---}\par
00025 _INST_IMPL (F6500::PLA)\par
00026 \{\par
00027     assert (parameters ().size () == 1);\par
00028 \par
00029     MCHEmul::UBytes u = stack () -> pull (1 );\par
00030     cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR).set (u);\par
00031 \par
00032     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00033     st.setBitStatus ({\cf22 "N"}, u [0][7]);\par
00034     st.setBitStatus ({\cf22 "Z"}, u [0] == MCHEmul::UByte::_0);\par
00035 \par
00036     {\cf19 return} ({\cf17 true});\par
00037 \}\par
00038 \par
00039 {\cf20 // ---}\par
00040 _INST_IMPL (F6500::PLP)\par
00041 \{\par
00042     assert (parameters ().size () == 1);\par
00043 \par
00044     cpu () -> statusRegister ().set (stack () -> pull (1 ));\par
00045 \par
00046     {\cf19 return} ({\cf17 true});\par
00047 \}\par
00048 \par
00049 {\cf20 // ---}\par
00050 _INST_IMPL (F6500::TSX)\par
00051 \{\par
00052     assert (parameters ().size () == 1);\par
00053 \par
00054     MCHEmul::UBytes u (\{ ({\cf18 unsigned} char) stack () -> position () \});\par
00055     cpu () -> internalRegister (F6500::C6510::_XREGISTER).set (u);\par
00056 \par
00057     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00058     st.setBitStatus ({\cf22 "N"}, u [0][7]);\par
00059     st.setBitStatus ({\cf22 "Z"}, u [0] == MCHEmul::UByte::_0);\par
00060 \par
00061     {\cf19 return} ({\cf17 true});\par
00062 \}\par
00063 \par
00064 {\cf20 // ---}\par
00065 _INST_IMPL (F6500::TXS)\par
00066 \{\par
00067     assert (parameters ().size () == 1);\par
00068 \par
00069     stack () -> setPosition (({\cf18 int}) cpu () -> \par
00070         internalRegister (F6500::C6510::_XREGISTER).values ()[0].value ()); {\cf20 // 1 byte long...}\par
00071 \par
00072     {\cf19 return} ({\cf17 true});\par
00073 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/StatusRegister.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/StatusRegister.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/StatusRegister.cpp}
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/StatusRegister.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StatusRegister.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/StatusRegister.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/StatusRegister.cpp}
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/StatusRegister.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 MCHEmul::UBytes MCHEmul::StatusRegister::valuesWithout ({\cf17 const} std::vector <std::string>& bN)\par
00005 \{\par
00006     MCHEmul::UBytes result = values ();\par
00007     {\cf19 for} ({\cf17 auto} i : _bitNames)\par
00008         {\cf19 if} (std::find (bN.begin (), bN.end (), i.first) != bN.end ())\par
00009             result [i.second] = {\cf17 false};\par
00010     {\cf19 return} (result);\par
00011 \}\par
00012 \par
00013 {\cf20 // ---}\par
00014 std::string MCHEmul::StatusRegister::asString (){\cf17  const}\par
00015 {\cf17 }\{\par
00016     std::string result = _name + {\cf22 ":"};\par
00017     {\cf19 for} ({\cf17 auto} i : _bitNames)\par
00018         result += i.first + {\cf22 "("} + (bitStatus (i.first) ? {\cf22 "1"} : {\cf22 "0"}) + {\cf22 ")"};\par
00019 \par
00020     {\cf19 return} (result);\par
00021 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/UByte.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/UByte.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/UByte.cpp}
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/UByte.hpp>}\par
{\f2 #include <sstream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UByte.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/UByte.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/UByte.cpp}
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/UByte.hpp>}\par
00002 {\cf21 #include <sstream>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} MCHEmul::UByte::shiftLeftC ({\cf18 bool} c, {\cf18 size_t} p)\par
00006 \{\par
00007     MCHEmul::UByte nV = MCHEmul::UByte::_0;\par
00008 \par
00009     {\cf18 bool} nC = {\cf17 false}; {\cf20 // Adjusted later}\par
00010     {\cf19 for} ({\cf18 size_t} i = 0; i < p; i++)\par
00011     \{\par
00012         {\cf19 for} ({\cf18 size_t} j = MCHEmul::UByte::sizeBits () - 1; j >= 1; j--)\par
00013         \{\par
00014             {\cf19 if} (j == MCHEmul::UByte::sizeBits () - 1) \par
00015                 nC = bit (j);\par
00016 \par
00017             nV.setBit (j, bit (j - 1));\par
00018         \}\par
00019 \par
00020         nV.setBit (0, c);\par
00021     \}\par
00022 \par
00023     *{\cf17 this} = nV;\par
00024 \par
00025     {\cf19 return} (nC);\par
00026 \}\par
00027 \par
00028 {\cf20 // ---}\par
00029 {\cf18 bool} MCHEmul::UByte::shiftRightC ({\cf18 bool} c, {\cf18 size_t} p)\par
00030 \{\par
00031     MCHEmul::UByte nV = MCHEmul::UByte::_0;\par
00032 \par
00033     {\cf18 bool} nC = {\cf17 false}; {\cf20 // Adjusted later}\par
00034     {\cf19 for} ({\cf18 size_t} i = 0; i < p; i++)\par
00035     \{\par
00036         {\cf19 for} ({\cf18 size_t} j = 0; j < (MCHEmul::UByte::sizeBits () - 1); j++)\par
00037         \{\par
00038             {\cf19 if} (j == 0) \par
00039                 nC = bit (j);\par
00040 \par
00041             nV.setBit (j, bit (j + 1));\par
00042         \}\par
00043 \par
00044         nV.setBit (MCHEmul::UByte::sizeBits () - 1, c);\par
00045     \}\par
00046 \par
00047     *{\cf17 this} = nV;\par
00048 \par
00049     {\cf19 return} (nC);\par
00050 \}\par
00051 \par
00052 {\cf20 // ---}\par
00053 {\cf18 bool} MCHEmul::UByte::rotateLeftC ({\cf18 bool} c, {\cf18 size_t} p)\par
00054 \{\par
00055     {\cf18 bool} r = c;\par
00056     {\cf19 for} ({\cf18 size_t} i = 0; i < p; i++)\par
00057         r = shiftLeftC (r);\par
00058 \par
00059     {\cf19 return} (r);\par
00060 \}\par
00061 \par
00062 {\cf20 // ---}\par
00063 MCHEmul::UByte& MCHEmul::UByte::rotateLeft ({\cf18 size_t} p)\par
00064 \{\par
00065     {\cf19 for} ({\cf18 size_t} i = 0; i < p; i++) \par
00066         rotateLeftC (bit (sizeBits () - 1), 1);\par
00067 \par
00068     {\cf19 return} (*{\cf17 this});\par
00069 \}\par
00070 \par
00071 {\cf20 // ---}\par
00072 {\cf18 bool} MCHEmul::UByte::rotateRightC ({\cf18 bool} c, {\cf18 size_t} p)\par
00073 \{\par
00074     {\cf18 bool} r = c;\par
00075     {\cf19 for} ({\cf18 size_t} i = 0; i < p; i++)\par
00076         r = shiftRightC (r);\par
00077 \par
00078     {\cf19 return} (r);\par
00079 \}\par
00080 \par
00081 {\cf20 // ---}\par
00082 MCHEmul::UByte& MCHEmul::UByte::rotateRight ({\cf18 size_t} p)\par
00083 \{\par
00084     {\cf19 for} ({\cf18 size_t} i = 0; i < p; i++)\par
00085         rotateRightC (bit (0), 1);\par
00086 \par
00087     {\cf19 return} (*{\cf17 this});\par
00088 \}\par
00089 \par
00090 {\cf20 // ---}\par
00091 std::string MCHEmul::UByte::asString (MCHEmul::UByte::OutputFormat oF, {\cf18 size_t} l){\cf17  const}\par
00092 {\cf17 }\{\par
00093     std::string result = {\cf22 ""};\par
00094 \par
00095     std::stringstream ss;\par
00096     {\cf19 switch} (oF)\par
00097     \{\par
00098         {\cf19 case} MCHEmul::UByte::OutputFormat::_DECIMAL:\par
00099             result = std::to_string (_value);\par
00100             {\cf19 break};\par
00101 \par
00102         {\cf19 case} MCHEmul::UByte::OutputFormat::_BINARY:\par
00103             {\cf19 for} ({\cf18 size_t} i = 0; i < MCHEmul::UByte::sizeBits (); result = (bit (i++) ? {\cf22 "1"} : {\cf22 "0"}) + result);\par
00104             {\cf19 break};\par
00105 \par
00106         {\cf19 case} MCHEmul::UByte::OutputFormat::_OCTAL:\par
00107             ss.clear ();\par
00108             ss << std::oct << (int) _value;\par
00109             result = ss.str ();\par
00110             {\cf19 break};\par
00111 \par
00112         {\cf19 case} MCHEmul::UByte::OutputFormat::_HEXA:\par
00113         {\cf19 default}:\par
00114             ss.clear ();\par
00115             ss << std::hex << (int) _value;\par
00116             result = ss.str ();\par
00117             {\cf19 break};\par
00118     \}\par
00119 \par
00120     {\cf19 if} (result.length () < l)\par
00121         result = MCHEmul::_CEROS.substr (0, l - result.length ()) + result;\par
00122 \par
00123     {\cf19 return} (result);\par
00124 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/UBytes.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/UBytes.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/UBytes.cpp}
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/UBytes.hpp>}\par
{\f2 #include <algorithm>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UBytes.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/UBytes.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/UBytes.cpp}
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/UBytes.hpp>}\par
00002 {\cf21 #include <algorithm>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf17 const} MCHEmul::UBytes MCHEmul::UBytes::_E = MCHEmul::UBytes ();\par
00006 \par
00007 {\cf20 // ---}\par
00008 {\cf18 void} MCHEmul::UBytes::setMinLength ({\cf18 size_t} l, {\cf18 bool} r)\par
00009 \{\par
00010     {\cf18 size_t} s = size ();\par
00011     {\cf19 if} (s < l)\par
00012     \{\par
00013         {\cf19 for} ({\cf18 size_t} i = 0; i < (l - s); i++)\par
00014         \{\par
00015             {\cf19 if} (r) _values.push_back (MCHEmul::UByte::_0);\par
00016             {\cf19 else} _values.insert (_values.begin (), MCHEmul::UByte::_0);\par
00017         \}\par
00018     \}\par
00019 \}\par
00020 \par
00021 {\cf20 // ---}\par
00022 MCHEmul::UBytes MCHEmul::UBytes::complement (){\cf17  const}\par
00023 {\cf17 }\{\par
00024     MCHEmul::UBytes result = *{\cf17 this};\par
00025     {\cf19 for} ({\cf17 auto} &i : result._values) \par
00026         i = i.complement ();\par
00027     \par
00028     {\cf19 return} (result);\par
00029 \}\par
00030 \par
00031 {\cf20 // ---}\par
00032 {\cf18 bool} MCHEmul::UBytes::shiftLeftC ({\cf18 bool} c, {\cf18 size_t} p)\par
00033 \{\par
00034     {\cf18 bool} nC = c;\par
00035     {\cf19 for} ({\cf18 size_t} i = 0; i < p; i++)\par
00036     \{\par
00037         {\cf18 bool} mc = c;\par
00038         {\cf19 for} ({\cf18 int} j = ({\cf18 int}) (size () - 1); j >= 0; j--)\par
00039             mc = _values [({\cf18 size_t}) j].shiftLeftC (mc, 1);\par
00040         nC = mc;\par
00041     \}\par
00042 \par
00043     {\cf19 return} (nC);\par
00044 \}\par
00045 \par
00046 {\cf20 // ---}\par
00047 {\cf18 bool} MCHEmul::UBytes::shiftRightC ({\cf18 bool} c, {\cf18 size_t} p)\par
00048 \{\par
00049     {\cf18 bool} nC = c;\par
00050     {\cf19 for} ({\cf18 size_t} i = 0; i < p; i++)\par
00051     \{\par
00052         {\cf18 bool} mc = c;\par
00053         {\cf19 for} ({\cf18 size_t} j = 0; j < size (); j++)\par
00054             mc = _values [({\cf18 size_t}) j].shiftRightC (mc, 1);\par
00055         nC = mc;\par
00056     \}\par
00057 \par
00058     {\cf19 return} (nC);\par
00059 \}\par
00060 \par
00061 {\cf20 // ---}\par
00062 {\cf18 bool} MCHEmul::UBytes::rotateLeftC ({\cf18 bool} c, {\cf18 size_t} p)\par
00063 \{\par
00064     {\cf18 bool} nC = c;\par
00065     {\cf19 for} ({\cf18 size_t} i = 0; i < p; i++)\par
00066     \{\par
00067         {\cf18 bool} mc = c;\par
00068         {\cf19 for} ({\cf18 int} j = ({\cf18 int}) (size () - 1); j >= 0; j--)\par
00069             mc = _values [({\cf18 size_t}) j].rotateLeftC (mc, 1);\par
00070         nC = mc;\par
00071     \}\par
00072 \par
00073     {\cf19 return} (nC);\par
00074 \}\par
00075 \par
00076 {\cf20 // ---}\par
00077 MCHEmul::UBytes& MCHEmul::UBytes::rotateLeft ({\cf18 size_t} p)\par
00078 \{\par
00079     {\cf19 for} ({\cf18 size_t} i = 0; i < p; i++)\par
00080         rotateLeftC (bit (sizeBits () - 1), 1);\par
00081 \par
00082     {\cf19 return} (*{\cf17 this});\par
00083 \}\par
00084 \par
00085 {\cf20 // ---}\par
00086 {\cf18 bool} MCHEmul::UBytes::rotateRightC ({\cf18 bool} c, {\cf18 size_t} p)\par
00087 \{\par
00088     {\cf18 bool} nC = c;\par
00089     {\cf19 for} ({\cf18 size_t} i = 0; i < p; i++)\par
00090     \{\par
00091         {\cf18 bool} mc = c;\par
00092         {\cf19 for} ({\cf18 size_t} j = 0; j < size (); j++)\par
00093             mc = _values [({\cf18 size_t}) j].rotateRightC (mc, 1);\par
00094         nC = mc;\par
00095     \}\par
00096 \par
00097     {\cf19 return} (nC);\par
00098 \}\par
00099 \par
00100 {\cf20 // ---}\par
00101 MCHEmul::UBytes& MCHEmul::UBytes::rotateRight ({\cf18 size_t} p)\par
00102 \{\par
00103     {\cf19 for} ({\cf18 size_t} i = 0; i < p; i++)\par
00104         rotateRightC (bit (0), 1);\par
00105 \par
00106     {\cf19 return} (*{\cf17 this});\par
00107 \}\par
00108 \par
00109 {\cf20 // ---}\par
00110 MCHEmul::UBytes MCHEmul::UBytes::bitAdding ({\cf17 const} MCHEmul::UBytes& u, {\cf18 bool} cin, {\cf18 bool}& cout, {\cf18 bool}& o){\cf17  const}\par
00111 {\cf17 }\{\par
00112     {\cf20 // If the elements to add already have the same size, no silly copies are done...}\par
00113 \par
00114     MCHEmul::UBytes result = *{\cf17 this};\par
00115     cout = cin ;\par
00116     {\cf19 if} (size () != u.size ())\par
00117     \{\par
00118         MCHEmul::UBytes u2 = u;\par
00119         {\cf18 size_t} mL = std::max (result.size (), u2.size ());\par
00120         {\cf20 // The operation has to be done with UBytes of the same length...}\par
00121         result.setMinLength (mL, {\cf17 false} ); u2.setMinLength (mL, {\cf17 false});\par
00122 \par
00123         {\cf19 for} ({\cf18 int} i = ({\cf18 int}) (result.size () - 1); i >= 0; i--) \par
00124             result [i] = result [i].bitAdding (u2 [i], cout, cout, o);\par
00125     \}\par
00126     {\cf19 else}\par
00127     \{\par
00128         {\cf19 for} ({\cf18 int} i = ({\cf18 int}) (result.size () - 1); i >= 0; i--) \par
00129             result [i] = result [i].bitAdding (u [i], cout, cout, o);\par
00130     \}\par
00131 \par
00132     {\cf19 return} (result);\par
00133 \}\par
00134 \par
00135 {\cf20 // ---}\par
00136 MCHEmul::UBytes MCHEmul::UBytes::reverse (){\cf17  const}\par
00137 {\cf17 }\{\par
00138     std::vector <MCHEmul::UByte> dt;\par
00139     {\cf19 for} ({\cf17 auto} i = _values.rbegin (); i != _values.rend (); i++) dt.push_back (*i);\par
00140     {\cf19 return} (MCHEmul::UBytes (dt));\par
00141 \}\par
00142 \par
00143 {\cf20 // ---}\par
00144 {\cf18 bool} MCHEmul::UBytes::operator == ({\cf17 const} MCHEmul::UBytes& u){\cf17  const}\par
00145 {\cf17 }\{\par
00146     {\cf18 bool} result = (size () == u.size ());\par
00147     {\cf19 for} ({\cf18 size_t} i = 0; i < _values.size () && result; i++)\par
00148         result = (_values [i] == u._values [i]);\par
00149     {\cf19 return} (result);\par
00150 \}\par
00151 \par
00152 {\cf20 // ---}\par
00153 std::string MCHEmul::UBytes::asString (MCHEmul::UByte::OutputFormat oF, {\cf18 char} s, {\cf18 size_t} l){\cf17  const}\par
00154 {\cf17 }\{\par
00155     std::string result = {\cf22 ""};\par
00156 \par
00157     {\cf18 size_t} c = 0;\par
00158     {\cf19 for} ({\cf17 auto} i : _values)\par
00159         result += ((c++ != 0) ? std::string (1, s) : {\cf22 ""}) + i.asString (oF, l);\par
00160     {\cf19 return} (result);\par
00161 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/CORE/UInt.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/UInt.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/UInt.cpp}
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CORE/UInt.hpp>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <sstream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UInt.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/CORE/UInt.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/CORE/UInt.cpp}
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <CORE/UInt.hpp>}\par
00002 {\cf21 #include <algorithm>}\par
00003 {\cf21 #include <sstream>}\par
00004 \par
00005 {\cf20 // ---}\par
00006 MCHEmul::UInt::FormatManagers* MCHEmul::UInt::FormatManagers::_instance = {\cf17 nullptr};\par
00007 {\cf17 const} MCHEmul::UInt MCHEmul::UInt::_0 = MCHEmul::UInt (\{ MCHEmul::UByte::_0 \}, {\cf17 false}, {\cf17 false});\par
00008 {\cf17 const} MCHEmul::UInt MCHEmul::UInt::_1 = MCHEmul::UInt (\{ MCHEmul::UByte::_1 \}, {\cf17 false}, {\cf17 false});\par
00009 MCHEmul::UInt::FormatManagers MCHEmul::UInt::_formaters \par
00010     ( \{ \{ MCHEmul::UInt::_BINARY, {\cf17 new} MCHEmul::UInt::BinaryFormatManager \},\par
00011         \{ MCHEmul::UInt::_PACKAGEDBCD, {\cf17 new} MCHEmul::UInt::PackagedBCDFormatManager \} \} );\par
00012 \par
00013 {\cf20 // ---}\par
00014 MCHEmul::UInt MCHEmul::UInt::BinaryFormatManager::add \par
00015     ({\cf17 const} MCHEmul::UInt& u1, {\cf17 const} MCHEmul::UInt& u2, {\cf18 bool} cIn){\cf17  const}\par
00016 {\cf17 }\{ \par
00017     {\cf18 bool} c,o; \par
00018     MCHEmul::UInt result (u1._values.bitAdding (u2._values, cIn, c, o)); \par
00019     result._carry = c; result._overflow = o; \par
00020     {\cf19 return} (result);\par
00021 \}\par
00022 \par
00023 {\cf20 // ---}\par
00024 MCHEmul::UInt MCHEmul::UInt::BinaryFormatManager::substract \par
00025     ({\cf17 const} MCHEmul::UInt& u1, {\cf17 const} MCHEmul::UInt& u2, {\cf18 bool} cIn){\cf17  const}\par
00026 {\cf17 }\{ \par
00027     {\cf18 bool} c,o; \par
00028     MCHEmul::UInt result (u1._values.bitAdding (u2.complement ()._values, cIn, c, o)); \par
00029     result._carry = c; result._overflow = o; \par
00030     {\cf19 return} (result);\par
00031 \}\par
00032 \par
00033 {\cf20 // ---}\par
00034 {\cf18 unsigned} {\cf18 int} MCHEmul::UInt::BinaryFormatManager::asUnsignedInt ({\cf17 const} MCHEmul::UInt& u){\cf17  const}\par
00035 {\cf17 }\{\par
00036     {\cf18 unsigned} {\cf18 int} result = 0;\par
00037 \par
00038     {\cf18 int} c = 0;\par
00039     {\cf19 for} ({\cf18 int} i = ({\cf18 int}) (u.size () - 1); i >= 0; i--, c++)\par
00040         result += u._values [(size_t) i].value () << (c * MCHEmul::UByte::sizeBits ());\par
00041 \par
00042     {\cf19 return} (result);\par
00043 \}\par
00044 \par
00045 {\cf20 // ---}\par
00046 MCHEmul::UInt MCHEmul::UInt::BinaryFormatManager::fromUnsignedInt ({\cf18 unsigned} {\cf18 int} n)\par
00047 \{\par
00048     std::vector <MCHEmul::UByte> dt;\par
00049 \par
00050     {\cf18 size_t} nB = 1;\par
00051     {\cf19 while} ((n / (MCHEmul::UByte::_1 << (nB * MCHEmul::UByte::sizeBits ()))) != 0) nB++; \par
00052     \par
00053     {\cf18 unsigned} {\cf18 int} r = n;\par
00054     {\cf19 for} ({\cf18 size_t} i = nB - 1; i > 0; i--)\par
00055     \{\par
00056         {\cf18 unsigned} {\cf18 int} dv = MCHEmul::UByte::_1 << (i * MCHEmul::UByte::sizeBits ());\par
00057         dt.push_back (r / dv);\par
00058         r = r % dv;\par
00059     \}\par
00060 \par
00061     dt.push_back (r);\par
00062 \par
00063     {\cf19 return} (MCHEmul::UInt (MCHEmul::UBytes (dt), {\cf17 true}, MCHEmul::UInt::_BINARY));\par
00064 \}\par
00065 \par
00066 {\cf20 // ---}\par
00067 MCHEmul::UInt MCHEmul::UInt::BinaryFormatManager::fromInt ({\cf18 int} n)\par
00068 \{\par
00069     std::vector <MCHEmul::UByte> dt;\par
00070 \par
00071     {\cf20 // Negative?}\par
00072     {\cf18 unsigned} {\cf18 int} r = (n > 0) ? n : -n;\par
00073 \par
00074     {\cf18 size_t} nB = 1;\par
00075     {\cf19 while} ((r / (MCHEmul::UByte::_1 << (nB * MCHEmul::UByte::sizeBits ()))) != 0) nB++;\par
00076     {\cf19 if} (r > ({\cf18 unsigned} {\cf18 int}) (0x01 << (nB * MCHEmul::UByte::sizeBits () - 1))) nB++; {\cf20 // One bit more for the the sign...}\par
00077 \par
00078     {\cf19 for} ({\cf18 size_t} i = nB - 1; i > 0; i--)\par
00079     \{\par
00080         {\cf18 unsigned} {\cf18 int} dv = MCHEmul::UByte::_1 << (i * MCHEmul::UByte::sizeBits ());\par
00081         dt.push_back (r / dv);\par
00082         r = r % dv;\par
00083     \}\par
00084 \par
00085     dt.push_back (r);\par
00086 \par
00087     {\cf19 return} ((n < 0) \par
00088         ? MCHEmul::UInt (dt, {\cf17 true}, MCHEmul::UInt::_BINARY).complement_2 () \par
00089         : MCHEmul::UInt (dt, {\cf17 true}, MCHEmul::UInt::_BINARY));\par
00090 \}\par
00091 \par
00092 {\cf20 // ---}\par
00093 MCHEmul::UInt MCHEmul::UInt::PackagedBCDFormatManager::add \par
00094     ({\cf17 const} MCHEmul::UInt& u1, {\cf17 const} MCHEmul::UInt& u2, {\cf18 bool} cIn){\cf17  const}\par
00095 {\cf17 }\{\par
00096     {\cf20 // At this point both elements has the same size...}\par
00097 \par
00098     {\cf18 unsigned} {\cf18 short} r = 0;\par
00099     {\cf18 bool} c = cIn;\par
00100     MCHEmul::UInt result = u1;\par
00101     {\cf19 for} ({\cf18 int} i = ({\cf18 int}) (u2.bytes ().size () - 1); i >= 0; i--) \par
00102     \{\par
00103         r  = ({\cf18 unsigned} short) (result [i].value () & 0x0f) + \par
00104              ({\cf18 unsigned} {\cf18 short}) (u2 [i].value () & 0x0f) + (c ? 0x0001 : 0x0000);\par
00105         {\cf19 if} (r > ({\cf18 unsigned} {\cf18 short}) MCHEmul::UByte::_09) \par
00106             r += ({\cf18 unsigned} {\cf18 short}) MCHEmul::UByte::_06;\par
00107         r += ({\cf18 unsigned} short) (result [i].value () & 0xf0) +\par
00108              ({\cf18 unsigned} {\cf18 short}) (u2 [i].value () & 0xf0);\par
00109         {\cf19 if} ((r & 0x01f0) > ({\cf18 unsigned} short) MCHEmul::UByte::_90)\par
00110             r += ({\cf18 unsigned} short) MCHEmul::UByte::_60;\par
00111 \par
00112         c = r > 0x00ff;\par
00113         \par
00114         result [i] = ({\cf18 unsigned} char) r;\par
00115     \}\par
00116 \par
00117     result._carry = c;\par
00118     result._overflow = !((u1 [0].value () ^ u2 [0].value ()) & 0x80) && \par
00119         ((u1 [0].value () ^ result [0].value ()) & 0x80);\par
00120 \par
00121     {\cf19 return} (result);\par
00122 \}\par
00123 \par
00124 {\cf20 // ---}\par
00125 MCHEmul::UInt MCHEmul::UInt::PackagedBCDFormatManager::substract\par
00126     ({\cf17 const} MCHEmul::UInt& u1, {\cf17 const} MCHEmul::UInt& u2, {\cf18 bool} cIn){\cf17  const}\par
00127 {\cf17 }\{\par
00128     {\cf20 // At this point both elements has the same size...}\par
00129 \par
00130     {\cf18 unsigned} {\cf18 short} r = 0;\par
00131     {\cf18 bool} c = cIn;\par
00132     MCHEmul::UInt result = u1;\par
00133     {\cf19 for} ({\cf18 int} i = ({\cf18 int}) (u2.bytes ().size () - 1); i >= 0; i--) \par
00134     \{\par
00135         r  = ({\cf18 unsigned} short) (result [i].value () & 0x0f) -\par
00136              ({\cf18 unsigned} {\cf18 short}) (u2 [i].value () & 0x0f) - (c ? 0x0000 : 0x0001);\par
00137         r = ((r & 0x0010) != 0x0000) \par
00138                 ? ((r - ({\cf18 unsigned} short) MCHEmul::UByte::_06) & 0x000f) | \par
00139                   (({\cf18 unsigned} {\cf18 short}) (result [i].value () & 0xf0) - ({\cf18 unsigned} {\cf18 short}) (u2 [i].value () & 0xf0) - ({\cf18 unsigned} {\cf18 short}) 0x10)\par
00140                 : (r & 0x000f) | \par
00141                   (({\cf18 unsigned} short) (result [i].value () & 0xf0) - ({\cf18 unsigned} {\cf18 short}) (u2 [i].value () & 0xf0));\par
00142         {\cf19 if} ((r & 0x0100) != 0x0000)\par
00143             r -= ({\cf18 unsigned} {\cf18 short}) MCHEmul::UByte::_60;\par
00144 \par
00145         c = r < 0x0100;\par
00146         \par
00147         result [i] = ({\cf18 unsigned} char) r;\par
00148     \}\par
00149 \par
00150     result._carry = c;\par
00151     result._overflow = ((u1 [0].value () ^ u2 [0].value ()) & 0x80) && \par
00152         ((u1 [0].value () ^ result [0].value ()) & 0x80);\par
00153 \par
00154     {\cf19 return} (result);\par
00155 \}\par
00156 \par
00157 {\cf20 // ---}\par
00158 {\cf18 unsigned} {\cf18 int} MCHEmul::UInt::PackagedBCDFormatManager::asUnsignedInt ({\cf17 const} UInt& u){\cf17  const}\par
00159 {\cf17 }\{\par
00160     {\cf18 unsigned} {\cf18 int} result = 0;\par
00161 \par
00162     {\cf18 int} c = 1;\par
00163     {\cf19 for} ({\cf18 int} i = ({\cf18 int}) (u.size () - 1); i >= 0; i -= 2, c *= 100)\par
00164         result += ((((u._values [(size_t) i].value () & 0xf0) >> 4) * 10) + (u._values [({\cf18 size_t}) i].value () & 0x0f)) * c;\par
00165 \par
00166     {\cf19 return} (result);\par
00167 \}\par
00168 \par
00169 {\cf20 // ---}\par
00170 MCHEmul::UInt MCHEmul::UInt::PackagedBCDFormatManager::fromUnsignedInt ({\cf18 unsigned} {\cf18 int} n)\par
00171 \{\par
00172     std::vector <MCHEmul::UByte> dt;\par
00173 \par
00174     std::string nS = std::to_string (n);\par
00175     {\cf19 for} ({\cf18 int} i = (({\cf18 int}) nS.length () - 1); i >= 0; i -= 2) {\cf20 // It can be negative..}\par
00176     \{\par
00177         {\cf19 if} (i == 0) {\cf20 // odd number of digits...}\par
00178             dt.insert (dt.begin (), nS [i] - {\cf23 '0'});\par
00179         {\cf19 else} \par
00180             dt.insert (dt.begin (), ((nS [i - 1] - {\cf23 '0'}) << 4 ) | (nS [i] - {\cf23 '0'} ));\par
00181     \}\par
00182 \par
00183     {\cf19 return} (MCHEmul::UInt (MCHEmul::UBytes (dt), {\cf17 true}, MCHEmul::UInt::_PACKAGEDBCD));\par
00184 \}\par
00185 \par
00186 {\cf20 // ---}\par
00187 MCHEmul::UInt MCHEmul::UInt::PackagedBCDFormatManager::fromInt ({\cf18 int} n)\par
00188 \{\par
00189     std::vector <MCHEmul::UByte> dt;\par
00190 \par
00191     {\cf20 // Negative?}\par
00192     {\cf18 unsigned} {\cf18 int} r = (n > 0) ? n : -n;\par
00193 \par
00194     std::string nS = std::to_string (r);\par
00195     {\cf19 for} ({\cf18 int} i = (({\cf18 int}) nS.length () - 1); i >= 0; i -= 2) {\cf20 // It might be negative..}\par
00196     \{\par
00197         {\cf19 if} (i == 0) {\cf20 // odd number of digits...}\par
00198             dt.insert (dt.begin (), nS [i] - {\cf23 '0'});\par
00199         {\cf19 else} \par
00200             dt.insert (dt.begin (), ((nS [i - 1] - {\cf23 '0'}) << 4 ) | (nS [i] - {\cf23 '0'} ));\par
00201     \}\par
00202 \par
00203     {\cf20 // In case the number (abs) is bigger than the maximum allowed at the saize already calculated...}\par
00204     {\cf19 if} (r > ({\cf18 unsigned} {\cf18 int}) std::pow (100, dt.size ())) dt.insert (dt.begin (), 0); {\cf20 // One bit more for the sign...}\par
00205 \par
00206     {\cf19 return} ((n < 0) \par
00207         ? MCHEmul::UInt (dt, {\cf17 true}, MCHEmul::UInt::_PACKAGEDBCD).complement_2 () \par
00208         : MCHEmul::UInt (dt, {\cf17 true}, MCHEmul::UInt::_PACKAGEDBCD));\par
00209 \}\par
00210 \par
00211 {\cf20 // ---}\par
00212 MCHEmul::UInt MCHEmul::UInt::add ({\cf17 const} MCHEmul::UInt& u, {\cf18 bool} iC){\cf17  const}\par
00213 {\cf17 }\{\par
00214     {\cf19 if} (_format != u._format)\par
00215         {\cf19 return} (MCHEmul::UInt::_0); {\cf20 // Impossible to add different "structures"}\par
00216 \par
00217     MCHEmul::UInt result;\par
00218     {\cf19 if} (size () != u.size ())\par
00219     \{\par
00220         {\cf18 size_t} l = std::max (size (), u.size ());\par
00221         MCHEmul::UInt u1 = *{\cf17 this}; MCHEmul::UInt u2 = u;\par
00222         u1.setMinLength (l); u2.setMinLength (l);\par
00223 \par
00224         result = MCHEmul::UInt::_formaters._formatManagers [_format] -> add (u1, u2, iC);\par
00225     \}\par
00226     {\cf19 else}\par
00227         result = MCHEmul::UInt::_formaters._formatManagers [_format] -> add (*{\cf17 this}, u, iC);\par
00228 \par
00229     {\cf19 return} (result);\par
00230 \}\par
00231 \par
00232 {\cf20 // ---}\par
00233 MCHEmul::UInt MCHEmul::UInt::substract ({\cf17 const} MCHEmul::UInt& u, {\cf18 bool} iC){\cf17  const}\par
00234 {\cf17 }\{\par
00235     {\cf19 if} (_format != u._format)\par
00236         {\cf19 return} (MCHEmul::UInt::_0); {\cf20 // Impossible to add different "structures"}\par
00237 \par
00238     MCHEmul::UInt result;\par
00239     {\cf19 if} (size () != u.size ())\par
00240     \{\par
00241         {\cf18 size_t} l = std::max (size (), u.size ());\par
00242         MCHEmul::UInt u1 = *{\cf17 this}; MCHEmul::UInt u2 = u;\par
00243         u1.setMinLength (l); u2.setMinLength (l);\par
00244 \par
00245         result = MCHEmul::UInt::_formaters._formatManagers [_format] -> substract (u1, u2, iC);\par
00246     \}\par
00247     {\cf19 else}\par
00248         result = MCHEmul::UInt::_formaters._formatManagers [_format] -> substract (*{\cf17 this}, u, iC);\par
00249 \par
00250     {\cf19 return} (result);\par
00251 \}\par
00252 \par
00253 {\cf20 // ---}\par
00254 MCHEmul::UInt MCHEmul::UInt::multiply ({\cf17 const} MCHEmul::UInt& u){\cf17  const}\par
00255 {\cf17 }\{\par
00256     MCHEmul::UInt result = *{\cf17 this};\par
00257     MCHEmul::UInt u2 = u;\par
00258 \par
00259     {\cf20 // Is the final outcome going to be negative?}\par
00260     {\cf18 bool} neg = (result.negative () && u.positive ()) | \par
00261         (result.positive () && u.negative ());\par
00262 \par
00263     {\cf20 // All positive just for calculus...}\par
00264     {\cf19 if} (result.negative ()) result = result.complement_2 ();\par
00265     {\cf19 if} (u2.negative ()) u2 = u2.complement_2 ();\par
00266 \par
00267     {\cf20 // Do the calculus...}\par
00268     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = ({\cf18 unsigned} {\cf18 int}) u2.asInt () ; \par
00269             i > 0; i--, result += u2);\par
00270 \par
00271     {\cf20 // The sign is assigned at the end!}\par
00272     {\cf19 if} (neg) result = result.complement_2 ();\par
00273 \par
00274     {\cf19 return} (result);\par
00275 \}\par
00276 \par
00277 {\cf20 // ---}\par
00278 MCHEmul::UInt MCHEmul::UInt::fromStr ({\cf17 const} std::string& s, {\cf18 unsigned} {\cf18 char} f)\par
00279 \{\par
00280     MCHEmul::UInt result;\par
00281 \par
00282     {\cf19 if} (s == {\cf22 ""})\par
00283         {\cf19 return} (result);\par
00284 \par
00285     {\cf18 bool} n = {\cf17 false};\par
00286     std::string str = s;\par
00287     {\cf19 if} (str [0] == {\cf23 '-'})\par
00288     \{\par
00289         n = {\cf17 true};\par
00290         str = str.substr (1);\par
00291     \}\par
00292 \par
00293     {\cf19 if} (!MCHEmul::validBytes (str))\par
00294         {\cf19 return} (result);\par
00295 \par
00296     {\cf19 switch} (str [0])\par
00297     \{\par
00298         {\cf19 case} {\cf23 '$'}:\par
00299         \{\par
00300             {\cf18 unsigned} {\cf18 int} i;\par
00301             std::istringstream ss (str.substr (1));\par
00302             ss >> std::hex >> i;\par
00303             result = MCHEmul::UInt::fromUnsignedInt (i, f); {\cf20 // Big - endian}\par
00304         \}\par
00305         \par
00306         {\cf19 break};\par
00307 \par
00308         {\cf19 case} {\cf23 '0'}:\par
00309         \{\par
00310             {\cf18 unsigned} {\cf18 int} i = 0;\par
00311             {\cf19 if} (str.length () != 0)\par
00312             \{\par
00313                 std::istringstream ss (str.substr (1));\par
00314                 ss >> std::oct >> i;\par
00315             \}\par
00316             \par
00317             result = MCHEmul::UInt::fromUnsignedInt (i, f); {\cf20 // Big - endian}\par
00318         \}\par
00319         \par
00320         {\cf19 break};\par
00321 \par
00322         {\cf19 default}:\par
00323         \{\par
00324             {\cf18 unsigned} {\cf18 int} i;\par
00325             std::istringstream ss (str);\par
00326             ss >> std::dec >> i;\par
00327             result = MCHEmul::UInt::fromUnsignedInt (i, f); {\cf20 // Big - endian}\par
00328         \}\par
00329             \par
00330         {\cf19 break};\par
00331     \}\par
00332 \par
00333     {\cf19 if} (n)\par
00334         result = -result;\par
00335 \par
00336     {\cf19 return} (result);\par
00337 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/EMULATORS/C64Emulator.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/EMULATORS/C64Emulator.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/EMULATORS/C64Emulator.cpp}
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <EMULATORS/C64Emulator.hpp>}\par
{\f2 #include <C64/C64.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C64Emulator.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/EMULATORS/C64Emulator.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/EMULATORS/C64Emulator.cpp}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <EMULATORS/C64Emulator.hpp>}\par
00002 {\cf21 #include <C64/C64.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf17 const} {\cf18 unsigned} {\cf18 char} Emuls::C64Emulator::_PARAMNTSC = {\cf23 'n'};\par
00006 {\cf17 const} std::string Emuls::C64Emulator::_NTSC = {\cf22 "NTSC"};\par
00007 \par
00008 {\cf20 // ---}\par
00009 {\cf18 bool} Emuls::C64Emulator::initialize ()\par
00010 \{\par
00011     {\cf19 if} (!Emuls::Emulator::initialize ())\par
00012         {\cf19 return} ({\cf17 false});\par
00013 \par
00014     {\cf20 // TODO}\par
00015     {\cf20 // To link the peripherals...}\par
00016 \par
00017     {\cf19 return} ({\cf17 true});\par
00018 \}\par
00019 \par
00020 {\cf20 // ---}\par
00021 Emuls::C64Emulator::C64Emulator ({\cf17 const} std::vector <std::string>& argv)\par
00022     : Emuls::Emulator (argv)\par
00023 \{\par
00024     {\cf17 static} std::map <unsigned char, std::string> _MATCH =\par
00025         \{ \{ _PARAMNTSC, _NTSC \} \};\par
00026 \par
00027     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 1 ; i < argv.size (); i++)\par
00028     \{\par
00029         std::map <unsigned char, std::string>::const_iterator p;\par
00030         {\cf19 if} (argv [i].length () < 2 || argv [i][0] != {\cf23 '/'} || \par
00031             (p = _MATCH.find (argv [i][1])) == _MATCH.end ())\par
00032             {\cf19 continue}; {\cf20 // Not valid argument...}\par
00033         _attributes [(*p).second] = argv [i].substr (2);\par
00034     \}\par
00035 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/EMULATORS/Emulator.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/EMULATORS/Emulator.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/EMULATORS/Emulator.cpp}
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <EMULATORS/Emulator.hpp>}\par
{\f2 #include <SDL.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Emulator.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/EMULATORS/Emulator.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/EMULATORS/Emulator.cpp}
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <EMULATORS/Emulator.hpp>}\par
00002 {\cf21 #include <SDL.h>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf17 const} {\cf18 unsigned} {\cf18 char} Emuls::Emulator::_PARAMBYTEFILE = {\cf23 'f'};\par
00006 {\cf17 const} std::string Emuls::Emulator::_BYTEFILE = {\cf22 "BYTEFILE"};\par
00007 {\cf17 const} {\cf18 unsigned} {\cf18 char} Emuls::Emulator::_PARAMASMFILE = {\cf23 'c'};\par
00008 {\cf17 const} std::string Emuls::Emulator::_ASMFILE = {\cf22 "ASMFILE"};\par
00009 {\cf17 const} {\cf18 unsigned} {\cf18 char} Emuls::Emulator::_PARAMLOGLEVEL = {\cf23 'l'};\par
00010 {\cf17 const} std::string Emuls::Emulator::_LOGLEVEL = {\cf22 "LOGLEVEL"};\par
00011 {\cf17 const} {\cf18 unsigned} {\cf18 char} Emuls::Emulator::_PARAMADDRESS = {\cf23 'a'};\par
00012 {\cf17 const} std::string Emuls::Emulator::_ADDRESS = {\cf22 "ADDRESS"};\par
00013 \par
00014 {\cf20 // ---}\par
00015 Emuls::Emulator::Emulator ({\cf17 const} std::vector <std::string>& argv)\par
00016     : _attributes (),\par
00017       _communicationSystem (nullptr),\par
00018       _debugLevel (MCHEmul::_DEBUGNOTHING),\par
00019       _computer (nullptr),\par
00020       _peripheralBuilder (nullptr),\par
00021       _running (false),\par
00022       _lastError (MCHEmul::_NOERROR),\par
00023       _lastAction (0)\par
00024 \{\par
00025     {\cf17 static} std::map <unsigned char, std::string> _MATCH =\par
00026         \{ \{ _PARAMBYTEFILE, _BYTEFILE \},\par
00027           \{ _PARAMASMFILE, _ASMFILE \},\par
00028           \{ _PARAMLOGLEVEL, _LOGLEVEL \},\par
00029           \{ _PARAMADDRESS, _ADDRESS \} \};\par
00030 \par
00031     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 1 ; i < argv.size (); i++)\par
00032     \{\par
00033         std::map <unsigned char, std::string>::const_iterator p;\par
00034         {\cf19 if} (argv [i].length () < 2 || argv [i][0] != {\cf23 '/'} || \par
00035             (p = _MATCH.find (argv [i][1])) == _MATCH.end ())\par
00036             {\cf19 continue}; {\cf20 // Not valid argument...}\par
00037         _attributes [(*p).second] = argv [i].substr (2);\par
00038     \}\par
00039 \par
00040     {\cf20 // The graphical and IO system used is based on SDL...}\par
00041     {\cf18 int} sdlE = 0;\par
00042     sdlE += SDL_Init (SDL_INIT_VIDEO);\par
00043     sdlE += SDL_InitSubSystem (SDL_INIT_JOYSTICK);\par
00044     {\cf19 if} (sdlE != 0)\par
00045         _lastError = MCHEmul::_INIT_ERROR;\par
00046     {\cf19 else}\par
00047         SDL_JoystickEventState (SDL_ENABLE);\par
00048 \}\par
00049 \par
00050 {\cf20 // ---}\par
00051 {\cf18 void} Emuls::Emulator::setCommunicationSystem (MCHEmul::CommunicationSystem* cS)\par
00052 \{\par
00053     {\cf19 if} (_running)\par
00054         {\cf19 return};\par
00055 \par
00056     _communicationSystem = cS;\par
00057 \}\par
00058 \par
00059 {\cf20 // ---}\par
00060 Emuls::Emulator::~Emulator ()\par
00061 \{ \par
00062     {\cf17 delete} (_communicationSystem);\par
00063 \par
00064     {\cf17 delete} (_computer); \par
00065 \par
00066     {\cf17 delete} (_peripheralBuilder);\par
00067 \par
00068     SDL_Quit ();\par
00069 \}\par
00070 \par
00071 {\cf20 // ---}\par
00072 {\cf18 void} Emuls::Emulator::addAction ({\cf17 const} MCHEmul::Address& at, {\cf18 unsigned} {\cf18 int} a)\par
00073 \{\par
00074     Emuls::Emulator::MapOfActions::iterator i = _actionsAt.find (at);\par
00075     {\cf19 if} (i == _actionsAt.end ()) _actionsAt.insert (Emuls::Emulator::MapOfActions::value_type (at, a));\par
00076     {\cf19 else} (*i).second = a;\par
00077 \}\par
00078 \par
00079 {\cf20 // ---}\par
00080 {\cf18 void} Emuls::Emulator::removeAction ({\cf17 const} MCHEmul::Address& at)\par
00081 \{\par
00082     Emuls::Emulator::MapOfActions::iterator i = _actionsAt.find (at);\par
00083     {\cf19 if} (i != _actionsAt.end ()) \par
00084         _actionsAt.erase (i);\par
00085 \}\par
00086 \par
00087 {\cf20 // ---}\par
00088 {\cf18 bool} Emuls::Emulator::initialize ()\par
00089 \{\par
00090     {\cf19 if} (_lastError != MCHEmul::_NOERROR)\par
00091     \{\par
00092         std::cout << {\cf22 "The emulator was not well created"} << std::endl;\par
00093 \par
00094         {\cf19 return} ({\cf17 false});\par
00095     \}\par
00096 \par
00097     setDebugLevel (logLevel ());\par
00098 \par
00099     {\cf19 if} (!computer () -> initialize ()) \par
00100     \{\par
00101         {\cf19 if} (_debugLevel >= MCHEmul::_DEBUGERRORS)\par
00102             std::cout << {\cf22 "Error initializing computer"} << std::endl;\par
00103 \par
00104         {\cf19 return} ({\cf17 false});\par
00105     \}\par
00106 \par
00107     {\cf19 if} (_communicationSystem != {\cf17 nullptr} && !_communicationSystem -> initialize ())\par
00108     \{\par
00109         {\cf19 if} (_debugLevel >= MCHEmul::_DEBUGERRORS)\par
00110             std::cout << {\cf22 "Error initializing communications"} << std::endl;\par
00111 \par
00112         {\cf19 return} ({\cf17 false});\par
00113     \}\par
00114 \par
00115     {\cf19 if} (_debugLevel >= MCHEmul::_DEBUGTRACEINTERNALS)\par
00116         std::cout << *computer () << std::endl;\par
00117 \par
00118     {\cf19 if} (byteFileName () != {\cf22 ""} && asmFileName () == {\cf22 ""})\par
00119     \{\par
00120         {\cf18 bool} r = computer () -> loadInto (byteFileName (), MCHEmul::Address (\{ 0x00, 0x00 \}));\par
00121         {\cf19 if} (!r)\par
00122         \{\par
00123             {\cf19 if} (_debugLevel >= MCHEmul::_DEBUGERRORS)\par
00124                 std::cout << {\cf22 "Error loading file: "} << byteFileName () << std::endl;\par
00125 \par
00126             {\cf19 return} ({\cf17 false});\par
00127         \}\par
00128     \}\par
00129 \par
00130     {\cf19 if} (asmFileName () != {\cf22 ""} && byteFileName () == {\cf22 ""})\par
00131     \{\par
00132         MCHEmul::Assembler::Parser parser (computer () -> cpu ());\par
00133         MCHEmul::Assembler::Compiler compiler (parser);\par
00134         MCHEmul::Assembler::ByteCode cL = compiler.compile (asmFileName ());\par
00135 \par
00136         {\cf19 if} (!compiler)\par
00137         \{\par
00138             {\cf19 if} (_debugLevel >= MCHEmul::_DEBUGERRORS)\par
00139                 {\cf19 for} ({\cf17 auto} i : compiler.errors ())\par
00140                     std::cout << i << std::endl;\par
00141 \par
00142             {\cf19 return} ({\cf17 false});\par
00143         \}\par
00144         {\cf19 else}\par
00145         \{\par
00146             {\cf19 if} (_debugLevel >= MCHEmul::_DEBUGALL)\par
00147                 {\cf19 for} ({\cf17 auto} i : cL._lines)\par
00148                     std::cout << i << std::endl;\par
00149         \}\par
00150 \par
00151         MCHEmul::Address iA; \par
00152         std::vector <MCHEmul::UByte> bt = cL.asSetOfBytes (iA);\par
00153         computer () -> memory () -> set (iA, bt);\par
00154         setActions (cL.listOfActions ());\par
00155 \par
00156         {\cf20 // Parser and compiler are destroyed here...}\par
00157     \}\par
00158 \par
00159     {\cf19 if} (startingAddress () != MCHEmul::Address ())\par
00160         computer () -> cpu () -> programCounter ().setAddress (startingAddress ());\par
00161 \par
00162     {\cf19 return} ({\cf17 true});\par
00163 \}\par
00164 \par
00165 {\cf20 // ---}\par
00166 {\cf18 bool} Emuls::Emulator::run ()\par
00167 \{\par
00168     _running = {\cf17 true};\par
00169 \par
00170     {\cf19 while} (runCycle () && \par
00171            !computer () -> exit ());\par
00172 \par
00173     {\cf19 if} (_communicationSystem != {\cf17 nullptr})\par
00174         _communicationSystem -> finalize ();\par
00175 \par
00176     _running = {\cf17 false};\par
00177 \par
00178     {\cf19 return} (computer () -> lastError () != MCHEmul::_NOERROR);\par
00179 \}\par
00180 \par
00181 {\cf20 // ---}\par
00182 {\cf18 bool} Emuls::Emulator::runCycle ({\cf18 unsigned} {\cf18 int} a)\par
00183 \{\par
00184     {\cf18 bool} result = {\cf17 true};\par
00185 \par
00186     computer () -> startsCycle ();\par
00187 \par
00188     {\cf20 // Is there any external action to take into account...}\par
00189     {\cf18 unsigned} {\cf18 int} fA = a; {\cf20 // By default..only the one passedf to this method will be taken into account!}\par
00190     {\cf19 if} (_communicationSystem != {\cf17 nullptr})\par
00191     \{\par
00192         {\cf18 unsigned} {\cf18 int} eA = _communicationSystem -> processMessagesOn (computer ());\par
00193         {\cf19 if} (a == 0  && eA != 0 ) \par
00194             fA = eA; {\cf20 // If there is no emulator action passed to this method and}\par
00195                      {\cf20 // there is one external, then the external is taken into account...}\par
00196     \}\par
00197 \par
00198     Emuls::Emulator::MapOfActions::const_iterator at = \par
00199         _actionsAt.find (computer () -> cpu () -> programCounter ().asAddress ());\par
00200     {\cf19 if} (executeAction (_lastAction {\cf20 /* can be modified within the method. */}, \par
00201             (at == _actionsAt.end ()) ? 0 : (*at).second, fA))\par
00202         result &= computer () -> runComputerCycle ();\par
00203 \par
00204     result &= computer () -> runIOCycle ();\par
00205     result &= additionalRunCycle ();\par
00206 \par
00207     computer () -> finishCycle ();\par
00208 \par
00209     {\cf19 return} (result);\par
00210 \}\par
00211 \par
00212 {\cf20 // ---}\par
00213 {\cf18 bool} Emuls::Emulator::executeAction ({\cf18 unsigned} {\cf18 int}& lA, {\cf18 unsigned} {\cf18 int} at, {\cf18 unsigned} {\cf18 int} a)\par
00214 \{\par
00215     {\cf20 // TODO}\par
00216 \par
00217     {\cf19 return} ({\cf17 true});\par
00218 \}\par
00219 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/ADC.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/ADC.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/ADC.cpp}
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ADC_Inmediate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ADC_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ADC_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ADC_ZeroPageIndirectX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ADC_ZeroPageIndirectY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ADC_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ADC_AbsoluteX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ADC_AbsoluteY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:ADC.cpp}
{\xe \v ADC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ADC_Absolute )}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b ADC.cpp}.}\par
}
{\xe \v _INST_IMPL\:ADC.cpp}
{\xe \v ADC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ADC_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b ADC.cpp}.}\par
}
{\xe \v _INST_IMPL\:ADC.cpp}
{\xe \v ADC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ADC_AbsoluteY )}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b ADC.cpp}.}\par
}
{\xe \v _INST_IMPL\:ADC.cpp}
{\xe \v ADC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ADC_Inmediate )}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b ADC.cpp}.}\par
}
{\xe \v _INST_IMPL\:ADC.cpp}
{\xe \v ADC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ADC_ZeroPage )}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b ADC.cpp}.}\par
}
{\xe \v _INST_IMPL\:ADC.cpp}
{\xe \v ADC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ADC_ZeroPageIndirectX )}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b ADC.cpp}.}\par
}
{\xe \v _INST_IMPL\:ADC.cpp}
{\xe \v ADC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ADC_ZeroPageIndirectY )}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b ADC.cpp}.}\par
}
{\xe \v _INST_IMPL\:ADC.cpp}
{\xe \v ADC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ADC_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b ADC.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ADC.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/ADC.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/ADC.cpp}
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::ADC_General::executeWith (MCHEmul::UByte u)\par
00006 \{\par
00007     MCHEmul::Register& a = cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR);\par
00008     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00009     \par
00010     {\cf20 // Calculate the addition...}\par
00011     {\cf18 unsigned} {\cf18 char} ft = st.bitStatus ({\cf22 "D"}) ? MCHEmul::UInt::_PACKAGEDBCD : MCHEmul::UInt::_BINARY; {\cf20 // In BCD?}\par
00012     MCHEmul::UInt r = MCHEmul::UInt (a.values () , {\cf17 false}, ft).\par
00013         add (MCHEmul::UInt (\{ u \}, {\cf17 false}, ft), st.bitStatus ({\cf22 "C"}));\par
00014     a.set (r.bytes ()); {\cf20 // The carry register is taken into account in the addition...}\par
00015 \par
00016     {\cf20 // Time of the status register...}\par
00017     st.setBitStatus ({\cf22 "N"}, r.negative ());\par
00018     st.setBitStatus ({\cf22 "V"}, r.overflow ());\par
00019     st.setBitStatus ({\cf22 "Z"}, r == MCHEmul::UInt::_0);\par
00020     st.setBitStatus ({\cf22 "C"}, r.carry ());\par
00021 \par
00022     {\cf19 return} ({\cf17 true});\par
00023 \}\par
00024 \par
00025 {\cf20 // ---}\par
00026 _INST_IMPL (F6500::ADC_Inmediate)\par
00027 \{\par
00028     {\cf19 return} (executeWith (value_inmediate ()));\par
00029 \}\par
00030 \par
00031 {\cf20 // ---}\par
00032 _INST_IMPL (F6500::ADC_Absolute)\par
00033 \{\par
00034     {\cf19 return} (executeWith (value_absolute ()));\par
00035 \}\par
00036 \par
00037 {\cf20 // ---}\par
00038 _INST_IMPL (F6500::ADC_ZeroPage)\par
00039 \{\par
00040     {\cf19 return} (executeWith (value_zeroPage ()));\par
00041 \}\par
00042 \par
00043 {\cf20 // ---}\par
00044 _INST_IMPL (F6500::ADC_ZeroPageIndirectX)\par
00045 \{\par
00046     {\cf19 return} (executeWith (value_indirectZeroPageX ()));\par
00047 \}\par
00048 \par
00049 {\cf20 // ---}\par
00050 _INST_IMPL (F6500::ADC_ZeroPageIndirectY)\par
00051 \{\par
00052     {\cf19 return} (executeWith (value_indirectZeroPageY ()));\par
00053 \}\par
00054 \par
00055 {\cf20 // ---}\par
00056 _INST_IMPL (F6500::ADC_ZeroPageX)\par
00057 \{\par
00058     {\cf19 return} (executeWith (value_zeroPageX ()));\par
00059 \}\par
00060 \par
00061 {\cf20 // ---}\par
00062 _INST_IMPL (F6500::ADC_AbsoluteX)\par
00063 \{\par
00064     {\cf19 return} (executeWith (value_absoluteX ()));\par
00065 \}\par
00066 \par
00067 {\cf20 // ---}\par
00068 _INST_IMPL (F6500::ADC_AbsoluteY)\par
00069 \{\par
00070     {\cf19 return} (executeWith (value_absoluteY ()));\par
00071 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/AND.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/AND.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/AND.cpp}
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::AND_Inmediate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::AND_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::AND_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::AND_ZeroPageIndirectX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::AND_ZeroPageIndirectY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::AND_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::AND_AbsoluteX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::AND_AbsoluteY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:AND.cpp}
{\xe \v AND.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::AND_Absolute )}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b AND.cpp}.}\par
}
{\xe \v _INST_IMPL\:AND.cpp}
{\xe \v AND.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::AND_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b AND.cpp}.}\par
}
{\xe \v _INST_IMPL\:AND.cpp}
{\xe \v AND.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::AND_AbsoluteY )}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b AND.cpp}.}\par
}
{\xe \v _INST_IMPL\:AND.cpp}
{\xe \v AND.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::AND_Inmediate )}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b AND.cpp}.}\par
}
{\xe \v _INST_IMPL\:AND.cpp}
{\xe \v AND.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::AND_ZeroPage )}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b AND.cpp}.}\par
}
{\xe \v _INST_IMPL\:AND.cpp}
{\xe \v AND.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::AND_ZeroPageIndirectX )}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b AND.cpp}.}\par
}
{\xe \v _INST_IMPL\:AND.cpp}
{\xe \v AND.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::AND_ZeroPageIndirectY )}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b AND.cpp}.}\par
}
{\xe \v _INST_IMPL\:AND.cpp}
{\xe \v AND.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::AND_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b AND.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AND.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/AND.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/AND.cpp}
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::AND_General::executeWith (MCHEmul::UByte u)\par
00006 \{\par
00007     MCHEmul::Register& a = cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR);\par
00008     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00009     \par
00010     {\cf20 // Set the value...}\par
00011     {\cf20 // The register is always 1 byte long...}\par
00012     MCHEmul::UByte r = a.values ()[0] & u;\par
00013     a.set (\{ r \});\par
00014 \par
00015     {\cf20 // Time of the status register...}\par
00016     st.setBitStatus ({\cf22 "N"}, r [7]);\par
00017     st.setBitStatus ({\cf22 "Z"}, r == MCHEmul::UByte::_0);\par
00018 \par
00019     {\cf19 return} ({\cf17 true});\par
00020 \}\par
00021 \par
00022 {\cf20 // ---}\par
00023 _INST_IMPL (F6500::AND_Inmediate)\par
00024 \{\par
00025     {\cf19 return} (executeWith (value_inmediate ()));\par
00026 \}\par
00027 \par
00028 {\cf20 // ---}\par
00029 _INST_IMPL (F6500::AND_Absolute)\par
00030 \{\par
00031     {\cf19 return} (executeWith (value_absolute ()));\par
00032 \}\par
00033 \par
00034 {\cf20 // ---}\par
00035 _INST_IMPL (F6500::AND_ZeroPage)\par
00036 \{\par
00037     {\cf19 return} (executeWith (value_zeroPage ()));\par
00038 \}\par
00039 \par
00040 {\cf20 // ---}\par
00041 _INST_IMPL (F6500::AND_ZeroPageIndirectX)\par
00042 \{\par
00043     {\cf19 return} (executeWith (value_indirectZeroPageX ()));\par
00044 \}\par
00045 \par
00046 {\cf20 // ---}\par
00047 _INST_IMPL (F6500::AND_ZeroPageIndirectY)\par
00048 \{\par
00049     {\cf19 return} (executeWith (value_indirectZeroPageY ()));\par
00050 \}\par
00051 \par
00052 {\cf20 // ---}\par
00053 _INST_IMPL (F6500::AND_ZeroPageX)\par
00054 \{\par
00055     {\cf19 return} (executeWith (value_zeroPageX ()));\par
00056 \}\par
00057 \par
00058 {\cf20 // ---}\par
00059 _INST_IMPL (F6500::AND_AbsoluteX)\par
00060 \{\par
00061     {\cf19 return} (executeWith (value_absoluteX ()));\par
00062 \}\par
00063 \par
00064 {\cf20 // ---}\par
00065 _INST_IMPL (F6500::AND_AbsoluteY)\par
00066 \{\par
00067     {\cf19 return} (executeWith (value_absoluteY ()));\par
00068 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/ASL.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/ASL.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/ASL.cpp}
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ASL_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ASL_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ASL_Accumulator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ASL_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ASL_AbsoluteX)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:ASL.cpp}
{\xe \v ASL.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ASL_Absolute )}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b ASL.cpp}.}\par
}
{\xe \v _INST_IMPL\:ASL.cpp}
{\xe \v ASL.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ASL_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b ASL.cpp}.}\par
}
{\xe \v _INST_IMPL\:ASL.cpp}
{\xe \v ASL.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ASL_Accumulator )}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0 is put into\par
}{
Definition at line {\b 34} of file {\b ASL.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_a_s_l_8cpp_a61aca3e6e68f660718e75af1f022c9ae_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:ASL.cpp}
{\xe \v ASL.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ASL_ZeroPage )}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b ASL.cpp}.}\par
}
{\xe \v _INST_IMPL\:ASL.cpp}
{\xe \v ASL.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ASL_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b ASL.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ASL.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/ASL.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/ASL.cpp}
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::ASL_General::executeOn ({\cf17 const} MCHEmul::Address& a)\par
00006 \{\par
00007     {\cf20 // Read the value, makes the operation and set it back!}\par
00008     MCHEmul::UByte v = memory () -> values (a, 1)[0]; {\cf20 // 1 byte long always}\par
00009     {\cf18 bool} c = v.shiftLeftC (1, {\cf17 false} ); {\cf20 // Keeps the status of the last bit to actualize later the carry flag}\par
00010     memory () -> set (a, \{ v \});\par
00011 \par
00012     {\cf20 // Time of the status register...}\par
00013     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00014     st.setBitStatus ({\cf22 "N"}, v [7]);\par
00015     st.setBitStatus ({\cf22 "Z"}, v == MCHEmul::UByte::_0);\par
00016     st.setBitStatus ({\cf22 "C"}, c);\par
00017 \par
00018     {\cf19 return} ({\cf17 true});\par
00019 \}\par
00020 \par
00021 {\cf20 // ---}\par
00022 _INST_IMPL (F6500::ASL_Absolute)\par
00023 \{\par
00024     {\cf19 return} (executeOn (address_absolute ()));\par
00025 \}\par
00026 \par
00027 {\cf20 // ---}\par
00028 _INST_IMPL (F6500::ASL_ZeroPage)\par
00029 \{\par
00030     {\cf19 return} (executeOn (address_zeroPage ()));\par
00031 \}\par
00032 \par
00033 {\cf20 // ---}\par
00034 _INST_IMPL (F6500::ASL_Accumulator)\par
00035 \{\par
00036     assert (parameters ().size () == 1);\par
00037 \par
00038     MCHEmul::Register& a = cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR);\par
00039 \par
00040     {\cf20 // Set the value...}\par
00041     MCHEmul::UBytes v = a.values ();\par
00042     {\cf18 bool} c = v.shiftLeftC (1, {\cf17 false} );\par
00043     a.set (v);\par
00044 \par
00045     {\cf20 // Time of the status register...}\par
00046     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00047     st.setBitStatus ({\cf22 "N"}, v [0][7]);\par
00048     st.setBitStatus ({\cf22 "Z"}, v [0] == MCHEmul::UByte::_0);\par
00049     st.setBitStatus ({\cf22 "C"}, c);\par
00050 \par
00051     {\cf19 return} ({\cf17 true});\par
00052 \}\par
00053 \par
00054 {\cf20 // ---}\par
00055 _INST_IMPL (F6500::ASL_ZeroPageX)\par
00056 \{\par
00057     {\cf19 return} (executeOn (address_zeroPageX ()));\par
00058 \}\par
00059 \par
00060 {\cf20 // ---}\par
00061 _INST_IMPL (F6500::ASL_AbsoluteX)\par
00062 \{\par
00063     {\cf19 return} (executeOn (address_absoluteX ()));\par
00064 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/BRANCHES.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/BRANCHES.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/BRANCHES.cpp}
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::BCC)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::BCS)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::BEQ)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::BMI)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::BNE)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::BPL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::BVC)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::BVS)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:BRANCHES.cpp}
{\xe \v BRANCHES.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::BCC )}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b BRANCHES.cpp}.}\par
}
{\xe \v _INST_IMPL\:BRANCHES.cpp}
{\xe \v BRANCHES.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::BCS )}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b BRANCHES.cpp}.}\par
}
{\xe \v _INST_IMPL\:BRANCHES.cpp}
{\xe \v BRANCHES.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::BEQ )}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b BRANCHES.cpp}.}\par
}
{\xe \v _INST_IMPL\:BRANCHES.cpp}
{\xe \v BRANCHES.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::BMI )}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b BRANCHES.cpp}.}\par
}
{\xe \v _INST_IMPL\:BRANCHES.cpp}
{\xe \v BRANCHES.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::BNE )}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b BRANCHES.cpp}.}\par
}
{\xe \v _INST_IMPL\:BRANCHES.cpp}
{\xe \v BRANCHES.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::BPL )}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b BRANCHES.cpp}.}\par
}
{\xe \v _INST_IMPL\:BRANCHES.cpp}
{\xe \v BRANCHES.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::BVC )}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b BRANCHES.cpp}.}\par
}
{\xe \v _INST_IMPL\:BRANCHES.cpp}
{\xe \v BRANCHES.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::BVS )}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b BRANCHES.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BRANCHES.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/BRANCHES.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/BRANCHES.cpp}
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 void} F6500::BXX_General::executeBranch ()\par
00006 \{\par
00007     {\cf18 int} jR = MCHEmul::UInt (\{ value_relative () \}).asInt (); {\cf20 // The value can be negative meaning back jump!}\par
00008 \par
00009     {\cf19 if} (jR == 0)\par
00010         {\cf19 return}; {\cf20 // No need to continue...}\par
00011 \par
00012     MCHEmul::ProgramCounter& pc = cpu () -> programCounter ();\par
00013     {\cf19 if} (jR > 0) pc.increment (({\cf18 size_t}) jR);\par
00014     {\cf19 else} pc.decrement (({\cf18 size_t}) -jR); {\cf20 // Parameter to "decrement" always positive...}\par
00015 \}\par
00016 \par
00017 {\cf20 // ---}\par
00018 _INST_IMPL (F6500::BCC)\par
00019 \{\par
00020     {\cf19 if} (!cpu () -> statusRegister ().bitStatus ({\cf22 "C"}))\par
00021         executeBranch ();\par
00022     {\cf19 return} ({\cf17 true});\par
00023 \}\par
00024 \par
00025 {\cf20 // ---}\par
00026 _INST_IMPL (F6500::BCS)\par
00027 \{\par
00028     {\cf19 if} (cpu () -> statusRegister ().bitStatus ({\cf22 "C"}))\par
00029         executeBranch ();\par
00030     {\cf19 return} ({\cf17 true});\par
00031 \}\par
00032 \par
00033 {\cf20 // ---}\par
00034 _INST_IMPL (F6500::BEQ)\par
00035 \{\par
00036     {\cf19 if} (cpu () -> statusRegister ().bitStatus ({\cf22 "Z"}))\par
00037         executeBranch ();\par
00038     {\cf19 return} ({\cf17 true});\par
00039 \}\par
00040 \par
00041 {\cf20 // ---}\par
00042 _INST_IMPL (F6500::BMI)\par
00043 \{\par
00044     {\cf19 if} (cpu () -> statusRegister ().bitStatus ({\cf22 "N"}))\par
00045         executeBranch ();\par
00046     {\cf19 return} ({\cf17 true});\par
00047 \}\par
00048 \par
00049 {\cf20 // ---}\par
00050 _INST_IMPL (F6500::BNE)\par
00051 \{\par
00052     {\cf19 if} (!cpu () -> statusRegister ().bitStatus ({\cf22 "Z"}))\par
00053         executeBranch ();\par
00054     {\cf19 return} ({\cf17 true});\par
00055 \}\par
00056 \par
00057 {\cf20 // ---}\par
00058 _INST_IMPL (F6500::BPL)\par
00059 \{\par
00060     {\cf19 if} (!cpu () -> statusRegister ().bitStatus ({\cf22 "N"}))\par
00061         executeBranch ();\par
00062     {\cf19 return} ({\cf17 true});\par
00063 \}\par
00064 \par
00065 {\cf20 // ---}\par
00066 _INST_IMPL (F6500::BVC)\par
00067 \{\par
00068     {\cf19 if} (!cpu () -> statusRegister ().bitStatus ({\cf22 "V"}))\par
00069         executeBranch ();\par
00070     {\cf19 return} ({\cf17 true});\par
00071 \}\par
00072 \par
00073 {\cf20 // ---}\par
00074 _INST_IMPL (F6500::BVS)\par
00075 \{\par
00076     {\cf19 if} (cpu () -> statusRegister ().bitStatus ({\cf22 "V"}))\par
00077         executeBranch ();\par
00078     {\cf19 return} ({\cf17 true});\par
00079 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/C6500.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/C6500.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/C6500.cpp}
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/C6500.hpp>}\par
{\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/IRQInterrupt.hpp>}\par
{\f2 #include <F6500/NMIInterrupt.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C6500.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/C6500.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/C6500.cpp}
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/C6500.hpp>}\par
00002 {\cf21 #include <F6500/Instructions.hpp>}\par
00003 {\cf21 #include <F6500/IRQInterrupt.hpp>}\par
00004 {\cf21 #include <F6500/NMIInterrupt.hpp>}\par
00005 \par
00006 {\cf20 // ---}\par
00007 F6500::C6500::C6500 ({\cf17 const} MCHEmul::CPUArchitecture& a)\par
00008     : MCHEmul::CPU (a,\par
00009         F6500::C6500::createInternalRegisters (), \par
00010         F6500::C6500::createStatusRegister (),\par
00011         F6500::C6500::createInstructions ())\par
00012 \{\par
00013     {\cf20 // The reference to the memory has not set still here...}\par
00014     {\cf20 // It is linked to the CPU at computer (class) level!}\par
00015 \par
00016     {\cf20 //This type of CPU admites two types of interruptions...}\par
00017     addInterrupt ({\cf17 new} F6500::IRQInterrupt);\par
00018     addInterrupt ({\cf17 new} F6500::NMIInterrupt);\par
00019 \}\par
00020 \par
00021 {\cf20 // ---}\par
00022 {\cf18 bool} F6500::C6500::initialize ()\par
00023 \{\par
00024     {\cf19 if} (!MCHEmul::CPU::initialize ())\par
00025         {\cf19 return} ({\cf17 false});\par
00026 \par
00027     {\cf20 // After 6 clock sycles, everything starts!}\par
00028     addClockCycles (6);\par
00029     {\cf20 // Initially the interruptions are disabled!}\par
00030     statusRegister ().setBitStatus ({\cf22 "I"}, {\cf17 false});\par
00031     {\cf20 // Sets the point where the execution starts!}\par
00032     programCounter ().setAddress (MCHEmul::Address \par
00033         (memoryRef () -> values (ResetVectorAddress (), 2), {\cf17 false} ));\par
00034 \par
00035     {\cf19 return} ({\cf17 true});\par
00036 \}\par
00037 \par
00038 {\cf20 // ---}\par
00039 MCHEmul::Registers F6500::C6500::createInternalRegisters ()\par
00040 \{\par
00041     {\cf19 return} (MCHEmul::Registers\par
00042             (\{ MCHEmul::Register (({\cf18 int}) _ACCUMULATOR,   {\cf22 "A"}, \{ MCHEmul::UByte::_0 \} ),\par
00043                MCHEmul::Register (({\cf18 int}) _XREGISTER,     {\cf22 "X"}, \{ MCHEmul::UByte::_0 \} ),\par
00044                MCHEmul::Register (({\cf18 int}) _YREGISTER,     {\cf22 "Y"}, \{ MCHEmul::UByte::_0 \} ) \}));\par
00045 \}\par
00046 \par
00047 {\cf20 // ---}\par
00048 MCHEmul::StatusRegister F6500::C6500::createStatusRegister ()\par
00049 \{\par
00050     {\cf19 return} (MCHEmul::StatusRegister \par
00051             (\par
00052                 1 ,\par
00053                 \{ \{ {\cf22 "C"}, 0  \},      {\cf20 // Carry flag}\par
00054                   \{ {\cf22 "Z"}, 1 \},       {\cf20 // Zero flag}\par
00055                   \{ {\cf22 "I"}, 2 \},       {\cf20 // Interrupt disable flag}\par
00056                   \{ {\cf22 "D"}, 3 \},       {\cf20 // Decimal mode flag}\par
00057                   \{ {\cf22 "B"}, 4 \},       {\cf20 // Break flag}\par
00058                   \{ {\cf22 "-"}, 5 \},       {\cf20 // Not used}\par
00059                   \{ {\cf22 "V"}, 6 \},       {\cf20 // Overflow flag}\par
00060                   \{ {\cf22 "N"}, 7 \} \}));   {\cf20 // Negative flag}\par
00061 \}\par
00062 \par
00063 {\cf20 // ---}\par
00064 MCHEmul::Instructions F6500::C6500::createInstructions ()\par
00065 \{\par
00066     MCHEmul::Instructions result;\par
00067 \par
00068     {\cf20 // ADC}\par
00069     result [0x69] = {\cf17 new} ADC_Inmediate;\par
00070     result [0x6D] = {\cf17 new} ADC_Absolute;\par
00071     result [0x65] = {\cf17 new} ADC_ZeroPage;\par
00072     result [0x61] = {\cf17 new} ADC_ZeroPageIndirectX;\par
00073     result [0x71] = {\cf17 new} ADC_ZeroPageIndirectY;\par
00074     result [0x75] = {\cf17 new} ADC_ZeroPageX;\par
00075     result [0x7D] = {\cf17 new} ADC_AbsoluteX;\par
00076     result [0x79] = {\cf17 new} ADC_AbsoluteY;\par
00077 \par
00078     {\cf20 // AND}\par
00079     result [0x29] = {\cf17 new} AND_Inmediate;\par
00080     result [0x2D] = {\cf17 new} AND_Absolute;\par
00081     result [0x25] = {\cf17 new} AND_ZeroPage;\par
00082     result [0x21] = {\cf17 new} AND_ZeroPageIndirectX;\par
00083     result [0x31] = {\cf17 new} AND_ZeroPageIndirectY;\par
00084     result [0x35] = {\cf17 new} AND_ZeroPageX;\par
00085     result [0x3D] = {\cf17 new} AND_AbsoluteX;\par
00086     result [0x39] = {\cf17 new} AND_AbsoluteY;\par
00087 \par
00088     {\cf20 // ASL}\par
00089     result [0x0E] = {\cf17 new} ASL_Absolute;\par
00090     result [0x06] = {\cf17 new} ASL_ZeroPage;\par
00091     result [0x0A] = {\cf17 new} ASL_Accumulator;\par
00092     result [0x16] = {\cf17 new} ASL_ZeroPageX;\par
00093     result [0x1E] = {\cf17 new} ASL_AbsoluteX;\par
00094 \par
00095     {\cf20 // BCC }\par
00096     result [0x90] = {\cf17 new} BCC;\par
00097 \par
00098     {\cf20 // BCS }\par
00099     result [0xB0] = {\cf17 new} BCS;\par
00100 \par
00101     {\cf20 // BEQ}\par
00102     result [0xF0] = {\cf17 new} BEQ;\par
00103 \par
00104     {\cf20 // BIT}\par
00105     result [0x2C] = {\cf17 new} BIT_Absolute;\par
00106     result [0x24] = {\cf17 new} BIT_ZeroPage;\par
00107 \par
00108     {\cf20 // BMI}\par
00109     result [0x30] = {\cf17 new} BMI;\par
00110 \par
00111     {\cf20 // BNE}\par
00112     result [0xD0] = {\cf17 new} BNE;\par
00113 \par
00114     {\cf20 // BPL}\par
00115     result [0x10] = {\cf17 new} BPL;\par
00116 \par
00117     {\cf20 // BRK}\par
00118     result [0x00] = {\cf17 new} BRK;\par
00119 \par
00120     {\cf20 // BVC}\par
00121     result [0x50] = {\cf17 new} BVC;\par
00122 \par
00123     {\cf20 // BVS}\par
00124     result [0x70] = {\cf17 new} BVS;\par
00125 \par
00126     {\cf20 // CLC}\par
00127     result [0x18] = {\cf17 new} CLC;\par
00128 \par
00129     {\cf20 // CLD}\par
00130     result [0xD8] = {\cf17 new} CLD;\par
00131 \par
00132     {\cf20 // CLI}\par
00133     result [0x58] = {\cf17 new} CLI;\par
00134 \par
00135     {\cf20 // CLV}\par
00136     result [0xB8] = {\cf17 new} CLV;\par
00137 \par
00138     {\cf20 // CMP}\par
00139     result [0xC9] = {\cf17 new} CMP_Inmediate;\par
00140     result [0xCD] = {\cf17 new} CMP_Absolute;\par
00141     result [0xC5] = {\cf17 new} CMP_ZeroPage;\par
00142     result [0xC1] = {\cf17 new} CMP_ZeroPageIndirectX;\par
00143     result [0xD1] = {\cf17 new} CMP_ZeroPageIndirectY;\par
00144     result [0xD5] = {\cf17 new} CMP_ZeroPageX;\par
00145     result [0xDD] = {\cf17 new} CMP_AbsoluteX;\par
00146     result [0xD9] = {\cf17 new} CMP_AbsoluteY;\par
00147 \par
00148     {\cf20 // CPX}\par
00149     result [0xE0] = {\cf17 new} CPX_Inmediate;\par
00150     result [0xEC] = {\cf17 new} CPX_Absolute;\par
00151     result [0xE4] = {\cf17 new} CPX_ZeroPage;\par
00152 \par
00153     {\cf20 // CPY}\par
00154     result [0xC0] = {\cf17 new} CPY_Inmediate;\par
00155     result [0xCC] = {\cf17 new} CPY_Absolute;\par
00156     result [0xC4] = {\cf17 new} CPY_ZeroPage;\par
00157 \par
00158     {\cf20 // DEC}\par
00159     result [0xCE] = {\cf17 new} DEC_Absolute;\par
00160     result [0xC6] = {\cf17 new} DEC_ZeroPage;\par
00161     result [0xD6] = {\cf17 new} DEC_ZeroPageX;\par
00162     result [0xDE] = {\cf17 new} DEC_AbsoluteX;\par
00163 \par
00164     {\cf20 // DEX}\par
00165     result [0xCA] = {\cf17 new} DEX;\par
00166 \par
00167     {\cf20 // DEY}\par
00168     result [0x88] = {\cf17 new} DEY;\par
00169 \par
00170     {\cf20 // EOR}\par
00171     result [0x49] = {\cf17 new} EOR_Inmediate;\par
00172     result [0x4D] = {\cf17 new} EOR_Absolute;\par
00173     result [0x45] = {\cf17 new} EOR_ZeroPage;\par
00174     result [0x41] = {\cf17 new} EOR_ZeroPageIndirectX;\par
00175     result [0x51] = {\cf17 new} EOR_ZeroPageIndirectY;\par
00176     result [0x55] = {\cf17 new} EOR_ZeroPageX;\par
00177     result [0x5D] = {\cf17 new} EOR_AbsoluteX;\par
00178     result [0x59] = {\cf17 new} EOR_AbsoluteY;\par
00179 \par
00180     {\cf20 // INC}\par
00181     result [0xEE] = {\cf17 new} INC_Absolute;\par
00182     result [0xE6] = {\cf17 new} INC_ZeroPage;\par
00183     result [0xF6] = {\cf17 new} INC_ZeroPageX;\par
00184     result [0xFE] = {\cf17 new} INC_AbsoluteX;\par
00185 \par
00186     {\cf20 // INX}\par
00187     result [0xE8] = {\cf17 new} INX;\par
00188 \par
00189     {\cf20 // INY}\par
00190     result [0xC8] = {\cf17 new} INY;\par
00191 \par
00192     {\cf20 // JMP}\par
00193     result [0x4C] = {\cf17 new} JMP_Absolute;\par
00194     result [0x6C] = {\cf17 new} JMP_Indirect;\par
00195 \par
00196     {\cf20 // JSR}\par
00197     result [0x20] = {\cf17 new} JSR_Absolute;\par
00198 \par
00199     {\cf20 // LDA}\par
00200     result [0xA9] = {\cf17 new} LDA_Inmediate;\par
00201     result [0xAD] = {\cf17 new} LDA_Absolute;\par
00202     result [0xA5] = {\cf17 new} LDA_ZeroPage;\par
00203     result [0xA1] = {\cf17 new} LDA_ZeroPageIndirectX;\par
00204     result [0xB1] = {\cf17 new} LDA_ZeroPageIndirectY;\par
00205     result [0xB5] = {\cf17 new} LDA_ZeroPageX;\par
00206     result [0xBD] = {\cf17 new} LDA_AbsoluteX;\par
00207     result [0xB9] = {\cf17 new} LDA_AbsoluteY;\par
00208 \par
00209     {\cf20 // LDX}\par
00210     result [0xA2] = {\cf17 new} LDX_Inmediate;\par
00211     result [0xAE] = {\cf17 new} LDX_Absolute;\par
00212     result [0xA6] = {\cf17 new} LDX_ZeroPage;\par
00213     result [0xBE] = {\cf17 new} LDX_AbsoluteY;\par
00214     result [0xB6] = {\cf17 new} LDX_ZeroPageY;\par
00215 \par
00216     {\cf20 // LDY}\par
00217     result [0xA0] = {\cf17 new} LDY_Inmediate;\par
00218     result [0xAC] = {\cf17 new} LDY_Absolute;\par
00219     result [0xA4] = {\cf17 new} LDY_ZeroPage;\par
00220     result [0xB4] = {\cf17 new} LDY_ZeroPageX;\par
00221     result [0xBC] = {\cf17 new} LDY_AbsoluteX;\par
00222 \par
00223     {\cf20 // LSR}\par
00224     result [0x4E] = {\cf17 new} LSR_Absolute;\par
00225     result [0x46] = {\cf17 new} LSR_ZeroPage;\par
00226     result [0x4A] = {\cf17 new} LSR_Accumulator;\par
00227     result [0x56] = {\cf17 new} LSR_ZeroPageX;\par
00228     result [0x5E] = {\cf17 new} LSR_AbsoluteX;\par
00229 \par
00230     {\cf20 // NOP}\par
00231     result [0xEA] = {\cf17 new} NOP;\par
00232 \par
00233     {\cf20 // ORA}\par
00234     result [0x09] = {\cf17 new} ORA_Inmediate;\par
00235     result [0x0D] = {\cf17 new} ORA_Absolute;\par
00236     result [0x05] = {\cf17 new} ORA_ZeroPage;\par
00237     result [0x01] = {\cf17 new} ORA_ZeroPageIndirectX;\par
00238     result [0x11] = {\cf17 new} ORA_ZeroPageIndirectY;\par
00239     result [0x15] = {\cf17 new} ORA_ZeroPageX;\par
00240     result [0x1D] = {\cf17 new} ORA_AbsoluteX;\par
00241     result [0x19] = {\cf17 new} ORA_AbsoluteY;\par
00242 \par
00243     {\cf20 // PHA}\par
00244     result [0x48] = {\cf17 new} PHA;\par
00245 \par
00246     {\cf20 // PHP}\par
00247     result [0x08] = {\cf17 new} PHP;\par
00248 \par
00249     {\cf20 // PLA}\par
00250     result [0x68] = {\cf17 new} PLA;\par
00251 \par
00252     {\cf20 // PLP}\par
00253     result [0x28] = {\cf17 new} PLP;\par
00254 \par
00255     {\cf20 // ROL}\par
00256     result [0x2E] = {\cf17 new} ROL_Absolute;\par
00257     result [0x26] = {\cf17 new} ROL_ZeroPage;\par
00258     result [0x2A] = {\cf17 new} ROL_Accumulator;\par
00259     result [0x36] = {\cf17 new} ROL_ZeroPageX;\par
00260     result [0x3E] = {\cf17 new} ROL_AbsoluteX;\par
00261 \par
00262     {\cf20 // ROR}\par
00263     result [0x6E] = {\cf17 new} ROR_Absolute;\par
00264     result [0x66] = {\cf17 new} ROR_ZeroPage;\par
00265     result [0x6A] = {\cf17 new} ROR_Accumulator;\par
00266     result [0x76] = {\cf17 new} ROR_ZeroPageX;\par
00267     result [0x7E] = {\cf17 new} ROR_AbsoluteX;\par
00268 \par
00269     {\cf20 // RTI}\par
00270     result [0x40] = {\cf17 new} RTI;\par
00271 \par
00272     {\cf20 // RTS}\par
00273     result [0x60] = {\cf17 new} RTS;\par
00274 \par
00275     {\cf20 // SBC}\par
00276     result [0xE9] = {\cf17 new} SBC_Inmediate;\par
00277     result [0xED] = {\cf17 new} SBC_Absolute;\par
00278     result [0xE5] = {\cf17 new} SBC_ZeroPage;\par
00279     result [0xE1] = {\cf17 new} SBC_ZeroPageIndirectX;\par
00280     result [0xF1] = {\cf17 new} SBC_ZeroPageIndirectY;\par
00281     result [0xF5] = {\cf17 new} SBC_ZeroPageX;\par
00282     result [0xFD] = {\cf17 new} SBC_AbsoluteX;\par
00283     result [0xF9] = {\cf17 new} SBC_AbsoluteY;\par
00284 \par
00285     {\cf20 // SEC}\par
00286     result [0x38] = {\cf17 new} SEC;\par
00287 \par
00288     {\cf20 // SED}\par
00289     result [0xF8] = {\cf17 new} SED;\par
00290 \par
00291     {\cf20 // SEI}\par
00292     result [0x78] = {\cf17 new} SEI;\par
00293 \par
00294     {\cf20 // STA}\par
00295     result [0x8D] = {\cf17 new} STA_Absolute;\par
00296     result [0x85] = {\cf17 new} STA_ZeroPage;\par
00297     result [0x81] = {\cf17 new} STA_ZeroPageIndirectX;\par
00298     result [0x91] = {\cf17 new} STA_ZeroPageIndirectY;\par
00299     result [0x95] = {\cf17 new} STA_ZeroPageX;\par
00300     result [0x9D] = {\cf17 new} STA_AbsoluteX;\par
00301     result [0x99] = {\cf17 new} STA_AbsoluteY;\par
00302 \par
00303     {\cf20 // STX}\par
00304     result [0x8E] = {\cf17 new} STX_Absolute;\par
00305     result [0x86] = {\cf17 new} STX_ZeroPage;\par
00306     result [0x96] = {\cf17 new} STX_ZeroPageY;\par
00307 \par
00308     {\cf20 // STY}\par
00309     result [0x8C] = {\cf17 new} STY_Absolute;\par
00310     result [0x84] = {\cf17 new} STY_ZeroPage;\par
00311     result [0x94] = {\cf17 new} STY_ZeroPageX;\par
00312 \par
00313     {\cf20 // TAX}\par
00314     result [0xAA] = {\cf17 new} TAX;\par
00315 \par
00316     {\cf20 // TAY}\par
00317     result [0xA8] = {\cf17 new} TAY;\par
00318 \par
00319     {\cf20 // TSX}\par
00320     result [0xBA] = {\cf17 new} TSX;\par
00321 \par
00322     {\cf20 // TXA}\par
00323     result [0x8A] = {\cf17 new} TXA;\par
00324 \par
00325     {\cf20 // TXS}\par
00326     result [0x9A] = {\cf17 new} TXS;\par
00327 \par
00328     {\cf20 // TYA}\par
00329     result [0x98] = {\cf17 new} TYA;\par
00330 \par
00331     assert (result.size () == 151); \par
00332 \par
00333     {\cf19 return} (result);\par
00334 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/C6510.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/C6510.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/C6510.cpp}
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/C6510.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C6510.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/C6510.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/C6510.cpp}
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/C6510.hpp>}\par
00002 \par
00003 {\cf20 // ---}\par
00004 MCHEmul::CPUArchitecture F6500::C6510::createArchitecture ()\par
00005 \{\par
00006     {\cf19 return} (\par
00007         MCHEmul::CPUArchitecture \par
00008             (2 , \par
00009              1 , \par
00010              {\cf17 false} , \par
00011              \{ \{ {\cf22 "Code"}, {\cf22 "6510/6150-1/6510-2"} \},\par
00012                \{ {\cf22 "Manufacturer"}, {\cf22 "MOS Technology INC/Commodore Semiconductor Group (CBM)"}\},\par
00013                \{ {\cf22 "Year"}, {\cf22 "1980"} \},\par
00014                \{ {\cf22 "Speed Range"}, {\cf22 "0.985(PAL)/1.023(NTSC) MHz"} \} \}));\par
00015 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/CMP.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/CMP.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/CMP.cpp}
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CMP_Inmediate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CMP_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CMP_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CMP_ZeroPageIndirectX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CMP_ZeroPageIndirectY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CMP_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CMP_AbsoluteX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CMP_AbsoluteY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:CMP.cpp}
{\xe \v CMP.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CMP_Absolute )}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b CMP.cpp}.}\par
}
{\xe \v _INST_IMPL\:CMP.cpp}
{\xe \v CMP.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CMP_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b CMP.cpp}.}\par
}
{\xe \v _INST_IMPL\:CMP.cpp}
{\xe \v CMP.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CMP_AbsoluteY )}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b CMP.cpp}.}\par
}
{\xe \v _INST_IMPL\:CMP.cpp}
{\xe \v CMP.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CMP_Inmediate )}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b CMP.cpp}.}\par
}
{\xe \v _INST_IMPL\:CMP.cpp}
{\xe \v CMP.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CMP_ZeroPage )}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b CMP.cpp}.}\par
}
{\xe \v _INST_IMPL\:CMP.cpp}
{\xe \v CMP.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CMP_ZeroPageIndirectX )}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b CMP.cpp}.}\par
}
{\xe \v _INST_IMPL\:CMP.cpp}
{\xe \v CMP.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CMP_ZeroPageIndirectY )}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b CMP.cpp}.}\par
}
{\xe \v _INST_IMPL\:CMP.cpp}
{\xe \v CMP.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CMP_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b CMP.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CMP.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/CMP.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/CMP.cpp}
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::CMP_General::executeWith (MCHEmul::UByte u)\par
00006 \{\par
00007     {\cf20 // To compare is like to substract...}\par
00008     MCHEmul::UInt r = \par
00009         MCHEmul::UInt (cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR).values () ) - \par
00010         MCHEmul::UInt (\{ u \});  {\cf20 // Never longer that 1 byte, but the result could be negative...}\par
00011 \par
00012     {\cf20 // Time of the status register...}\par
00013     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00014     st.setBitStatus ({\cf22 "N"}, r.negative ());\par
00015     st.setBitStatus ({\cf22 "Z"}, r == MCHEmul::UInt::_0);\par
00016     st.setBitStatus ({\cf22 "C"}, r.carry ()); {\cf20 // When the result is positive (a >= u)}\par
00017 \par
00018     {\cf19 return} ({\cf17 true});\par
00019 \}\par
00020 \par
00021 {\cf20 // ---}\par
00022 _INST_IMPL (F6500::CMP_Inmediate)\par
00023 \{\par
00024     {\cf19 return} (executeWith (value_inmediate ()));\par
00025 \}\par
00026 \par
00027 _INST_IMPL (F6500::CMP_Absolute)\par
00028 \{\par
00029     {\cf19 return} (executeWith (value_absolute ()));\par
00030 \}\par
00031 \par
00032 _INST_IMPL (F6500::CMP_ZeroPage)\par
00033 \{\par
00034     {\cf19 return} (executeWith (value_zeroPage ()));\par
00035 \}\par
00036 \par
00037 _INST_IMPL (F6500::CMP_ZeroPageIndirectX)\par
00038 \{\par
00039     {\cf19 return} (executeWith (value_indirectZeroPageX ()));\par
00040 \}\par
00041 \par
00042 _INST_IMPL (F6500::CMP_ZeroPageIndirectY)\par
00043 \{\par
00044     {\cf19 return} (executeWith (value_indirectZeroPageY ()));\par
00045 \}\par
00046 \par
00047 _INST_IMPL (F6500::CMP_ZeroPageX)\par
00048 \{\par
00049     {\cf19 return} (executeWith (value_zeroPageX ()));\par
00050 \}\par
00051 \par
00052 _INST_IMPL (F6500::CMP_AbsoluteX)\par
00053 \{\par
00054     {\cf19 return} (executeWith (value_absoluteX ()));\par
00055 \}\par
00056 \par
00057 _INST_IMPL (F6500::CMP_AbsoluteY)\par
00058 \{\par
00059     {\cf19 return} (executeWith (value_absoluteY ()));\par
00060 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/CPX.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/CPX.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/CPX.cpp}
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CPX_Inmediate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CPX_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CPX_ZeroPage)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:CPX.cpp}
{\xe \v CPX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CPX_Absolute )}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b CPX.cpp}.}\par
}
{\xe \v _INST_IMPL\:CPX.cpp}
{\xe \v CPX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CPX_Inmediate )}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b CPX.cpp}.}\par
}
{\xe \v _INST_IMPL\:CPX.cpp}
{\xe \v CPX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CPX_ZeroPage )}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b CPX.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPX.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/CPX.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/CPX.cpp}
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::CPX_General::executeWith (MCHEmul::UByte u)\par
00006 \{\par
00007     {\cf20 // To compare is like to substract...}\par
00008     MCHEmul::UInt r = \par
00009         MCHEmul::UInt (cpu () -> internalRegister (F6500::C6510::_XREGISTER).values () ) - \par
00010         MCHEmul::UInt (\{ u \});  {\cf20 // Never longer that 1 byte, but the result could be negative...}\par
00011 \par
00012     {\cf20 // Time of the status register...}\par
00013     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00014     st.setBitStatus ({\cf22 "N"}, r.negative ());\par
00015     st.setBitStatus ({\cf22 "Z"}, r [0] == MCHEmul::UByte::_0);\par
00016     st.setBitStatus ({\cf22 "C"}, r.carry ()); {\cf20 // When the result is positive (a >= u)}\par
00017 \par
00018     {\cf19 return} ({\cf17 true});\par
00019 \}\par
00020 \par
00021 {\cf20 // ---}\par
00022 _INST_IMPL (F6500::CPX_Inmediate)\par
00023 \{\par
00024     {\cf19 return} (executeWith (value_inmediate ()));\par
00025 \}\par
00026 \par
00027 {\cf20 // ---}\par
00028 _INST_IMPL (F6500::CPX_Absolute)\par
00029 \{\par
00030     {\cf19 return} (executeWith (value_absolute ()));\par
00031 \}\par
00032 \par
00033 {\cf20 // ---}\par
00034 _INST_IMPL (F6500::CPX_ZeroPage)\par
00035 \{\par
00036     {\cf19 return} (executeWith (value_zeroPage ()));\par
00037 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/CPY.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/CPY.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/CPY.cpp}
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CPY_Inmediate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CPY_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CPY_ZeroPage)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:CPY.cpp}
{\xe \v CPY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CPY_Absolute )}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b CPY.cpp}.}\par
}
{\xe \v _INST_IMPL\:CPY.cpp}
{\xe \v CPY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CPY_Inmediate )}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b CPY.cpp}.}\par
}
{\xe \v _INST_IMPL\:CPY.cpp}
{\xe \v CPY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CPY_ZeroPage )}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b CPY.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPY.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/CPY.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/CPY.cpp}
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::CPY_General::executeWith (MCHEmul::UByte u)\par
00006 \{\par
00007     {\cf20 // To compare is like to substract...}\par
00008     MCHEmul::UInt r = \par
00009         MCHEmul::UInt (cpu () -> internalRegister (F6500::C6510::_YREGISTER).values () ) - \par
00010         MCHEmul::UInt (\{ u \});  {\cf20 // Never longer that 1 byte, but the result could be negative...}\par
00011 \par
00012     {\cf20 // Time of the status register...}\par
00013     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00014     st.setBitStatus ({\cf22 "N"}, r.negative ());\par
00015     st.setBitStatus ({\cf22 "Z"}, r [0] == MCHEmul::UByte::_0);\par
00016     st.setBitStatus ({\cf22 "C"}, r.carry ()); {\cf20 // When the result is positive (a >= u)}\par
00017 \par
00018     {\cf19 return} ({\cf17 true});\par
00019 \}\par
00020 \par
00021 {\cf20 // ---}\par
00022 _INST_IMPL (F6500::CPY_Inmediate)\par
00023 \{\par
00024     {\cf19 return} (executeWith (value_inmediate ()));\par
00025 \}\par
00026 \par
00027 {\cf20 // ---}\par
00028 _INST_IMPL (F6500::CPY_Absolute)\par
00029 \{\par
00030     {\cf19 return} (executeWith (value_absolute ()));\par
00031 \}\par
00032 \par
00033 {\cf20 // ---}\par
00034 _INST_IMPL (F6500::CPY_ZeroPage)\par
00035 \{\par
00036     {\cf19 return} (executeWith (value_zeroPage ()));\par
00037 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/DEC.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/DEC.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/DEC.cpp}
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::DEC_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::DEC_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::DEC_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::DEC_AbsoluteX)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:DEC.cpp}
{\xe \v DEC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::DEC_Absolute )}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b DEC.cpp}.}\par
}
{\xe \v _INST_IMPL\:DEC.cpp}
{\xe \v DEC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::DEC_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b DEC.cpp}.}\par
}
{\xe \v _INST_IMPL\:DEC.cpp}
{\xe \v DEC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::DEC_ZeroPage )}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b DEC.cpp}.}\par
}
{\xe \v _INST_IMPL\:DEC.cpp}
{\xe \v DEC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::DEC_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b DEC.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DEC.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/DEC.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/DEC.cpp}
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::DEC_General::executeOn ({\cf17 const} MCHEmul::Address& a)\par
00006 \{\par
00007     {\cf20 // Read the value, makes the operation and sets it back...}\par
00008     MCHEmul::UInt v = MCHEmul::UInt ((memory () -> values (a, 1))) - MCHEmul::UInt::_1;\par
00009     {\cf20 // A carry could be generated, but it will be ignored...}\par
00010     memory () -> set (a, v.bytes ()); {\cf20 // 1 byte long always}\par
00011 \par
00012     {\cf20 // Time of the status register...}\par
00013     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00014     st.setBitStatus ({\cf22 "N"}, v.negative ());\par
00015     st.setBitStatus ({\cf22 "Z"}, v == MCHEmul::UInt::_0);\par
00016 \par
00017     {\cf19 return} ({\cf17 true});\par
00018 \}\par
00019 \par
00020 {\cf20 // ---}\par
00021 _INST_IMPL (F6500::DEC_Absolute)\par
00022 \{\par
00023     {\cf19 return} (executeOn (address_absolute ()));\par
00024 \}\par
00025 \par
00026 {\cf20 // ---}\par
00027 _INST_IMPL (F6500::DEC_ZeroPage)\par
00028 \{\par
00029     {\cf19 return} (executeOn (address_zeroPage ()));\par
00030 \}\par
00031 \par
00032 {\cf20 // ---}\par
00033 _INST_IMPL (F6500::DEC_ZeroPageX)\par
00034 \{\par
00035     {\cf19 return} (executeOn (address_zeroPageX ()));\par
00036 \}\par
00037 \par
00038 {\cf20 // ---}\par
00039 _INST_IMPL (F6500::DEC_AbsoluteX)\par
00040 \{\par
00041     {\cf19 return} (executeOn (address_absoluteX ()));\par
00042 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/EOR.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/EOR.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/EOR.cpp}
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::EOR_Inmediate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::EOR_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::EOR_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::EOR_ZeroPageIndirectX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::EOR_ZeroPageIndirectY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::EOR_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::EOR_AbsoluteX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::EOR_AbsoluteY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:EOR.cpp}
{\xe \v EOR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::EOR_Absolute )}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b EOR.cpp}.}\par
}
{\xe \v _INST_IMPL\:EOR.cpp}
{\xe \v EOR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::EOR_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b EOR.cpp}.}\par
}
{\xe \v _INST_IMPL\:EOR.cpp}
{\xe \v EOR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::EOR_AbsoluteY )}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b EOR.cpp}.}\par
}
{\xe \v _INST_IMPL\:EOR.cpp}
{\xe \v EOR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::EOR_Inmediate )}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b EOR.cpp}.}\par
}
{\xe \v _INST_IMPL\:EOR.cpp}
{\xe \v EOR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::EOR_ZeroPage )}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b EOR.cpp}.}\par
}
{\xe \v _INST_IMPL\:EOR.cpp}
{\xe \v EOR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::EOR_ZeroPageIndirectX )}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b EOR.cpp}.}\par
}
{\xe \v _INST_IMPL\:EOR.cpp}
{\xe \v EOR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::EOR_ZeroPageIndirectY )}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b EOR.cpp}.}\par
}
{\xe \v _INST_IMPL\:EOR.cpp}
{\xe \v EOR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::EOR_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b EOR.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EOR.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/EOR.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/EOR.cpp}
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::EOR_General::executeWith (MCHEmul::UByte u)\par
00006 \{\par
00007     MCHEmul::Register& a = cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR);\par
00008     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00009     \par
00010     {\cf20 // Read the value, makes the operation and sets it back...}\par
00011     MCHEmul::UByte r = a.values ()[0] ^ u;\par
00012     a.set (\{ r \});\par
00013 \par
00014     {\cf20 // Time of the status register...}\par
00015     st.setBitStatus ({\cf22 "N"}, r [7]);\par
00016     st.setBitStatus ({\cf22 "Z"}, r == MCHEmul::UByte::_0);\par
00017 \par
00018     {\cf19 return} ({\cf17 true});\par
00019 \}\par
00020 \par
00021 {\cf20 // ---}\par
00022 _INST_IMPL (F6500::EOR_Inmediate)\par
00023 \{\par
00024     {\cf19 return} (executeWith (value_inmediate ()));\par
00025 \}\par
00026 \par
00027 {\cf20 // ---}\par
00028 _INST_IMPL (F6500::EOR_Absolute)\par
00029 \{\par
00030     {\cf19 return} (executeWith (value_absolute ()));\par
00031 \}\par
00032 \par
00033 {\cf20 // ---}\par
00034 _INST_IMPL (F6500::EOR_ZeroPage)\par
00035 \{\par
00036     {\cf19 return} (executeWith (value_zeroPage ()));\par
00037 \}\par
00038 \par
00039 {\cf20 // ---}\par
00040 _INST_IMPL (F6500::EOR_ZeroPageIndirectX)\par
00041 \{\par
00042     {\cf19 return} (executeWith (value_indirectZeroPageX ()));\par
00043 \}\par
00044 \par
00045 {\cf20 // ---}\par
00046 _INST_IMPL (F6500::EOR_ZeroPageIndirectY)\par
00047 \{\par
00048     {\cf19 return} (executeWith (value_indirectZeroPageY ()));\par
00049 \}\par
00050 \par
00051 {\cf20 // ---}\par
00052 _INST_IMPL (F6500::EOR_ZeroPageX)\par
00053 \{\par
00054     {\cf19 return} (executeWith (value_zeroPageX ()));\par
00055 \}\par
00056 \par
00057 {\cf20 // ---}\par
00058 _INST_IMPL (F6500::EOR_AbsoluteX)\par
00059 \{\par
00060     {\cf19 return} (executeWith (value_absoluteX ()));\par
00061 \}\par
00062 \par
00063 {\cf20 // ---}\par
00064 _INST_IMPL (F6500::EOR_AbsoluteY)\par
00065 \{\par
00066     {\cf19 return} (executeWith (value_absoluteY ()));\par
00067 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/INC.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/INC.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/INC.cpp}
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::INC_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::INC_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::INC_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::INC_AbsoluteX)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:INC.cpp}
{\xe \v INC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::INC_Absolute )}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b INC.cpp}.}\par
}
{\xe \v _INST_IMPL\:INC.cpp}
{\xe \v INC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::INC_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b INC.cpp}.}\par
}
{\xe \v _INST_IMPL\:INC.cpp}
{\xe \v INC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::INC_ZeroPage )}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b INC.cpp}.}\par
}
{\xe \v _INST_IMPL\:INC.cpp}
{\xe \v INC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::INC_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b INC.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
INC.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/INC.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/INC.cpp}
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::INC_General::executeOn ({\cf17 const} MCHEmul::Address& a)\par
00006 \{\par
00007     {\cf20 // Read the value, makes the operation and sets it back...}\par
00008     MCHEmul::UInt v = MCHEmul::UInt ((memory () -> values (a, 1))) + MCHEmul::UInt::_1;\par
00009     {\cf20 // A carry could be generated, but it will be ignored...}\par
00010     memory () -> set (a, v.bytes ()); {\cf20 // 1 byte long always}\par
00011 \par
00012     {\cf20 // Time of the status register...}\par
00013     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00014     st.setBitStatus ({\cf22 "N"}, v.negative ());\par
00015     st.setBitStatus ({\cf22 "Z"}, v == MCHEmul::UInt::_0);\par
00016 \par
00017     {\cf19 return} ({\cf17 true});\par
00018 \}\par
00019 \par
00020 {\cf20 // ---}\par
00021 _INST_IMPL (F6500::INC_Absolute)\par
00022 \{\par
00023     {\cf19 return} (executeOn (address_absolute ()));\par
00024 \}\par
00025 \par
00026 {\cf20 // ---}\par
00027 _INST_IMPL (F6500::INC_ZeroPage)\par
00028 \{\par
00029     {\cf19 return} (executeOn (address_zeroPage ()));\par
00030 \}\par
00031 \par
00032 {\cf20 // ---}\par
00033 _INST_IMPL (F6500::INC_ZeroPageX)\par
00034 \{\par
00035     {\cf19 return} (executeOn (address_zeroPageX ()));\par
00036 \}\par
00037 \par
00038 {\cf20 // ---}\par
00039 _INST_IMPL (F6500::INC_AbsoluteX)\par
00040 \{\par
00041     {\cf19 return} (executeOn (address_absoluteX ()));\par
00042 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/INCDECXY.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/INCDECXY.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/INCDECXY.cpp}
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::DEX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::DEY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::INX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::INY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:INCDECXY.cpp}
{\xe \v INCDECXY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::DEX )}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b INCDECXY.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_i_n_c_d_e_c_x_y_8cpp_a985f009a339f18da343db9af3abd21c5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:INCDECXY.cpp}
{\xe \v INCDECXY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::DEY )}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b INCDECXY.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_i_n_c_d_e_c_x_y_8cpp_aea17d12e7ddf6435f2d3f162aff16831_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:INCDECXY.cpp}
{\xe \v INCDECXY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::INX )}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b INCDECXY.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_i_n_c_d_e_c_x_y_8cpp_a1ffc318909614d033e51513b6c532c09_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:INCDECXY.cpp}
{\xe \v INCDECXY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::INY )}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b INCDECXY.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_i_n_c_d_e_c_x_y_8cpp_a7cb7ac740cbb5ee5655241ce4ea88932_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
INCDECXY.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/INCDECXY.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/INCDECXY.cpp}
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 _INST_IMPL (F6500::DEX)\par
00006 \{\par
00007     assert (parameters ().size () == 1);\par
00008 \par
00009     MCHEmul::Register& x = cpu () -> internalRegister (F6500::C6510::_XREGISTER);\par
00010 \par
00011     {\cf20 // Read the value, makes the operation and sets it back...}\par
00012     MCHEmul::UInt v = MCHEmul::UInt (x.values ()) - MCHEmul::UInt::_1;\par
00013     {\cf20 // A carry could be generated, but it will be ignored...}\par
00014     x.set (v.bytes ()); {\cf20 // 1 byte long always}\par
00015 \par
00016     {\cf20 // Time of the status register}\par
00017     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00018     st.setBitStatus ({\cf22 "N"}, v.negative ());\par
00019     st.setBitStatus ({\cf22 "Z"}, v == MCHEmul::UInt::_0);\par
00020 \par
00021     {\cf19 return} ({\cf17 true});\par
00022 \}\par
00023 \par
00024 {\cf20 // ---}\par
00025 _INST_IMPL (F6500::DEY)\par
00026 \{\par
00027     assert (parameters ().size () == 1);\par
00028 \par
00029     MCHEmul::Register& y = cpu () -> internalRegister (F6500::C6510::_YREGISTER);\par
00030 \par
00031     {\cf20 // Read the value, makes the operation and sets it back...}\par
00032     MCHEmul::UInt v = MCHEmul::UInt (y.values ()) - MCHEmul::UInt::_1;\par
00033     {\cf20 // A carry could be generated, but it will be ignored...}\par
00034     y.set (v.bytes ()); {\cf20 // 1 byte long always}\par
00035 \par
00036     {\cf20 // Time of the status register}\par
00037     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00038     st.setBitStatus ({\cf22 "N"}, v.negative ());\par
00039     st.setBitStatus ({\cf22 "Z"}, v == MCHEmul::UInt::_0);\par
00040 \par
00041     {\cf19 return} ({\cf17 true});\par
00042 \}\par
00043 \par
00044 {\cf20 // ---}\par
00045 _INST_IMPL (F6500::INX)\par
00046 \{\par
00047     assert (parameters ().size () == 1);\par
00048 \par
00049     MCHEmul::Register& x = cpu () -> internalRegister (F6500::C6510::_XREGISTER);\par
00050 \par
00051     {\cf20 // Read the value, makes the operation and sets it back...}\par
00052     MCHEmul::UInt v = MCHEmul::UInt (x.values ()) + MCHEmul::UInt::_1;\par
00053     {\cf20 // A carry could be generated, but it will be ignored...}\par
00054     x.set (v.bytes ()); {\cf20 // 1 byte long always}\par
00055 \par
00056     {\cf20 // Time of the status register}\par
00057     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00058     st.setBitStatus ({\cf22 "N"}, v.negative ());\par
00059     st.setBitStatus ({\cf22 "Z"}, v == MCHEmul::UInt::_0);\par
00060 \par
00061     {\cf19 return} ({\cf17 true});\par
00062 \}\par
00063 \par
00064 {\cf20 // ---}\par
00065 _INST_IMPL (F6500::INY)\par
00066 \{\par
00067     assert (parameters ().size () == 1);\par
00068 \par
00069     MCHEmul::Register& y = cpu () -> internalRegister (F6500::C6510::_YREGISTER);\par
00070 \par
00071     {\cf20 // Read the value, makes the operation and sets it back...}\par
00072     MCHEmul::UInt v = MCHEmul::UInt (y.values ()) + MCHEmul::UInt::_1;\par
00073     {\cf20 // A carry could be generated, but it will be ignored...}\par
00074     y.set (v.bytes ()); {\cf20 // 1 byte long always}\par
00075 \par
00076     {\cf20 // Time of the status register}\par
00077     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00078     st.setBitStatus ({\cf22 "N"}, v.negative ());\par
00079     st.setBitStatus ({\cf22 "Z"}, v == MCHEmul::UInt::_0);\par
00080 \par
00081     {\cf19 return} ({\cf17 true});\par
00082 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/Instructions.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/Instructions.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/Instructions.cpp}
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::BIT_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::BIT_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::NOP)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:Instructions.cpp}
{\xe \v Instructions.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::BIT_Absolute )}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 byte long\par
}{
Definition at line {\b 119} of file {\b Instructions.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_instructions_8cpp_a966bbc6c4a88452e5967adf2864ff95f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:Instructions.cpp}
{\xe \v Instructions.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::BIT_ZeroPage )}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 byte long\par
}{
Definition at line {\b 133} of file {\b Instructions.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_instructions_8cpp_a3e80ec142e3f7979be209df709825de3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:Instructions.cpp}
{\xe \v Instructions.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::NOP )}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b Instructions.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Instructions.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/Instructions.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/Instructions.cpp}
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 MCHEmul::Address F6500::Instruction::address_absolute ()\par
00006 \{\par
00007     assert (parameters ().size () == 3);\par
00008 \par
00009     {\cf19 return} (MCHEmul::Address (\{ parameters ()[1], parameters ()[2] \}, {\cf17 false}));\par
00010 \}\par
00011 \par
00012 {\cf20 // ---}\par
00013 MCHEmul::Address F6500::Instruction::address_zeroPage ()\par
00014 \{\par
00015     assert (parameters ().size () == 2);\par
00016 \par
00017     {\cf19 return} (MCHEmul::Address (\{ parameters ()[1] \}));\par
00018 \}\par
00019 \par
00020 {\cf20 // ---}\par
00021 MCHEmul::Address F6500::Instruction::address_absoluteX ()\par
00022 \{\par
00023     assert (parameters ().size () == 3);\par
00024 \par
00025     MCHEmul::Register& x = cpu () -> internalRegister (F6500::C6510::_XREGISTER);\par
00026 \par
00027     MCHEmul::Address iA (\{ parameters ()[1], parameters ()[2] \}, {\cf17 false});\par
00028     MCHEmul::Address fA = iA + x [0].value ();\par
00029     {\cf19 if} (iA [0] != fA [0]) _additionalCycles = 1; {\cf20 // Page jump in the address so one cycle more}\par
00030     {\cf19 return} (fA);\par
00031 \}\par
00032 \par
00033 {\cf20 // ---}\par
00034 MCHEmul::Address F6500::Instruction::address_absoluteY ()\par
00035 \{\par
00036     assert (parameters ().size () == 3);\par
00037 \par
00038     MCHEmul::Register& y = cpu () -> internalRegister (F6500::C6510::_YREGISTER);\par
00039 \par
00040     MCHEmul::Address iA (\{ parameters ()[1], parameters ()[2] \}, {\cf17 false});\par
00041     MCHEmul::Address fA = iA + y [0].value ();\par
00042     {\cf19 if} (iA [0] != fA [0]) _additionalCycles = 1; {\cf20 // Page jump in the address so one cycle more}\par
00043     {\cf19 return} (fA);\par
00044 \}\par
00045 \par
00046 {\cf20 // ---}\par
00047 MCHEmul::Address F6500::Instruction::address_zeroPageX ()\par
00048 \{\par
00049     assert (parameters ().size () == 2);\par
00050 \par
00051     MCHEmul::Register& x = cpu () -> internalRegister (F6500::C6510::_XREGISTER);\par
00052 \par
00053     MCHEmul::Address iA (\{ parameters ()[1] \});\par
00054     {\cf19 return} (iA + x [0].value ());\par
00055 \}\par
00056 \par
00057 {\cf20 // ---}\par
00058 MCHEmul::Address F6500::Instruction::address_zeroPageY ()\par
00059 \{\par
00060     assert (parameters ().size () == 2);\par
00061 \par
00062     MCHEmul::Register& y = cpu () -> internalRegister (F6500::C6510::_XREGISTER);\par
00063 \par
00064     MCHEmul::Address iA (\{ parameters ()[1] \});\par
00065     {\cf19 return} (iA + y [0].value ());\par
00066 \}\par
00067 \par
00068 {\cf20 // ---}\par
00069 MCHEmul::Address F6500::Instruction::address_indirectZeroPageX ()\par
00070 \{\par
00071     assert (parameters ().size () == 2);\par
00072 \par
00073     MCHEmul::Register& x = cpu () -> internalRegister (F6500::C6510::_XREGISTER);\par
00074 \par
00075     {\cf20 // Pre - indirect zero page addressing...}\par
00076     MCHEmul::Address iA = MCHEmul::Address (\{ parameters ()[1] \}) + x [0].value ();\par
00077     {\cf19 return} (MCHEmul::Address (memory () -> values (iA, 2), {\cf17 false})); \par
00078 \}\par
00079 \par
00080 {\cf20 // ---}\par
00081 MCHEmul::Address F6500::Instruction::address_indirectZeroPageY ()\par
00082 \{\par
00083     assert (parameters ().size () == 2);\par
00084 \par
00085     MCHEmul::Register& y = cpu () -> internalRegister (F6500::C6510::_YREGISTER);\par
00086 \par
00087     {\cf20 // Post - indirect zero page addressing...}\par
00088     MCHEmul::Address iA (memory () -> values (MCHEmul::Address (\{ parameters ()[1] \}), 2), {\cf17 false});\par
00089     MCHEmul::Address fA = iA + y [0].value ();\par
00090     {\cf19 if} (iA [0] != fA [0]) _additionalCycles = 1; {\cf20 // Page jump in the address so one cycle more}\par
00091     {\cf19 return} (fA);\par
00092 \}\par
00093 \par
00094 {\cf20 // ---}\par
00095 MCHEmul::Address F6500::Instruction::address_indirect ()\par
00096 \{\par
00097     assert (parameters ().size () == 3);\par
00098 \par
00099     {\cf19 return} (MCHEmul::Address (memory () -> values \par
00100         (MCHEmul::Address (\{ parameters ()[1], parameters ()[2] \}, {\cf17 false}), 2), {\cf17 false}));\par
00101 \}\par
00102 \par
00103 {\cf20 // ---}\par
00104 MCHEmul::UByte F6500::Instruction::value_inmediate ()\par
00105 \{\par
00106     assert (parameters ().size () == 2);\par
00107 \par
00108     {\cf19 return} (parameters ()[1]);\par
00109 \}\par
00110 \par
00111 {\cf20 // ---}\par
00112 MCHEmul::UByte F6500::Instruction::value_relative ()\par
00113 \{\par
00114     assert (parameters ().size () == 2);\par
00115 \par
00116     {\cf19 return} (parameters ()[1]); {\cf20 // The number can be interpreted as a negative number (used in jumps)...}\par
00117 \}\par
00118 \par
00119 _INST_IMPL (F6500::BIT_Absolute)\par
00120 \{\par
00121     MCHEmul::UByte v = value_absolute ();\par
00122 \par
00123     {\cf18 bool} z = (v & cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR).values ()[0] ) == MCHEmul::UByte::_0;\par
00124 \par
00125     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00126     st.setBitStatus ({\cf22 "N"}, v [7]);\par
00127     st.setBitStatus ({\cf22 "V"}, v [6]);\par
00128     st.setBitStatus ({\cf22 "Z"}, z);\par
00129 \par
00130     {\cf19 return} ({\cf17 true});\par
00131 \}\par
00132 \par
00133 _INST_IMPL (F6500::BIT_ZeroPage)\par
00134 \{\par
00135     MCHEmul::UByte v = value_zeroPage ();\par
00136 \par
00137     {\cf18 bool} z = (v & cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR).values ()[0] ) == MCHEmul::UByte::_0;\par
00138 \par
00139     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00140     st.setBitStatus ({\cf22 "N"}, v [7]);\par
00141     st.setBitStatus ({\cf22 "V"}, v [6]);\par
00142     st.setBitStatus ({\cf22 "Z"}, z);\par
00143 \par
00144     {\cf19 return} ({\cf17 true});\par
00145 \}\par
00146 \par
00147 _INST_IMPL (F6500::NOP)\par
00148 \{\par
00149     assert (parameters ().size () == 1);\par
00150 \par
00151     {\cf20 // Does nothing}\par
00152     {\cf19 return} ({\cf17 true});\par
00153 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/IRQInterrupt.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/IRQInterrupt.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/IRQInterrupt.cpp}
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/IRQInterrupt.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IRQInterrupt.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/IRQInterrupt.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/IRQInterrupt.cpp}
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/IRQInterrupt.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::IRQInterrupt::isTime (MCHEmul::CPU* c){\cf17  const}\par
00006 {\cf17 }\{\par
00007     {\cf19 return} (!c -> statusRegister ().bitStatus ({\cf22 "I"}));\par
00008 \}\par
00009 \par
00010 {\cf20 // ---}\par
00011 {\cf18 void} F6500::IRQInterrupt::executeOverImpl (MCHEmul::CPU* c, {\cf18 unsigned} {\cf18 int}& nC)\par
00012 \{\par
00013     assert (c != {\cf17 nullptr});\par
00014     assert (c -> memoryRef () != {\cf17 nullptr});\par
00015     assert (c -> memoryRef () -> stack () != {\cf17 nullptr});\par
00016 \par
00017     MCHEmul::StatusRegister& st = c -> statusRegister ();\par
00018     MCHEmul::ProgramCounter& pc = c -> programCounter ();\par
00019     c -> memoryRef () -> stack () -> push (pc.asAddress ().bytes () );\par
00020     c -> memoryRef () -> stack () -> push (st.valuesWithout (\{ {\cf22 "B"} \})); {\cf20 // The break flag is not taken into account...}\par
00021     st.setBitStatus ({\cf22 "I"}, {\cf17 true}); {\cf20 // No more interruptions so far...}\par
00022 \par
00023     pc.setAddress (MCHEmul::Address (c -> memoryRef () -> values \par
00024         ({\cf17 dynamic_cast <}F6500::C6510*{\cf17 >} (c) -> IRQVectorAddress (), 2), {\cf17 false} ));\par
00025 \par
00026     nC = 7; {\cf20 // 7 ticks has taken...}\par
00027 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/JUMPS.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/JUMPS.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/JUMPS.cpp}
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::BRK)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::JMP_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::JMP_Indirect)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::JSR_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::RTI)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::RTS)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:JUMPS.cpp}
{\xe \v JUMPS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::BRK )}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Little - endian.\par
}{
Definition at line {\b 5} of file {\b JUMPS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_j_u_m_p_s_8cpp_a51db7645c84e2f42f42b67c1fcc046eb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:JUMPS.cpp}
{\xe \v JUMPS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::JMP_Absolute )}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b JUMPS.cpp}.}\par
}
{\xe \v _INST_IMPL\:JUMPS.cpp}
{\xe \v JUMPS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::JMP_Indirect )}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b JUMPS.cpp}.}\par
}
{\xe \v _INST_IMPL\:JUMPS.cpp}
{\xe \v JUMPS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::JSR_Absolute )}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b JUMPS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_j_u_m_p_s_8cpp_a6cf22315acbb444e845a4556a08f3f33_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:JUMPS.cpp}
{\xe \v JUMPS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::RTI )}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Are recover in Little-endian format\par
}{
Definition at line {\b 59} of file {\b JUMPS.cpp}.}\par
}
{\xe \v _INST_IMPL\:JUMPS.cpp}
{\xe \v JUMPS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::RTS )}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Are recover in Little-endian format\par
}{
Definition at line {\b 76} of file {\b JUMPS.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JUMPS.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/JUMPS.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/JUMPS.cpp}
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 _INST_IMPL (F6500::BRK)\par
00006 \{\par
00007     assert (parameters ().size () == 1);\par
00008 \par
00009     MCHEmul::ProgramCounter& pc = cpu () -> programCounter ();\par
00010     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00011 \par
00012     stack () -> push (pc.asAddress ().bytes ());\par
00013     stack () -> push (st.values ());\par
00014 \par
00015     st.setBitStatus ({\cf22 "I"}, {\cf17 true}); {\cf20 // No more interruptions so far...}\par
00016     st.setBitStatus ({\cf22 "B"}, {\cf17 true});\par
00017 \par
00018     {\cf20 // Jump to the IRQ vector...}\par
00019     pc.setAddress (MCHEmul::Address (memory () -> values \par
00020         ({\cf17 dynamic_cast <}F6500::C6510*{\cf17 >} (cpu ()) -> IRQVectorAddress (), 2), {\cf17 false} ));\par
00021 \par
00022     {\cf19 return} ({\cf17 true});\par
00023 \}\par
00024 \par
00025 {\cf20 // ---}\par
00026 _INST_IMPL (F6500::JMP_Absolute)\par
00027 \{\par
00028     cpu () -> programCounter ().setAddress (address_absolute ());\par
00029 \par
00030     {\cf19 return} ({\cf17 true});\par
00031 \}\par
00032 \par
00033 {\cf20 // ---}\par
00034 _INST_IMPL (F6500::JMP_Indirect)\par
00035 \{\par
00036     cpu () -> programCounter ().setAddress (address_indirect ());\par
00037 \par
00038     {\cf19 return} ({\cf17 true});\par
00039 \}\par
00040 \par
00041 {\cf20 // ---}\par
00042 _INST_IMPL (F6500::JSR_Absolute)\par
00043 \{\par
00044     assert (parameters ().size () == 3);\par
00045 \par
00046     MCHEmul::ProgramCounter& pc = cpu () -> programCounter ();\par
00047 \par
00048     {\cf20 // The address always is kept in Big-endian format,}\par
00049     {\cf20 // The stack stores always high byte first. So no changes are needed...}\par
00050     {\cf20 // Different story in RTI or RTS!}\par
00051     stack () -> push (pc.asAddress ().values ());\par
00052 \par
00053     pc.setAddress (address_absolute ());\par
00054 \par
00055     {\cf19 return} ({\cf17 true});\par
00056 \}\par
00057 \par
00058 {\cf20 // ---}\par
00059 _INST_IMPL (F6500::RTI)\par
00060 \{\par
00061     assert (parameters ().size () == 1);\par
00062 \par
00063     {\cf20 // When a interruption is lunched, the status and the program counter is stored,}\par
00064     {\cf20 // so it has to be recovered just in the other way around...}\par
00065     cpu () -> programCounter ().setAddress \par
00066         (MCHEmul::Address (stack () -> pull (2), {\cf17 false} ));\par
00067 \par
00068     {\cf20 // See the part of the logic where the interruptions are managed, }\par
00069     {\cf20 // to see how status register is also saved!}\par
00070     cpu () -> statusRegister ().set (stack () -> pull (1)); \par
00071 \par
00072     {\cf19 return} ({\cf17 true});\par
00073 \}\par
00074 \par
00075 {\cf20 // ---}\par
00076 _INST_IMPL (F6500::RTS)\par
00077 \{\par
00078     assert (parameters ().size () == 1);\par
00079 \par
00080     cpu () -> programCounter ().setAddress \par
00081         (MCHEmul::Address (stack () -> pull (2), {\cf17 false} ));\par
00082 \par
00083     {\cf19 return} ({\cf17 true});\par
00084 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/LDA.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/LDA.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/LDA.cpp}
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDA_Inmediate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDA_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDA_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDA_ZeroPageIndirectX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDA_ZeroPageIndirectY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDA_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDA_AbsoluteX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDA_AbsoluteY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:LDA.cpp}
{\xe \v LDA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDA_Absolute )}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b LDA.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDA.cpp}
{\xe \v LDA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDA_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b LDA.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDA.cpp}
{\xe \v LDA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDA_AbsoluteY )}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b LDA.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDA.cpp}
{\xe \v LDA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDA_Inmediate )}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b LDA.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDA.cpp}
{\xe \v LDA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDA_ZeroPage )}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b LDA.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDA.cpp}
{\xe \v LDA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDA_ZeroPageIndirectX )}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b LDA.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDA.cpp}
{\xe \v LDA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDA_ZeroPageIndirectY )}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b LDA.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDA.cpp}
{\xe \v LDA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDA_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b LDA.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LDA.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/LDA.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/LDA.cpp}
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::LDA_General::executeWith (MCHEmul::UByte u)\par
00006 \{\par
00007     {\cf20 // Set the value...}\par
00008     cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR).set (\{ u \});\par
00009 \par
00010     {\cf20 // Time of the status register...}\par
00011     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00012     st.setBitStatus ({\cf22 "N"}, u [7]);\par
00013     st.setBitStatus ({\cf22 "Z"}, u == MCHEmul::UByte::_0);\par
00014 \par
00015     {\cf19 return} ({\cf17 true});\par
00016 \}\par
00017 \par
00018 {\cf20 // ---}\par
00019 _INST_IMPL (F6500::LDA_Inmediate)\par
00020 \{\par
00021     {\cf19 return} (executeWith (value_inmediate ()));\par
00022 \}\par
00023 \par
00024 {\cf20 // ---}\par
00025 _INST_IMPL (F6500::LDA_Absolute)\par
00026 \{\par
00027     {\cf19 return} (executeWith (value_absolute ()));\par
00028 \}\par
00029 \par
00030 {\cf20 // ---}\par
00031 _INST_IMPL (F6500::LDA_ZeroPage)\par
00032 \{\par
00033     {\cf19 return} (executeWith (value_zeroPage ()));\par
00034 \}\par
00035 \par
00036 {\cf20 // ---}\par
00037 _INST_IMPL (F6500::LDA_ZeroPageIndirectX)\par
00038 \{\par
00039     {\cf19 return} (executeWith (value_indirectZeroPageX ()));\par
00040 \}\par
00041 \par
00042 {\cf20 // ---}\par
00043 _INST_IMPL (F6500::LDA_ZeroPageIndirectY)\par
00044 \{\par
00045     {\cf19 return} (executeWith (value_indirectZeroPageY ()));\par
00046 \}\par
00047 \par
00048 {\cf20 // ---}\par
00049 _INST_IMPL (F6500::LDA_ZeroPageX)\par
00050 \{\par
00051     {\cf19 return} (executeWith (value_zeroPageX ()));\par
00052 \}\par
00053 \par
00054 {\cf20 // ---}\par
00055 _INST_IMPL (F6500::LDA_AbsoluteX)\par
00056 \{\par
00057     {\cf19 return} (executeWith (value_absoluteX ()));\par
00058 \}\par
00059 \par
00060 {\cf20 // ---}\par
00061 _INST_IMPL (F6500::LDA_AbsoluteY)\par
00062 \{\par
00063     {\cf19 return} (executeWith (value_absoluteY ()));\par
00064 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/LDX.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/LDX.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/LDX.cpp}
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDX_Inmediate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDX_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDX_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDX_AbsoluteY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDX_ZeroPageY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:LDX.cpp}
{\xe \v LDX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDX_Absolute )}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b LDX.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDX.cpp}
{\xe \v LDX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDX_AbsoluteY )}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b LDX.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDX.cpp}
{\xe \v LDX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDX_Inmediate )}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b LDX.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDX.cpp}
{\xe \v LDX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDX_ZeroPage )}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b LDX.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDX.cpp}
{\xe \v LDX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDX_ZeroPageY )}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b LDX.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LDX.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/LDX.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/LDX.cpp}
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::LDX_General::executeWith (MCHEmul::UByte u)\par
00006 \{\par
00007     {\cf20 // Set the value...}\par
00008     cpu () -> internalRegister (F6500::C6510::_XREGISTER).set (\{ u \});\par
00009 \par
00010     {\cf20 // Time of the status register...}\par
00011     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00012     st.setBitStatus ({\cf22 "N"}, u [7]);\par
00013     st.setBitStatus ({\cf22 "Z"}, u == MCHEmul::UByte::_0);\par
00014 \par
00015     {\cf19 return} ({\cf17 true});\par
00016 \}\par
00017 \par
00018 {\cf20 // ---}\par
00019 _INST_IMPL (F6500::LDX_Inmediate)\par
00020 \{\par
00021     {\cf19 return} (executeWith (value_inmediate ()));\par
00022 \}\par
00023 \par
00024 {\cf20 // ---}\par
00025 _INST_IMPL (F6500::LDX_Absolute)\par
00026 \{\par
00027     {\cf19 return} (executeWith (value_absolute ()));\par
00028 \}\par
00029 \par
00030 {\cf20 // ---}\par
00031 _INST_IMPL (F6500::LDX_ZeroPage)\par
00032 \{\par
00033     {\cf19 return} (executeWith (value_zeroPage ()));\par
00034 \}\par
00035 \par
00036 {\cf20 // ---}\par
00037 _INST_IMPL (F6500::LDX_AbsoluteY)\par
00038 \{\par
00039     {\cf19 return} (executeWith (value_absoluteY ()));\par
00040 \}\par
00041 \par
00042 {\cf20 // ---}\par
00043 _INST_IMPL (F6500::LDX_ZeroPageY)\par
00044 \{\par
00045     {\cf19 return} (executeWith (value_zeroPageY ()));\par
00046 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/LDY.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/LDY.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/LDY.cpp}
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDY_Inmediate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDY_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDY_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDY_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LDY_AbsoluteX)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:LDY.cpp}
{\xe \v LDY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDY_Absolute )}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b LDY.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDY.cpp}
{\xe \v LDY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDY_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b LDY.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDY.cpp}
{\xe \v LDY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDY_Inmediate )}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b LDY.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDY.cpp}
{\xe \v LDY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDY_ZeroPage )}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b LDY.cpp}.}\par
}
{\xe \v _INST_IMPL\:LDY.cpp}
{\xe \v LDY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LDY_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b LDY.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LDY.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/LDY.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/LDY.cpp}
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::LDY_General::executeWith (MCHEmul::UByte u)\par
00006 \{\par
00007     {\cf20 // Set the value...}\par
00008     cpu () -> internalRegister (F6500::C6510::_YREGISTER).set (\{ u \});\par
00009 \par
00010     {\cf20 // Time of the status register...}\par
00011     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00012     st.setBitStatus ({\cf22 "N"}, u [7]);\par
00013     st.setBitStatus ({\cf22 "Z"}, u == MCHEmul::UByte::_0);\par
00014 \par
00015     {\cf19 return} ({\cf17 true});\par
00016 \}\par
00017 \par
00018 {\cf20 // ---}\par
00019 _INST_IMPL (F6500::LDY_Inmediate)\par
00020 \{\par
00021     {\cf19 return} (executeWith (value_inmediate ()));\par
00022 \}\par
00023 \par
00024 {\cf20 // ---}\par
00025 _INST_IMPL (F6500::LDY_Absolute)\par
00026 \{\par
00027     {\cf19 return} (executeWith (value_absolute ()));\par
00028 \}\par
00029 \par
00030 {\cf20 // ---}\par
00031 _INST_IMPL (F6500::LDY_ZeroPage)\par
00032 \{\par
00033     {\cf19 return} (executeWith (value_zeroPage ()));\par
00034 \}\par
00035 \par
00036 {\cf20 // ---}\par
00037 _INST_IMPL (F6500::LDY_ZeroPageX)\par
00038 \{\par
00039     {\cf19 return} (executeWith (value_zeroPageX ()));\par
00040 \}\par
00041 \par
00042 {\cf20 // ---}\par
00043 _INST_IMPL (F6500::LDY_AbsoluteX)\par
00044 \{\par
00045     {\cf19 return} (executeWith (value_absoluteX ()));\par
00046 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/LSR.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/LSR.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/LSR.cpp}
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LSR_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LSR_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LSR_Accumulator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LSR_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::LSR_AbsoluteX)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:LSR.cpp}
{\xe \v LSR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LSR_Absolute )}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b LSR.cpp}.}\par
}
{\xe \v _INST_IMPL\:LSR.cpp}
{\xe \v LSR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LSR_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b LSR.cpp}.}\par
}
{\xe \v _INST_IMPL\:LSR.cpp}
{\xe \v LSR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LSR_Accumulator )}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0 is put into\par
}{
Definition at line {\b 34} of file {\b LSR.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_l_s_r_8cpp_ae50ff83b00d18c11536f3e387a560cd3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:LSR.cpp}
{\xe \v LSR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LSR_ZeroPage )}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b LSR.cpp}.}\par
}
{\xe \v _INST_IMPL\:LSR.cpp}
{\xe \v LSR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::LSR_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b LSR.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LSR.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/LSR.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/LSR.cpp}
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::LSR_General::executeOn ({\cf17 const} MCHEmul::Address& a)\par
00006 \{\par
00007     {\cf20 // Read the value, makes the operation and set it back!}\par
00008     MCHEmul::UByte v = memory () -> values (a, 1)[0]; {\cf20 // 1 byte long always}\par
00009     {\cf18 bool} c = v.shiftRightC (1, {\cf17 false} ); {\cf20 // Keeps the status of the last bit to actualize later the carry flag}\par
00010     memory () -> set (a, \{ v \});\par
00011 \par
00012     {\cf20 // Time of the status register...}\par
00013     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00014     st.setBitStatus ({\cf22 "N"}, v [7]);\par
00015     st.setBitStatus ({\cf22 "Z"}, v == MCHEmul::UByte::_0);\par
00016     st.setBitStatus ({\cf22 "C"}, c);\par
00017 \par
00018     {\cf19 return} ({\cf17 true});\par
00019 \}\par
00020 \par
00021 {\cf20 // ---}\par
00022 _INST_IMPL (F6500::LSR_Absolute)\par
00023 \{\par
00024     {\cf19 return} (executeOn (address_absolute ()));\par
00025 \}\par
00026 \par
00027 {\cf20 // ---}\par
00028 _INST_IMPL (F6500::LSR_ZeroPage)\par
00029 \{\par
00030     {\cf19 return} (executeOn (address_zeroPage ()));\par
00031 \}\par
00032 \par
00033 {\cf20 // ---}\par
00034 _INST_IMPL (F6500::LSR_Accumulator)\par
00035 \{\par
00036     assert (parameters ().size () == 1);\par
00037 \par
00038     MCHEmul::Register& a = cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR);\par
00039 \par
00040     {\cf20 // Set the value...}\par
00041     MCHEmul::UBytes v = a.values ();\par
00042     {\cf18 bool} c = v.shiftRightC (1, {\cf17 false} );\par
00043     a.set (v);\par
00044 \par
00045     {\cf20 // Time of the status register...}\par
00046     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00047     st.setBitStatus ({\cf22 "N"}, v [0][7]);\par
00048     st.setBitStatus ({\cf22 "Z"}, v [0] == MCHEmul::UByte::_0);\par
00049     st.setBitStatus ({\cf22 "C"}, c);\par
00050 \par
00051     {\cf19 return} ({\cf17 true});\par
00052 \}\par
00053 \par
00054 {\cf20 // ---}\par
00055 _INST_IMPL (F6500::LSR_ZeroPageX)\par
00056 \{\par
00057     {\cf19 return} (executeOn (address_zeroPageX ()));\par
00058 \}\par
00059 \par
00060 {\cf20 // ---}\par
00061 _INST_IMPL (F6500::LSR_AbsoluteX)\par
00062 \{\par
00063     {\cf19 return} (executeOn (address_absoluteX ()));\par
00064 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/NMIInterrupt.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/NMIInterrupt.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/NMIInterrupt.cpp}
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/NMIInterrupt.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NMIInterrupt.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/NMIInterrupt.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/NMIInterrupt.cpp}
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/NMIInterrupt.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 void} F6500::NMIInterrupt::executeOverImpl (MCHEmul::CPU* c, {\cf18 unsigned} {\cf18 int}& nC)\par
00006 \{\par
00007     assert (c != {\cf17 nullptr});\par
00008     assert (c -> memoryRef () != {\cf17 nullptr});\par
00009     assert (c -> memoryRef () -> stack () != {\cf17 nullptr});\par
00010 \par
00011     MCHEmul::ProgramCounter& pc = c -> programCounter ();\par
00012     MCHEmul::StatusRegister& st = c -> statusRegister ();\par
00013     c -> memoryRef () -> stack () -> push (pc.asAddress ().bytes () );\par
00014     c -> memoryRef () -> stack () -> push (st.valuesWithout (\{ {\cf22 "B"} \})); {\cf20 // The break flag is not taken into account...}\par
00015 \par
00016     pc.setAddress (MCHEmul::Address (c -> memoryRef () -> values \par
00017         ({\cf17 dynamic_cast <}F6500::C6510*{\cf17 >} (c) -> NMIVectorAddress (), 2), {\cf17 false} ));\par
00018 \par
00019     nC = 7; {\cf20 // It took 7 ticks to run it...}\par
00020 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/ORA.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/ORA.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/ORA.cpp}
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ORA_Inmediate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ORA_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ORA_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ORA_ZeroPageIndirectX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ORA_ZeroPageIndirectY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ORA_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ORA_AbsoluteX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ORA_AbsoluteY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:ORA.cpp}
{\xe \v ORA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ORA_Absolute )}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b ORA.cpp}.}\par
}
{\xe \v _INST_IMPL\:ORA.cpp}
{\xe \v ORA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ORA_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b ORA.cpp}.}\par
}
{\xe \v _INST_IMPL\:ORA.cpp}
{\xe \v ORA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ORA_AbsoluteY )}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b ORA.cpp}.}\par
}
{\xe \v _INST_IMPL\:ORA.cpp}
{\xe \v ORA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ORA_Inmediate )}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b ORA.cpp}.}\par
}
{\xe \v _INST_IMPL\:ORA.cpp}
{\xe \v ORA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ORA_ZeroPage )}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b ORA.cpp}.}\par
}
{\xe \v _INST_IMPL\:ORA.cpp}
{\xe \v ORA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ORA_ZeroPageIndirectX )}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b ORA.cpp}.}\par
}
{\xe \v _INST_IMPL\:ORA.cpp}
{\xe \v ORA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ORA_ZeroPageIndirectY )}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b ORA.cpp}.}\par
}
{\xe \v _INST_IMPL\:ORA.cpp}
{\xe \v ORA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ORA_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b ORA.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ORA.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/ORA.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/ORA.cpp}
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::ORA_General::executeWith (MCHEmul::UByte u)\par
00006 \{\par
00007     MCHEmul::Register& a = cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR);\par
00008     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00009     \par
00010     {\cf20 // Read the value, makes the operation and sets it back...}\par
00011     MCHEmul::UByte r = a.values ()[0] | u;\par
00012     a.set (\{ r \});\par
00013 \par
00014     {\cf20 // Time of the status register...}\par
00015     st.setBitStatus ({\cf22 "N"}, r [7]);\par
00016     st.setBitStatus ({\cf22 "Z"}, r == MCHEmul::UByte::_0);\par
00017 \par
00018     {\cf19 return} ({\cf17 true});\par
00019 \}\par
00020 \par
00021 {\cf20 // ---}\par
00022 _INST_IMPL (F6500::ORA_Inmediate)\par
00023 \{\par
00024     {\cf19 return} (executeWith (value_inmediate ()));\par
00025 \}\par
00026 \par
00027 {\cf20 // ---}\par
00028 _INST_IMPL (F6500::ORA_Absolute)\par
00029 \{\par
00030     {\cf19 return} (executeWith (value_absolute ()));\par
00031 \}\par
00032 \par
00033 {\cf20 // ---}\par
00034 _INST_IMPL (F6500::ORA_ZeroPage)\par
00035 \{\par
00036     {\cf19 return} (executeWith (value_zeroPage ()));\par
00037 \}\par
00038 \par
00039 {\cf20 // ---}\par
00040 _INST_IMPL (F6500::ORA_ZeroPageIndirectX)\par
00041 \{\par
00042     {\cf19 return} (executeWith (value_indirectZeroPageX ()));\par
00043 \}\par
00044 \par
00045 {\cf20 // ---}\par
00046 _INST_IMPL (F6500::ORA_ZeroPageIndirectY)\par
00047 \{\par
00048     {\cf19 return} (executeWith (value_indirectZeroPageY ()));\par
00049 \}\par
00050 \par
00051 {\cf20 // ---}\par
00052 _INST_IMPL (F6500::ORA_ZeroPageX)\par
00053 \{\par
00054     {\cf19 return} (executeWith (value_zeroPageX ()));\par
00055 \}\par
00056 \par
00057 {\cf20 // ---}\par
00058 _INST_IMPL (F6500::ORA_AbsoluteX)\par
00059 \{\par
00060     {\cf19 return} (executeWith (value_absoluteX ()));\par
00061 \}\par
00062 \par
00063 {\cf20 // ---}\par
00064 _INST_IMPL (F6500::ORA_AbsoluteY)\par
00065 \{\par
00066     {\cf19 return} (executeWith (value_absoluteY ()));\par
00067 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/ROL.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/ROL.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/ROL.cpp}
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ROL_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ROL_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ROL_Accumulator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ROL_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ROL_AbsoluteX)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:ROL.cpp}
{\xe \v ROL.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ROL_Absolute )}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b ROL.cpp}.}\par
}
{\xe \v _INST_IMPL\:ROL.cpp}
{\xe \v ROL.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ROL_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b ROL.cpp}.}\par
}
{\xe \v _INST_IMPL\:ROL.cpp}
{\xe \v ROL.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ROL_Accumulator )}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b ROL.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_r_o_l_8cpp_ad42b0c961975b1d41d3173a932a6aa29_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:ROL.cpp}
{\xe \v ROL.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ROL_ZeroPage )}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b ROL.cpp}.}\par
}
{\xe \v _INST_IMPL\:ROL.cpp}
{\xe \v ROL.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ROL_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b ROL.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ROL.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/ROL.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/ROL.cpp}
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::ROL_General::executeOn ({\cf17 const} MCHEmul::Address& a)\par
00006 \{\par
00007     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00008     {\cf18 bool} c = st.bitStatus ({\cf22 "C"}); \par
00009 \par
00010     {\cf20 // Read the value, makes the operation and set it back!}\par
00011     MCHEmul::UByte v = memory () -> values (a, 1)[0]; {\cf20 // 1 byte long always}\par
00012     c = v.rotateLeftC (1, c ); {\cf20 // Keeps the status of the last bit to actualize later the carry flag}\par
00013     memory () -> set (a, \{ v \});\par
00014 \par
00015     {\cf20 // Time of the status register...}\par
00016     st.setBitStatus ({\cf22 "N"}, v [7]);\par
00017     st.setBitStatus ({\cf22 "Z"}, v == MCHEmul::UByte::_0);\par
00018     st.setBitStatus ({\cf22 "C"}, c);\par
00019 \par
00020     {\cf19 return} ({\cf17 true});\par
00021 \}\par
00022 \par
00023 {\cf20 // ---}\par
00024 _INST_IMPL (F6500::ROL_Absolute)\par
00025 \{\par
00026     {\cf19 return} (executeOn (address_absolute ()));\par
00027 \}\par
00028 \par
00029 {\cf20 // ---}\par
00030 _INST_IMPL (F6500::ROL_ZeroPage)\par
00031 \{\par
00032     {\cf19 return} (executeOn (address_zeroPage ()));\par
00033 \}\par
00034 \par
00035 {\cf20 // ---}\par
00036 _INST_IMPL (F6500::ROL_Accumulator)\par
00037 \{\par
00038     assert (parameters ().size () == 1);\par
00039 \par
00040     MCHEmul::Register& a = cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR);\par
00041     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00042     {\cf18 bool} c = st.bitStatus ({\cf22 "C"}); \par
00043 \par
00044     {\cf20 // Set the value...}\par
00045     MCHEmul::UBytes v = a.values ();\par
00046     c = v.rotateLeftC (1, c);\par
00047     a.set (v);\par
00048 \par
00049     {\cf20 // Time of the status register...}\par
00050     st.setBitStatus ({\cf22 "N"}, v [0][7]);\par
00051     st.setBitStatus ({\cf22 "Z"}, v [0] == MCHEmul::UByte::_0);\par
00052     st.setBitStatus ({\cf22 "C"}, c);\par
00053 \par
00054     {\cf19 return} ({\cf17 true});\par
00055 \}\par
00056 \par
00057 {\cf20 // ---}\par
00058 _INST_IMPL (F6500::ROL_ZeroPageX)\par
00059 \{\par
00060     {\cf19 return} (executeOn (address_zeroPageX ()));\par
00061 \}\par
00062 \par
00063 {\cf20 // ---}\par
00064 _INST_IMPL (F6500::ROL_AbsoluteX)\par
00065 \{\par
00066     {\cf19 return} (executeOn (address_absoluteX ()));\par
00067 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/ROR.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/ROR.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/ROR.cpp}
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ROR_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ROR_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ROR_Accumulator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ROR_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::ROR_AbsoluteX)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:ROR.cpp}
{\xe \v ROR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ROR_Absolute )}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b ROR.cpp}.}\par
}
{\xe \v _INST_IMPL\:ROR.cpp}
{\xe \v ROR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ROR_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b ROR.cpp}.}\par
}
{\xe \v _INST_IMPL\:ROR.cpp}
{\xe \v ROR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ROR_Accumulator )}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b ROR.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_r_o_r_8cpp_a5a69e7e9c3e49fe46b8aa739013f8d98_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:ROR.cpp}
{\xe \v ROR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ROR_ZeroPage )}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b ROR.cpp}.}\par
}
{\xe \v _INST_IMPL\:ROR.cpp}
{\xe \v ROR.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::ROR_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b ROR.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ROR.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/ROR.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/ROR.cpp}
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::ROR_General::executeOn ({\cf17 const} MCHEmul::Address& a)\par
00006 \{\par
00007     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00008     {\cf18 bool} c = st.bitStatus ({\cf22 "C"}); \par
00009 \par
00010     {\cf20 // Read the value, makes the operation and set it back!}\par
00011     MCHEmul::UByte v = memory () -> values (a, 1)[0]; {\cf20 // 1 byte long always}\par
00012     c = v.rotateRightC (1, c ); {\cf20 // Keeps the status of the last bit to actualize later the carry flag}\par
00013     memory () -> set (a, \{ v \});\par
00014 \par
00015     {\cf20 // Time of the status register...}\par
00016     st.setBitStatus ({\cf22 "N"}, v [7]);\par
00017     st.setBitStatus ({\cf22 "Z"}, v == MCHEmul::UByte::_0);\par
00018     st.setBitStatus ({\cf22 "C"}, c);\par
00019 \par
00020     {\cf19 return} ({\cf17 true});\par
00021 \}\par
00022 \par
00023 {\cf20 // ---}\par
00024 _INST_IMPL (F6500::ROR_Absolute)\par
00025 \{\par
00026     {\cf19 return} (executeOn (address_absolute ()));\par
00027 \}\par
00028 \par
00029 {\cf20 // ---}\par
00030 _INST_IMPL (F6500::ROR_ZeroPage)\par
00031 \{\par
00032     {\cf19 return} (executeOn (address_zeroPage ()));\par
00033 \}\par
00034 \par
00035 {\cf20 // ---}\par
00036 _INST_IMPL (F6500::ROR_Accumulator)\par
00037 \{\par
00038     assert (parameters ().size () == 1);\par
00039 \par
00040     MCHEmul::Register& a = cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR);\par
00041     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00042     {\cf18 bool} c = st.bitStatus ({\cf22 "C"}); \par
00043 \par
00044     {\cf20 // Set the value...}\par
00045     MCHEmul::UBytes v = a.values ();\par
00046     c = v.rotateRightC (1, c);\par
00047     a.set (v);\par
00048 \par
00049     {\cf20 // Time of the status register...}\par
00050     st.setBitStatus ({\cf22 "N"}, v [0][7]);\par
00051     st.setBitStatus ({\cf22 "Z"}, v [0] == MCHEmul::UByte::_0);\par
00052     st.setBitStatus ({\cf22 "C"}, c);\par
00053 \par
00054     {\cf19 return} ({\cf17 true});\par
00055 \}\par
00056 \par
00057 {\cf20 // ---}\par
00058 _INST_IMPL (F6500::ROR_ZeroPageX)\par
00059 \{\par
00060     {\cf19 return} (executeOn (address_zeroPageX ()));\par
00061 \}\par
00062 \par
00063 {\cf20 // ---}\par
00064 _INST_IMPL (F6500::ROR_AbsoluteX)\par
00065 \{\par
00066     {\cf19 return} (executeOn (address_absoluteX ()));\par
00067 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/SBC.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/SBC.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/SBC.cpp}
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SBC_Inmediate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SBC_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SBC_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SBC_ZeroPageIndirectX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SBC_ZeroPageIndirectY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SBC_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SBC_AbsoluteX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SBC_AbsoluteY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:SBC.cpp}
{\xe \v SBC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SBC_Absolute )}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b SBC.cpp}.}\par
}
{\xe \v _INST_IMPL\:SBC.cpp}
{\xe \v SBC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SBC_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b SBC.cpp}.}\par
}
{\xe \v _INST_IMPL\:SBC.cpp}
{\xe \v SBC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SBC_AbsoluteY )}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b SBC.cpp}.}\par
}
{\xe \v _INST_IMPL\:SBC.cpp}
{\xe \v SBC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SBC_Inmediate )}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b SBC.cpp}.}\par
}
{\xe \v _INST_IMPL\:SBC.cpp}
{\xe \v SBC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SBC_ZeroPage )}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b SBC.cpp}.}\par
}
{\xe \v _INST_IMPL\:SBC.cpp}
{\xe \v SBC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SBC_ZeroPageIndirectX )}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b SBC.cpp}.}\par
}
{\xe \v _INST_IMPL\:SBC.cpp}
{\xe \v SBC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SBC_ZeroPageIndirectY )}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b SBC.cpp}.}\par
}
{\xe \v _INST_IMPL\:SBC.cpp}
{\xe \v SBC.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SBC_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b SBC.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SBC.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/SBC.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/SBC.cpp}
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::SBC_General::executeWith (MCHEmul::UByte u)\par
00006 \{\par
00007     MCHEmul::Register& a = cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR);\par
00008     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00009 \par
00010     {\cf20 // Read the value, makes the operation and set it back!}\par
00011     {\cf18 unsigned} {\cf18 char} ft = st.bitStatus ({\cf22 "D"}) ? MCHEmul::UInt::_PACKAGEDBCD : MCHEmul::UInt::_BINARY; {\cf20 // In BCD?}\par
00012     MCHEmul::UInt r = MCHEmul::UInt (a.values () , {\cf17 false}, ft).\par
00013         substract (MCHEmul::UInt (\{ u \}), st.bitStatus ({\cf22 "C"}));\par
00014     a.set (r.bytes ()); {\cf20 // The carry is taken into account in the substraction}\par
00015 \par
00016     {\cf20 // Time of the status register...}\par
00017     st.setBitStatus ({\cf22 "N"}, r.negative ());\par
00018     st.setBitStatus ({\cf22 "V"}, r.overflow ());\par
00019     st.setBitStatus ({\cf22 "Z"}, r == MCHEmul::UInt::_0);\par
00020     st.setBitStatus ({\cf22 "C"}, r.carry ());\par
00021 \par
00022     {\cf19 return} ({\cf17 true});\par
00023 \}\par
00024 \par
00025 {\cf20 // ---}\par
00026 _INST_IMPL (F6500::SBC_Inmediate)\par
00027 \{\par
00028     {\cf19 return} (executeWith (value_inmediate ()));\par
00029 \}\par
00030 \par
00031 {\cf20 // ---}\par
00032 _INST_IMPL (F6500::SBC_Absolute)\par
00033 \{\par
00034     {\cf19 return} (executeWith (value_absolute ()));\par
00035 \}\par
00036 \par
00037 {\cf20 // ---}\par
00038 _INST_IMPL (F6500::SBC_ZeroPage)\par
00039 \{\par
00040     {\cf19 return} (executeWith (value_zeroPage ()));\par
00041 \}\par
00042 \par
00043 {\cf20 // ---}\par
00044 _INST_IMPL (F6500::SBC_ZeroPageIndirectX)\par
00045 \{\par
00046     {\cf19 return} (executeWith (value_indirectZeroPageX ()));\par
00047 \}\par
00048 \par
00049 {\cf20 // ---}\par
00050 _INST_IMPL (F6500::SBC_ZeroPageIndirectY)\par
00051 \{\par
00052     {\cf19 return} (executeWith (value_indirectZeroPageY ()));\par
00053 \}\par
00054 \par
00055 {\cf20 // ---}\par
00056 _INST_IMPL (F6500::SBC_ZeroPageX)\par
00057 \{\par
00058     {\cf19 return} (executeWith (value_zeroPageX ()));\par
00059 \}\par
00060 \par
00061 {\cf20 // ---}\par
00062 _INST_IMPL (F6500::SBC_AbsoluteX)\par
00063 \{\par
00064     {\cf19 return} (executeWith (value_absoluteX ()));\par
00065 \}\par
00066 \par
00067 {\cf20 // ---}\par
00068 _INST_IMPL (F6500::SBC_AbsoluteY)\par
00069 \{\par
00070     {\cf19 return} (executeWith (value_absoluteY ()));\par
00071 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/SEX.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/SEX.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/SEX.cpp}
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
{\f2 #include <core/CPU.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SEC)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SED)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SEI)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:SEX.cpp}
{\xe \v SEX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SEC )}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b SEX.cpp}.}\par
}
{\xe \v _INST_IMPL\:SEX.cpp}
{\xe \v SEX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SED )}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b SEX.cpp}.}\par
}
{\xe \v _INST_IMPL\:SEX.cpp}
{\xe \v SEX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SEI )}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b SEX.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SEX.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/SEX.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/SEX.cpp}
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 {\cf21 #include <core/CPU.hpp>}\par
00004 \par
00005 _INST_IMPL (F6500::SEC)\par
00006 \{\par
00007     cpu () -> statusRegister ().setBitStatus ({\cf22 "C"}, {\cf17 true});\par
00008 \par
00009     {\cf19 return} ({\cf17 true});\par
00010 \}\par
00011 \par
00012 _INST_IMPL (F6500::SED)\par
00013 \{\par
00014     cpu () -> statusRegister ().setBitStatus ({\cf22 "D"}, {\cf17 true});\par
00015 \par
00016     {\cf19 return} ({\cf17 true});\par
00017 \}\par
00018 \par
00019 _INST_IMPL (F6500::SEI)\par
00020 \{\par
00021     cpu () -> statusRegister ().setBitStatus ({\cf22 "I"}, {\cf17 true});\par
00022 \par
00023     {\cf19 return} ({\cf17 true});\par
00024 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/STA.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/STA.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/STA.cpp}
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::STA_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::STA_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::STA_ZeroPageIndirectX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::STA_ZeroPageIndirectY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::STA_ZeroPageX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::STA_AbsoluteX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::STA_AbsoluteY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:STA.cpp}
{\xe \v STA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::STA_Absolute )}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b STA.cpp}.}\par
}
{\xe \v _INST_IMPL\:STA.cpp}
{\xe \v STA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::STA_AbsoluteX )}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b STA.cpp}.}\par
}
{\xe \v _INST_IMPL\:STA.cpp}
{\xe \v STA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::STA_AbsoluteY )}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b STA.cpp}.}\par
}
{\xe \v _INST_IMPL\:STA.cpp}
{\xe \v STA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::STA_ZeroPage )}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b STA.cpp}.}\par
}
{\xe \v _INST_IMPL\:STA.cpp}
{\xe \v STA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::STA_ZeroPageIndirectX )}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b STA.cpp}.}\par
}
{\xe \v _INST_IMPL\:STA.cpp}
{\xe \v STA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::STA_ZeroPageIndirectY )}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b STA.cpp}.}\par
}
{\xe \v _INST_IMPL\:STA.cpp}
{\xe \v STA.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::STA_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b STA.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
STA.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/STA.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/STA.cpp}
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::STA_General::executeOn ({\cf17 const} MCHEmul::Address& a)\par
00006 \{\par
00007     {\cf20 // Set the value...}\par
00008     memory () -> set (a, cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR).values ()); {\cf20 // 1 byte-length}\par
00009 \par
00010     {\cf19 return} ({\cf17 true});\par
00011 \}\par
00012 \par
00013 {\cf20 // ---}\par
00014 _INST_IMPL (F6500::STA_Absolute)\par
00015 \{\par
00016     {\cf19 return} (executeOn (address_absolute ()));\par
00017 \}\par
00018 \par
00019 {\cf20 // ---}\par
00020 _INST_IMPL (F6500::STA_ZeroPage)\par
00021 \{\par
00022     {\cf19 return} (executeOn (address_zeroPage ()));\par
00023 \}\par
00024 \par
00025 {\cf20 // ---}\par
00026 _INST_IMPL (F6500::STA_ZeroPageIndirectX)\par
00027 \{\par
00028     {\cf19 return} (executeOn (address_indirectZeroPageX ()));\par
00029 \}\par
00030 \par
00031 {\cf20 // ---}\par
00032 _INST_IMPL (F6500::STA_ZeroPageIndirectY)\par
00033 \{\par
00034     {\cf19 return} (executeOn (address_indirectZeroPageY ()));\par
00035 \}\par
00036 \par
00037 {\cf20 // ---}\par
00038 _INST_IMPL (F6500::STA_ZeroPageX)\par
00039 \{\par
00040     {\cf19 return} (executeOn (address_zeroPageX ()));\par
00041 \}\par
00042 \par
00043 {\cf20 // ---}\par
00044 _INST_IMPL (F6500::STA_AbsoluteX)\par
00045 \{\par
00046     {\cf19 return} (executeOn (address_absoluteX ()));\par
00047 \}\par
00048 \par
00049 {\cf20 // ---}\par
00050 _INST_IMPL (F6500::STA_AbsoluteY)\par
00051 \{\par
00052     {\cf19 return} (executeOn (address_absoluteY ()));\par
00053 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/STATUS.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/STATUS.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/STATUS.cpp}
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CLC)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CLD)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CLI)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::CLV)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SEC)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SED)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::SEI)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:STATUS.cpp}
{\xe \v STATUS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CLC )}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b STATUS.cpp}.}\par
}
{\xe \v _INST_IMPL\:STATUS.cpp}
{\xe \v STATUS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CLD )}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b STATUS.cpp}.}\par
}
{\xe \v _INST_IMPL\:STATUS.cpp}
{\xe \v STATUS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CLI )}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b STATUS.cpp}.}\par
}
{\xe \v _INST_IMPL\:STATUS.cpp}
{\xe \v STATUS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::CLV )}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b STATUS.cpp}.}\par
}
{\xe \v _INST_IMPL\:STATUS.cpp}
{\xe \v STATUS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SEC )}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b STATUS.cpp}.}\par
}
{\xe \v _INST_IMPL\:STATUS.cpp}
{\xe \v STATUS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SED )}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b STATUS.cpp}.}\par
}
{\xe \v _INST_IMPL\:STATUS.cpp}
{\xe \v STATUS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::SEI )}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b STATUS.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
STATUS.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/STATUS.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/STATUS.cpp}
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 _INST_IMPL (F6500::CLC)\par
00006 \{\par
00007     assert (parameters ().size () == 1);\par
00008 \par
00009     cpu () -> statusRegister ().setBitStatus ({\cf22 "C"}, {\cf17 false});\par
00010 \par
00011     {\cf19 return} ({\cf17 true});\par
00012 \}\par
00013 \par
00014 {\cf20 // ---}\par
00015 _INST_IMPL (F6500::CLD)\par
00016 \{\par
00017     assert (parameters ().size () == 1);\par
00018 \par
00019     cpu () -> statusRegister ().setBitStatus ({\cf22 "D"}, {\cf17 false});\par
00020 \par
00021     {\cf19 return} ({\cf17 true});\par
00022 \}\par
00023 \par
00024 {\cf20 // ---}\par
00025 _INST_IMPL (F6500::CLI)\par
00026 \{\par
00027     assert (parameters ().size () == 1);\par
00028 \par
00029     cpu () -> statusRegister ().setBitStatus ({\cf22 "I"}, {\cf17 false});\par
00030 \par
00031     {\cf19 return} ({\cf17 true});\par
00032 \}\par
00033 \par
00034 {\cf20 // ---}\par
00035 _INST_IMPL (F6500::CLV)\par
00036 \{\par
00037     assert (parameters ().size () == 1);\par
00038 \par
00039     cpu () -> statusRegister ().setBitStatus ({\cf22 "V"}, {\cf17 false});\par
00040 \par
00041     {\cf19 return} ({\cf17 true});\par
00042 \}\par
00043 \par
00044 {\cf20 // ---}\par
00045 _INST_IMPL (F6500::SEC)\par
00046 \{\par
00047     assert (parameters ().size () == 1);\par
00048 \par
00049     cpu () -> statusRegister ().setBitStatus ({\cf22 "C"}, {\cf17 true});\par
00050 \par
00051     {\cf19 return} ({\cf17 true});\par
00052 \}\par
00053 \par
00054 {\cf20 // ---}\par
00055 _INST_IMPL (F6500::SED)\par
00056 \{\par
00057     assert (parameters ().size () == 1);\par
00058 \par
00059     cpu () -> statusRegister ().setBitStatus ({\cf22 "D"}, {\cf17 true});\par
00060 \par
00061     {\cf19 return} ({\cf17 true});\par
00062 \}\par
00063 \par
00064 {\cf20 // ---}\par
00065 _INST_IMPL (F6500::SEI)\par
00066 \{\par
00067     assert (parameters ().size () == 1);\par
00068 \par
00069     cpu () -> statusRegister ().setBitStatus ({\cf22 "I"}, {\cf17 true});\par
00070 \par
00071     {\cf19 return} ({\cf17 true});\par
00072 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/STX.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/STX.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/STX.cpp}
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::STX_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::STX_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::STX_ZeroPageY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:STX.cpp}
{\xe \v STX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::STX_Absolute )}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b STX.cpp}.}\par
}
{\xe \v _INST_IMPL\:STX.cpp}
{\xe \v STX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::STX_ZeroPage )}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b STX.cpp}.}\par
}
{\xe \v _INST_IMPL\:STX.cpp}
{\xe \v STX.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::STX_ZeroPageY )}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b STX.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
STX.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/STX.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/STX.cpp}
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::STX_General::executeOn ({\cf17 const} MCHEmul::Address& a)\par
00006 \{\par
00007     {\cf20 // Set the value...}\par
00008     memory () -> set (a, cpu () -> internalRegister (F6500::C6510::_XREGISTER).values ()); {\cf20 // 1 byte-length}\par
00009 \par
00010     {\cf19 return} ({\cf17 true});\par
00011 \}\par
00012 \par
00013 {\cf20 // ---}\par
00014 _INST_IMPL (F6500::STX_Absolute)\par
00015 \{\par
00016     {\cf19 return} (executeOn (address_absolute ()));\par
00017 \}\par
00018 \par
00019 {\cf20 // ---}\par
00020 _INST_IMPL (F6500::STX_ZeroPage)\par
00021 \{\par
00022     {\cf19 return} (executeOn (address_zeroPage ()));\par
00023 \}\par
00024 \par
00025 {\cf20 // ---}\par
00026 _INST_IMPL (F6500::STX_ZeroPageY)\par
00027 \{\par
00028     {\cf19 return} (executeOn (address_zeroPageY ()));\par
00029 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/STY.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/STY.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/STY.cpp}
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::STY_Absolute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::STY_ZeroPage)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::STY_ZeroPageX)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:STY.cpp}
{\xe \v STY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::STY_Absolute )}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b STY.cpp}.}\par
}
{\xe \v _INST_IMPL\:STY.cpp}
{\xe \v STY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::STY_ZeroPage )}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b STY.cpp}.}\par
}
{\xe \v _INST_IMPL\:STY.cpp}
{\xe \v STY.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::STY_ZeroPageX )}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b STY.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
STY.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/STY.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/STY.cpp}
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 {\cf18 bool} F6500::STY_General::executeOn ({\cf17 const} MCHEmul::Address& a)\par
00006 \{\par
00007     {\cf20 // Set the value...}\par
00008     memory () -> set (a, cpu () -> internalRegister (F6500::C6510::_XREGISTER).values ()); {\cf20 // 1 byte-length}\par
00009 \par
00010     {\cf19 return} ({\cf17 true});\par
00011 \}\par
00012 \par
00013 {\cf20 // ---}\par
00014 _INST_IMPL (F6500::STY_Absolute)\par
00015 \{\par
00016     {\cf19 return} (executeOn (address_absolute ()));\par
00017 \}\par
00018 \par
00019 {\cf20 // ---}\par
00020 _INST_IMPL (F6500::STY_ZeroPage)\par
00021 \{\par
00022     {\cf19 return} (executeOn (address_zeroPage ()));\par
00023 \}\par
00024 \par
00025 {\cf20 // ---}\par
00026 _INST_IMPL (F6500::STY_ZeroPageX)\par
00027 \{\par
00028     {\cf19 return} (executeOn (address_zeroPageX ()));\par
00029 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/WorkspacesII/EMULATORS/src/F6500/TRANSFERS.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/TRANSFERS.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/TRANSFERS.cpp}
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <F6500/Instructions.hpp>}\par
{\f2 #include <F6500/C6510.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::TAX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::TAY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::TXA)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b _INST_IMPL} (F6500::TYA)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _INST_IMPL\:TRANSFERS.cpp}
{\xe \v TRANSFERS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::TAX )}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b TRANSFERS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_t_r_a_n_s_f_e_r_s_8cpp_ac87a663a3b634dbd69544a54094da10f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:TRANSFERS.cpp}
{\xe \v TRANSFERS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::TAY )}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b TRANSFERS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_t_r_a_n_s_f_e_r_s_8cpp_ae1124dd404aef5640c08464ba4dc472a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:TRANSFERS.cpp}
{\xe \v TRANSFERS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::TXA )}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b TRANSFERS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_t_r_a_n_s_f_e_r_s_8cpp_a1fae30e586749cb1b30d4de133b931b7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v _INST_IMPL\:TRANSFERS.cpp}
{\xe \v TRANSFERS.cpp\:_INST_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_INST_IMPL (F6500::TYA )}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b TRANSFERS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_t_r_a_n_s_f_e_r_s_8cpp_a0508849dc9e3c100353c44e565843062_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TRANSFERS.cpp\par \pard\plain 
{\tc\tcl2 \v C:/WorkspacesII/EMULATORS/src/F6500/TRANSFERS.cpp}
{\xe \v C:/WorkspacesII/EMULATORS/src/F6500/TRANSFERS.cpp}
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <F6500/Instructions.hpp>}\par
00002 {\cf21 #include <F6500/C6510.hpp>}\par
00003 \par
00004 {\cf20 // ---}\par
00005 _INST_IMPL (F6500::TAX)\par
00006 \{\par
00007     assert (parameters ().size () == 1);\par
00008 \par
00009     MCHEmul::UBytes u = cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR).values ();\par
00010     cpu () -> internalRegister (F6500::C6510::_XREGISTER).set (u);\par
00011 \par
00012     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00013     st.setBitStatus ({\cf22 "N"}, u [0][7]);\par
00014     st.setBitStatus ({\cf22 "Z"}, u [0] == MCHEmul::UByte::_0);\par
00015 \par
00016     {\cf19 return} ({\cf17 true});\par
00017 \}\par
00018 \par
00019 {\cf20 // ---}\par
00020 _INST_IMPL (F6500::TAY)\par
00021 \{\par
00022     assert (parameters ().size () == 1);\par
00023 \par
00024     MCHEmul::UBytes u = cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR).values ();\par
00025     cpu () -> internalRegister (F6500::C6510::_YREGISTER).set (u);\par
00026 \par
00027     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00028     st.setBitStatus ({\cf22 "N"}, u [0][7]);\par
00029     st.setBitStatus ({\cf22 "Z"}, u [0] == MCHEmul::UByte::_0);\par
00030 \par
00031     {\cf19 return} ({\cf17 true});\par
00032 \}\par
00033 \par
00034 {\cf20 // ---}\par
00035 _INST_IMPL (F6500::TXA)\par
00036 \{\par
00037     assert (parameters ().size () == 1);\par
00038 \par
00039     MCHEmul::UBytes u = cpu () -> internalRegister (F6500::C6510::_XREGISTER).values ();\par
00040     cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR).set (u);\par
00041 \par
00042     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00043     st.setBitStatus ({\cf22 "N"}, u [0][7]);\par
00044     st.setBitStatus ({\cf22 "Z"}, u [0] == MCHEmul::UByte::_0);\par
00045 \par
00046     {\cf19 return} ({\cf17 true});\par
00047 \}\par
00048 \par
00049 {\cf20 // ---}\par
00050 _INST_IMPL (F6500::TYA)\par
00051 \{\par
00052     assert (parameters ().size () == 1);\par
00053 \par
00054     MCHEmul::UBytes u = cpu () -> internalRegister (F6500::C6510::_YREGISTER).values ();\par
00055     cpu () -> internalRegister (F6500::C6510::_ACCUMULATOR).set (u);\par
00056 \par
00057     MCHEmul::StatusRegister& st = cpu () -> statusRegister ();\par
00058     st.setBitStatus ({\cf22 "N"}, u [0][7]);\par
00059     st.setBitStatus ({\cf22 "Z"}, u [0] == MCHEmul::UByte::_0);\par
00060 \par
00061     {\cf19 return} ({\cf17 true});\par
00062 \}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
